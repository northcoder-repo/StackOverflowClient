<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>SQL injection is 17 years old. Why is it still around?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>SQL injection is 17 years old. Why is it still around?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>310</span>
    </div>
    <div>
     <span>Asker: </span> <span>Ishan Mathur</span>
    </div>
    <div>
     <span>Asked: </span> <span>27 Jun 2016 at 05:13</span>
    </div>
    <div>
     <a href="https://security.stackexchange.com/questions/128412/sql-injection-is-17-years-old-why-is-it-still-around">source</a>
    </div>
   </div>
   <div>
    <p>I'm no techie and would like your expertise in understanding this. I recently read a detailed article on SQLi for a research paper.</p>
    <p>It strikes me as odd. Why do so many data breaches still happen through SQL injection? Is there no fix?</p>
   </div>
   <div class="tags">
    <span class="tag">web-application</span><span class="tag">sql-injection</span><span class="tag">data-leakage</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td></td>
       <td><span>Comments are not for extended discussion; this conversation has been <a href="http://chat.stackexchange.com/rooms/41748/discussion-on-question-by-ishan-mathur-sql-injection-is-17-years-old-why-is-it">moved to chat</a>.</span> <span> - </span> <span class="display-name">Rory Alsop</span> <span> </span> <span class="date">28 Jun 2016 at 07:13</span></td>
      </tr>
      <tr>
       <td>86</td>
       <td><span>You know that malaria is still around right? and that actually kills people.</span> <span> - </span> <span class="display-name">zzzzBov</span> <span> </span> <span class="date">29 Jun 2016 at 14:11</span></td>
      </tr>
      <tr>
       <td>70</td>
       <td><span>Buffer overflow exploits have existed for <i>over 30 years</i>, yet they are still a thing, despite the fact that it really is not that hard for the vendors to fix.</span> <span> - </span> <span class="display-name">RBarryYoung</span> <span> </span> <span class="date">29 Jun 2016 at 15:14</span></td>
      </tr>
      <tr>
       <td>35</td>
       <td><span>I'd ask the same thing about SQL.</span> <span> - </span> <span class="display-name">JamesFaix</span> <span> </span> <span class="date">29 Jun 2016 at 19:38</span></td>
      </tr>
      <tr>
       <td>39</td>
       <td><span>Non tech-savy customers simply wont pay for code changes until they see something bad happen that hurts their bottom line: "It's not in the budget!", "I dont see the problem, it's been working fine the last 15 years". They don't know that they have been hacked via SQL injection because they never check their server logs, and the hacker is never nice enough to send them an email ...</span> <span> - </span> <span class="display-name">iHaveacomputer</span> <span> </span> <span class="date">30 Jun 2016 at 02:06</span></td>
      </tr>
      <tr>
       <td>60</td>
       <td><span>Picking people's pockets is still "a thing" after thousands of years of trouser-wearing.</span> <span> - </span> <span class="display-name">Max Williams</span> <span> </span> <span class="date">30 Jun 2016 at 11:25</span></td>
      </tr>
      <tr>
       <td>7</td>
       <td><span>Seat belts have been around for more than 17 and some people still don't use them. SQL injection will always be around as you have trusted users that need to write direct queries. If you have un-trusted (user) data there are reliable tools (prepared / parameterized) for queries that 100% prevent injection.</span> <span> - </span> <span class="display-name">paparazzo</span> <span> </span> <span class="date">30 Jun 2016 at 14:05</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>In my opinion, it comes down to the users (or the buyers, which is almost the same thing, in cases where the software is bought). They are willing to pay less for cheap junk rather than more for solid programs. This is far bigger than just in the computer industry, of course, but it boils down to the fact that the extra time to correctly prevent SQL Injection isn't worth it to the business, and they pay our paychecks.</span> <span> - </span> <span class="display-name">Guy Schalnat</span> <span> </span> <span class="date">12 Jul 2016 at 14:09</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>The "Is there no <i>fix</i>?" wording makes me suspect a misconception: SQLi is not a "bug" that needs to be <i>fixed.</i> The question might be rephrased as, "Why hasn't a 100% foolproof, automated way of blocking SQLi been developed?" The answer is that there is no 100% foolproof, automated way to distinguish legitimate SQL from illegitimate SQL. Only the designer of an application will know if submitted text should allow SQL or not. So it's up to the designer to implement the various protections mentioned in the other answers.</span> <span> - </span> <span class="display-name">Syntax Junkie</span> <span> </span> <span class="date">14 Apr 2017 at 19:29</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>484</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Steffen Ullrich</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Jun 2016 at 05:25</span>
     </div>
    </div>
    <div>
     <p>There is no general fix for SQLi because there is no fix for human stupidity. There are established techniques which are easy to use and which fix the problems (especially parameter binding) but one still has to use these techniques. And many developers are simply not aware of security problems. Most care that the application works at all and don't care much about security, especially if it makes things (even slightly) more complex and comes with additional costs like testing.</p>
     <p>This kind of problem is not restricted to SQLi but you'll find it with buffer overflows, certificate checking, XSS, CSRF... . It is more expensive to do secure programming because of the additional testing and of the additional expertise needed by the (thus more expensive) developer. And as long as the market prefers it cheap and does not care much about security you get the cheap and insecure solutions. And while security by design helps a lot to make it better developers often work around this design because they don't understand it and it is just in their way.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>88</td>
        <td><span>Lack of awareness and Laziness...</span> <span> - </span> <span class="display-name">Matthieu M.</span> <span> </span> <span class="date">27 Jun 2016 at 06:34</span></td>
       </tr>
       <tr>
        <td>231</td>
        <td><span>"There is no general fix for SQLi because there is no fix for human stupidity." That's a beautiful quote!</span> <span> - </span> <span class="display-name">miva2</span> <span> </span> <span class="date">27 Jun 2016 at 09:36</span></td>
       </tr>
       <tr>
        <td>44</td>
        <td><span>There are general fixes for sqli just like there are fixes for buffer overflows, they involve working on higher level constructs that do not allow for those to occur. Working with most managed languages fixes buffer overflows, techs like linq fix sqli. Sqli will be there as long as people use sql directly but it's already gone for those who want it so</span> <span> - </span> <span class="display-name">Ronan Thibaudau</span> <span> </span> <span class="date">27 Jun 2016 at 09:50</span></td>
       </tr>
       <tr>
        <td>18</td>
        <td><span>It's not always human stupidity thou (at least not by the part of the developer)! I know many brazilian companies who do a cheap tatic here: They hire instead of full-fledge developers, they hire a bunch of trainees to avoid taxes and pay less their employees. And these are big companies! Such juniors have yet no knowledge (some of them are on their first semester of their studies) or even awareness of such problems, and are placed with the responsability to build systems that will be, of course, flawed. I have seen this too much here. I could even give 5 to 6 names. It's a really sad thing.</span> <span> - </span> <span class="display-name">Malavos</span> <span> </span> <span class="date">27 Jun 2016 at 14:20</span></td>
       </tr>
       <tr>
        <td>49</td>
        <td><span>@Malavos: I don't necessarily mean stupidity of the developer. Hiring developers based on salary instead of knowledge is stupid too.</span> <span> - </span> <span class="display-name">Steffen Ullrich</span> <span> </span> <span class="date">27 Jun 2016 at 15:42</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span><b>Comments are not for extended discussion</b>; this conversation has been <a href="http://chat.stackexchange.com/rooms/41757/discussion-on-answer-by-steffen-ullrich-sql-injection-is-17-years-old-why-is-it">moved to chat</a>.</span> <span> - </span> <span class="display-name">Rory Alsop</span> <span> </span> <span class="date">28 Jun 2016 at 11:09</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>"because there is no fix for human stupidity" Then why are humans still around?</span> <span> - </span> <span class="display-name">Turion</span> <span> </span> <span class="date">29 Jun 2016 at 07:10</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@Malavos I share your sentiment. I lost count on how many systems I had to fix that were built by "that trainee that worked here before". As another brazilian developer, I can also state that this happens everywhere on this country!</span> <span> - </span> <span class="display-name">T. Sar</span> <span> </span> <span class="date">29 Jun 2016 at 13:20</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>@Turion, give it <a href="https://books.google.com/books?hl=en&amp;lr=&amp;id=gUXgpH6nizIC" rel="nofollow noreferrer">a little more time</a>. It's <a href="http://thebulletin.org/timeline" rel="nofollow noreferrer">3 minutes to midnight</a></span> <span> - </span> <span class="display-name">Jedi</span> <span> </span> <span class="date">29 Jun 2016 at 16:12</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>Injection is not a failure of a language or platform; it is a failure of a programmer. You can't fix people issues with technology solutions (though you can cover for them, for example parameterised queries can cover for injection vulnerabilities).</span> <span> - </span> <span class="display-name">Greenstone Walker</span> <span> </span> <span class="date">1 Jul 2016 at 03:11</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I think the comparison to some diseases works in the way that although getting SQLi is possible AND frequent, there are proven well known ways to avoid it. Is not a vulnerability you "get" from a bad download and then your system dies. You can avoid many diseases by following some guidelines yet people still get sick from not washing their hands or not cooking food properly.</span> <span> - </span> <span class="display-name">Ernesto</span> <span> </span> <span class="date">1 Jul 2016 at 17:47</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>As long as there's no fire, it is fine not to fireproof your house.</span> <span> - </span> <span class="display-name">Paul de Vrieze</span> <span> </span> <span class="date">4 Jul 2016 at 13:40</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>but..it might be fixed by not having SQL</span> <span> - </span> <span class="display-name">prusswan</span> <span> </span> <span class="date">5 Jul 2016 at 18:02</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Human stupidity is regulated by death.</span> <span> - </span> <span class="display-name">Cees Timmerman</span> <span> </span> <span class="date">6 Jul 2016 at 11:56</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>284</span>
     </div>
     <div>
      <span>Answerer: </span> <span>TessellatingHeckler</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Jun 2016 at 17:10</span>
     </div>
    </div>
    <div>
     <p>Because it's not a problem.</p>
     <ul>
      <li>
       <p>When was the last time a company with a SQL injection vulnerability got hauled up in court, and slapped with a big fine for being reckless with user data, and the directors' warned, fined or locked up for negligence?</p></li>
      <li>
       <p>When was the last time a company lost a big contract because their company website login page didn't validate passwords properly?</p></li>
      <li>
       <p>When was the last time a qualified regulator/auditor from a professional organisation had to approve and sign off a public facing computer system before it could be put into use?</p></li>
     </ul>
     <p>You would think that "people will die" would be a good enough reason to make buildings with fireproof materials, alarms and good escape routes. <a href="https://en.wikipedia.org/wiki/Beverly_Hills_Supper_Club_fire">It wasn't</a>. We introduced regulation to force non-flammable building materials, fire safe designs with fire breaks, fire alarms.</p>
     <p>You might think "people will die" would be a good enough reason to make <em>everyone</em> care about building structural design. <a href="https://en.wikipedia.org/wiki/Versailles_wedding_hall_disaster">It isn't</a>. <a href="https://en.wikipedia.org/wiki/2013_Savar_building_collapse">It just isn't</a>. We have to have regulation to have qualified engineers sign off on building designs, that they be designed and built for specific uses, and when things fail, society <a href="http://www.jpost.com/Israel/Court-upholds-prison-terms-in-Versailles-hall-disaster">takes the engineers to court</a>.</p>
     <p>You would think that "people will die" would be a good enough reason to make food processing clean and safe, <a href="https://en.wikipedia.org/wiki/The_Jungle">but it wasn't</a>.</p>
     <p>SQL Injection is less obvious, less publicly visible, and has less severity impact, and is in a completely unregulated industry.</p>
     <p>Even to companies which do care about it, they can't usefully advertise "<em>No known SQL injection vulnerabilities in our code</em>" as a marketing bullet point anyone cares about. It's not the sort of question customers ask salespeople. It's not a competitive advantage for them, it's a cost, an overhead. Protecting against it makes them <em>less</em> competitive, slower moving, doing more work for the same functionality.</p>
     <p><strong>The incentives are all aligned for it to keep existing. So it keeps existing.</strong></p>
     <p>Make SQL injection <em>a problem</em> for companies, and they will make it go away.</p>
     <p>[Edit: But there's an EU regulation that websites have to warn you if they use cookies. And they do. So regulating public facing computer systems to make them more annoying can come into effect - even if the current regulation is pretty useless.]</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Comments are not for extended discussion; this conversation has been <a href="http://chat.stackexchange.com/rooms/41860/discussion-on-answer-by-tessellatingheckler-sql-injection-is-17-years-old-why-i">moved to chat</a>.</span> <span> - </span> <span class="display-name">Rory Alsop</span> <span> </span> <span class="date">30 Jun 2016 at 09:53</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>I wonder when the time will come for computer science-related legislation to be introduced</span> <span> - </span> <span class="display-name">prusswan</span> <span> </span> <span class="date">5 Jul 2016 at 17:57</span></td>
       </tr>
       <tr>
        <td>21</td>
        <td><span>Careful what you wish for @prusswan. In the US, at least, the vast majority of tech-regulating laws that are in place or attempted have been put in place by lobbyists with little to no understanding of the big picture.</span> <span> - </span> <span class="display-name">Paul</span> <span> </span> <span class="date">6 Jul 2016 at 00:46</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>well, some legislation is better than no legislation</span> <span> - </span> <span class="display-name">prusswan</span> <span> </span> <span class="date">6 Jul 2016 at 06:27</span></td>
       </tr>
       <tr>
        <td>26</td>
        <td><span>@prusswan I refute your argument thus: No legislation is better than bad legislation.</span> <span> - </span> <span class="display-name">daiscog</span> <span> </span> <span class="date">6 Jul 2016 at 11:13</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span><a href="https://en.wikipedia.org/wiki/Security_breach_notification_laws" rel="nofollow noreferrer">Security breach notification laws</a> are company problems.</span> <span> - </span> <span class="display-name">Cees Timmerman</span> <span> </span> <span class="date">6 Jul 2016 at 11:52</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@prusswan, there are laws. Look into HIPPA for example.</span> <span> - </span> <span class="display-name">Paul Draper</span> <span> </span> <span class="date">6 Jul 2016 at 15:51</span></td>
       </tr>
       <tr>
        <td>15</td>
        <td><span>@prusswan Really? You would rather have <i>any</i> legislation than no legislation? What if that legislation required your encryption to have a backdoor? What if that legislation forced you to use md5 for all hashing? What if that legislation required you to keep all passwords in plaintext, unhashed and unsalted? Are you <i>absolutely sure</i> that <i>some legislation</i> is better than <i>no legislation</i>?</span> <span> - </span> <span class="display-name">Kyeotic</span> <span> </span> <span class="date">6 Jul 2016 at 17:20</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>no legislation gives the idea that the profession as a whole is reluctant to accept responsibility and cannot be taken more seriously. If legislation is bad then fix it, or better still, introduce good legislation before someone else gets the bad one in</span> <span> - </span> <span class="display-name">prusswan</span> <span> </span> <span class="date">6 Jul 2016 at 20:02</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>HIPPA is health-related, so everything else is fair game?</span> <span> - </span> <span class="display-name">prusswan</span> <span> </span> <span class="date">6 Jul 2016 at 20:03</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>put in this way: would you rather write your own SQL, or let Trump write it for you?</span> <span> - </span> <span class="display-name">prusswan</span> <span> </span> <span class="date">7 Sep 2018 at 08:27</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>121</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Luis Casillas</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Jun 2016 at 05:49</span>
     </div>
    </div>
    <div>
     <p>SQL injection is still around because the software world still doesn't understand that programmatic generation of tree-structured values (like queries or markup) should be done by constructing <strong>syntax trees</strong> as first-class objects, not by concatenating strings that represent fragments of a language.</p>
     <p>There has been a bit of progress in recent years with the increasing availability of query builder tools like <a href="https://msdn.microsoft.com/en-us/library/bb386976(v=vs.110).aspx">LINQ to SQL</a> or <a href="http://www.sqlalchemy.org/">SQLAlchemy</a>, but that's on the programming language side. Relational databases still don't offer a standard, compelling alternative interface that's not fundamentally based on sending queries as strings.</p>
     <p>Prepared statements with query parameters are barely an improvement, because they're only easy to use if the <em>structure</em> of your queries—which tables are joined, what filtering conditions, what columns to project—is <em>fixed</em>. When you have an application that needs to construct query text at runtime, prepared query parameters are a big pain to use.</p>
     <p>So if a standardized, non-textual, tree-structured protocol could be constructed for describing and communicating queries to the database, and it was designed to be easier to use than textual queries, then that would solve the problem in the long term. But the problem won't go away until the industry adopts something where the <em>path of least resistance</em> is safe. As long as we insist on unsafe-by-default systems where writing safe code takes unnecessary effort, problems will be with us. (Think of all the buffer overflows that <em>don't exist at all</em> in memory-managed languages!)</p>
     <hr>
     <p>Note that the same fundamental problem as SQL injection plagues the Web, under the name of <strong>cross-site scripting</strong>—which is really just Javascript injection into dynamic HTML pages. A very common pattern is Javascript programmers who, instead of working with the DOM by treating it as a tree of objects, resort to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML">the <code>innerHTML</code> property</a> to set it to HTML text that's built by naïve string concatenation. A lot of XSS vulnerabilities would <strong>never</strong> have existed if the <code>innerHTML</code> property had never been put into the browsers' DOM implementations.</p>
     <hr>
     <p>Also, for folks who haven't seen Tony Hoare's talk on null pointers, it's simultaneously orthogonal (null pointers, not SQL injection) but at the same time incredibly relevant:</p>
     <ul>
      <li><a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare">Tony Hoare, "Null References: The Billion Dollar Mistake"</a>.</li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>13</td>
        <td><span><b>Relational databases still don't offer a standard, ... on sending queries as strings.</b> Database are accessed by networks, so the API to generate secured query is always on application sides. Furthermore that would require them to implements that solution in every languages. They have already implemented drivers to communicate, perform transactions and allow to do parametrized query easier. I don't think we can really ask the more on their side.</span> <span> - </span> <span class="display-name">Walfrat</span> <span> </span> <span class="date">27 Jun 2016 at 06:58</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Comments are not for extended discussion; this conversation has been <a href="http://chat.stackexchange.com/rooms/41756/discussion-on-answer-by-luis-casillas-sql-injection-is-17-years-old-why-is-it-s">moved to chat</a>.</span> <span> - </span> <span class="display-name">Rory Alsop</span> <span> </span> <span class="date">28 Jun 2016 at 11:06</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>I don't think there would be anything wrong with using <code>innerHTML</code> if it were limited to creating anonymous text-only objects. It's a lot more practical to be able to set a field to <code>This is &lt;b&gt;important&lt;/b&gt;: whatever</code> rather than having to create and insert a separate nested object for the bold-face text. Unfortunately, I know of no mechanism for creating that kind of aggregate object which would simply be incapable of creating more "dangerous" kinds of objects.</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">28 Jun 2016 at 22:21</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>Cannot upvote this answer enough. I have been saying this for decades, it is so great to hear at least one other person saying it too.</span> <span> - </span> <span class="display-name">RBarryYoung</span> <span> </span> <span class="date">29 Jun 2016 at 15:09</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>As far as the most trivial vulnerabilities from naive use of string concatenation, they're still common in code written by people who don't know what they're doing because <b>the less-safe APIs haven't been removed</b>. If DB interface functions in PHP and other languages completely removed the old-style flat-string APIs (breaking tons of existing code), a lot of homebrew code written by people that don't really know how to program would be somewhat safer.</span> <span> - </span> <span class="display-name">Peter Cordes</span> <span> </span> <span class="date">29 Jun 2016 at 19:26</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Existence of old tutorials teaching the bad way is also a major problem for things like PHP, where a lot of code is copy&amp;pasted by people that don't understand it.</span> <span> - </span> <span class="display-name">Peter Cordes</span> <span> </span> <span class="date">29 Jun 2016 at 19:28</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>I am a SQL developer and do not agree with this "When you have an application that needs to construct query text at runtime, prepared query parameters are a big pain to use." It is no harder to create secure query in a program than it is by hand.</span> <span> - </span> <span class="display-name">paparazzo</span> <span> </span> <span class="date">30 Jun 2016 at 13:41</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@PeterCordes Using the more safe APIs won't force people to not use string concatenation. How would it? You can easily do <code>$db-&gt;buildQuery("select * from users where username = '$username'")-&gt;execute()</code> or similar.</span> <span> - </span> <span class="display-name">user253751</span> <span> </span> <span class="date">4 Jul 2016 at 01:38</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>I do not agree that parameters are a pain to use in dynamic query-building. That it's not hard at all - once we had to develop our own hibernate-like solution for a in-house project, and the parameters where one of the most easy parts do deal with.</span> <span> - </span> <span class="display-name">T. Sar</span> <span> </span> <span class="date">5 Jul 2016 at 20:10</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I really like t his answer and I'd be really interested in seeing such a syntax-tree solution. However, as Steffen Ullrich says, human stupidity knows no bounds, so I bet there'd be people who'd build this syntax tree by concatenating strings and then using their favorite language's eval pendant to turn it into an actual data structure. So then we'd have two gaping security holes where there was only one to start with. :-(</span> <span> - </span> <span class="display-name">Out of Band</span> <span> </span> <span class="date">24 Oct 2016 at 16:00</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>63</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Nick Gammon</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Jun 2016 at 07:23</span>
     </div>
    </div>
    <div>
     <p>When testing, it is very easy to test for what you <em>expect</em> to happen. For example, when filling in a "name" field in a database you will probably choose something you are familiar with, like "John Doe". This works, and your application seems to work fine.</p>
     <p>Then, one day, someone names their child <code>Robert'); DROP TABLE Students; --</code> (little Bobby Tables).</p>
     <p><a href="https://imgs.xkcd.com/comics/exploits_of_a_mom.png"><img src="https://imgs.xkcd.com/comics/exploits_of_a_mom.png" alt="enter image description here"></a></p>
     <p>Of course, you don't test your app for names like that, so the security hole that such a name exposes slips through all your testing.</p>
     <p>There is an interesting comment here: <a href="https://www.schneier.com/crypto-gram/archives/2016/0615.html#1">The Unfalsifiability of Security Claims</a></p>
     <p>It's easy to prove a security hole exists (you just test for a name like the above). It's also easy to prove that a particular hole has been fixed. It's hard to prove no <em>other</em> security holes exist.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Though it does not cover all SQL injection, juste testing by using the simple quote in a name or the hash # character cover quite a huge part of the vulnerability of applications toward SQL injection.</span> <span> - </span> <span class="display-name">Walfrat</span> <span> </span> <span class="date">27 Jun 2016 at 07:41</span></td>
       </tr>
       <tr>
        <td>39</td>
        <td><span>@Walfrat Too bad <code>O'Brien</code> might want to open an account.</span> <span> - </span> <span class="display-name">user</span> <span> </span> <span class="date">27 Jun 2016 at 13:42</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>+1 for an excellent answer. Lack of proper test cases is (IMHO) a better reason than human stupidity or mistakes. It's hard to claim that something which is functionally correct for the existing test cases is a "mistake", and not using best practices isn't really "stupidity" either, but rather just lack of knowledge of the subject. If the test cases always included SQL injection, the problem wouldn't arise nearly as often, and best practices would more likely be adhered to.</span> <span> - </span> <span class="display-name">TTT</span> <span> </span> <span class="date">27 Jun 2016 at 14:47</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@MichaelKjörling Is O'Brian's first name <i>Bobby</i>? That might be a problem...</span> <span> - </span> <span class="display-name">user82913</span> <span> </span> <span class="date">27 Jun 2016 at 18:59</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@MichaelKjörling I think @Walfrat's point was that it's fairly easy to do some testing for SQLi by just including the odd <code>'</code> in your test input data. I don't think he meant to promote filtering apostrophes at the application level (although I can see how you could interpret it as such).</span> <span> - </span> <span class="display-name">marcelm</span> <span> </span> <span class="date">27 Jun 2016 at 20:20</span></td>
       </tr>
       <tr>
        <td>10</td>
        <td><span>My answer was really trying to address the question: <i>why is the problem still around after 17 years?</i> Not: <i>how best to fix SQL injection.</i></span> <span> - </span> <span class="display-name">Nick Gammon</span> <span> </span> <span class="date">27 Jun 2016 at 22:00</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Nothing like a concrete example to quickly and clearly explain a problem. Cannot upvote THIS answer enough...</span> <span> - </span> <span class="display-name">duanev</span> <span> </span> <span class="date">29 Jun 2016 at 16:58</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@MichaelKjörling that's actually one <i>more</i> reason to test that it works with <code>'</code> in the name, not one less. (I recently had a web shop strip the <code>+</code> from my email address. They had to send me a paper mail instead. Should also have been tested.)</span> <span> - </span> <span class="display-name">Paŭlo Ebermann</span> <span> </span> <span class="date">1 Jul 2016 at 23:28</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Regarding the XKCD cartoon, sanitizing inputs is <i>not</i> the solution: rendering the input to the database, <i>and</i> any processing of the data inside the database, as impotent is the solution. Which is what SQL parameters and careful consideration of the processing (e.g. dynamic SQL) are used for. A similar attitude to rendered HTML is also necessary.</span> <span> - </span> <span class="display-name">Andrew Morton</span> <span> </span> <span class="date">3 Jul 2016 at 17:25</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>30</span>
     </div>
     <div>
      <span>Answerer: </span> <span>h4ckNinja</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Jun 2016 at 06:00</span>
     </div>
    </div>
    <div>
     <p>Steffen makes good points in his answer, but I'd like to add to it. The why, I think, can be broken in to the following topics:</p>
     <ul>
      <li>Lack of knowledge or education of developers</li>
      <li>Churn in an enterprise development environment</li>
      <li>Pressure to deliver ahead of schedule</li>
      <li>Not enough emphasis from the top on security</li>
     </ul>
     <p>So let's break those down.</p>
     <h2>Developer training</h2>
     <p>There's a lot of emphasis on user education these days. Teach users how to maintain strong passwords. Teach users how to identify phishing. Teach users how to .... You get the idea. Some enterprises, a lot probably, but I can only speak to my professional experience and I haven't worked at a lot of enterprises ;), do have training programs. But those training programs can be incomplete or not reach the depth of knowledge needed. That's not to disparage the hard work that goes in to building those programs. But to say that just like in school environment, different people learn differently. And unless you have a continued education program for developers, it's going to be hard to communicate "use parameterized queries, and here's how to do it in PHP, Java, Python, Ruby, Scala, NodeJS, ...". It's hard work developing, delivering, and maintaining developer programs that effectively reach the audience.</p>
     <h2>Developer churn</h2>
     <p>Above, one of the things that I alluded to was reaching the audience effectively for different learning types. One of the reasons for that is a lot of enterprises have a high churn rate for developers, because the developers are contractors that get shifted from project to project at different companies. And companies are not always at the same security maturity. One company may not have a security program at all, while another may have an excellent security program and the developer is suddenly bombarded with new information that'll be required of them for all of six months before they move to another company. It's sad, but it happens.</p>
     <h2>Project delivery</h2>
     <p>Project delivery on schedule, or even ahead of schedule. The quickest path to completing the project usually, sadly, isn't completing the project with security controls. It's getting it done in the most broken way that still works. We know that it'll cause more work, more time, and more money later when it comes time to maintain the project and fix problems, but management just wants the project out.</p>
     <p>Another item I touched on is developing security training programs for a myriad of programming languages. A lot of enterprises don't have one or two set languages. So developers like to (or are encouraged) try out the new hotness. That includes languages and frameworks. This means security programs must continually evolve.</p>
     <h2>Management buy-in</h2>
     <p>And here we are at management. Every time, it seems like in a public breach, there were controls that could have been implemented, that aren't that hard, but were missed. Pushes to deliver products first and worry second always, despite lesson after lesson after lesson, comes back on product companies. Management must push from the top to take the time to build in security at the beginning. They must understand that more work, more time, and more money will be spent fixing problems, maintaining the product, and paying fines. But cost-benefit analyses point to the problem being product delivery, not the fines or maintenance work required. Those equations must change, and that comes, in part, to education (wooo, full circle) at the MBA level. Business managers must be taught that to be successful in a landscape of ever-increasing breaches, security must be front and center.</p>
     <h2>Conclusion</h2>
     <p>The why, despite SQLi being nearly 20 years old, is fraught with several reasons. As security practitioners, we can only do so much to educate and raise awareness of what happens when security is not considered as an integral part of the SDLC.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>6</td>
        <td><span>"Developer training"... Right... sometimes folks would be better off without it. A friend of mine finished a supposedly accredited (whatever that means) Java course in Germany earlier this year. The stars of the SQL part of the course? String concatenation and a method called <code>safe()</code> that would make strings "safe" by escaping quotes - and only quotes. In 5 minutes I found 2-3 different ways to do SQLi on the sample code provided by the teacher. Who knows what automated SQLi probing tools would make out of that pile of, uh, code...</span> <span> - </span> <span class="display-name">thkala</span> <span> </span> <span class="date">28 Jun 2016 at 23:57</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>Then those programs are operated by incompetent people. But that doesn't mean that developer training doesn't work. I have seen it work. Rather than assuming developer training doesn't work, look at the reason for its failure. So, right ...</span> <span> - </span> <span class="display-name">h4ckNinja</span> <span> </span> <span class="date">29 Jun 2016 at 17:22</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>I'd add "DB vendors trying to cram everything into one call". If the way to run some sql is to always call a function that takes arbitrary SQL, developers have to do a lot of safety work. Vendors could easily add a function (maybe named "select"?) that allows <i>only</i> <i>one</i> <i>select</i> -- no statement-separators, no comments, no "drop", no "update".... Easy to implement, easy to use, pretty safe, and covers a <i>lot</i> of what users (especially beginners) need -- so could reduce attack surfaces significantly.</span> <span> - </span> <span class="display-name">TextGeek</span> <span> </span> <span class="date">1 Jul 2016 at 22:17</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@TextGeek The integration between SQL Server and C#/.NET is pretty awesome. You have several tools to use safe selects and updates and whatever - still, <i>lots</i> of developers just ignore those and go right away to the unsafe, generic "just execute this SQL" calls.</span> <span> - </span> <span class="display-name">T. Sar</span> <span> </span> <span class="date">6 Jul 2016 at 11:02</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>24</span>
     </div>
     <div>
      <span>Answerer: </span> <span>David Mulder</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Jun 2016 at 20:01</span>
     </div>
    </div>
    <div>
     <p>I agree with a lot of the answers, but one very important point isn't made: code doesn't magically fix itself, and there is a lot of code out there which is 17 years old. I have seen many companies write clean and safe new code, whilst the application could still be attacked in some of it's older sections. And worst of all: fixing old code is expensive, because it requires developers to delve into code that was written in a different era with different coding styles and different technologies. Sometimes fixing old code to not cause SQL injections requires one to recreate entire libraries that were bought back in the day (this is something I had to do a couple of years ago).</p>
     <p>Not to say that <em>all</em> new code is free of SQL injections, but I personally haven't seen any professionally written new code in the past 4 or 5 years which contained them. (The only exception being where developers have to do a quick and dirty fix in old code and use the same style/technology in which the rest of the code is written.)</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>16</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Andy Lester</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Jul 2016 at 19:58</span>
     </div>
    </div>
    <div>
     <p>I believe it's because many developers learn just enough to get the job done, for some value of "done". They learn how to build SQL code, often from outdated online tutorials, and then when the code "works" to the extent that they can say "I can put stuff in the database, and I can generate the page of results", then they're satisfied.</p>
     <p>Consider this guy on the ladder:</p>
     <p><a href="https://i.stack.imgur.com/lhgN4.jpg" rel="noreferrer"><img src="lhgN4.jpg" alt="Guy on a dangerous ladder"></a></p>
     <p>Why's he doing that? Why doesn't he have proper scaffolding? Because he's getting the job done. Put the ladder up against the wall over the stairs, and it works just fine. Until it doesn't.</p>
     <p>Same thing with <code>INSERT INTO users VALUES($_POST['user'])</code>. It works just fine. Until it doesn't.</p>
     <p>The other thing is that they're not aware of the dangers. With the guy on the unstable ladder, we understand gravity and falling. With building SQL statements from unvalidated outside data, they don't know about what can be done.</p>
     <p>I spoke to a web developer user group last month, and of the 15 devs in the audience, two had heard of SQL injection.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>11</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Bron Davies</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Jun 2016 at 16:10</span>
     </div>
    </div>
    <div>
     <p>I think the main reason is that developer training doesn't start with best practices, it starts with language understanding. Thus, new programmers, believing they have been trained with the tools to create something proceed to create the queries the way they've been taught. The next and most dangerous step, is to allow someone to develop anything without review and therefore continued opportunity to make more poor choices without knowing that there is something wrong with it and produce further habits that ignore industry-wide accepted best practices. So, to sum it up - poorly trained programmers operating in an environment that does not value anything but the end product.</p>
     <p>It has nothing to do with intelligence or "human stupidity". There is a systematic approach that has been well defined over the years and it is negligent for anyone who produces software to ignore that process in the name of faster or cheaper implementation. Perhaps some day the legal ramifications of this behavior will enable us to have more controls in place like the medical or construction industries where failure to comply with these rules and accepted practices will result in a loss of license or other penalty.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>agreed. google "sql examples" and you will get lots of examples of SQL expressions, none of which are safe, because they are all just strings. If that is how you learn to write SQL, then that is what you are going to use on your first project...</span> <span> - </span> <span class="display-name">Mark Lakata</span> <span> </span> <span class="date">30 Jun 2016 at 17:26</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@MarkLakata That's my observation as well. New people rely heavily on Google. Google tends to pull up absolutely horrible examples... Dynamic queries selecting * for one column out of really wide tables. It's mind-boggling how those horrible SQL examples keep floating to the top of the Google searches that new developers use.</span> <span> - </span> <span class="display-name">Brian Knoblauch</span> <span> </span> <span class="date">13 Jul 2016 at 13:25</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Bob Ortiz</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Jun 2016 at 09:15</span>
     </div>
    </div>
    <div>
     <p>Why did SQL injection vulnerabilities not got extinct yet? Metaphorically speaking, for the same reason that car crashes are still around since the very first car in <a href="https://en.wikipedia.org/wiki/Car#Etymology" rel="nofollow noreferrer">1895</a> and even the most innovating and modern self-driving cars today, <a href="http://electrek.co/2016/05/26/tesla-model-s-crash-autopilot-video/" rel="nofollow noreferrer">Tesla model S</a> (on autopilot) or <a href="https://www.engadget.com/2016/02/29/google-self-driving-car-accident/" rel="nofollow noreferrer">Google self-driving car</a> crash from time to time.</p>
     <p><strong>The cars are created (and controlled) by humans, humans make mistakes.</strong></p>
     <p>Web sites and (web) applications are built by human programmers. They tend to make poor mistakes in the security design or tend to break things with "quick-dirty-fixes" when something was secure but actually introducing a new vulnerability for example because time/budget for developing a fix was limited, <em>or the developer had a great hangover when he wrote the fix</em>.</p>
     <p>Is it always caused by developers? Essentially yes, but <strong>not always by the first-line developer</strong>. For example, a local supermarket asked a web development company to create a website for them. The developers rent some shared hosting space from a hosting company to host the site on and they install WordPress and some useful plugins.</p>
     <p>Now the developers of the web development company don't necessarily have to make a mistake to introduce a SQL injection vulnerability in order to be vulnerable. What could go wrong here? A few examples:</p>
     <ol>
      <li>The hosting company didn't update to the latest PHP version and the used PHP versions turn out to be vulnerable to SQLi in general.</li>
      <li>The hosting company configured some public additional software like phpMyAdmin and didn't update that.</li>
      <li>The used WordPress version turns out to be vulnerable to SQLi but the update was missed or there is not patch available yet.</li>
      <li>A used WordPress plugin is vulnerable to SQLi.</li>
     </ol>
     <p><em>Now <strong>the question that is raised</strong>, who is responsible? The supermarket, the web development company, the hosting company, the WordPress community, the WordPress plugin developers or the attacker who misused the vulnerability, rhetorically speaking?</em> - This isn't a statement, it's exaggerated and just some questions that are likely to be asked in case something goes wrong.</p>
     <p>Often the above discussion (questions about responsibility, although slightly exaggerated) are also a risk factor since some developers tend to have a <strong>"that's not my code"-attitude</strong>. You can imagine how complicated that makes the situation sometimes.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>14</td>
        <td><span>Using Wordpress itself should be considered a vulnerability.</span> <span> - </span> <span class="display-name">André Borie</span> <span> </span> <span class="date">27 Jun 2016 at 10:28</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The Tesla car's are crashing because Tesla sort of a loose cannon. To see a better example, look at Google's Self driving cars. (Tesla literally built in self-driving capabilities without telling anyone, and then quietly enabled it with a <b>software update</b>.)</span> <span> - </span> <span class="display-name">PyRulez</span> <span> </span> <span class="date">27 Jun 2016 at 13:36</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>I don't think car crashes is a good comparison. Since 1895 there has been no way to ensure car crashes cannot happen, and there has been progress in reducing the number of incidents (e.g. white lines on the road, dipped beam headlights, better junction and traffic light design), and their impact (airbags, seatbelts, crumple zones). By contrast, SQL injection can be completely fixed by a design change, full stop. Modern cars are not crashing because companies are poorly incentivised, clueless, lazy or incompetent - but that is why SQLi exists.</span> <span> - </span> <span class="display-name">TessellatingHeckler</span> <span> </span> <span class="date">27 Jun 2016 at 17:34</span></td>
       </tr>
       <tr>
        <td>10</td>
        <td><span>@EvanderConsus The web development company. They were contracted to provide a website for use on the internet, and they provided one that was not fit for purpose. To suggest that they might not be responsible because their tools were bad, after they chose no-cost, unwarranted, unsuported tools from unknown people of unknown skill, with many known previous vulnerabilities, is just daft. "<i>We contracted you to build a new building and it's fallen down</i>", "*it's not our fault, we used free steel from some amateur home blacksmiths, how could we possibly know it wouldn't be strong enough?" "oh, ok"</span> <span> - </span> <span class="display-name">TessellatingHeckler</span> <span> </span> <span class="date">27 Jun 2016 at 17:48</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>I don't really understand what car crashes has to do with SQL injection.</span> <span> - </span> <span class="display-name">Ellesedil</span> <span> </span> <span class="date">27 Jun 2016 at 19:04</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@TessellatingHeckler I agree that the responsibility lies with the development company. However, I'd like to note that high-cost, warranted, vendor-supported tools are also written by unknown people of unknown skill. People, even highly-paid people at highly-paid companies, make mistakes, and I would be cautious to make a blanket statement (which you almost seem to be making) that free steel is always worse than <a href="https://www.cvedetails.com/vulnerability-list.php?vendor_id=93&amp;product_id=467&amp;version_id=&amp;page=1&amp;order=3" rel="nofollow noreferrer">the expensive stuff</a>.</span> <span> - </span> <span class="display-name">Wander Nauta</span> <span> </span> <span class="date">27 Jun 2016 at 19:07</span></td>
       </tr>
       <tr>
        <td>8</td>
        <td><span>@WanderNauta Evander asked: <i>*Now the question that is raised, who is responsible?"</i> - I'm not stating that free steel is always worse, only saying that you cannot offset your responsibility by invoking "open source!". If you pick up free steel off the ground, don't put it through metallurgical testing, and later find that it's weak, <i>you</i> are responsible. In this answer, a flaw in a Wordpress plugin? The plugin author never agreed to any contract that it was fit for any purpose. A vendor tool might not be better, but if they sold it as fit for purpose, you are not responsible, they are.</span> <span> - </span> <span class="display-name">TessellatingHeckler</span> <span> </span> <span class="date">27 Jun 2016 at 19:35</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The question about responsibility is indeed rhetorically, I wasn't making any statement about open-source, nor highly-payed developers (therefor I will add it in my answer). @Ellesedil Car crashes have indeed nothing to do with SQL injections, but it it's metaphorically, a figure of speech in which a phrase applies to something to which it is not literally applicable in order to suggest a resemblance.</span> <span> - </span> <span class="display-name">Bob Ortiz</span> <span> </span> <span class="date">29 Jun 2016 at 09:31</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@TessellatingHeckler I'm curious as to what "design change" would fix SQL injection without breaking the right side of operator <code>IN</code>.</span> <span> - </span> <span class="display-name">Damian Yerrick</span> <span> </span> <span class="date">3 Jul 2018 at 19:12</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@DamianYerrick designing your application in such a way that you can only talk to the database after escaping uncontrolled data, using whatever escaping tools are appropriate for your library/DB might be one. On the database side, <a href="https://dba.stackexchange.com/a/55018">PostgreSQL</a> and <a href="https://stackoverflow.com/a/3724272/478656">H2database</a> appear to have ways to pass arrays as single parameters to avoid stringbuilding for this specific purpose. And <a href="https://stackoverflow.com/a/189399/478656">variations</a> on stringbuilding the prepared query - laborious, slower, but still safer app design.</span> <span> - </span> <span class="display-name">TessellatingHeckler</span> <span> </span> <span class="date">3 Jul 2018 at 20:13</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Colin Cassidy</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Jun 2016 at 12:05</span>
     </div>
    </div>
    <div>
     <p>Firstly no one writes secure requirements properly, they say something like "The product shall be secure" Which in no way is testable</p>
     <p>Secondly Profession developers are not stupid, and to say so is rather disingenuous, they are all likely to have university degrees, and have been solving problems we haven`t even begun to look out... The problem is that they have never been taught what it is to develop software securely. This starts out at schools, then university and then whatever job they take, where any training is "on-the-job' because software firms are too scared to train developers in case they leave.</p>
     <p>Developers are also under increasing pressure to do more work in less time, they are busy fixing one issue and moving on to the next, there is little time to reflect as the next problem comes along.</p>
     <p>Developers are not incentivised to test beyond what they are developing, if they find an issue, they are likely to be the developer to fix it. The developer mantra here is "Do not test what you are not prepared to fix"</p>
     <p>Thirdly testers are also not trained to find security vulnerabilities, for much the same reason as software developers. In fact a great deal of testing (in my opinion) is simply repeating the testing that the development team.</p>
     <p>Forthly, time to market is a <strong><em>huge</em></strong> factor, if you are out there first you are making money, developing securely is seen as having a big impact on speed of development - I mean really, who has time for a threat model! ;)</p>
     <p>Finally it's not just SQL injections, buffer overflows have been known about since the 1960's and you can still stumble over them with alarming regularity.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>11</td>
        <td><span>"Secondly Profession[al] developers are not stupid... they are all likely to have university degrees" The smartest developer I ever hired had a two-year degree from a tech school. Some of the worst had doctorates. A piece of paper imbues neither intelligence nor common sense, and I've seen a pervasive lack of both. Unfortunately academia tends to value paper over experience, so new developers are being taught the wrong things because the people doing the teaching don't know any better themselves.</span> <span> - </span> <span class="display-name">DVK</span> <span> </span> <span class="date">27 Jun 2016 at 20:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>still proves that they are not stupid. It shows the huge disparity between academia and industry in the way that software developers are taught. students are being taught the language de-jour, which is likely to be javascript... And that is whole impractical when faced with real-world problems or reliability, performance scalability, un-clean data etc etc... all the things that you would end up having to manage in applications.</span> <span> - </span> <span class="display-name">Colin Cassidy</span> <span> </span> <span class="date">28 Jun 2016 at 04:54</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>Universities seem to just teach you how to sound smart while not knowing anything of practical use.</span> <span> - </span> <span class="display-name">crush</span> <span> </span> <span class="date">28 Jun 2016 at 15:35</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>no. In the context of the original question, there's just very little focus on product security in a university syllabus</span> <span> - </span> <span class="display-name">Colin Cassidy</span> <span> </span> <span class="date">28 Jun 2016 at 19:34</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@colincassidy your comment should read, there isn't any focus on product security in a university syllabus.</span> <span> - </span> <span class="display-name">Jim B</span> <span> </span> <span class="date">30 Jun 2016 at 17:22</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Jedi</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Jun 2016 at 16:58</span>
     </div>
    </div>
    <div>
     <p>Yes, anthropologically, <a href="https://security.stackexchange.com/a/128413/111626">humans are stupid</a>.</p>
     <p>Yes, politically, <a href="https://security.stackexchange.com/a/128483/111626">the incentive structure does not sufficiently penalize vulnerable applications</a></p>
     <p>Yes, <a href="https://security.stackexchange.com/a/128453/111626">the process is flawed</a>-- code is written in a hurry; bad/old code is <a href="https://security.stackexchange.com/questions/15214/are-prepared-statements-100-safe-against-sql-injection">not always thrown away</a>.</p>
     <p>And, yes, technically, <a href="https://security.stackexchange.com/a/128414/111626">treating and mixing data as code</a> <a href="http://c2.com/cgi/wiki?DataAndCodeAreTheSameThing" rel="nofollow noreferrer">is harder to do by default</a>.</p>
     <p>But, there's a more positive view (lets ignore the 99% of SQLi vulnerabilities that the answers above explain). SQLi still exists on extremely well-designed and carefully developed websites because <strong>we are awesome</strong>. Hackers rule. You only need to look at the hundreds of attack vectors and thousands of SQLi payloads that have been developed over the last seventeen years to regain some faith in the human race. Every year brings with it new techniques presented DEFCON/BlackHat/RSA/IEEESSP. Bug bounty programs for Facebook, Google and the like have all had to shell out at least once for a critical SQLi.</p>
     <p>Partly, it's because of the complexity and number of layers in our system, each mutating data in newer and more interesting ways. We increasingly need more done, faster, using fewer resources. And as long as we cannot feasibly test all paths into the system, <a href="https://security.stackexchange.com/questions/15214/are-prepared-statements-100-safe-against-sql-injection">no one is going to certify a solution to injection problems</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>niilzon</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Jun 2016 at 11:18</span>
     </div>
    </div>
    <div>
     <p>Because such security issues are not covered during most 3-year education cycles and equivalent studies, and many developers followed such track (including myself). Given how wide the field is, actually 3 years is not even enough to cope with the actual study program.. So things like security are dropped.</p>
     <p>It is unfortunate, but since some of the new developers won't ever try to learn new things by themselves, those people will always write SQLi-prone code until a more educated colleague points the issue out (or until an actual SQLi happens).</p>
     <p>During my studies (many years ago), our teachers always told us to use PreparedStatements when creating manual SQL queries, because it is "best-practice", but they did not say why. This is better than nothing, but pretty sad, still. I'm not sure if those teachers even knew themselves.</p>
     <p>We learned how to display stuff on a jsp, but not what Cross-Site-Scripting is..</p>
     <p>I am "lucky" to be a passionate dev with some time in my hands, so I learned all these things by myself a long time ago, but I'm sure that many developers just do their 8-hours-a-day (for legitimate reasons by the way), and as long as nobody shows them what is wrong, it won't change.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Sometimes, some developers underestimate the risk of SQLi.</span> <span> - </span> <span class="display-name">Stephan</span> <span> </span> <span class="date">29 Jun 2016 at 14:45</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The uneducated usually do. It reminds me of a post on this very site, where a student was having issues with queries. I showed him how to made the code work, and pointed out that it was SQLi-prone, suggesting to refactor the code with PreparedStatements. His answer was "but it is just for a class exercise, this code won't be reused, I don't care". This is the kind of attitude we must fight against. Coding as properly as possible on all occasions is important, <i>especially if you don't highly master what you are doing</i>.</span> <span> - </span> <span class="display-name">niilzon</span> <span> </span> <span class="date">8 Jul 2016 at 07:01</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Neil Davis</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Jun 2016 at 01:54</span>
     </div>
    </div>
    <div>
     <p>If you use prepared statements correctly, SQL injection is not possible.</p>
     <p>"If the original statement template is not derived from external input, SQL injection cannot occur."</p>
     <p><a href="https://en.m.wikipedia.org/wiki/Prepared_statement" rel="nofollow">https://en.m.wikipedia.org/wiki/Prepared_statement</a></p>
     <p>Unfortunately people usually don't use prepared statements correctly, if at all.</p>
     <p>SQL injection would be a thing of the past if they did.</p>
     <p>And yes, php/MySQL have had a prepared statement implementation for a very long time, over 10 years if memory serves...</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span> <span class="arrow"> <a href="#answer_15">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>mystupidstory</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Jul 2016 at 23:49</span>
     </div>
    </div>
    <div>
     <p>The other answers have pointed to almost all the reasons. But there is something else, which I think is the most dangerous security concern of all. Developers attempt to add more and more features to technologies, and sometimes deviate from the actual purpose of the technology. A little like how a client side scripting language ended up being used for server side coding or was allowed access to remote resources as well as client side local storage. Instead of layering these as separate technologies, they were all put into one big honeypot. Looking into some of the advanced SQL injections, we can see how they have played a part in the steady accent of SQLi attacks.</p>
     <p>With SQL though, I guess the biggest mistake was the coupling of commands and parameters. It's a little like calling <code>run(value, printf)</code> instead of <code>printf(value)</code>.</p>
     <p>Oh and one last thing, while it's quite easy to convert between different type of databases, the changes required in the server side code are mammoth.</p>
     <p>Someone should abstract between different type of databases and make it easier to switch between different dbs. Say a php plugin which takes in as input QL commands and the type of database, and may be a whitelisted filter to sanitize the input.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_15"><span>Answer 15</span> <span class="arrow"> <a href="#answer_14">↑</a> </span> <span class="arrow"> <a href="#answer_16">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Bradley Thomas</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Jun 2016 at 18:06</span>
     </div>
    </div>
    <div>
     <p>Personally I think this is a specific case of a more general problem in programming, that IDE's and languages are overly permissive. We give our developers immense power in the name of flexibility and efficiency. The result is "what can happen will happen", and security lapses are inevitable.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_16"><span>Answer 16</span> <span class="arrow"> <a href="#answer_15">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>pppp</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Jun 2016 at 06:30</span>
     </div>
    </div>
    <div>
     <p>PDO (or other "safe" methods) is no more secure than mysql_ (or other "unsafe" methods). It makes it easier to write safe code, but it is even simpler to just concatenate the unescaped user provided strings into the query and not bother with the parameters.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>7</td>
        <td><span>I'm not sure this answers the question. Was this meant as a comment on another answer?</span> <span> - </span> <span class="display-name">schroeder</span> <span> </span> <span class="date">28 Jun 2016 at 07:19</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>I believe he meant to say that the reason SQL Injection still exists is because the above "safe methods" don't fully protect from SQL Injections, and that people need to be aware of fully protecting yourself, and making sure you use a DB that is able to handle the needed situations.</span> <span> - </span> <span class="display-name">XaolingBao</span> <span> </span> <span class="date">28 Jun 2016 at 20:07</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Making safe code harder to write results in more bugs and thus less secure code.</span> <span> - </span> <span class="display-name">Cees Timmerman</span> <span> </span> <span class="date">6 Jul 2016 at 12:19</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>