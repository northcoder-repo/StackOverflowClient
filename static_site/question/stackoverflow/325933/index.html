<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>Determine Whether Two Date Ranges Overlap</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>Determine Whether Two Date Ranges Overlap</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>1593</span>
    </div>
    <div>
     <span>Asker: </span> <span>Ian Nelson</span>
    </div>
    <div>
     <span>Asked: </span> <span>28 Nov 2008 at 14:48</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/325933/determine-whether-two-date-ranges-overlap">source</a>
    </div>
   </div>
   <div>
    <p>Given two date ranges, what is the simplest or most efficient way to determine whether the two date ranges overlap?</p>
    <p>As an example, suppose we have ranges denoted by DateTime variables <code>StartDate1</code> to <code>EndDate1</code> <em>and</em> <code>StartDate2</code> to <code>EndDate2</code>.</p>
   </div>
   <div class="tags">
    <span class="tag">datetime</span><span class="tag">math</span><span class="tag">language-agnostic</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>3</td>
       <td><span>Extremely similar to <a href="http://stackoverflow.com/questions/306316/determine-if-two-rectangles-overlap-each-other#306332" title="determine if two rectangles overlap each other%23306332">stackoverflow.com/questions/306316/…</a></span> <span> - </span> <span class="display-name">Charles Bretana</span> <span> </span> <span class="date">28 Nov 2008 at 14:54</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>@CharlesBretana thanks for that, you're right - that's almost like a two-dimensional version of my question!</span> <span> - </span> <span class="display-name">Ian Nelson</span> <span> </span> <span class="date">28 Nov 2008 at 14:57</span></td>
      </tr>
      <tr>
       <td>2</td>
       <td><span>very similar to <a href="http://stackoverflow.com/questions/117962/simplestefficient-way-to-find-rows-with-time-interval-overlaps-in-sql" title="simplestefficient way to find rows with time interval overlaps in sql">stackoverflow.com/questions/117962/…</a></span> <span> - </span> <span class="display-name">Steven A. Lowe</span> <span> </span> <span class="date">28 Nov 2008 at 16:35</span></td>
      </tr>
      <tr>
       <td>2</td>
       <td><span>Divide the situation 'the two date ranges intersect' into cases (there are two) then test for each case.</span> <span> - </span> <span class="display-name">Colonel Panic</span> <span> </span> <span class="date">12 Oct 2012 at 23:14</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>I know this has been tagged as language-agnostic, but for all of you implementing in Java: Don't reinvent the wheel and use Joda Time. <a href="http://joda-time.sourceforge.net/api-release/org/joda/time/base/AbstractInterval.html#overlaps(org.joda.time.ReadableInterval)" rel="nofollow noreferrer">joda-time.sourceforge.net/api-release/org/joda/time/base/…</a></span> <span> - </span> <span class="display-name">Stefan Haberl</span> <span> </span> <span class="date">13 Oct 2012 at 15:10</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>If dates can be NULL values (or empty), when they are not set, there is <a href="https://stackoverflow.com/questions/3196099/date-range-overlap-with-nullable-dates">this question</a> which is an extension of this one.</span> <span> - </span> <span class="display-name">lepe</span> <span> </span> <span class="date">24 Jun 2017 at 06:09</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span><a href="https://www.geeksforgeeks.org/merging-intervals/" rel="nofollow noreferrer">Merge Overlapping Intervals</a> algorithm can give some leads.</span> <span> - </span> <span class="display-name">RBT</span> <span> </span> <span class="date">30 May 2018 at 10:33</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>Hi.. A: StartDate1, B: EndDate1, C: StartDate2, D: EndDate2. if B &lt; C or A &gt; D then we assume that they are not intersected.. So, we can easily test with " isintersects = not (B &lt; C or A &gt; D) " this will give us always whether it intersects or not.</span> <span> - </span> <span class="display-name">Nihat Erim inceoğlu</span> <span> </span> <span class="date">11 Feb 2020 at 12:20</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Yet another interval utility for .Net <a href="https://github.com/AlexeyBoiko/IntervalUtility" rel="nofollow noreferrer">github.com/AlexeyBoiko/IntervalUtility</a> (I am the author)</span> <span> - </span> <span class="display-name">user1167761</span> <span> </span> <span class="date">10 Mar 2021 at 10:59</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2894</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Charles Bretana</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Nov 2008 at 15:00</span>
     </div>
    </div>
    <div>
     <p><strong>(StartA &lt;= EndB) and (EndA &gt;= StartB)</strong></p>
     <p><em>Proof:</em><br>
       Let ConditionA Mean that DateRange A Completely After DateRange B</p>
     <pre><code>_                        |---- DateRange A ------|
|---Date Range B -----|                          _
</code></pre>
     <p>(True if <code>StartA &gt; EndB</code>)</p>
     <p>Let ConditionB Mean that DateRange A is Completely Before DateRange B</p>
     <pre><code>|---- DateRange A -----|                        _ 
_                          |---Date Range B ----|
</code></pre>
     <p>(True if <code>EndA &lt; StartB</code>)</p>
     <p>Then Overlap exists if Neither A Nor B is true -<br>
       (If one range is neither completely after the other,<br>
       nor completely before the other, then they must overlap.)</p>
     <p>Now one of <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" rel="noreferrer">De Morgan's laws</a> says that:</p>
     <p><code>Not (A Or B)</code> &lt;=&gt; <code>Not A And Not B</code></p>
     <p>Which translates to: <code>(StartA &lt;= EndB) and (EndA &gt;= StartB)</code></p>
     <hr>
     <p>NOTE: This includes conditions where the edges overlap exactly. If you wish to exclude that,<br>
       change the <code>&gt;=</code> operators to <code>&gt;</code>, and <code>&lt;=</code> to <code>&lt;</code></p>
     <hr>
     <p>NOTE2. Thanks to @Baodad, see <a href="http://baodad.blogspot.com/2014/06/date-range-overlap.html" rel="noreferrer">this blog</a>, the actual overlap is least of:<br>
       { <code>endA-startA</code>, <code>endA - startB</code>, <code>endB-startA</code>, <code>endB - startB</code> }</p>
     <p><code>(StartA &lt;= EndB) and (EndA &gt;= StartB)</code> <code>(StartA &lt;= EndB) and (StartB &lt;= EndA)</code></p>
     <hr>
     <p>NOTE3. Thanks to @tomosius, a shorter version reads:<br><code>DateRangesOverlap = max(start1, start2) &lt; min(end1, end2)</code><br>
       This is actually a syntactical shortcut for what is a longer implementation, which includes extra checks to verify that the start dates are on or before the endDates. Deriving this from above:</p>
     <p>If start and end dates can be out of order, i.e., if it is possible that <code>startA &gt; endA</code> or <code>startB &gt; endB</code>, then you also have to check that they are in order, so that means you have to add two additional validity rules:<br><code>(StartA &lt;= EndB) and (StartB &lt;= EndA) and (StartA &lt;= EndA) and (StartB &lt;= EndB)</code> or:<br><code>(StartA &lt;= EndB) and (StartA &lt;= EndA) and (StartB &lt;= EndA) and (StartB &lt;= EndB)</code> or,<br><code>(StartA &lt;= Min(EndA, EndB) and (StartB &lt;= Min(EndA, EndB))</code> or:<br><code>(Max(StartA, StartB) &lt;= Min(EndA, EndB)</code></p>
     <p>But to implement <code>Min()</code> and <code>Max()</code>, you have to code, (using C ternary for terseness),:<br><code>((StartA &gt; StartB) ? StartA : StartB) &lt;= ((EndA &lt; EndB) ? EndA : EndB)</code></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>anyway we can get the actual number of overlap seconds</span> <span> - </span> <span class="display-name">rashid</span> <span> </span> <span class="date">1 Apr 2015 at 05:42</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Yes, but I don't think there's a simple way... Without writing actual SQL one algorithm would be: using A0, A1, B0 and B1 as points: When No Overlap, then <code>0</code>; When Bo and B1 are both between A0 and A1, then it's <code>B1-B0</code>; When only B0 is between A0 and A1, then it's <code>A1-B0</code>; when only B1 is between A0 and A1 then it's <code>B1-A0</code>; else, it's <code>A1-A0</code></span> <span> - </span> <span class="display-name">Charles Bretana</span> <span> </span> <span class="date">1 Apr 2015 at 13:55</span></td>
       </tr>
       <tr>
        <td>58</td>
        <td><span>This is a simplified logic based on these two assumptions: 1) StartA &lt; EndA; 2) StartB &lt; EndB. It seems to be obvious but in reality data can come from unknown source like user input or a database without sanitization. Keep in mind that you will need to validate input data to make sure those two assumptions are true before you can use this simplified logic or everything will be falling apart. Lesson learned from my own experience ;)</span> <span> - </span> <span class="display-name">Devy</span> <span> </span> <span class="date">27 Jul 2015 at 19:08</span></td>
       </tr>
       <tr>
        <td>14</td>
        <td><span>@Devy, You are correct. Except that it will also work if startA = endA. Indeed, that's exactly what the words <code>Start</code> and <code>End</code> mean. If you have two variables named Top and Bottom, or East and West, or HighValue and LoValue, it can be assumed or implied that something or someone, somewhere should be ensuring that one of the pairs of values are not stored in the opposite variables. -Only one of the two pairs because, well, it will also work if both pairs of values are switched.</span> <span> - </span> <span class="display-name">Charles Bretana</span> <span> </span> <span class="date">5 Aug 2015 at 12:08</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Devy That seems like an unrelated problem. Draw a line to show 5th - 9th August on a calendar, then draw a line to show 7th - 3rd August and tell me if they overlap. You can't, because you can't draw a line starting on the 7th August and ending on the 3rd (only the other way round).</span> <span> - </span> <span class="display-name">thelem</span> <span> </span> <span class="date">20 Nov 2015 at 11:48</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@rashid, <a href="http://baodad.blogspot.com/2014/06/date-range-overlap.html" rel="nofollow noreferrer">here's a post</a> the might give you some hints on how to get the actual amount of overlap.</span> <span> - </span> <span class="display-name">Baodad</span> <span> </span> <span class="date">15 Dec 2015 at 17:39</span></td>
       </tr>
       <tr>
        <td>29</td>
        <td><span>You can easily add nullable <code>start</code> and <code>end</code> (with the semantic that "null start" = "From the beginning of the time" and "null end" = "To the end of the time") like that: <code>(startA === null || endB === null || startA &lt;= endB) &amp;&amp; (endA === null || startB === null || endA &gt;= startB)</code></span> <span> - </span> <span class="display-name">Kevin Robatel</span> <span> </span> <span class="date">26 Feb 2016 at 13:38</span></td>
       </tr>
       <tr>
        <td>8</td>
        <td><span>This is the best answer I ever saw in the StackOverflow.</span> <span> - </span> <span class="display-name">Sampath</span> <span> </span> <span class="date">17 Oct 2017 at 07:27</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span><a href="https://silentmatt.com/rectangle-intersection/" rel="nofollow noreferrer">silentmatt.com/rectangle-intersection</a> Use this tool to check different cases easily with drag and drop and verify your solution.</span> <span> - </span> <span class="display-name">habib</span> <span> </span> <span class="date">11 Nov 2019 at 14:42</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@KevinRobatel, This works for all scenarios but when both endA and endB are null, this is a scenario where no matter which dates are set, they will conflict, but in your scenario they pass.</span> <span> - </span> <span class="display-name">xcyteh</span> <span> </span> <span class="date">16 Nov 2020 at 15:36</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>How about inverted logic? Something like: NOT (EndA &lt; StartB OR StartA &gt; EndB)</span> <span> - </span> <span class="display-name">Giuse Petroso</span> <span> </span> <span class="date">12 Nov 2021 at 14:34</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Giuse, Read my answer. I start out with that. In the middle, I apply de Morgan's law to convert it to the shorter but equivalent representation.</span> <span> - </span> <span class="display-name">Charles Bretana</span> <span> </span> <span class="date">12 Nov 2021 at 14:40</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>My solution: <code>database_record_start_date &lt;= filter_end_date and database_record_end_date &gt;= filter_start_date</code> Example: <code>database_record_start_date &lt;= '2022-02-28' and database_record_end_date &gt;= '2022-02-01'</code></span> <span> - </span> <span class="display-name">Eduardo Mior</span> <span> </span> <span class="date">25 Feb 2022 at 13:23</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This seems to be the best approach. However I found an alternate, interesting way of doing it here: <a href="https://stackoverflow.com/a/27430668/2157236">stackoverflow.com/a/27430668/2157236</a></span> <span> - </span> <span class="display-name">Carl</span> <span> </span> <span class="date">1 Jun 2022 at 10:45</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Carl, your alternate approach is actually just the equivalent mathematical expression for the logical expression above. When two real numbers have the opposite sign, their product is negative, when they have the same sign, the product is positive.</span> <span> - </span> <span class="display-name">Charles Bretana</span> <span> </span> <span class="date">1 Jun 2022 at 13:15</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>526</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ian Nelson</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Nov 2008 at 14:49</span>
     </div>
    </div>
    <div>
     <p>I believe that it is sufficient to say that the two ranges overlap if:</p>
     <pre><code>(StartDate1 &lt;= EndDate2) and (StartDate2 &lt;= EndDate1)
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>108</td>
        <td><span>I find the <code>(StartDate1 &lt;= EndDate2) and (EndDate1 &gt;= StartDate2)</code> notation easier to understand, Range1 is always on left in the tests.</span> <span> - </span> <span class="display-name">A.L</span> <span> </span> <span class="date">2 Dec 2013 at 14:46</span></td>
       </tr>
       <tr>
        <td>18</td>
        <td><span>This assumes start and end dates are inclusive. Change <code>&lt;=</code> to <code>&lt;</code> if start is inclusive and end is exclusive.</span> <span> - </span> <span class="display-name">Richard Schneider</span> <span> </span> <span class="date">9 Apr 2014 at 02:54</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This will work very well even if startDate2 is before startDate1. So no need to assume that startDate1 is earlier than startDate2.</span> <span> - </span> <span class="display-name">Shehan Simen</span> <span> </span> <span class="date">6 Feb 2015 at 05:04</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>I found (StartDate1 &lt;= EndDate2) and (StartDate2 &lt;= EndDate1) notation (as per answer) easier to understand than that in other answers.</span> <span> - </span> <span class="display-name">apc</span> <span> </span> <span class="date">4 Aug 2016 at 08:44</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>How to adapt so that it works with data that has StartDate1 AND/OR EndDate1? The code assumes that StartDate1 and EndDate1 are always present. What if StartDate1 is given but no EndDate1 OR EndDate1 given but not StartDate1. How to handle this extra case?</span> <span> - </span> <span class="display-name">juFo</span> <span> </span> <span class="date">6 Aug 2019 at 15:18</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>How can I make start exclusive &amp; end inclusive?</span> <span> - </span> <span class="display-name">Jay Patel</span> <span> </span> <span class="date">10 Jan 2020 at 07:43</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>169</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user687474</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Apr 2011 at 22:42</span>
     </div>
    </div>
    <div>
     <p>This article <a href="http://www.codeproject.com/KB/datetime/TimePeriod.aspx">Time Period Library for .NET</a> describes the relation of two time periods by the enumeration <strong>PeriodRelation</strong>:</p>
     <pre><code>// ------------------------------------------------------------------------
public enum PeriodRelation
{
    After,
    StartTouching,
    StartInside,
    InsideStartTouching,
    EnclosingStartTouching,
    Enclosing,
    EnclosingEndTouching,
    ExactMatch,
    Inside,
    InsideEndTouching,
    EndInside,
    EndTouching,
    Before,
} // enum PeriodRelation
</code></pre>
     <p><img src="https://i.stack.imgur.com/0c6q0.png" alt="enter image description here"></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Nice, I have implemented Allens interval algebra in Java, too, see the <a href="http://time4j.net/javadoc-en/net/time4j/range/IntervalRelation.html" rel="nofollow noreferrer">API of IntervalRelation and IsoInterval</a></span> <span> - </span> <span class="display-name">Meno Hochschild</span> <span> </span> <span class="date">10 Apr 2017 at 06:05</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>Great summarize to write specs for overlaping dates</span> <span> - </span> <span class="display-name">ToTenMilan</span> <span> </span> <span class="date">1 Aug 2020 at 15:23</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>102</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Jonathan Leffler</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Nov 2008 at 06:54</span>
     </div>
    </div>
    <div>
     <p>For reasoning about temporal relations (or any other interval relations, come to that), consider <a href="http://en.wikipedia.org/wiki/Allen%27s_Interval_Algebra" rel="noreferrer">Allen's Interval Algebra</a>. It describes the 13 possible relations that two intervals can have with respect to each other. You can find other references — "Allen Interval" seems to be an operative search term. You can also find information about these operations in Snodgrass's <a href="http://www.cs.arizona.edu/~rts/publications.html" rel="noreferrer">Developing Time-Oriented Applications in SQL</a> (PDF available online at URL), and in Date, Darwen and Lorentzos <a href="https://rads.stackoverflow.com/amzn/click/com/B005UY0W0E" rel="noreferrer">Temporal Data and the Relational Model</a> (2002) or <a href="https://rads.stackoverflow.com/amzn/click/com/B00N2SNSUG" rel="noreferrer">Time and Relational Theory: Temporal Databases in the Relational Model and SQL</a> (2014; effectively the second edition of TD&amp;RM).</p>
     <hr>
     <p>The short(ish) answer is: given two date intervals <code>A</code> and <code>B</code> with components <code>.start</code> and <code>.end</code> and the constraint <code>.start &lt;= .end</code>, then two intervals overlap if:</p>
     <pre><code>A.end &gt;= B.start AND A.start &lt;= B.end
</code></pre>
     <p>You can tune the use of <code>&gt;=</code> vs <code>&gt;</code> and <code>&lt;=</code> vs <code>&lt;</code> to meet your requirements for degree of overlap.</p>
     <hr>
     <p>ErikE comments:</p>
     <blockquote>
      <p>You can only get 13 if you count things funny... I can get "15 possible relations that two intervals can have" when I go crazy with it. By sensible counting, I get only six, and if you throw out caring whether A or B comes first, I get only three (no intersect, partially intersect, one wholly within other). 15 goes like this: [before:before, start, within, end, after], [start:start, within, end, after], [within:within, end, after], [end:end, after], [after:after].</p>
     </blockquote>
     <p>I think that you cannot count the two entries 'before:before' and 'after:after'. I could see 7 entries if you equate some relations with their inverses (see the diagram in the referenced Wikipedia URL; it has 7 entries, 6 of which have a different inverse, with equals not having a distinct inverse). And whether three is sensible depends on your requirements.</p>
     <pre><code>----------------------|-------A-------|----------------------
    |----B1----|
           |----B2----|
               |----B3----|
               |----------B4----------|
               |----------------B5----------------|
                      |----B6----|
----------------------|-------A-------|----------------------
                      |------B7-------|
                      |----------B8-----------|
                         |----B9----|
                         |----B10-----|
                         |--------B11--------|
                                      |----B12----|
                                         |----B13----|
----------------------|-------A-------|----------------------
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>You can only get 13 if you count things funny... I can get "15 possible relations that two intervals can have" when I go crazy with it. By sensible counting, I get only six, and if you throw out caring whether A or B comes first, I get only three (no intersect, partially intersect, one wholly within other). 15 goes like this: [before:before, start, within, end, after], [start:start, within, end, after],[within:within, end, after], [end:end, after], [after:after].</span> <span> - </span> <span class="display-name">ErikE</span> <span> </span> <span class="date">9 Mar 2010 at 01:18</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Emtucifor: I think that you cannot count the two entries 'before:before' and 'after:after'.</span> <span> - </span> <span class="display-name">Jonathan Leffler</span> <span> </span> <span class="date">9 Mar 2010 at 02:37</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Re your update: B1 to A is before:before and B13 to A is after:after. Your nice diagram is missing start:start between B5 B6, and end:end between B11 and B12. If being on an endpoint is significant, then you have to count it, so the final tally is 15, not 13. I <i>don't</i> think the endpoint thing is significant, so I personally count it [before: before, within, after], [within: within, after], [after:after] which comes to 6. I think the whole endpoint thing is just confusion about whether the bounds are inclusive or exclusive. The exclusiveness of the endpoints don't change the core relations!</span> <span> - </span> <span class="display-name">ErikE</span> <span> </span> <span class="date">10 Mar 2010 at 20:38</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>That is, in my scheme the these are equivalent: (B2, B3, B4), (B6, B7, B9, B10), (B8, B11, B12). I realize that B7 implies the information that the two ranges exactly coincide. But I'm not convinced this <i>additional</i> information should be part of the base intersection relations. For example, when two intervals are the exact same length even if not coincident or even overlapping, should that be considered another "relation"? I say no, and seeing as this additional aspect is the only thing making B7 distinct from B6, then I think having endpoints-as-separate-cases makes things inconsistent.</span> <span> - </span> <span class="display-name">ErikE</span> <span> </span> <span class="date">10 Mar 2010 at 20:51</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Emtucifor: OK - I see why I misidentified 'before:before' and 'after:after' as the entries; however, I cannot picture what the 'start:start' and 'end:end' entries should look like. Since you can't edit my diagram, can you email me (see my profile) with a modified copy of the diagram showing the 'start:start' and 'end:end' relationships? I have no major issues with your groupings.</span> <span> - </span> <span class="display-name">Jonathan Leffler</span> <span> </span> <span class="date">10 Mar 2010 at 21:07</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>start:start would be starting and ending at the same time, the beginning of A. Since time in computers always has a granularity or resolution, this still denotes a (possibly very short) time range. end:end would be starting and ending at the end of A. I'll do the email for completeness.</span> <span> - </span> <span class="display-name">ErikE</span> <span> </span> <span class="date">11 Mar 2010 at 05:14</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>After an email exchange with Jonathan, I realized that in my model where the start time is inclusive and the end time is exclusive, a range beginning and stopping at the same time is zero length (because it ends before it starts). So [start:start] and [end:end] don't make sense in my scheme. However, the scheme Jonathan suggests requires that the endpoints are inclusive, otherwise ranges B2 and A (for example) would not intersect. This to me is problematic because times in a computer are not represented to infinite precision. See next comment -&gt;</span> <span> - </span> <span class="display-name">ErikE</span> <span> </span> <span class="date">12 Mar 2010 at 17:18</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>If the end time is inclusive, then to denote non-overlapping but contiguous ranges in a computer, one has to subtract the smallest time increment allowed from the end time of the earlier segment. In SQL Server with the datetime data type, for example, the ranges A:'20100101 09:00' - '20100101 10:00' and B:'20100101 10:00' - '20100101 11:00' would overlap by 1/300th of a millisecond. To make them contiguous and non-overlapping, the first range would have to be adjusted to A:'20100101 09:00' - '20100101 09:59:59.997'. But this is completely unacceptable for multiple reasons (Next -&gt;)</span> <span> - </span> <span class="display-name">ErikE</span> <span> </span> <span class="date">12 Mar 2010 at 17:21</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The first and less important reason is that people don't think of times this way. They want to say that the range begins at 9 and ends at 10. If you're collecting data from a user then you either have to present the 09:59:59.997 garbage (this would never work) or adjust all the times when you store them (not much better). The second and more important reason is that the underlying data type shouldn't change the business meaning of data. What iff the datetime column was converted to datetime2 (<a href="http://technet.microsoft.com/en-us/library/bb677335.aspx" rel="nofollow noreferrer">technet.microsoft.com/en-us/library/bb677335.aspx</a>) which has 00:00:00 through 23:59:59.9999999?</span> <span> - </span> <span class="display-name">ErikE</span> <span> </span> <span class="date">12 Mar 2010 at 17:23</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Now there is a gap between the end of A and the start of B. The only sensible solution to all this madness is to just to treat end times as exclusive. Once this is done, the 13 ranges mentioned by Jonathan completely break down. There is no special difference between two non-overlapping ranges that are adjacent or separated. After removing collapsed or equivalent cases, we are left with only 6 basic relations (3 if A and B are considered interchangeably).</span> <span> - </span> <span class="display-name">ErikE</span> <span> </span> <span class="date">12 Mar 2010 at 17:26</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>40</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Vitalii Fedorenko</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Sep 2012 at 02:07</span>
     </div>
    </div>
    <div>
     <p>If the overlap itself should be calculated as well, you can use the following formula:</p>
     <pre><code>overlap = max(0, min(EndDate1, EndDate2) - max(StartDate1, StartDate2))
if (overlap &gt; 0) { 
    ...
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>so overlap is the amount of time that the two events share? Does this work for all the different ways events can overlap?</span> <span> - </span> <span class="display-name">NSjonas</span> <span> </span> <span class="date">9 Sep 2016 at 20:15</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>This does not work when there is complete overlap. For e.g. Range1: 1-7 Range2: 4-5</span> <span> - </span> <span class="display-name">Kakshil Shah</span> <span> </span> <span class="date">15 Apr 2021 at 12:52</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>23</span>
     </div>
     <div>
      <span>Answerer: </span> <span>paxdiablo</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Aug 2010 at 02:39</span>
     </div>
    </div>
    <div>
     <p>All the solutions that check a multitude of conditions based on where the ranges are in relation to one another can be greatly simplified by <em><strong>simply ensuring that one range starts before or at the same time as the other.</strong></em> You can do this by swapping the ranges if necessary up front.</p>
     <p>Then, you can detect overlap if the second range start is:</p>
     <ul>
      <li>less than or equal to the first range end (if ranges are inclusive, containing both the start and end times); or</li>
      <li>less than (if ranges are inclusive of start and exclusive of end).</li>
     </ul>
     <p>For example (assuming inclusive at both ends), there's only four possibilities for range 2, of which <em>one</em> is a non-overlap (the <code>&gt;</code> at the end of the range means it doesn't matter where the range ends):</p>
     <pre class="lang-none prettyprint-override"><code>|-----|        range 1, lines below are all range 2.
|--&gt;  :        overlap.
 |--&gt; :        overlap.
      |---&gt;    overlap (no overlap in exclusive-of-end case).
       |---&gt;   no overlap.
</code></pre>
     <p>The <em>endpoint</em> of the second range doesn't affect the result at all. So, in pseudo-code, you can do something like (assuming <code>s &lt;= e</code> holds for all ranges - if not, you may have top swap them as well):</p>
     <pre class="lang-py prettyprint-override"><code>def overlaps(r1, r2):
    if r1.s &gt; r2.s:
        swap r1, r2
    return r2.s &lt;= r1.e
</code></pre>
     <p>Or, the one-level-limit recursive option:</p>
     <pre class="lang-py prettyprint-override"><code>def overlaps(r1, r2):
    if r1.s &lt;= r2.s:
        return r2.s &lt;= r1.e
    return overlaps(r2, r1)
</code></pre>
     <p>If the ranges are <em>exclusive</em> at the end, you just have to replace <code>&lt;=</code> with <code>&lt;</code> in the expression you return (in both code snippets).</p>
     <p>This greatly limits the number of checks you have to make because you remove half of the problem space early by ensuring the first range never starts after the second.</p>
     <hr>
     <p>And, since "code talks", here is some Python code that shows this in action, with quite a few test cases. First, the <code>InclusiveRange</code> class:</p>
     <pre class="lang-py prettyprint-override"><code>class InclusiveRange:
    """InclusiveRange class to represent a lower and upper bound."""

    def __init__(self, start, end):
        """Initialisation, ensures start &lt;= end.
        Args:
            start: The start of the range.
            end: The end of the range.
        """
        self.start = min(start, end)
        self.end = max(start, end)

    def __repr__(self):
        """Return representation for f-string."""
        return f"({self.start}, {self.end})"

    def overlaps(self, other):
        """True if range overlaps with another.
        Args:
            other: The other InclusiveRange to check against.
        """

        # Very limited recursion to ensure start of first range
        # isn't after start of second.

        if self.start &gt; other.start:
            return other.overlaps(self)

        # Greatly simplified check for overlap.

        return other.start &lt;= self.end
</code></pre>
     <p>Then a test case handler to allow us to nicely present the result of a <em>single</em> test case:</p>
     <pre class="lang-py prettyprint-override"><code>def test_case(range1, range2):
    """Single test case checker."""

    # Get low and high value for "graphic" output.

    low = min(range1.start, range2.start)
    high = max(range1.end, range2.end)

    # Output ranges and graphic.

    print(f"r1={range1} r2={range2}: ", end="")
    for val in range(low, high + 1):
        is_in_first = range1.start &lt;= val &lt;= range1.end
        is_in_second = range2.start &lt;= val &lt;= range2.end

        if is_in_first and is_in_second:
            print("|", end="")
        elif is_in_first:
            print("'", end="")
        elif is_in_second:
            print(",", end="")
        else:
            print(" ", end="")

    # Finally, output result of overlap check.

    print(f" - {range1.overlaps(range2)}\n")
</code></pre>
     <p>Then finally, a decent chunk of test cases to which you can add your own if need be:</p>
     <pre class="lang-py prettyprint-override"><code># Various test cases, add others if you doubt the correctness.

test_case(InclusiveRange(0, 1), InclusiveRange(8, 9))
test_case(InclusiveRange(0, 4), InclusiveRange(5, 9))
test_case(InclusiveRange(0, 4), InclusiveRange(4, 9))
test_case(InclusiveRange(0, 7), InclusiveRange(2, 9))
test_case(InclusiveRange(0, 4), InclusiveRange(0, 9))
test_case(InclusiveRange(0, 9), InclusiveRange(0, 9))
test_case(InclusiveRange(0, 9), InclusiveRange(4, 5))

test_case(InclusiveRange(8, 9), InclusiveRange(0, 1))
test_case(InclusiveRange(5, 9), InclusiveRange(0, 4))
test_case(InclusiveRange(4, 9), InclusiveRange(0, 4))
test_case(InclusiveRange(2, 9), InclusiveRange(0, 7))
test_case(InclusiveRange(0, 9), InclusiveRange(0, 4))
test_case(InclusiveRange(0, 9), InclusiveRange(0, 9))
test_case(InclusiveRange(4, 5), InclusiveRange(0, 9))
</code></pre>
     <p>Running that produces the output:</p>
     <pre class="lang-none prettyprint-override"><code>r1=(0, 1) r2=(8, 9): ''      ,, - False
r1=(0, 4) r2=(5, 9): ''''',,,,, - False
r1=(0, 4) r2=(4, 9): ''''|,,,,, - True
r1=(0, 7) r2=(2, 9): ''||||||,, - True
r1=(0, 4) r2=(0, 9): |||||,,,,, - True
r1=(0, 9) r2=(0, 9): |||||||||| - True
r1=(0, 9) r2=(4, 5): ''''||'''' - True
r1=(8, 9) r2=(0, 1): ,,      '' - False
r1=(5, 9) r2=(0, 4): ,,,,,''''' - False
r1=(4, 9) r2=(0, 4): ,,,,|''''' - True
r1=(2, 9) r2=(0, 7): ,,||||||'' - True
r1=(0, 9) r2=(0, 4): |||||''''' - True
r1=(0, 9) r2=(0, 9): |||||||||| - True
r1=(4, 5) r2=(0, 9): ,,,,||,,,, - True
</code></pre>
     <p>where each line has:</p>
     <ul>
      <li>the two ranges being evaluated;</li>
      <li>a graphical representation of the "range space" (from lowest start to highest end) where each character is a value in that "range space": 
       <ul>
        <li><code>'</code> indicates a value in the first range only;</li>
        <li><code>,</code> indicates a value in the second range only;</li>
        <li><code>|</code> indicates a value in both ranges; and</li>
        <li><code> </code> indicates a value in neither range.</li>
       </ul></li>
      <li>the result of the overlap check.</li>
     </ul>
     <p>You can see quite clearly that you only get true in the overlap check when there is at least one value in <em>both</em> ranges (i.e., a <code>|</code> character). Every other case gives false.</p>
     <p>Feel free to use any other values if you want to add more test cases.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>+1 for mentioning the inclusive/exclusive problem. I was going to whip up an answer myself when I had time, but no need now. The thing is you almost never allow both the start and end to be inclusive simultaneously. In my industry it is common practice to treat the start as exlusive and the end as inclusive, but either way is fine as long as you stay consistent. This is the first completely correct answer on this question so far...IMO.</span> <span> - </span> <span class="display-name">Brian Gideon</span> <span> </span> <span class="date">6 Aug 2010 at 03:50</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>20</span>
     </div>
     <div>
      <span>Answerer: </span> <span>yankee</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 Mar 2015 at 13:19</span>
     </div>
    </div>
    <div>
     <p>Here is yet another solution using JavaScript. Specialities of my solution:</p>
     <ul>
      <li>Handles null values as infinity</li>
      <li>Assumes that the lower bound is inclusive and the upper bound exclusive.</li>
      <li>Comes with a bunch of tests</li>
     </ul>
     <p>The tests are based on integers but since date objects in JavaScript are comparable you can just throw in two date objects as well. Or you could throw in the millisecond timestamp.</p>
     <h1>Code:</h1>
     <pre class="lang-javascript prettyprint-override"><code>/**
 * Compares to comparable objects to find out whether they overlap.
 * It is assumed that the interval is in the format [from,to) (read: from is inclusive, to is exclusive).
 * A null value is interpreted as infinity
 */
function intervalsOverlap(from1, to1, from2, to2) {
    return (to2 === null || from1 &lt; to2) &amp;&amp; (to1 === null || to1 &gt; from2);
}
</code></pre>
     <h1>Tests:</h1>
     <pre class="lang-javascript prettyprint-override"><code>describe('', function() {
    function generateTest(firstRange, secondRange, expected) {
        it(JSON.stringify(firstRange) + ' and ' + JSON.stringify(secondRange), function() {
            expect(intervalsOverlap(firstRange[0], firstRange[1], secondRange[0], secondRange[1])).toBe(expected);
        });
    }

    describe('no overlap (touching ends)', function() {
        generateTest([10,20], [20,30], false);
        generateTest([20,30], [10,20], false);

        generateTest([10,20], [20,null], false);
        generateTest([20,null], [10,20], false);

        generateTest([null,20], [20,30], false);
        generateTest([20,30], [null,20], false);
    });

    describe('do overlap (one end overlaps)', function() {
        generateTest([10,20], [19,30], true);
        generateTest([19,30], [10,20], true);

        generateTest([10,20], [null,30], true);
        generateTest([10,20], [19,null], true);
        generateTest([null,30], [10,20], true);
        generateTest([19,null], [10,20], true);
    });

    describe('do overlap (one range included in other range)', function() {
        generateTest([10,40], [20,30], true);
        generateTest([20,30], [10,40], true);

        generateTest([10,40], [null,null], true);
        generateTest([null,null], [10,40], true);
    });

    describe('do overlap (both ranges equal)', function() {
        generateTest([10,20], [10,20], true);

        generateTest([null,20], [null,20], true);
        generateTest([10,null], [10,null], true);
        generateTest([null,null], [null,null], true);
    });
});
</code></pre>
     <p>Result when run with karma&amp;jasmine&amp;PhantomJS:</p>
     <blockquote>
      <p>PhantomJS 1.9.8 (Linux): Executed 20 of 20 SUCCESS (0.003 secs / 0.004 secs)</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>17</span>
     </div>
     <div>
      <span>Answerer: </span> <span>sandeep talabathula</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Oct 2017 at 16:41</span>
     </div>
    </div>
    <div>
     <p><a href="https://i.stack.imgur.com/bDVe1.png" rel="noreferrer"><img src="https://i.stack.imgur.com/bDVe1.png" alt="enter image description here"></a></p>
     <p>Here is the code that does the magic:</p>
     <pre><code> var isOverlapping =  ((A == null || D == null || A &lt;= D) 
            &amp;&amp; (C == null || B == null || C &lt;= B)
            &amp;&amp; (A == null || B == null || A &lt;= B)
            &amp;&amp; (C == null || D == null || C &lt;= D));
</code></pre>
     <p>Where..</p>
     <ul>
      <li>A -&gt; 1Start</li>
      <li>B -&gt; 1End</li>
      <li>C -&gt; 2Start</li>
      <li>D -&gt; 2End</li>
     </ul>
     <p>Proof? Check out this test <a href="https://gist.github.com/sandeeptalabathula/3b469065251eb1992dd92b168fea0b61" rel="noreferrer">console code gist</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>That works, but i would prefer to test for not overlapping, only two scenarios</span> <span> - </span> <span class="display-name">John Albert</span> <span> </span> <span class="date">25 Oct 2018 at 11:55</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Thanks for explaining this using images. Your answer is the perfect solution for this question.</span> <span> - </span> <span class="display-name">Rakesh Verma</span> <span> </span> <span class="date">31 Jul 2019 at 10:20</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Since, by definition A is always &lt;= B and C is always &lt;= D, you can simplify by (A &lt;= D) &amp;&amp; (C &lt;= B)</span> <span> - </span> <span class="display-name">Manuel Romeiro</span> <span> </span> <span class="date">31 May 2021 at 16:06</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@ManuelRomeiro Hi will it work in the case where 2Start &lt; 1Start and 2End &gt; 1End</span> <span> - </span> <span class="display-name">ITSagar</span> <span> </span> <span class="date">20 Jan 2023 at 18:08</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@sandeep talabathula Hi will it work in the case where 2Start &lt; 1Start and 2End &gt; 1End</span> <span> - </span> <span class="display-name">ITSagar</span> <span> </span> <span class="date">20 Jan 2023 at 18:09</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>13</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Radacina</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Jan 2019 at 19:45</span>
     </div>
    </div>
    <div>
     <p>An easy way to remember the solution would be<br><code>min(ends)&gt;max(starts)</code></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>10</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Bob</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Nov 2008 at 14:51</span>
     </div>
    </div>
    <div>
     <p>I would do</p>
     <pre><code>StartDate1.IsBetween(StartDate2, EndDate2) || EndDate1.IsBetween(StartDate2, EndDate2)
</code></pre>
     <p>Where <code>IsBetween</code> is something like</p>
     <pre><code>    public static bool IsBetween(this DateTime value, DateTime left, DateTime right) {
        return (value &gt; left &amp;&amp; value &lt; right) || (value &lt; left &amp;&amp; value &gt; right);
    }
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>I would prefer (left &lt; value &amp;&amp; value &lt; right) || (right &lt; value &amp;&amp; value &lt; left) for this method.</span> <span> - </span> <span class="display-name">Patrick Huizinga</span> <span> </span> <span class="date">28 Nov 2008 at 15:22</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Thanks for this. Makes things easier in my head.</span> <span> - </span> <span class="display-name">sshow</span> <span> </span> <span class="date">10 Nov 2009 at 15:05</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Why would you check four conditions when you only have to check two? Fail.</span> <span> - </span> <span class="display-name">ErikE</span> <span> </span> <span class="date">9 Mar 2010 at 01:19</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>Ah, my apologies, I see now that you are allowing the ranges to be in reverse order (StartDateX &gt; EndDateX). Strange. Anyway, what if StartDate1 is less than StartDate2 and EndDate1 is greater than EndDate2? The code you gave will not detect this overlapping condition.</span> <span> - </span> <span class="display-name">ErikE</span> <span> </span> <span class="date">11 Mar 2010 at 05:17</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>Won't this return false if Date1 contains whole Date2? Then StartDate1 is before StartDate2 and EndDate1 is after EndDate2</span> <span> - </span> <span class="display-name">user158037</span> <span> </span> <span class="date">11 Aug 2015 at 13:06</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>10</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Khaled.K</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Feb 2017 at 07:53</span>
     </div>
    </div>
    <div>
     <p>Here's my solution in <em>Java</em>, which works on unbounded intervals too</p>
     <pre class="lang-java prettyprint-override"><code>private Boolean overlap (Timestamp startA, Timestamp endA,
                         Timestamp startB, Timestamp endB)
{
    return (endB == null || startA == null || !startA.after(endB))
        &amp;&amp; (endA == null || startB == null || !endA.before(startB));
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>I think you meant unbounded ends instead of open intervals.</span> <span> - </span> <span class="display-name">Henrik</span> <span> </span> <span class="date">4 Oct 2017 at 09:33</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Henrik both terms work <a href="https://en.wikipedia.org/wiki/Interval_(mathematics)#Terminology" rel="nofollow noreferrer">en.wikipedia.org/wiki/Interval_(mathematics)#Terminology</a></span> <span> - </span> <span class="display-name">Khaled.K</span> <span> </span> <span class="date">4 Oct 2017 at 11:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span><code>!startA.after(endB)</code> means startA &lt;= endB and <code>!endA.before(startB)</code> means startB &lt;= endA. These are the criterias for a closed interval and not an open interval.</span> <span> - </span> <span class="display-name">Henrik</span> <span> </span> <span class="date">4 Oct 2017 at 12:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Henrik true, and the other conditions such as <code>endB == null</code> and <code>startA == null</code> check for an open interval.</span> <span> - </span> <span class="display-name">Khaled.K</span> <span> </span> <span class="date">4 Oct 2017 at 14:32</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span><code>endB == null</code>, <code>startA == null</code>, <code>endA == null</code> and <code>startB == null</code> are all criteria to check for an unbounded interval and not an open interval. Example for the differences between unbounded and open intervals: (10, 20) and (20, null) are two open intervals which do not overlap. The last one does have an unbounded end. Your function will return true, but the intervals do not overlap, because the intervals do not include 20. (used numbers instead of timestamps for simplicity)</span> <span> - </span> <span class="display-name">Henrik</span> <span> </span> <span class="date">4 Oct 2017 at 15:39</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Henrik I understand, I've fixed it now.</span> <span> - </span> <span class="display-name">Khaled.K</span> <span> </span> <span class="date">5 Oct 2017 at 09:11</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>9</span>
     </div>
     <div>
      <span>Answerer: </span> <span>on_</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Nov 2013 at 08:24</span>
     </div>
    </div>
    <div>
     <p>The solution posted here did not work for all overlapping ranges...</p>
     <pre>----------------------|-------A-------|----------------------
    |----B1----|
           |----B2----|
               |----B3----|
               |----------B4----------|
               |----------------B5----------------|
                      |----B6----|
----------------------|-------A-------|----------------------
                      |------B7-------|
                      |----------B8-----------|
                         |----B9----|
                         |----B10-----|
                         |--------B11--------|
                                      |----B12----|
                                         |----B13----|
----------------------|-------A-------|----------------------</pre>
     <p>my working solution was:</p>
     <pre>AND (
  ('start_date' BETWEEN STARTDATE AND ENDDATE) -- caters for inner and end date outer
  OR
  ('end_date' BETWEEN STARTDATE AND ENDDATE) -- caters for inner and start date outer
  OR
  (STARTDATE BETWEEN 'start_date' AND 'end_date') -- only one needed for outer range where dates are inside.
) 
</pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>a_horse_with_no_name</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Feb 2021 at 13:50</span>
     </div>
    </div>
    <div>
     <p>As there have been several answers for different languages and environments, here is one for standard ANSI SQL.</p>
     <p>In standard SQL it is as as simple as</p>
     <pre><code>(StartDate1, EndDate1) overlaps (StartDate2, EndDate2)
</code></pre>
     <p>assuming all four columns are <code>DATE</code> or <code>TIMESTAMP</code> columns. It returns true if both ranges have at least one day in common (assuming <code>DATE</code> values)</p>
     <p>(However not all DBMS products support that)</p>
     <hr>
     <p>In PostgreSQL it's also easy to test for <em>inclusion</em> by using <a href="https://www.postgresql.org/docs/current/rangetypes.html" rel="noreferrer">date ranges</a></p>
     <pre><code>daterange(StartDate1, EndDate1) @&gt; daterange(StartDate2, EndDate2)
</code></pre>
     <p>the above returns true if the second range is completely included in the first (which is different to "overlaps")</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span> <span class="arrow"> <a href="#answer_15">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ignacio Pascual</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Sep 2013 at 20:28</span>
     </div>
    </div>
    <div>
     <p>This was my javascript solution with moment.js:</p>
     <pre><code>// Current row dates
var dateStart = moment("2014-08-01", "YYYY-MM-DD");
var dateEnd = moment("2014-08-30", "YYYY-MM-DD");

// Check with dates above
var rangeUsedStart = moment("2014-08-02", "YYYY-MM-DD");
var rangeUsedEnd = moment("2014-08-015", "YYYY-MM-DD");

// Range covers other ?
if((dateStart &lt;= rangeUsedStart) &amp;&amp; (rangeUsedEnd &lt;= dateEnd)) {
    return false;
}
// Range intersects with other start ?
if((dateStart &lt;= rangeUsedStart) &amp;&amp; (rangeUsedStart &lt;= dateEnd)) {
    return false;
}
// Range intersects with other end ?
if((dateStart &lt;= rangeUsedEnd) &amp;&amp; (rangeUsedEnd &lt;= dateEnd)) {
    return false;
}

// All good
return true;
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_15"><span>Answer 15</span> <span class="arrow"> <a href="#answer_14">↑</a> </span> <span class="arrow"> <a href="#answer_16">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Nitin Jadhav</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Jul 2018 at 17:43</span>
     </div>
    </div>
    <div>
     <p><strong>Short answer using momentjs</strong>:</p>
     <pre><code>function isOverlapping(startDate1, endDate1, startDate2, endDate2){ 
    return moment(startDate1).isSameOrBefore(endDate2) &amp;&amp; 
    moment(startDate2).isSameOrBefore(endDate1);
}
</code></pre>
     <p>the answer is based on above answers, but its shortened.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_16"><span>Answer 16</span> <span class="arrow"> <a href="#answer_15">↑</a> </span> <span class="arrow"> <a href="#answer_17">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Prasenjit Banerjee</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Jul 2014 at 13:44</span>
     </div>
    </div>
    <div>
     <p>In Microsoft SQL SERVER - SQL Function</p>
     <pre><code>CREATE FUNCTION IsOverlapDates 
(
    @startDate1 as datetime,
    @endDate1 as datetime,
    @startDate2 as datetime,
    @endDate2 as datetime
)
RETURNS int
AS
BEGIN
DECLARE @Overlap as int
SET @Overlap = (SELECT CASE WHEN  (
        (@startDate1 BETWEEN @startDate2 AND @endDate2) -- caters for inner and end date outer
        OR
        (@endDate1 BETWEEN @startDate2 AND @endDate2) -- caters for inner and start date outer
        OR
        (@startDate2 BETWEEN @startDate1 AND @endDate1) -- only one needed for outer range where dates are inside.
        ) THEN 1 ELSE 0 END
    )
    RETURN @Overlap

END
GO

--Execution of the above code
DECLARE @startDate1 as datetime
DECLARE @endDate1 as datetime
DECLARE @startDate2 as datetime
DECLARE @endDate2 as datetime
DECLARE @Overlap as int
SET @startDate1 = '2014-06-01 01:00:00' 
SET @endDate1 =   '2014-06-01 02:00:00'
SET @startDate2 = '2014-06-01 01:00:00' 
SET @endDate2 =   '2014-06-01 01:30:00'

SET @Overlap = [dbo].[IsOverlapDates]  (@startDate1, @endDate1, @startDate2, @endDate2)

SELECT Overlap = @Overlap
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_17"><span>Answer 17</span> <span class="arrow"> <a href="#answer_16">↑</a> </span> <span class="arrow"> <a href="#answer_18">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Basil Bourque</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Nov 2016 at 23:30</span>
     </div>
    </div>
    <div>
     <blockquote>
      <p>the simplest</p>
     </blockquote>
     <p>The simplest way is to use a well-engineered dedicated library for date-time work.</p>
     <pre class="lang-java prettyprint-override"><code>someInterval.overlaps( anotherInterval )
</code></pre>
     <h1>java.time &amp; ThreeTen-Extra</h1>
     <p>The best in the business is the <a href="https://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html" rel="nofollow noreferrer"><code>java.time</code></a> framework built into Java 8 and later. Add to that the <a href="http://www.threeten.org/threeten-extra/" rel="nofollow noreferrer">ThreeTen-Extra</a> project that supplements java.time with additional classes, specifically the <a href="http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Interval.html" rel="nofollow noreferrer"><code>Interval</code></a> class we need here.</p>
     <p>As for the <code>language-agnostic</code> tag on this Question, the source code for both projects is available for use in other languages (mind their licenses).</p>
     <h2><code>Interval</code></h2>
     <p>The <a href="http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Interval.html" rel="nofollow noreferrer"><code>org.threeten.extra.Interval</code></a> class is handy, but requires date-time moments (<code>java.time.Instant</code> objects) rather than date-only values. So we proceed by using the first moment of the day in UTC to represent the date.</p>
     <pre class="lang-java prettyprint-override"><code>Instant start = Instant.parse( "2016-01-01T00:00:00Z" );
Instant stop = Instant.parse( "2016-02-01T00:00:00Z" );
</code></pre>
     <p>Create an <code>Interval</code> to represent that span of time.</p>
     <pre class="lang-java prettyprint-override"><code>Interval interval_A = Interval.of( start , stop );
</code></pre>
     <p>We can also define an <code>Interval</code> with a starting moment plus a <a href="http://docs.oracle.com/javase/8/docs/api/java/time/Duration.html" rel="nofollow noreferrer"><code>Duration</code></a>.</p>
     <pre class="lang-java prettyprint-override"><code>Instant start_B = Instant.parse( "2016-01-03T00:00:00Z" );
Interval interval_B = Interval.of( start_B , Duration.of( 3 , ChronoUnit.DAYS ) );
</code></pre>
     <p>Comparing to test for overlaps is easy.</p>
     <pre class="lang-java prettyprint-override"><code>Boolean overlaps = interval_A.overlaps( interval_B );
</code></pre>
     <p>You can compare an <a href="http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Interval.html" rel="nofollow noreferrer"><code>Interval</code></a> against another <a href="http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Interval.html" rel="nofollow noreferrer"><code>Interval</code></a> or <a href="http://docs.oracle.com/javase/8/docs/api/java/time/Instant.html?is-external=true" rel="nofollow noreferrer"><code>Instant</code></a>:</p>
     <ul>
      <li><a href="http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Interval.html#abuts-org.threeten.extra.Interval-" rel="nofollow noreferrer"><code>abuts</code></a></li>
      <li><a href="http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Interval.html#contains-java.time.Instant-" rel="nofollow noreferrer"><code>contains</code></a></li>
      <li><a href="http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Interval.html#encloses-org.threeten.extra.Interval-" rel="nofollow noreferrer"><code>encloses</code></a></li>
      <li><a href="http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Interval.html#equals-java.lang.Object-" rel="nofollow noreferrer"><code>equals</code></a></li>
      <li><a href="http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Interval.html#isAfter-org.threeten.extra.Interval-" rel="nofollow noreferrer"><code>isAfter</code></a></li>
      <li><a href="http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Interval.html#isBefore-org.threeten.extra.Interval-" rel="nofollow noreferrer"><code>isBefore</code></a></li>
      <li><a href="http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Interval.html#overlaps-org.threeten.extra.Interval-" rel="nofollow noreferrer"><code>overlaps</code></a></li>
     </ul>
     <p>All of these use the <code>Half-Open</code> approach to defining a span of time where the beginning is <em>inclusive</em> and the ending is <em>exclusive</em>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_18"><span>Answer 18</span> <span class="arrow"> <a href="#answer_17">↑</a> </span> <span class="arrow"> <a href="#answer_19">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Gus</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Jan 2017 at 14:06</span>
     </div>
    </div>
    <div>
     <p>I had a situation where we had dates instead of datetimes, and the dates could overlap only on start/end. Example below:</p>
     <p><a href="https://i.stack.imgur.com/qzRBx.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/qzRBx.png" alt="enter image description here"></a></p>
     <p>(Green is the current interval, blue blocks are valid intervals, red ones are overlapping intervals).</p>
     <p>I adapted Ian Nelson's answer to the following solution:</p>
     <pre><code>   (startB &lt;= startA &amp;&amp; endB &gt; startA)
|| (startB &gt;= startA &amp;&amp; startB &lt; endA)
</code></pre>
     <p>This matches all overlap cases but ignores the allowed overlap ones.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_19"><span>Answer 19</span> <span class="arrow"> <a href="#answer_18">↑</a> </span> <span class="arrow"> <a href="#answer_20">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Meno Hochschild</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Apr 2017 at 05:56</span>
     </div>
    </div>
    <div>
     <p>The mathematical solution given by @Bretana is good but neglects two specific details:</p>
     <ol>
      <li>aspect of closed or half-open intervals</li>
      <li>empty intervals</li>
     </ol>
     <hr>
     <p>About the closed or open state of interval boundaries, the solution of @Bretana valid <strong>for closed intervals</strong></p>
     <blockquote>
      <p>(StartA &lt;= EndB) and (EndA &gt;= StartB)</p>
     </blockquote>
     <p>can be rewritten <strong>for half-open intervals</strong> to:</p>
     <blockquote>
      <p>(StartA &lt; EndB) and (EndA &gt; StartB)</p>
     </blockquote>
     <p>This correction is necessary because an open interval boundary does not belong to the value range of an interval by definition.</p>
     <hr>
     <p>And about <strong>empty intervals</strong>, well, here the relationship shown above does NOT hold. Empty intervals which do not contain any valid value by definition must be handled as special case. I demonstrate it by my Java time library <a href="https://github.com/MenoData/Time4J" rel="nofollow noreferrer">Time4J</a> via this example:</p>
     <pre><code>MomentInterval a = MomentInterval.between(Instant.now(), Instant.now().plusSeconds(2));
MomentInterval b = a.collapse(); // make b an empty interval out of a

System.out.println(a); // [2017-04-10T05:28:11,909000000Z/2017-04-10T05:28:13,909000000Z)
System.out.println(b); // [2017-04-10T05:28:11,909000000Z/2017-04-10T05:28:11,909000000Z)
</code></pre>
     <p>The leading square bracket "[" indicates a closed start while the last bracket ")" indicates an open end.</p>
     <pre><code>System.out.println(
      "startA &lt; endB: " + a.getStartAsInstant().isBefore(b.getEndAsInstant())); // false
System.out.println(
      "endA &gt; startB: " + a.getEndAsInstant().isAfter(b.getStartAsInstant())); // true

System.out.println("a overlaps b: " + a.intersects(b)); // a overlaps b: false
</code></pre>
     <p>As shown above, empty intervals violate the overlap condition above (especially startA &lt; endB), so Time4J (and other libraries, too) has to handle it as special edge case in order to guarantee that the overlap of any arbitrary interval with an empty interval does not exist. Of course, date intervals (which are closed by default in Time4J but can be half-open, too, like empty date intervals) are handled in a similar way.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_20"><span>Answer 20</span> <span class="arrow"> <a href="#answer_19">↑</a> </span> <span class="arrow"> <a href="#answer_21">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user2314737</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Jun 2017 at 18:57</span>
     </div>
    </div>
    <div>
     <p>This is an extension to the <a href="https://stackoverflow.com/a/325964/2314737">excellent answer</a> by @charles-bretana.</p>
     <p>The answer however does not make a distinction among open, closed, and half-open (or half-closed) intervals.</p>
     <p><strong>Case 1</strong>: A, B are closed intervals</p>
     <pre><code>A = [StartA, EndA]
B = [StartB, EndB]

                         [---- DateRange A ------]   (True if StartA &gt; EndB)
[--- Date Range B -----]                           


[---- DateRange A -----]                             (True if EndA &lt; StartB)
                         [--- Date Range B ----]
</code></pre>
     <p>Overlap iff: <code>(StartA &lt;= EndB) and (EndA &gt;= StartB)</code></p>
     <p><strong>Case 2</strong>: A, B are open intervals</p>
     <pre><code>A = (StartA, EndA)
B = (StartB, EndB)

                         (---- DateRange A ------)   (True if StartA &gt;= EndB)
(--- Date Range B -----)                           

(---- DateRange A -----)                             (True if EndA &lt;= StartB)
                         (--- Date Range B ----)
</code></pre>
     <p>Overlap iff: <code>(StartA &lt; EndB) and (EndA &gt; StartB)</code></p>
     <p><strong>Case 3</strong>: A, B right open</p>
     <pre><code>A = [StartA, EndA)
B = [StartB, EndB)

                         [---- DateRange A ------)   (True if StartA &gt;= EndB) 
[--- Date Range B -----)                           

[---- DateRange A -----)                             (True if EndA &lt;= StartB)
                         [--- Date Range B ----)
</code></pre>
     <p>Overlap condition: <code>(StartA &lt; EndB) and (EndA &gt; StartB)</code></p>
     <p><strong>Case 4</strong>: A, B left open</p>
     <pre><code>A = (StartA, EndA]
B = (StartB, EndB]

                         (---- DateRange A ------]   (True if StartA &gt;= EndB)
(--- Date Range B -----]                           

(---- DateRange A -----]                             (True if EndA &lt;= StartB)
                         (--- Date Range B ----]
</code></pre>
     <p>Overlap condition: <code>(StartA &lt; EndB) and (EndA &gt; StartB)</code></p>
     <p><strong>Case 5</strong>: A right open, B closed</p>
     <pre><code>A = [StartA, EndA)
B = [StartB, EndB]

                         [---- DateRange A ------)    (True if StartA &gt; EndB)
[--- Date Range B -----]                           


[---- DateRange A -----)                              (True if EndA &lt;= StartB)  
                         [--- Date Range B ----]
</code></pre>
     <p>Overlap condition: <code>(StartA &lt;= EndB) and (EndA &gt; StartB)</code></p>
     <p><strong>etc...</strong></p>
     <p>Finally, the general condition for two intervals to overlap is</p>
     <p><strong>(StartA &lt;🞐 EndB) and (EndA &gt;🞐 StartB)</strong></p>
     <p>where 🞐 turns a strict inequality into a non-strict one whenever the comparison is made between two included endpoint.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Cases two, three, and four have the same Overlap condition, is this intentional?</span> <span> - </span> <span class="display-name">Marie</span> <span> </span> <span class="date">22 Nov 2017 at 14:09</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Marie, I just listed a few cases (not all)</span> <span> - </span> <span class="display-name">user2314737</span> <span> </span> <span class="date">22 Nov 2017 at 17:34</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This, but as elaborated as <a href="https://stackoverflow.com/a/328558/303290">Jonathan Leffler's answer</a> would be what I had in mind as accepted answer for OPs question.</span> <span> - </span> <span class="display-name">mbx</span> <span> </span> <span class="date">20 Apr 2020 at 13:23</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_21"><span>Answer 21</span> <span class="arrow"> <a href="#answer_20">↑</a> </span> <span class="arrow"> <a href="#answer_22">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>jack</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Mar 2014 at 16:47</span>
     </div>
    </div>
    <div>
     <p>In case you're using a date range that has not ended yet (still on going) e.g. not set endDate = '0000-00-00' you can not use BETWEEN because 0000-00-00 is not a valid date!</p>
     <p>I used this solution:</p>
     <pre><code>(Startdate BETWEEN '".$startdate2."' AND '".$enddate2."')  //overlap: starts between start2/end2
OR (Startdate &lt; '".$startdate2."' 
  AND (enddate = '0000-00-00' OR enddate &gt;= '".$startdate2."')
) //overlap: starts before start2 and enddate not set 0000-00-00 (still on going) or if enddate is set but higher then startdate2
</code></pre>
     <p>If startdate2 is higher then enddate there is no overlap!</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_22"><span>Answer 22</span> <span class="arrow"> <a href="#answer_21">↑</a> </span> <span class="arrow"> <a href="#answer_23">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Tom McDonough</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Dec 2016 at 16:16</span>
     </div>
    </div>
    <div>
     <p>The answer is too simple for me so I have created a more generic dynamic SQL statement which checks to see if a person has any overlapping dates.</p>
     <pre><code>SELECT DISTINCT T1.EmpID
FROM Table1 T1
INNER JOIN Table2 T2 ON T1.EmpID = T2.EmpID 
    AND T1.JobID &lt;&gt; T2.JobID
    AND (
        (T1.DateFrom &gt;= T2.DateFrom AND T1.dateFrom &lt;= T2.DateTo) 
        OR (T1.DateTo &gt;= T2.DateFrom AND T1.DateTo &lt;= T2.DateTo)
        OR (T1.DateFrom &lt; T2.DateFrom AND T1.DateTo IS NULL)
    )
    AND NOT (T1.DateFrom = T2.DateFrom)
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_23"><span>Answer 23</span> <span class="arrow"> <a href="#answer_22">↑</a> </span> <span class="arrow"> <a href="#answer_24">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>AlexDrenea</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Nov 2008 at 14:52</span>
     </div>
    </div>
    <div>
     <p>The easiest way to do it in my opinion would be to compare if either EndDate1 is before StartDate2 and EndDate2 is before StartDate1.</p>
     <p>That of course if you are considering intervals where StartDate is always before EndDate.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_24"><span>Answer 24</span> <span class="arrow"> <a href="#answer_23">↑</a> </span> <span class="arrow"> <a href="#answer_25">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Shehan Simen</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Feb 2015 at 05:21</span>
     </div>
    </div>
    <div>
     <p>Using Java util.Date, here what I did.</p>
     <pre><code>    public static boolean checkTimeOverlaps(Date startDate1, Date endDate1, Date startDate2, Date endDate2)
    {
        if (startDate1 == null || endDate1 == null || startDate2 == null || endDate2 == null)
           return false;

        if ((startDate1.getTime() &lt;= endDate2.getTime()) &amp;&amp; (startDate2.getTime() &lt;= endDate1.getTime()))
           return true;

        return false;
    }
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_25"><span>Answer 25</span> <span class="arrow"> <a href="#answer_24">↑</a> </span> <span class="arrow"> <a href="#answer_26">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>mahatmanich</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Oct 2015 at 23:40</span>
     </div>
    </div>
    <div>
     <p>For ruby I also found this:</p>
     <pre><code>class Interval &lt; ActiveRecord::Base

  validates_presence_of :start_date, :end_date

  # Check if a given interval overlaps this interval    
  def overlaps?(other)
    (start_date - other.end_date) * (other.start_date - end_date) &gt;= 0
  end

  # Return a scope for all interval overlapping the given interval, including the given interval itself
  named_scope :overlapping, lambda { |interval| {
    :conditions =&gt; ["id &lt;&gt; ? AND (DATEDIFF(start_date, ?) * DATEDIFF(?, end_date)) &gt;= 0", interval.id, interval.end_date, interval.start_date]
  }}

end
</code></pre>
     <p>Found it here with nice explaination -&gt; <a href="http://makandracards.com/makandra/984-test-if-two-date-ranges-overlap-in-ruby-or-rails" rel="nofollow">http://makandracards.com/makandra/984-test-if-two-date-ranges-overlap-in-ruby-or-rails</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_26"><span>Answer 26</span> <span class="arrow"> <a href="#answer_25">↑</a> </span> <span class="arrow"> <a href="#answer_27">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>AL-zami</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Oct 2017 at 07:50</span>
     </div>
    </div>
    <div>
     <p>If you provide a date range as input and want to find out if it overlaps with the existing date range in database, the following conditions can successfully meet your demand</p>
     <blockquote>
      <p>Assume you provide a <code>@StartDate</code> and <code>@EndDate</code> from your form input.</p>
     </blockquote>
     <p><strong>conditions are :</strong></p>
     <p>If <code>@StartDate</code> is ahead of <code>existingStartDate</code> and behind <code>existingEndDate</code> then we can say <code>@StartDate</code> is in the middle of a existing date range, thus we can conclude it will overlap</p>
     <pre><code>@StartDate &gt;=existing.StartDate And @StartDate &lt;= existing.EndDate) 
</code></pre>
     <p>If <code>@StartDate</code> is behind <code>existingStartDate</code> but <code>@EndDate</code> is ahead of <code>existingStartDate</code> we can say that it will overlap</p>
     <pre><code> (@StartDate &lt;= existing.StartDate And @EndDate &gt;= existing.StartDate)
</code></pre>
     <p>If <code>@StartDate</code> is behind <code>existingStartDate</code> And <code>@EndDate</code> is ahead of <code>existingEndDate</code> we can conclude that the provided date range devours a existing date range , thus overlaps</p>
     <pre><code> (@StartDate &lt;= existing.StartDate And @EndDate &gt;= existing.EndDate))
</code></pre>
     <p>If any of the condition stands true, your provided date range overlaps with existing ones in the database.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_27"><span>Answer 27</span> <span class="arrow"> <a href="#answer_26">↑</a> </span> <span class="arrow"> <a href="#answer_28">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Colonel Panic</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Oct 2012 at 23:17</span>
     </div>
    </div>
    <div>
     <p><strong>Split the problem into cases then handle each case</strong>.</p>
     <p>The situation 'two date ranges intersect' is covered by two cases - the first date range starts within the second, or the second date range starts within the first.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_28"><span>Answer 28</span> <span class="arrow"> <a href="#answer_27">↑</a> </span> <span class="arrow"> <a href="#answer_29">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ilya</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Mar 2014 at 13:42</span>
     </div>
    </div>
    <div>
     <p>You can try this:</p>
     <pre><code>//custom date for example
$d1 = new DateTime("2012-07-08");
$d2 = new DateTime("2012-07-11");
$d3 = new DateTime("2012-07-08");
$d4 = new DateTime("2012-07-15");

//create a date period object
$interval = new DateInterval('P1D');
$daterange = iterator_to_array(new DatePeriod($d1, $interval, $d2));
$daterange1 = iterator_to_array(new DatePeriod($d3, $interval, $d4));
array_map(function($v) use ($daterange1) { if(in_array($v, $daterange1)) print "Bingo!";}, $daterange);
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_29"><span>Answer 29</span> <span class="arrow"> <a href="#answer_28">↑</a> </span> <span class="arrow"> <a href="#answer_30">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>mmarjeh</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Jul 2014 at 17:12</span>
     </div>
    </div>
    <div>
     <pre><code>public static class NumberExtensionMethods
    {
        public static Boolean IsBetween(this Int64 value, Int64 Min, Int64 Max)
        {
            if (value &gt;= Min &amp;&amp; value &lt;= Max) return true;
            else return false;
        }

        public static Boolean IsBetween(this DateTime value, DateTime Min, DateTime Max)
        {
            Int64 numricValue = value.Ticks;
            Int64 numericStartDate = Min.Ticks;
            Int64 numericEndDate = Max.Ticks;

            if (numricValue.IsBetween(numericStartDate, numericEndDate) )
            {
                return true;
            }

            return false;
        }
    }

public static Boolean IsOverlap(DateTime startDate1, DateTime endDate1, DateTime startDate2, DateTime endDate2)
        {
            Int64 numericStartDate1 = startDate1.Ticks;
            Int64 numericEndDate1 = endDate1.Ticks;
            Int64 numericStartDate2 = startDate2.Ticks;
            Int64 numericEndDate2 = endDate2.Ticks;

            if (numericStartDate2.IsBetween(numericStartDate1, numericEndDate1) ||
                numericEndDate2.IsBetween(numericStartDate1, numericEndDate1) ||
                numericStartDate1.IsBetween(numericStartDate2, numericEndDate2) ||
                numericEndDate1.IsBetween(numericStartDate2, numericEndDate2))
            {
                return true;
            }

            return false;
        } 


if (IsOverlap(startdate1, enddate1, startdate2, enddate2))
            {
                Console.WriteLine("IsOverlap");
            }
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span>Mind to add some words of explanation?</span> <span> - </span> <span class="display-name">Phantômaxx</span> <span> </span> <span class="date">18 Jul 2014 at 17:31</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_30"><span>Answer 30</span> <span class="arrow"> <a href="#answer_29">↑</a> </span> <span class="arrow"> <a href="#answer_31">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Fez Vrasta</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Nov 2014 at 15:26</span>
     </div>
    </div>
    <div>
     <p>This was my solution, it returns true when the values don't overlap:</p>
     <p>X START 1 Y END 1</p>
     <p>A START 2 B END 2</p>
     <pre><code>TEST1: (X &lt;= A || X &gt;= B)
        &amp;&amp;
TEST2: (Y &gt;= B || Y &lt;= A) 
        &amp;&amp; 
TEST3: (X &gt;= B || Y &lt;= A)


X-------------Y
    A-----B

TEST1:  TRUE
TEST2:  TRUE
TEST3:  FALSE
RESULT: FALSE

---------------------------------------

X---Y
      A---B

TEST1:  TRUE
TEST2:  TRUE
TEST3:  TRUE
RESULT: TRUE

---------------------------------------

      X---Y
A---B

TEST1:  TRUE
TEST2:  TRUE
TEST3:  TRUE
RESULT: TRUE

---------------------------------------

     X----Y
A---------------B

TEST1:  FALSE
TEST2:  FALSE
TEST3:  FALSE
RESULT: FALSE
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_31"><span>Answer 31</span> <span class="arrow"> <a href="#answer_30">↑</a> </span> <span class="arrow"> <a href="#answer_32">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Shravan Ramamurthy</span>
     </div>
     <div>
      <span> Answered: </span> <span>19 Jan 2016 at 21:57</span>
     </div>
    </div>
    <div>
     <p>Below query gives me the ids for which the supplied date range (start and end dates overlaps with any of the dates (start and end dates) in my table_name</p>
     <pre><code>select id from table_name where (START_DT_TM &gt;= 'END_DATE_TIME'  OR   
(END_DT_TM BETWEEN 'START_DATE_TIME' AND 'END_DATE_TIME'))
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_32"><span>Answer 32</span> <span class="arrow"> <a href="#answer_31">↑</a> </span> <span class="arrow"> <a href="#answer_33">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Bilal Ahmed Yaseen</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Jul 2020 at 11:06</span>
     </div>
    </div>
    <div>
     <p>I found another quite simple approach. If start and end date of daterange1 falls before start date of daterange2 or start and end date of daterange1 falls after end date of daterange2 this means they don't intersect with each other.</p>
     <pre><code>public boolean doesIntersect(DateRangeModel daterange1, DateRangeModel  daterange2) {
    return !(
            (daterange1.getStartDate().isBefore(daterange2.getStartDate())
                    &amp;&amp; daterange1.getEndDate().isBefore(daterange2.getStartDate())) ||
                    (daterange1.getStartDate().isAfter(daterange2.getStartDate())
                            &amp;&amp; daterange1.getEndDate().isAfter(daterange2.getEndDate())));
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_33"><span>Answer 33</span> <span class="arrow"> <a href="#answer_32">↑</a> </span> <span class="arrow"> <a href="#answer_34">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>John</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Jun 2022 at 04:42</span>
     </div>
    </div>
    <div>
     <p>As long as there are simple solutions to this, it might not be efficient to use additional packages just to do the simple stuff. However, if you are already using <code>date-fns</code> already in your project, there is a method called <code>areIntervalsOverlapping</code> which does the same thing.</p>
     <p><strong>Syntax:</strong></p>
     <pre><code>areIntervalsOverlapping(intervalLeft, intervalRight, [options])
</code></pre>
     <p><strong>Example:</strong></p>
     <pre><code>// For overlapping time intervals:
areIntervalsOverlapping(
  { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
  { start: new Date(2014, 0, 17), end: new Date(2014, 0, 21) }
)
//=&gt; true
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_34"><span>Answer 34</span> <span class="arrow"> <a href="#answer_33">↑</a> </span> <span class="arrow"> <a href="#answer_35">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Umer</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Sep 2022 at 18:50</span>
     </div>
    </div>
    <div>
     <p>For covering all the overlapping cases in PHP/Laravel Carbon Package, You can expand logic in <a href="https://stackoverflow.com/a/325964/4360616">Charles' Answer</a> as follows.</p>
     <pre><code>if ( ($startTime1-&gt;between($startTime2, $endTime2, true) || $endTime1-&gt;between($startTime2, $endTime2, true)) || (($startTime1 &lt;= $endTime2) &amp;&amp; ($endTime2 &lt;= $endTime1)) ){
//Complete Overlap, Partial Left Overlap, Partial Right Overlap. 
}
</code></pre>
     <p>This Checks if the StartTime1 is between the range of (StartTime2-EndTime2) Or of EndTime1 is Between the range of (StartTime2-EndTime2).</p>
     <p>The Rest of the part for complete overlaps as explained in other answers.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_35"><span>Answer 35</span> <span class="arrow"> <a href="#answer_34">↑</a> </span> <span class="arrow"> <a href="#answer_36">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Jay-Pi</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Dec 2022 at 13:08</span>
     </div>
    </div>
    <div>
     <p>Here my simplification. Assume intervals</p>
     <pre><code>       | |
     | |
</code></pre>
     <p>dont overlap, xa &lt; xb and ya &lt; yb to simplify the handling. Above conditions can be trivially checked. Then you end up with</p>
     <pre><code>      ya       yb
      |--------|
xa |--|xb
   |----|
         |----|
ya &gt; xa =&gt; return ya - xa &lt; xb - xa
else    =&gt; return xa &lt; yb
</code></pre>
     <p>As you may notice, the second interval is only relevant in case xa &gt;= ya.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_36"><span>Answer 36</span> <span class="arrow"> <a href="#answer_35">↑</a> </span> <span class="arrow"> <a href="#answer_37">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>staceyw</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 Apr 2009 at 05:14</span>
     </div>
    </div>
    <div>
     <p>Here is a generic method that can be usefull locally.</p>
     <pre><code>    // Takes a list and returns all records that have overlapping time ranges.
    public static IEnumerable&lt;T&gt; GetOverlappedTimes&lt;T&gt;(IEnumerable&lt;T&gt; list, Func&lt;T, bool&gt; filter, Func&lt;T,DateTime&gt; start, Func&lt;T, DateTime&gt; end)
    {
        // Selects all records that match filter() on left side and returns all records on right side that overlap.
        var overlap = from t1 in list
                      where filter(t1)
                      from t2 in list
                      where !object.Equals(t1, t2) // Don't match the same record on right side.
                      let in1 = start(t1)
                      let out1 = end(t1)
                      let in2 = start(t2)
                      let out2 = end(t2)
                      where in1 &lt;= out2 &amp;&amp; out1 &gt;= in2
                      let totover = GetMins(in1, out1, in2, out2)
                      select t2;

        return overlap;
    }

    public static void TestOverlap()
    {
        var tl1 = new TempTimeEntry() { ID = 1, Name = "Bill", In = "1/1/08 1:00pm".ToDate(), Out = "1/1/08 4:00pm".ToDate() };
        var tl2 = new TempTimeEntry() { ID = 2, Name = "John", In = "1/1/08 5:00pm".ToDate(), Out = "1/1/08 6:00pm".ToDate() };
        var tl3 = new TempTimeEntry() { ID = 3, Name = "Lisa", In = "1/1/08 7:00pm".ToDate(), Out = "1/1/08 9:00pm".ToDate() };
        var tl4 = new TempTimeEntry() { ID = 4, Name = "Joe", In = "1/1/08 3:00pm".ToDate(), Out = "1/1/08 8:00pm".ToDate() };
        var tl5 = new TempTimeEntry() { ID = 1, Name = "Bill", In = "1/1/08 8:01pm".ToDate(), Out = "1/1/08 8:00pm".ToDate() };
        var list = new List&lt;TempTimeEntry&gt;() { tl1, tl2, tl3, tl4, tl5 };
        var overlap = GetOverlappedTimes(list, (TempTimeEntry t1)=&gt;t1.ID==1, (TempTimeEntry tIn) =&gt; tIn.In, (TempTimeEntry tOut) =&gt; tOut.Out);

        Console.WriteLine("\nRecords overlap:");
        foreach (var tl in overlap)
            Console.WriteLine("Name:{0} T1In:{1} T1Out:{2}", tl.Name, tl.In, tl.Out);
        Console.WriteLine("Done");

        /*  Output:
            Records overlap:
            Name:Joe T1In:1/1/2008 3:00:00 PM T1Out:1/1/2008 8:00:00 PM
            Name:Lisa T1In:1/1/2008 7:00:00 PM T1Out:1/1/2008 9:00:00 PM
            Done
         */
    }
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_37"><span>Answer 37</span> <span class="arrow"> <a href="#answer_36">↑</a> </span> <span class="arrow"> <a href="#answer_38">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Syam</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Jan 2012 at 07:02</span>
     </div>
    </div>
    <div>
     <pre><code>if (StartDate1 &gt; StartDate2) swap(StartDate, EndDate);

(StartDate1 &lt;= EndDate2) and (StartDate2 &lt;= EndDate1);
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span>Second line is sufficient. What is the purpose of the first line? What are StartDate and EndDate it refers to?</span> <span> - </span> <span class="display-name">0xF</span> <span> </span> <span class="date">22 Oct 2013 at 11:20</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_38"><span>Answer 38</span> <span class="arrow"> <a href="#answer_37">↑</a> </span> <span class="arrow"> <a href="#answer_39">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>sorry_I_wont</span>
     </div>
     <div>
      <span> Answered: </span> <span>20 Jan 2017 at 06:17</span>
     </div>
    </div>
    <div>
     <p>Easy solution:</p>
     <pre><code>compare the two dates: 
    A = the one with smaller start date, B = the one with bigger start date
if(A.end &lt; B.start)
    return false
return true
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_39"><span>Answer 39</span> <span class="arrow"> <a href="#answer_38">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Roberto77</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Apr 2019 at 12:27</span>
     </div>
    </div>
    <div>
     <p>a compact formula that works for me</p>
     <pre><code>class ValidityRuleRange {
        private final Date from;
        private final Date to;
    ...
    private boolean isOverlap(ValidityRuleRange vrr) {
        int c1 = from.compareTo(vrr.getTo());
        int c2 = to.compareTo(vrr.getFrom());
        return c1 == 0 || c2 == 0 || c1 + c2 == 0;
    }
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>