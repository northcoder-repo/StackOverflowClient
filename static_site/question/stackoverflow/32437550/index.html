<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>What's the difference between Instant and LocalDateTime?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>What's the difference between Instant and LocalDateTime?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>516</span>
    </div>
    <div>
     <span>Asker: </span> <span>manuel aldana</span>
    </div>
    <div>
     <span>Asked: </span> <span>7 Sep 2015 at 11:25</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/32437550/whats-the-difference-between-instant-and-localdatetime">source</a>
    </div>
   </div>
   <div>
    <p>I know that:</p>
    <ul>
     <li><strong>Instant</strong> is rather a "technical" timestamp representation (nanoseconds) for computing.</li>
     <li><strong>LocalDateTime</strong> is rather date/clock representation <strike>including time-zones</strike> for humans.</li>
    </ul>
    <p>Still in the end IMO both can be taken as types for most application use cases. As an example: currently, I am running a batch job where I need to calculate the next run based on dates and I am struggling to find pros/cons between these two types (apart from the nanosecond precision advantage of <code>Instant</code> and the time-zone part of <code>LocalDateTime</code>).</p>
    <p>Can you name some application examples where only <code>Instant</code> or <code>LocalDateTime</code> should be used?</p>
    <p><em>Edit: Beware of misread documentations for <code>LocalDateTime</code> regarding precision and time-zone.</em></p>
   </div>
   <div class="tags">
    <span class="tag">java</span><span class="tag">datetime</span><span class="tag">java-8</span><span class="tag">jsr310</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td></td>
       <td><span>Instant is more elementary, wrapping the standard long for the UTC. For a cron like batch not so logical a choice.</span> <span> - </span> <span class="display-name">Joop Eggen</span> <span> </span> <span class="date">7 Sep 2015 at 11:31</span></td>
      </tr>
      <tr>
       <td>65</td>
       <td><span><b>Incorrect</b> definition. <code>LocalDateTime</code> does <i>not</i> have a time zone!</span> <span> - </span> <span class="display-name">Basil Bourque</span> <span> </span> <span class="date">7 Sep 2015 at 16:48</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1777</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Basil Bourque</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Sep 2015 at 16:40</span>
     </div>
    </div>
    <div>
     <p><a href="https://i.stack.imgur.com/QPhGW.png" rel="noreferrer"><img src="QPhGW.png" alt="Table of all date-time types in Java, both modern and legacy"></a></p>
     <h1>tl;dr</h1>
     <p><code>Instant</code> and <code>LocalDateTime</code> are two entirely different animals: One represents a moment, the other does not.</p>
     <ul>
      <li><code>Instant</code> represents a moment, a specific point in the timeline.</li>
      <li><code>LocalDateTime</code> represents a date and a time-of-day. But lacking a time zone or offset-from-UTC, <strong>this class <em>cannot</em> represent a moment</strong>. It represents <em>potential</em> moments along a range of about 26 to 27 hours, the range of all time zones around the globe. A <code>LocalDateTime</code> value is <strong>inherently ambiguous</strong>.</li>
     </ul>
     <h1>Incorrect Presumption</h1>
     <blockquote>
      <p><code>LocalDateTime</code> is rather date/clock representation including time-zones for humans.</p>
     </blockquote>
     <p>Your statement is incorrect: <strong>A <a href="http://docs.oracle.com/javase/11/docs/api/java/time/LocalDateTime.html" rel="noreferrer"><code>LocalDateTime</code></a> has <em>no</em> time zone</strong>. Having no time zone is the entire point of that class.</p>
     <p>To quote that class’ doc:</p>
     <blockquote>
      <p>This class does not store or represent a time-zone. Instead, it is a description of the date, as used for birthdays, combined with the local time as seen on a wall clock. It cannot represent an instant on the time-line without additional information such as an offset or time-zone.</p>
     </blockquote>
     <p>So <code>Local…</code> means “not zoned, no offset”.</p>
     <h1><code>Instant</code></h1>
     <p><a href="https://i.stack.imgur.com/9c9c8.png" rel="noreferrer"><img src="9c9c8.png" alt="enter image description here"></a></p>
     <p>An <a href="http://docs.oracle.com/javase/11/docs/api/java/time/Instant.html" rel="noreferrer"><code>Instant</code></a> is a moment on the timeline in <a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time" rel="noreferrer">UTC</a>, a count of <a href="https://en.wikipedia.org/wiki/Nanosecond" rel="noreferrer">nanoseconds</a> since the epoch of the first moment of 1970 UTC (basically, see class doc for nitty-gritty details). Since most of your business logic, data storage, and data exchange should be in UTC, this is a handy class to be used often.</p>
     <pre><code>Instant instant = Instant.now() ;  // Capture the current moment in UTC.
</code></pre>
     <h1><code>OffsetDateTime</code></h1>
     <p><a href="https://i.stack.imgur.com/D3rQ0.png" rel="noreferrer"><img src="D3rQ0.png" alt="enter image description here"></a></p>
     <p>The class <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/OffsetDateTime.html" rel="noreferrer"><code>OffsetDateTime</code></a> class represents a moment as a date and time with a context of some number of hours-minutes-seconds ahead of, or behind, UTC. The amount of offset, the number of hours-minutes-seconds, is represented by the <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/ZoneOffset.html" rel="noreferrer"><code>ZoneOffset</code></a> class.</p>
     <p>If the number of hours-minutes-seconds is zero, an <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/OffsetDateTime.html" rel="noreferrer"><code>OffsetDateTime</code></a> represents a moment in UTC the same as an <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/Instant.html" rel="noreferrer"><code>Instant</code></a>.</p>
     <h1><code>ZoneOffset</code></h1>
     <p><a href="https://i.stack.imgur.com/uw7es.png" rel="noreferrer"><img src="uw7es.png" alt="enter image description here"></a></p>
     <p>The <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/ZoneOffset.html" rel="noreferrer"><code>ZoneOffset</code></a> class represents an <a href="https://en.wikipedia.org/wiki/UTC_offset" rel="noreferrer">offset-from-UTC</a>, a number of hours-minutes-seconds ahead of UTC or behind UTC.</p>
     <p>A <code>ZoneOffset</code> is merely a number of hours-minutes-seconds, nothing more. A zone is much more, having a name and a history of changes to offset. So using a zone is always preferable to using a mere offset.</p>
     <h1><code>ZoneId</code></h1>
     <p><a href="https://i.stack.imgur.com/fIsUK.jpg" rel="noreferrer"><img src="fIsUK.jpg" alt="enter image description here"></a></p>
     <p>A <a href="https://en.wikipedia.org/wiki/Time_zone" rel="noreferrer">time zone</a> is represented by the <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/ZoneId.html" rel="noreferrer"><code>ZoneId</code></a> class.</p>
     <p>A new day dawns earlier in <a href="https://en.wikipedia.org/wiki/Paris" rel="noreferrer">Paris</a> than in <a href="https://en.wikipedia.org/wiki/Montreal" rel="noreferrer">Montréal</a>, for example. So we need to move the clock’s hands to better reflect <a href="https://en.wikipedia.org/wiki/Noon" rel="noreferrer">noon</a> (when the Sun is directly overhead) for a given region. The further away eastward/westward from the UTC line in west Europe/Africa the larger the offset.</p>
     <p>A time zone is a set of rules for handling adjustments and anomalies as practiced by a local community or region. The most common anomaly is the all-too-popular lunacy known as <a href="https://en.wikipedia.org/wiki/Daylight_saving_time" rel="noreferrer">Daylight Saving Time (DST)</a>.</p>
     <p>A time zone has the history of past rules, present rules, and rules confirmed for the near future.</p>
     <p>These rules change more often than you might expect. Be sure to keep your date-time library's rules, usually a copy of <a href="https://en.wikipedia.org/wiki/Tz_database" rel="noreferrer">the 'tz' database</a>, up to date. Keeping up-to-date is easier than ever now in Java 8 with Oracle releasing a <a href="http://www.oracle.com/technetwork/java/javase/tzupdater-readme-136440.html" rel="noreferrer">Timezone Updater Tool</a>.</p>
     <p>Specify a <a href="https://en.wikipedia.org/wiki/List_of_tz_zones_by_name" rel="noreferrer">proper time zone name</a> in the format of <code>Continent/Region</code>, such as <code>America/Montreal</code>, <code>Africa/Casablanca</code>, or <code>Pacific/Auckland</code>. Never use the 2-4 letter abbreviation such as <code>EST</code> or <code>IST</code> as they are <em>not</em> true time zones, not standardized, and not even unique(!).</p>
     <blockquote>
      <p>Time Zone = Offset + Rules of Adjustments</p>
     </blockquote>
     <pre><code>ZoneId z = ZoneId.of( “Africa/Tunis” ) ; 
</code></pre>
     <h1><code>ZonedDateTime</code></h1>
     <p><a href="https://i.stack.imgur.com/2j5Ui.png" rel="noreferrer"><img src="2j5Ui.png" alt="enter image description here"></a></p>
     <p>Think of <a href="http://docs.oracle.com/javase/11/docs/api/java/time/ZonedDateTime.html" rel="noreferrer"><code>ZonedDateTime</code></a> conceptually as an <code>Instant</code> with an assigned <code>ZoneId</code>.</p>
     <blockquote>
      <p>ZonedDateTime = ( Instant + ZoneId )</p>
     </blockquote>
     <p>To capture the current moment as seen in the wall-clock time used by the people of a particular region (a time zone):</p>
     <pre><code>ZonedDateTime zdt = ZonedDateTime.now( z ) ;  // Pass a `ZoneId` object such as `ZoneId.of( "Europe/Paris" )`. 
</code></pre>
     <p>Nearly all of your backend, database, business logic, data persistence, data exchange should all be in UTC. But for presentation to users you need to adjust into a time zone expected by the user. This is the purpose of the <code>ZonedDateTime</code> class and the <a href="http://docs.oracle.com/javase/11/docs/api/java/time/format/package-summary.html" rel="noreferrer">formatter classes</a> used to generate String representations of those date-time values.</p>
     <pre><code>ZonedDateTime zdt = instant.atZone( z ) ;
String output = zdt.toString() ;                 // Standard ISO 8601 format.
</code></pre>
     <p>You can generate text in localized format using <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/format/DateTimeFormatter.html" rel="noreferrer"><code>DateTimeFormatter</code></a>.</p>
     <pre><code>DateTimeFormatter f = DateTimeFormatter.ofLocalizedDateTime( FormatStyle.FULL ).withLocale( Locale.CANADA_FRENCH ) ; 
String outputFormatted = zdt.format( f ) ;
</code></pre>
     <blockquote>
      <p>mardi 30 avril 2019 à 23 h 22 min 55 s heure de l’Inde</p>
     </blockquote>
     <h1><code>LocalDate</code>, <code>LocalTime</code>, <code>LocalDateTime</code></h1>
     <p><a href="https://i.stack.imgur.com/PJSsX.jpg" rel="noreferrer"><img src="PJSsX.jpg" alt="Diagram showing only a calendar for a LocalDate."></a></p>
     <p><a href="https://i.stack.imgur.com/WXBy8.jpg" rel="noreferrer"><img src="WXBy8.jpg" alt="Diagram showing only a clock for a LocalTime."></a></p>
     <p><a href="https://i.stack.imgur.com/cmEdq.png" rel="noreferrer"><img src="cmEdq.png" alt="Diagram showing a calendar plus clock for a LocalDateTime."></a></p>
     <p>The "local" date time classes, <a href="http://docs.oracle.com/javase/11/docs/api/java/time/LocalDateTime.html" rel="noreferrer"><code>LocalDateTime</code></a>, <a href="http://docs.oracle.com/javase/11/docs/api/java/time/LocalDate.html" rel="noreferrer"><code>LocalDate</code></a>, <a href="http://docs.oracle.com/javase/11/docs/api/java/time/LocalTime.html" rel="noreferrer"><code>LocalTime</code></a>, are a different kind of critter. The are not tied to any one locality or time zone. They are not tied to the timeline. <strong>They have no real meaning</strong> until you apply them to a locality to find a point on the timeline.</p>
     <p>The word “Local” in these class names may be counter-intuitive to the uninitiated. The word means <em>any</em> locality, or <em>every</em> locality, but <em>not</em> a particular locality.</p>
     <p>So for business apps, the "Local" types are not often used as they represent just the general idea of a possible date or time not a specific moment on the timeline. Business apps tend to care about the exact moment an invoice arrived, a product shipped for transport, an employee was hired, or the taxi left the garage. So business app developers use <code>Instant</code> and <code>ZonedDateTime</code> classes most commonly.</p>
     <p>So when would we use <code>LocalDateTime</code>? In three situations:</p>
     <ul>
      <li>We want to apply a certain date and time-of-day across multiple locations.</li>
      <li>We are booking appointments.</li>
      <li>We have an intended yet undetermined time zone.</li>
     </ul>
     <p>Notice that none of these three cases involve a single certain specific point on the timeline, none of these are a moment.</p>
     <h2>One time-of-day, multiple moments</h2>
     <p>Sometimes we want to represent a certain time-of-day on a certain date, but want to apply that into multiple localities across time zones.</p>
     <p>For example, "Christmas starts at midnight on the 25th of December 2015" is a <code>LocalDateTime</code>. Midnight strikes at different moments in Paris than in Montréal, and different again in <a href="https://en.wikipedia.org/wiki/Seattle" rel="noreferrer">Seattle</a> and in <a href="https://en.wikipedia.org/wiki/Auckland" rel="noreferrer">Auckland</a>.</p>
     <pre><code>LocalDate ld = LocalDate.of( 2018 , Month.DECEMBER , 25 ) ;
LocalTime lt = LocalTime.MIN ;   // 00:00:00
LocalDateTime ldt = LocalDateTime.of( ld , lt ) ;  // Christmas morning anywhere. 
</code></pre>
     <p>Another example, "Acme Company has a policy that lunchtime starts at 12:30 PM at each of its factories worldwide" is a <code>LocalTime</code>. To have real meaning you need to apply it to the timeline to figure the moment of 12:30 at the <a href="https://en.wikipedia.org/wiki/Stuttgart" rel="noreferrer">Stuttgart</a> factory or 12:30 at the <a href="https://en.wikipedia.org/wiki/Rabat" rel="noreferrer">Rabat</a> factory or 12:30 at the <a href="https://en.wikipedia.org/wiki/Sydney" rel="noreferrer">Sydney</a> factory.</p>
     <h2>Booking appointments</h2>
     <p>Another situation to use <code>LocalDateTime</code> is for booking future events (ex: Dentist appointments). These appointments may be far enough out in the future that you risk politicians redefining the time zone. Politicians often give little forewarning, or even no warning at all. If you mean "3 PM next January 23rd" regardless of how the politicians may play with the clock, then you cannot record a moment – that would see 3 PM turn into 2 PM or 4 PM if that region adopted or dropped Daylight Saving Time, for example.</p>
     <p>For appointments, store a <code>LocalDateTime</code> and a <code>ZoneId</code>, kept separately. Later, when generating a schedule, on-the-fly determine a moment by calling <code>LocalDateTime::atZone( ZoneId )</code> to generate a <code>ZonedDateTime</code> object.</p>
     <pre><code>ZonedDateTime zdt = ldt.atZone( z ) ;  // Given a date, a time-of-day, and a time zone, determine a moment, a point on the timeline.
</code></pre>
     <p>If needed, you can adjust to UTC. Extract an <code>Instant</code> from the <code>ZonedDateTime</code>.</p>
     <pre><code>Instant instant = zdt.toInstant() ;  // Adjust from some zone to UTC. Same moment, same point on the timeline, different wall-clock time.
</code></pre>
     <h2>Unknown zone</h2>
     <p>Some people might use <code>LocalDateTime</code> in a situation where the time zone or offset is unknown.</p>
     <p>I consider this case inappropriate and unwise. If a zone or offset is intended but undetermined, you have bad data. That would be like storing a price of a product without knowing the intended currency (dollars, pounds, euros, etc.). Not a good idea.</p>
     <h1>All date-time types</h1>
     <p>For completeness, here is a table of all the possible date-time types, both modern and legacy in Java, as well as those defined by the SQL standard. This might help to place the <code>Instant</code> &amp; <code>LocalDateTime</code> classes in a larger context.</p>
     <p><a href="https://i.stack.imgur.com/GRtXz.png" rel="noreferrer"><img src="GRtXz.png" alt="Table of all date-time types in Java (both modern &amp; legacy) as well as SQL standard."></a></p>
     <p>Notice the odd choices made by the Java team in designing JDBC 4.2. They chose to support all the <em>java.time</em> times… except for the two most commonly used classes: <code>Instant</code> &amp; <code>ZonedDateTime</code>.</p>
     <p>But not to worry. We can easily convert back and forth.</p>
     <p>Converting <code>Instant</code>.</p>
     <pre><code>// Storing
OffsetDateTime odt = instant.atOffset( ZoneOffset.UTC ) ;
myPreparedStatement.setObject( … , odt ) ;

// Retrieving
OffsetDateTime odt = myResultSet.getObject( … , OffsetDateTime.class ) ;
Instant instant = odt.toInstant() ;
</code></pre>
     <p>Converting <code>ZonedDateTime</code>.</p>
     <pre><code>// Storing
OffsetDateTime odt = zdt.toOffsetDateTime() ;
myPreparedStatement.setObject( … , odt ) ;

// Retrieving
OffsetDateTime odt = myResultSet.getObject( … , OffsetDateTime.class ) ;
ZoneId z = ZoneId.of( "Asia/Kolkata" ) ;
ZonedDateTime zdt = odt.atZone( z ) ; 
</code></pre>
     <hr>
     <h1>About <em>java.time</em></h1>
     <p>The <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/package-summary.html" rel="noreferrer"><em>java.time</em></a> framework is built into Java 8 and later. These classes supplant the troublesome old <a href="https://en.wikipedia.org/wiki/Legacy_system" rel="noreferrer">legacy</a> date-time classes such as <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Date.html" rel="noreferrer"><code>java.util.Date</code></a>, <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Calendar.html" rel="noreferrer"><code>Calendar</code></a>, &amp; <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/text/SimpleDateFormat.html" rel="noreferrer"><code>SimpleDateFormat</code></a>.</p>
     <p>To learn more, see the <a href="http://docs.oracle.com/javase/tutorial/datetime/TOC.html" rel="noreferrer"><em>Oracle Tutorial</em></a>. And search Stack Overflow for many examples and explanations. Specification is <a href="https://jcp.org/en/jsr/detail?id=310" rel="noreferrer">JSR 310</a>.</p>
     <p>The <a href="http://www.joda.org/joda-time/" rel="noreferrer"><em>Joda-Time</em></a> project, now in <a href="https://en.wikipedia.org/wiki/Maintenance_mode" rel="noreferrer">maintenance mode</a>, advises migration to the <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/package-summary.html" rel="noreferrer">java.time</a> classes.</p>
     <p>You may exchange <em>java.time</em> objects directly with your database. Use a <a href="https://en.wikipedia.org/wiki/JDBC_driver" rel="noreferrer">JDBC driver</a> compliant with <a href="http://openjdk.java.net/jeps/170" rel="noreferrer">JDBC 4.2</a> or later. No need for strings, no need for <code>java.sql.*</code> classes. Hibernate 5 &amp; JPA 2.2 support <em>java.time</em>.</p>
     <p>Where to obtain the java.time classes?</p>
     <ul>
      <li><a href="https://en.wikipedia.org/wiki/Java_version_history#Java_SE_8" rel="noreferrer"><strong>Java SE 8</strong></a>, <a href="https://en.wikipedia.org/wiki/Java_version_history#Java_SE_9" rel="noreferrer"><strong>Java SE 9</strong></a>, <a href="https://en.wikipedia.org/wiki/Java_version_history#Java_SE_10" rel="noreferrer"><strong>Java SE 10</strong></a>, <a href="https://en.wikipedia.org/wiki/Java_version_history#Java_SE_11" rel="noreferrer"><strong>Java SE 11</strong></a>, and later - Part of the standard Java API with a bundled implementation. 
       <ul>
        <li><a href="https://en.wikipedia.org/wiki/Java_version_history#Java_SE_9" rel="noreferrer"><strong>Java 9</strong></a> brought some minor features and fixes.</li>
       </ul></li>
      <li><a href="https://en.wikipedia.org/wiki/Java_version_history#Java_SE_6" rel="noreferrer"><strong>Java SE 6</strong></a> and <a href="https://en.wikipedia.org/wiki/Java_version_history#Java_SE_7" rel="noreferrer"><strong>Java SE 7</strong></a>
       <ul>
        <li>Most of the <em>java.time</em> functionality is back-ported to Java 6 &amp; 7 in <a href="http://www.threeten.org/threetenbp/" rel="noreferrer"><em><strong>ThreeTen-Backport</strong></em></a>.</li>
       </ul></li>
      <li><a href="https://en.wikipedia.org/wiki/Android_(operating_system)" rel="noreferrer"><strong>Android</strong></a>
       <ul>
        <li>Later versions of Android (26+) bundle implementations of the <em>java.time</em> classes.</li>
        <li>For earlier Android (&lt;26), a process known as <a href="https://developer.android.com/studio/write/java8-support#library-desugaring" rel="noreferrer"><em>API desugaring</em></a> brings a <a href="https://developer.android.com/studio/write/java8-support-table" rel="noreferrer">subset of the <em>java.time</em></a> functionality not originally built into Android. 
         <ul>
          <li>If the desugaring does not offer what you need, the <a href="https://github.com/JakeWharton/ThreeTenABP" rel="noreferrer"><em><strong>ThreeTenABP</strong></em></a> project adapts <a href="http://www.threeten.org/threetenbp/" rel="noreferrer"><em><strong>ThreeTen-Backport</strong></em></a> (mentioned above) to Android. See <a href="http://stackoverflow.com/q/38922754/642706"><em>How to use ThreeTenABP…</em></a>.</li>
         </ul></li>
       </ul></li>
     </ul>
     <p><a href="https://i.stack.imgur.com/Sksw9.png" rel="noreferrer"><img src="Sksw9.png" alt="Table of which java.time library to use with which version of Java or Android"></a></p>
     <p>The <a href="http://www.threeten.org/threeten-extra/" rel="noreferrer"><strong>ThreeTen-Extra</strong></a> project extends java.time with additional classes. This project is a proving ground for possible future additions to java.time. You may find some useful classes here such as <a href="http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/Interval.html" rel="noreferrer"><code>Interval</code></a>, <a href="http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/YearWeek.html" rel="noreferrer"><code>YearWeek</code></a>, <a href="http://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/YearQuarter.html" rel="noreferrer"><code>YearQuarter</code></a>, and <a href="http://www.threeten.org/threeten-extra/apidocs/index.html" rel="noreferrer">more</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>75</td>
        <td><span>Great answer. I think some confusion (at least mine) comes from the <code>Local</code> naming. My intuition for <code>Local</code> means in relation to where I am AND when I am (?!), which leads me to believe that it would actually be what a <code>ZonedDateTime</code> is.</span> <span> - </span> <span class="display-name">mkobit</span> <span> </span> <span class="date">8 Sep 2015 at 13:55</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>Yes it is confusing. That is why java.time cleverly added the word 'Zoned' to the <code>DateTime</code> class name used by its predecessor Joda-Time (producing <code>ZonedDateTime</code>), to stress the difference from the "Local" classes. Think of the name "Local" as being shorthand for "needing to be applied to some particular locality".</span> <span> - </span> <span class="display-name">Basil Bourque</span> <span> </span> <span class="date">8 Sep 2015 at 16:14</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Prefixing with the word <code>Local</code> may have also been a way to differentiate from the java.util package, though somehow I feel there could have been a better word choice.</span> <span> - </span> <span class="display-name">riddle_me_this</span> <span> </span> <span class="date">31 Mar 2016 at 18:23</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@bphilipnyc I’ve had the same feeling about a better word choice. But I’ve yet to think of a better one, except perhaps the clunky term “Unzoned”.</span> <span> - </span> <span class="display-name">Basil Bourque</span> <span> </span> <span class="date">10 Aug 2016 at 04:16</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Great answer, @Basil Bourque, although i disagree with one assumption - that LocalDate is rarely useful in business apps. I think there are many cases where a date is important but the time portion isn't. You give an example of when an employee is hired. You'd almost certainly want to use a LocalDate to represent that. No-one wants to see that the employee started at midnight UTC, or 18:30 UTC the previous day if the employee is in India. You just want the date.</span> <span> - </span> <span class="display-name">simonh</span> <span> </span> <span class="date">18 Mar 2017 at 09:37</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@simonh On the contrary… When that new employee signs his/her hiring papers defining their benefits including life insurance and then that new hire steps outside for a coffee only to get hit and killed by a truck, there are going to be many people such as Human Resources managers, insurance agents, and attorneys who are going to want to know the precise moment when that new employment took effect.</span> <span> - </span> <span class="display-name">Basil Bourque</span> <span> </span> <span class="date">7 Apr 2017 at 21:45</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@simonh Yes, there are cases where the "local" date time is appropriate. Besides those mentioned in my Answer, another common case in business is for appointments being made more than a couple months out in the future, far enough out that politicians might change the time zone rules, usually with little forewarning. Politicians frequently make these changes such as changing the dates when going on/off Daylight Saving Time (DST) or staying permanently on/off DST.</span> <span> - </span> <span class="display-name">Basil Bourque</span> <span> </span> <span class="date">26 Jul 2017 at 19:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>According to <code>org.hibernate.type.descriptor.sql.TimestampTypeDescriptor</code>, I noticed that, Hibernate do: <code>Timestamp.from(instant)</code> before it saves <code>Instant</code> date to SQL database as Timestamp. and then sets the timestamp value depending on JDBC Driver Timezone. (hence it is DB Timezone)</span> <span> - </span> <span class="display-name">Muhammad Hewedy</span> <span> </span> <span class="date">6 Mar 2018 at 15:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@BasilBourque In the case of the future appointment, why wouldn't you still just treat it as a date/time in UTC? Since UTC never changes, just always treat and store in the database in UTC. When displaying to a user you use their timezone rules at that point in time to show them the date/time in the future converted from UTC. Right? So would Instant be the best class to use at all times until needing to convert to a particular locale/timezone?</span> <span> - </span> <span class="display-name">Kevin M</span> <span> </span> <span class="date">11 May 2018 at 14:23</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@KevinM Ask a North Korean dentist why all their patients are showing up <a href="http://www.latimes.com/world/asia/la-fg-north-korea-time-20180505-story.html" rel="nofollow noreferrer">a half-hour early this week</a>. All the patients are a half-hour ahead of the poorly-designed UTC-based appointment scheduling software.</span> <span> - </span> <span class="display-name">Basil Bourque</span> <span> </span> <span class="date">11 May 2018 at 16:54</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I get it they can change timezones. Let's look at this from the database perspective. You are saying that you would store appointments that are only somewhat in the future in UTC but then if it's far enough in the future you would not store it in UTC? Or would you store everything as UTC and then convert/display them differently based on how far in the future they are? That seems very inconsistent and arbitrary. You seem to be advocating for storing dates in the db Not in UTC and Not with specific timezone information. Or I'm just not following, which is possible</span> <span> - </span> <span class="display-name">Kevin M</span> <span> </span> <span class="date">11 May 2018 at 17:17</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>If your future appointments are far enough out that a government might, in the interval, change the offset used in that zone, then you must use the <i>concept</i> of “3 PM January 27, 2019” without determining a point in the timeline. That means using a <code>LocalDateTime</code>; store that. When you need to determine a moment, a point on the timeline, apply a <code>ZoneId</code> to get a <code>ZonedDateTime</code>. If you want to see UTC, extract an <code>Instant</code> from that <code>ZonedDateTime</code>. But do not store these. Later, when the gov. does redefine the zone’s offset, you’ll get a different result when applying the <code>ZoneId</code>.</span> <span> - </span> <span class="display-name">Basil Bourque</span> <span> </span> <span class="date">11 May 2018 at 17:45</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Great answer. Just one improvement: <code>ZonedDateTime</code> should be viewed as an alternative form to represent an <code>Instant</code>, and <code>ZonedDateTime</code> is actually <code>LocalDateTime</code> + <code>ZoneId</code> (instead of <code>Instant</code> + <code>ZoneId</code>). In another word: <code>LocalDateTime + ZoneId</code> = <code>ZonedDateTime</code>; and <code>ZonedDateTime</code> can be converted to <code>Instant</code>. I understand the reason you said <code>ZonedDateTime = Instant + ZoneId</code>, as you need to specify the timezone you want to convert an <code>Instant</code> to a <code>ZonedDateTime</code>, but it seems a bit misleading in some aspect (especially if we look into the implementation of <code>ZonedDateDate</code>)</span> <span> - </span> <span class="display-name">Adrian Shum</span> <span> </span> <span class="date">2 Aug 2018 at 06:25</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@AdrianShum <i>Conceptually</i>, adding <code>LocalDateTime</code> to this discussion is the wrong way to go. A <code>ZonedDateTime</code>, like <code>Instant</code>, represents a moment. A <code>LocalDateTime</code> <i>cannot</i> represent a moment, by definition, lacking the context of a time zone or offset-from-UTC. For example, <code>LocalDateTime.parse( "2018-03-11T02:30:00" )</code> (a) is a different moment on the east coast of the US versus the west coast of the US, and (b) does not even exist in much of the United States, as 2 AM to 3 AM is the "Spring Ahead" cutover of Daylight Saving Time (DST). Class implementation details are but a distraction.</span> <span> - </span> <span class="display-name">Basil Bourque</span> <span> </span> <span class="date">3 Aug 2018 at 19:03</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Conceptually, simply by the name of ZonedDateTime, it already hinted on what it is: it is a Date + Time (for which in JSR310/Joda, this is modelled as LocalDateTime) , that is Zoned (ie with Time Zone). So it is definitely not incorrect to mention LocalDateTime in discussion.</span> <span> - </span> <span class="display-name">Adrian Shum</span> <span> </span> <span class="date">4 Aug 2018 at 06:58</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I think your statement about business apps is unnecessary and also wrong - time-zone independent data is very important for a lot of businesses; if you need to be sure that your data still is valid in 10/20/30 years you <i>need</i> to use classes like these - system misconfigurations and miscalculations can corrupt your timestamps if they are bound to some timezone which is not the case with timezone-free stamps, they represent an abstract point in time which can be represented arbitrarily, depending on your needs. For instance : one could re-calculate everything with new timezones</span> <span> - </span> <span class="display-name">specializt</span> <span> </span> <span class="date">23 Oct 2018 at 15:37</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@specializt Reread my last sentence that starts with “On the other hand”. As I stated there, I agree with you about needing to use <code>LocalDateTime</code> to represent a date with time far enough in the future that we risk politicians changing the definition of the offset of their time zone(s).</span> <span> - </span> <span class="display-name">Basil Bourque</span> <span> </span> <span class="date">23 Oct 2018 at 15:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>its also the case for past timestamps - if (and only if) there is a need for re-calculation and/or re-interpretation; inside of fault-tolerant systems, for instance</span> <span> - </span> <span class="display-name">specializt</span> <span> </span> <span class="date">24 Oct 2018 at 08:20</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@specializt I don’t follow you there. For the past, time zone definitions do not change. So no risk associated with storing a date-time associated with a time zone such as a <code>ZonedDateTime</code>. But generally it is best to store passed moments in UTC. That means either an <code>Instant</code> or an <code>OffsetDateTime</code> set to <code>ZoneOffset.UTC</code>. But I don’t see any reason to ever handle a past moment as a <code>LocalDateTime</code>.</span> <span> - </span> <span class="display-name">Basil Bourque</span> <span> </span> <span class="date">24 Oct 2018 at 15:39</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>like i said : if the timestamp is used for calculations and applied timezones could change in the future such a persistence field really is needed. This is the case for fault-tolerant systems and/or especially volatile calculation steps which need to be adjusted in the future according to local law and/or court orders. Calculations like these cannot be fixed to any assumption whatsoever and timezones basically are assumptions of system clock integrity, precision, data source validity and -integrity and so on. Imagine a court order re-defining a formula which has already been applied to data.</span> <span> - </span> <span class="display-name">specializt</span> <span> </span> <span class="date">24 Oct 2018 at 16:08</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@specializt That is true for <i>future</i> moments, not <i>past</i>.</span> <span> - </span> <span class="display-name">Basil Bourque</span> <span> </span> <span class="date">24 Oct 2018 at 16:12</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>i think you fail to grasp the basic concept of retroactive and fault-tolerant calculations. Well ... its not that important, these requirements are way above what most programmers have to face and are actually a bit exotic. You just need to know that there are very valid needs for persistence fields like these and they also matter for <b>past</b> moments</span> <span> - </span> <span class="display-name">specializt</span> <span> </span> <span class="date">24 Oct 2018 at 16:17</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@specializt I suggest you post your own Question and Answer to educate others about this mysterious retroactive and fault-tolerant calculations concept. I am curious.</span> <span> - </span> <span class="display-name">Basil Bourque</span> <span> </span> <span class="date">11 Mar 2019 at 21:36</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Hi, <b>1-</b> what is difference between <code>instant.atZone( z )</code> and <code>ZonedDateTime.ofInstant( instant , z )</code>? <b>2-</b> If i want to update a field in a page by changing the day, is better to use the <i>instant</i> or the <i>LocalDateTime</i>?</span> <span> - </span> <span class="display-name">Arash</span> <span> </span> <span class="date">11 Aug 2020 at 19:55</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Arash (1) No difference. (2) If you mean to represent a moment, a specific point in time, you cannot use <code>LocalDateTime</code>, you must use the other three types as shown on my chart. To represent merely a date with time-of-day but without the context of an offset-from-UTC or a time zone, and therefore inherently ambiguous, use <code>LocalDateTime</code>.</span> <span> - </span> <span class="display-name">Basil Bourque</span> <span> </span> <span class="date">13 Aug 2020 at 20:11</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@BasilBourque &gt; Class implementation details are but a distraction Not if we consider how <code>LocalDateTime("some-dst-overlap-time").atZone()</code> works versus <code>Instant.atZone()</code>. Or <code>ZonedDateTime.parse("some-dst-overlap-time+ANYOFFSETWHATSOEV‌​ER[ZoneId]")</code>, which works identically to the <code>LocalDateTime.atZone</code> variant. The <code>LocalDateTime</code>/<code>parse</code> variants will preserve the <code>LocalDateTime</code> component in case of law changes/dst, ignoring the offset in the parsed string, while the Instant variant will preserve the Instant.</span> <span> - </span> <span class="display-name">iwat0qs</span> <span> </span> <span class="date">10 Sep 2020 at 07:17</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Wanted to point out that there is an alternative to LocalDateTime in pre-java-8 world. It's the java.sql.Timestamp itself. If constructed using <code>Timestamp.valueOf(string)</code> and stored in a zone-less db column,then regardless of the tz it will be read back out with toString returning the original time (except the offset). A quirk is, that if constructed with string, the milliseconds stored internally are completely awry and depend on the TZ. So, build with millis - get millis. Same for string. Or <code>.toLocalDateTime</code> in java 8. This is inherent to all java.util.Date based classes.</span> <span> - </span> <span class="display-name">iwat0qs</span> <span> </span> <span class="date">10 Sep 2020 at 08:27</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Basil Bourque I have a working Android app that uses legacy Date, Calendar and Timestamp functions to provide local date, time and timer features for the user. Works perfectly but I realize the code should be replaced with more robust and stable java.time code. Are there any good tutorials about using API desugaring and/or ThreeTenABP to replace my legacy code for API &lt;26.</span> <span> - </span> <span class="display-name">AJW</span> <span> </span> <span class="date">6 Dec 2022 at 19:01</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@AJW <a href="https://stackoverflow.com/q/38922754/642706"><i>How to use ThreeTenABP in Android Project</i></a>. And you can easily use a search engine such as Duck Duck Go, Bing, or Google to find the phrase “API desugaring”.</span> <span> - </span> <span class="display-name">Basil Bourque</span> <span> </span> <span class="date">7 Dec 2022 at 06:20</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Basil Bourque Very good, thank you for the reply and info, cheers.</span> <span> - </span> <span class="display-name">AJW</span> <span> </span> <span class="date">7 Dec 2022 at 19:50</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>37</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Dariusz</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Sep 2015 at 11:49</span>
     </div>
    </div>
    <div>
     <p>One main difference is the "Local" part of <code>LocalDateTime</code>. If you live in Germany and create a <code>LocalDateTime</code> instance and someone else lives in the USA and creates another instance at the very same moment (provided the clocks are properly set) - the value of those objects would actually be different. This does not apply to <code>Instant</code>, which is calculated independently from a time zone.</p>
     <p><code>LocalDateTime</code> stores date and time without a timezone, but its initial value is timezone-dependent. <code>Instant</code>'s is not.</p>
     <p>Moreover, <code>LocalDateTime</code> provides methods for manipulating date components like days, hours, and months. An <code>Instant</code> does not.</p>
     <blockquote>
      <p>apart from the nanosecond precision advantage of <code>Instant</code> and the time-zone part of <code>LocalDateTime</code></p>
     </blockquote>
     <p>Both classes have the same precision. <code>LocalDateTime</code> does not store the timezone. Read Javadocs thoroughly, because you may make a big mistake with such invalid assumptions: <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html" rel="noreferrer"><code>Instant</code></a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDateTime.html" rel="noreferrer"><code>LocalDateTime</code></a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>sorry for misreading part on zone + precision. Sorry for repeating from above post: Considering a single time-zone application, in which use-cases would you favor LocalDateTime or vice versa?</span> <span> - </span> <span class="display-name">manuel aldana</span> <span> </span> <span class="date">7 Sep 2015 at 14:10</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>I'd take LocalDateTime whenever I need dates and/or times. In hours, minutes, or so. I'd use Instant to measure execution times, for example, or store an internal field of sth happening then and there. Calculating next runs, as in your case? LocalDateTime seems appropriate, but it's an opinion. As you stated, both can be used.</span> <span> - </span> <span class="display-name">Dariusz</span> <span> </span> <span class="date">7 Sep 2015 at 14:25</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>18</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Tunaki</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Sep 2015 at 11:50</span>
     </div>
    </div>
    <div>
     <p>You are wrong about <a href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDateTime.html" rel="noreferrer"><code>LocalDateTime</code></a>: it does not store any time-zone information and it has nanosecond precision. Quoting the Javadoc (emphasis mine):</p>
     <blockquote>
      <p><strong>A date-time without a time-zone in the ISO-8601 calendar system</strong>, such as 2007-12-03T10:15:30.</p>
      <p><code>LocalDateTime</code> is an immutable date-time object that represents a date-time, often viewed as year-month-day-hour-minute-second. Other date and time fields, such as day-of-year, day-of-week and week-of-year, can also be accessed. <strong>Time is represented to nanosecond precision</strong>. For example, the value "2nd October 2007 at 13:45.30.123456789" can be stored in a <code>LocalDateTime</code>.</p>
     </blockquote>
     <p>The difference between the two is that <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html" rel="noreferrer"><code>Instant</code></a> represents an offset from the Epoch (01-01-1970) and, as such, represents a particular instant on the time-line. Two <code>Instant</code> objects created at the same moment in two different places on the Earth will have exactly the same value.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Considering a single time-zone application, in which use-cases would you favor LocalDateTime or vice versa?</span> <span> - </span> <span class="display-name">manuel aldana</span> <span> </span> <span class="date">7 Sep 2015 at 14:10</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@manuelaldana It is more a matter of taste. I'd prefer LocalDateTime for anything user-related (birthday...) and Instant for anything machine-related (execution time...).</span> <span> - </span> <span class="display-name">Tunaki</span> <span> </span> <span class="date">7 Sep 2015 at 14:31</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@manuelaldana A single time zone app is rare if not nonexistent. You might get away with ignoring time zones for a little app you whipped up for your local Baroque music club. But as soon as you need to post an event to people who travel (and cross time zones) they'll want that data tied to a time zone so their calendar app can adjust as needed. I suggest you learn to work with time zones properly in all your apps.</span> <span> - </span> <span class="display-name">Basil Bourque</span> <span> </span> <span class="date">7 Sep 2015 at 16:52</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Tunaki Your use of the word 'offset' in the last paragraph is distracting. That word has a certain meaning in date-time work, so it's use here in this context could be unhelpful.</span> <span> - </span> <span class="display-name">Basil Bourque</span> <span> </span> <span class="date">7 Sep 2015 at 19:35</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Sebien</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 May 2022 at 12:45</span>
     </div>
    </div>
    <div>
     <p>LocalDateTime has no time-zone information: one LocalDateTime may represent different instants for different machines around the world. So you should not try to use it with an implicit time-zone (the system's default one). You should use it for what it represents, for instance "New-year is January 1st, at 0:00": this means a different time at all points on the globe but it's wanted in this case.</p>
     <p>Instant is a point in time at the Greenwich time-zone. Use it in addition to the user's time-zone to show him/her the start of a meeting in his/her time-zone, for instance.</p>
     <p>If these two classes do not represent what you wanted to store/exchange, then maybe ZonedDateTime or another class may do a better job.</p>
     <p>Here is a simple synthetic schema to get the big-picture of the classes in the java.time package and their relation to the ISO-8601 standard used to reliably and effortlessly exchange dates and times between Java and other languages or frameworks:</p>
     <p><a href="https://i.stack.imgur.com/UF4J9.png" rel="noreferrer"><img src="UF4J9.png" alt="Classes of the java.time package and their relations to the ISO-8601 standard"></a></p>
     <p>The schema is explained in details here: <a href="http://slaout.linux62.org/java-date-time/" rel="noreferrer">http://slaout.linux62.org/java-date-time/</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>