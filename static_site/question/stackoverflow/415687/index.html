<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>Why are local variables not initialized in Java?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>Why are local variables not initialized in Java?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>112</span>
    </div>
    <div>
     <span>Asker: </span> <span>Shivasubramanian A</span>
    </div>
    <div>
     <span>Asked: </span> <span>6 Jan 2009 at 07:03</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/415687/why-are-local-variables-not-initialized-in-java">source</a>
    </div>
   </div>
   <div>
    <p>Was there any reason why the designers of Java felt that local variables should not be given a default value? Seriously, if instance variables can be given a default value, then why can't we do the same for local variables?</p>
    <p>And it also leads to problems as explained in <a href="http://javahowto.blogspot.com/2007/01/variable-might-not-have-been.html?showComment=1206851400000#c1463508649088298714" rel="noreferrer">this comment to a blog post</a>:</p>
    <blockquote>
     <p>Well this rule is most frustrating when trying to close a resource in a finally block. If I instantiate the resource inside a try, but try to close it within the finally, I get this error. If I move the instantiation outside the try, I get another error stating that a it must be within a try.</p>
     <p>Very frustrating.</p>
    </blockquote>
   </div>
   <div class="tags">
    <span class="tag">java</span><span class="tag">variables</span><span class="tag">initialization</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>2</td>
       <td><span>Same question: <a href="http://stackoverflow.com/questions/268814/uninitialized-variables-and-members-in-java">http://stackoverflow.com/questions/268814/uninitialized-vari‌​ables-and-members-in‌​-java</a></span> <span> - </span> <span class="display-name">Yuval Adam</span> <span> </span> <span class="date">6 Jan 2009 at 10:43</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>Sorry about that... this question didn't popup when I was typing in the question.. however, I guess there's a difference between the two questions... I want to know why the designers of Java <i>designed</i> it this way, whereas the question you pointed to does not ask that...</span> <span> - </span> <span class="display-name">Shivasubramanian A</span> <span> </span> <span class="date">8 Jan 2009 at 06:20</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>See also this related C# question: <a href="http://stackoverflow.com/questions/1542824/initialization-of-instance-fields-vs-local-variables" title="initialization of instance fields vs local variables">stackoverflow.com/questions/1542824/…</a></span> <span> - </span> <span class="display-name">Raedwald</span> <span> </span> <span class="date">11 Mar 2014 at 13:06</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Simply - because it's easy for the compiler to track uninitialized local variables. If it could to the same with other variables, it would. The compiler is just trying to help you.</span> <span> - </span> <span class="display-name">rustyx</span> <span> </span> <span class="date">17 Dec 2015 at 21:11</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Similar question for C# (despite the title - see the answers): <i><a href="https://stackoverflow.com/questions/8931226">Are C# uninitialized variables dangerous?</a></i></span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">17 Jan 2021 at 02:15</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>67</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Warrior</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Jan 2009 at 07:18</span>
     </div>
    </div>
    <div>
     <p>Local variables are declared mostly to do some calculation. So it's the programmer's decision to set the value of the variable and it should not take a default value.</p>
     <p>If the programmer, by mistake, did not initialize a local variable and it takes a default value, then the output could be some unexpected value. So in case of local variables, the compiler will ask the programmer to initialize it with some value before they access the variable to avoid the usage of undefined values.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>24</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Rob Kennedy</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Jan 2009 at 08:00</span>
     </div>
    </div>
    <div>
     <p><a href="http://javahowto.blogspot.com/2007/01/variable-might-not-have-been.html?showComment=1206851400000#c1463508649088298714" rel="noreferrer">The "problem" you link to</a> seems to be describing this situation:</p>
     <pre><code>SomeObject so;
try {
  // Do some work here ...
  so = new SomeObject();
  so.DoUsefulThings();
} finally {
  so.CleanUp(); // Compiler error here
}
</code></pre>
     <p>The commenter's complaint is that the compiler balks at the line in the <code>finally</code> section, claiming that <code>so</code> might be uninitialized. The comment then mentions another way of writing the code, probably something like this:</p>
     <pre><code>// Do some work here ...
SomeObject so = new SomeObject();
try {
  so.DoUsefulThings();
} finally {
  so.CleanUp();
}
</code></pre>
     <p>The commenter is unhappy with that solution because the compiler then says that the code "must be within a try." I guess that means some of the code may raise an exception that isn't handled anymore. I'm not sure. Neither version of my code handles any exceptions, so anything exception-related in the first version should work the same in the second.</p>
     <p>Anyway, this second version of code is the <em>correct</em> way to write it. In the first version, the compiler's error message was correct. The <code>so</code> variable might be uninitialized. In particular, if the <code>SomeObject</code> constructor fails, <code>so</code> will not be initialized, and so it will be an error to attempt to call <code>so.CleanUp</code>. Always enter the <code>try</code> section <em>after</em> you have acquired the resource that the <code>finally</code> section finalizes.</p>
     <p>The <code>try</code>-<code>finally</code> block after the <code>so</code> initialization is there <em>only</em> to protect the <code>SomeObject</code> instance, to make sure it gets cleaned up no matter what else happens. If there are <em>other</em> things that need to run, but they aren't related to whether the <code>SomeObject</code> instance was property allocated, then they should go in <em>another</em> <code>try</code>-<code>finally</code> block, probably one that wraps the one I've shown.</p>
     <p>Requiring variables to be assigned manually before use does not lead to real problems. It only leads to minor hassles, but your code will be better for it. You'll have variables with more limited scope, and <code>try</code>-<code>finally</code> blocks that don't try to protect too much.</p>
     <p>If local variables had default values, then <code>so</code> in the first example would have been <code>null</code>. That wouldn't really have solved anything. Instead of getting a compile-time error in the <code>finally</code> block, you'd have a <code>NullPointerException</code> lurking there that might <em>hide</em> whatever other exception could occur in the "Do some work here" section of the code. (Or do exceptions in <code>finally</code> sections automatically chain to the previous exception? I don't remember. Even so, you'd have an extra exception in the way of the real one.)</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>why not just have an if(so!=null)... in the finally block?</span> <span> - </span> <span class="display-name">izb</span> <span> </span> <span class="date">6 Jan 2009 at 09:42</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>that will still cause the compiler warning/error - i dont think the compiler understands that if check (but i m just doing this off memory, not tested).</span> <span> - </span> <span class="display-name">Chii</span> <span> </span> <span class="date">6 Jan 2009 at 09:52</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>I'd put just SomeObject so = null before try and put null check to finally clause. This way there will be no compiler warnings.</span> <span> - </span> <span class="display-name">Juha Syrjälä</span> <span> </span> <span class="date">6 Jan 2009 at 11:00</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Why complicate things? Write the try-finally block this way, and you KNOW the variable has a valid value. No null-checking required.</span> <span> - </span> <span class="display-name">Rob Kennedy</span> <span> </span> <span class="date">6 Jan 2009 at 16:09</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Rob, your example "new SomeObject()" is simple and no exceptions should be generated there, but if the call can generate exceptions then it would be better to have it occur inside the try-block so that it can be handled.</span> <span> - </span> <span class="display-name">Sarel Botha</span> <span> </span> <span class="date">28 Jan 2009 at 16:58</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>You could always just use an additional try-catch block around the whole thing.</span> <span> - </span> <span class="display-name">Tim Frey</span> <span> </span> <span class="date">30 Jan 2009 at 15:31</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>First, Sjbotha, exceptions <i>can</i> be generated there. We could run out of memory, or, more likely, the SomeObject constructor could throw its own exceptions. We have no idea what it does.</span> <span> - </span> <span class="display-name">Rob Kennedy</span> <span> </span> <span class="date">30 Jan 2009 at 17:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Second, it would NOT be better to have the constructor call inside that try block. That's a try-finally block, which does NOTHING to handle exceptions. If an exception occurred, we'd be calling CleanUp on an uninitialized or null variable, and we'd be back to the same state as in my first code block</span> <span> - </span> <span class="display-name">Rob Kennedy</span> <span> </span> <span class="date">30 Jan 2009 at 17:05</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>12</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Adeel Ansari</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Jan 2009 at 07:31</span>
     </div>
    </div>
    <div>
     <p>Notice that the final instance/member variables don't get initialized by default. Because those are final and can't be changed in the program afterwards. That's the reason that Java doesn't give any default value for them and force the programmer to initialize it.</p>
     <p>On the other hand, non-final member variables can be changed later. Hence, the compiler doesn't let them remain uninitialised; precisely, because those can be changed later. Regarding local variables, the scope of local variables is much narrower; and compiler knows when it's getting used. Hence, forcing the programmer to initialize the variable, makes sense.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>12</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Electric Monk</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Jan 2009 at 09:58</span>
     </div>
    </div>
    <div>
     <p>Moreover, in the example below, an exception may have been thrown inside the SomeObject construction, in which case the 'so' variable would be null and the call to CleanUp will throw a NullPointerException</p>
     <pre><code>SomeObject so;
try {
  // Do some work here ...
  so = new SomeObject();
  so.DoUsefulThings();
} finally {
  so.CleanUp(); // Compiler error here
}
</code></pre>
     <p>What I tend to do is this:</p>
     <pre><code>SomeObject so = null;
try {
  // Do some work here ...
  so = new SomeObject();
  so.DoUsefulThings();
} finally {
  if (so != null) {
     so.CleanUp(); // safe
  }
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>Yup, ugly. Yup, it's what I do, too.</span> <span> - </span> <span class="display-name">SMBiggs</span> <span> </span> <span class="date">28 Mar 2013 at 20:38</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@ElectricMonk Which form you think is better, the one you shown or that shown here in the getContents(..) method: <a href="http://www.javapractices.com/topic/TopicAction.do?Id=126" rel="nofollow noreferrer">javapractices.com/topic/TopicAction.do?Id=126</a></span> <span> - </span> <span class="display-name">Atom</span> <span> </span> <span class="date">22 Jun 2016 at 16:57</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>12</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Bill K</span>
     </div>
     <div>
      <span> Answered: </span> <span>20 May 2011 at 23:11</span>
     </div>
    </div>
    <div>
     <p>The actual answer to your question is because method variables are instantiated by simply adding a number to the stack pointer. To zero them would be an extra step. For class variables they are put into initialized memory on the heap.</p>
     <p>Why not take the extra step? Take a step back--Nobody mentioned that the "warning" in this case is a Very Good Thing.</p>
     <p>You should never initialize your variable to zero or null on the first pass (when you are first coding it). Either assign it to the actual value or don't assign it at all because if you don't then Java can tell you when you really screw up. Take <a href="https://stackoverflow.com/questions/415687/why-are-local-variables-not-initialized-in-java/415978#415978">Electric Monk's answer</a> as a great example. In the first case, it's actually amazingly useful that it's telling you that if the try() fails because SomeObject's constructor threw an exception, then you would end up with an <a href="https://en.wikipedia.org/wiki/Null_pointer#Dereferencing" rel="nofollow noreferrer">NPE</a> in the finally. If the constructor can't throw an exception, it shouldn't be in the try.</p>
     <p>This warning is an awesome multi-path bad programmer checker that has saved me from doing stupid stuff since it checks every path and makes sure that if you used the variable in some path then you had to initialize it in every path that lead up to it. I now never explicitly initialize variables until I determine that it is the correct thing to do.</p>
     <p>On top of that, isn't it better to explicitly say "int size=0" rather than "int size" and make the next programmer go figure out that you intend it to be zero?</p>
     <p>On the flip side I can't come up with a single valid reason to have the compiler initialize all uninitialized variables to 0.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>Yes, and there are others where it more or less has to be initialized to null because of the way the code flows--I shouldn't have said "never" updated the answer to reflect this.</span> <span> - </span> <span class="display-name">Bill K</span> <span> </span> <span class="date">12 Jan 2012 at 20:35</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>T.J. Crowder</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Mar 2010 at 08:24</span>
     </div>
    </div>
    <div>
     <p>For me, the <em>reason</em> comes down to this this: The purpose of local variables is different than the purpose of instance variables. Local variables are there to be used as part of a calculation; instance variables are there to contain state. If you use a local variable without assigning it a value, that's almost certainly a logic error.</p>
     <p>That said, I could totally get behind requiring that instance variables were always explicitly initialized; the error would occur on any constructor where the result allows an uninitialized instance variable (e.g., not initialized at declaration and not in the constructor). But that's not the decision Gosling, et. al., took in the early 90's, so here we are. (And I'm not saying they made the wrong call.)</p>
     <p>I could <em>not</em> get behind defaulting local variables, though. Yes, we shouldn't rely on compilers to double-check our logic, and one doesn't, but it's still handy when the compiler catches one out. :-)</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span><i>"That said, I could totally get behind requiring that instance variables were always explicitly initialized..."</i> which, FWIW, is the direction they've taken in TypeScript.</span> <span> - </span> <span class="display-name">T.J. Crowder</span> <span> </span> <span class="date">21 Apr 2020 at 06:27</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mehrdad Afshari</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Jan 2009 at 07:12</span>
     </div>
    </div>
    <div>
     <p>I think the primary purpose was to maintain similarity with C/C++. However the compiler detects and warns you about using uninitialized variables which will reduce the problem to a minimal point. From a performance perspective, it's a little faster to let you declare uninitialized variables since the compiler will not have to write an assignment statement, even if you overwrite the value of the variable in the next statement.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>Arguably, the compiler could determine whether you always assign to the variable before doing anything with it, and suppress an automatic default value assignment in such a case. If the compiler can't determine whether an assignment happens before access, it would generate the default assignment.</span> <span> - </span> <span class="display-name">Greg Hewgill</span> <span> </span> <span class="date">6 Jan 2009 at 07:13</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Yes, but one might argue that it lets the programmer know if he or she has left the variable uninitialized by mistake.</span> <span> - </span> <span class="display-name">Mehrdad Afshari</span> <span> </span> <span class="date">6 Jan 2009 at 07:15</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>The compiler could do that in either case too. :) Personally, I would prefer that the compiler treats an uninitialised variable as an error. It means I might have made a mistake somewhere.</span> <span> - </span> <span class="display-name">Greg Hewgill</span> <span> </span> <span class="date">6 Jan 2009 at 07:16</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I'm not a Java guy, but I like the C# way of handling it. The difference is in that case, the compiler had to issue a warning, which might make you get a couple hundred of warnings for your correct program ;)</span> <span> - </span> <span class="display-name">Mehrdad Afshari</span> <span> </span> <span class="date">6 Jan 2009 at 07:29</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Does it warn for the member variables too?</span> <span> - </span> <span class="display-name">Adeel Ansari</span> <span> </span> <span class="date">6 Jan 2009 at 07:32</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Nope, member variables will be initialized both in Java and C# by the compiler, if you don't specify a thing.</span> <span> - </span> <span class="display-name">Mehrdad Afshari</span> <span> </span> <span class="date">6 Jan 2009 at 08:37</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Re <i>"it's a little faster to let you declare uninitialized variables"</i>: Doesn't the runtime (JVM) do it anyway (not a rhetorical quesion)?</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">17 Jan 2021 at 02:17</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>starblue</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Jan 2009 at 09:48</span>
     </div>
    </div>
    <div>
     <p>It is more efficient not to initialize variables, and in the case of local variables it is safe to do so, because initialization can be tracked by the compiler.</p>
     <p>In cases where you need a variable to be initialized you can always do it yourself, so it is not a problem.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>kumquatfelafel</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Sep 2018 at 02:49</span>
     </div>
    </div>
    <div>
     <p>The idea behind local variables is they only exist inside the limited scope for which they are needed. As such, there should be little reason for uncertainty as to the value, or at least, where that value is coming from. I could imagine many errors arising from having a default value for local variables.</p>
     <p>For example, consider the following simple code... (<strong>N.B. let us assume for demonstration purposes that local variables are assigned a default value, as specified, if not explicitly initialized</strong>)</p>
     <pre><code>System.out.println("Enter grade");
int grade = new Scanner(System.in).nextInt(); // I won't bother with exception handling here, to cut down on lines.
char letterGrade; // Let us assume the default value for a char is '\0'
if (grade &gt;= 90)
    letterGrade = 'A';
else if (grade &gt;= 80)
    letterGrade = 'B';
else if (grade &gt;= 70)
    letterGrade = 'C';
else if (grade &gt;= 60)
    letterGrade = 'D';
else
    letterGrade = 'F';
System.out.println("Your grade is " + letterGrade);
</code></pre>
     <p>When all is said and done, <em><strong>assuming the compiler assigned a default value of '\0' to letterGrade</strong></em>, this code as written would work properly. However, what if we forgot the else statement?</p>
     <p>A test run of our code might result in the following</p>
     <pre class="lang-none prettyprint-override"><code>Enter grade
43
Your grade is
</code></pre>
     <p>This outcome, while to be expected, surely was not the coder's intent. Indeed, probably in a vast majority of cases (or at least, a significant number, thereof), the default value wouldn't be the <em>desired</em> value, so in the vast majority of cases the default value would result in error. It makes more sense to force the coder to assign an initial value to a local variable before using it, since the debugging grief caused by forgetting the <code>= 1</code> in <code>for(int i = 1; i &lt; 10; i++)</code> far outweighs the convenience in not having to include the <code>= 0</code> in <code>for(int i; i &lt; 10; i++)</code>.</p>
     <p>It is true that try-catch-finally blocks could get a little messy (but it isn't actually a catch-22 as the quote seems to suggest), when for example an object throws a checked exception in its constructor, yet for one reason or another, something <em>must</em> be done to this object at the end of the block in finally. A perfect example of this is when dealing with resources, which must be closed.</p>
     <p>One way to handle this in the past might be like so...</p>
     <pre><code>Scanner s = null; // Declared and initialized to null outside the block. This gives us the needed scope, and an initial value.
try {
    s = new Scanner(new FileInputStream(new File("filename.txt")));
    int someInt = s.nextInt();
} catch (InputMismatchException e) {
    System.out.println("Some error message");
} catch (IOException e) {
    System.out.println("different error message");
} finally {
    if (s != null) // In case exception during initialization prevents assignment of new non-null value to s.
        s.close();
}
</code></pre>
     <p>However, as of Java 7, this finally block is no longer necessary using try-with-resources, like so.</p>
     <pre><code>try (Scanner s = new Scanner(new FileInputStream(new File("filename.txt")))) {
    ...
    ...
} catch(IOException e) {
    System.out.println("different error message");
}
</code></pre>
     <p>That said, (as the name suggests) this only works with resources.</p>
     <p>And while the former example is a bit yucky, this perhaps speaks more to the way try-catch-finally or these classes are implemented than it speaks about local variables and how they are implemented.</p>
     <p>It is true that fields are initialized to a default value, but this is a bit different. When you say, for example, <code>int[] arr = new int[10];</code>, as soon as you've initialized this array, the object exists in memory at a given location. Let's assume for a moment that there is no default values, but instead the initial value is whatever series of 1s and 0s happens to be in that memory location at the moment. This could lead to non-deterministic behavior in a number of cases.</p>
     <p>Suppose we have...</p>
     <pre><code>int[] arr = new int[10];
if(arr[0] == 0)
    System.out.println("Same.");
else
    System.out.println("Not same.");
</code></pre>
     <p>It would be perfectly possible that <code>Same.</code> might be displayed in one run and <code>Not same.</code> might be displayed in another. The problem could become even more grievous once you start talking reference variables.</p>
     <pre><code>String[] s = new String[5];
</code></pre>
     <p>According to definition, each element of s should point to a String (or is null). However, if the initial value is whatever series of 0s and 1s happens to occur at this memory location, not only is there no guarantee you'll get the same results each time, but there's also no guarantee that the object s[0] points to (assuming it points to anything meaningful) even <strong>is</strong> a String (perhaps it's a Rabbit, <strong>:p</strong>)! This lack of concern for type would fly in the face of pretty much everything that makes Java Java. So while having default values for local variables could be seen as optional at best, having default values for instance variables is closer to a <strong>necessity</strong>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>kaya3 - support the strike</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Jan 2022 at 13:02</span>
     </div>
    </div>
    <div>
     <p>Flip this around and ask: why are fields initialised to default values? If the Java compiler required you to initialise fields yourself instead of using their default values, that would be more efficient because there would be no need to zero out memory before you used it. So it would be a sensible language design if <em>all</em> variables were treated like local variables in this regard.</p>
     <p>The reason is not because it's more difficult to check this for fields than for local variables. The Java compiler already knows how to check whether a field is definitely initialised by a constructor, because it has to check this for <code>final</code> fields. So it would be little extra work for the compiler to apply the same logic to other fields to ensure they are definitely assigned in the constructor.</p>
     <p>The reason is that, even for <code>final</code> fields where the compiler proves that the field is definitely assigned in the constructor, its value before assignment can still be visible from other code:</p>
     <pre class="lang-java prettyprint-override"><code>class A {
    final int x;
    A() {
        this.x = calculate();
    }
    int calculate() {
        System.out.println(this.x);
        return 1;
    }
}
</code></pre>
     <p>In this code, the constructor definitely assigns to <code>this.x</code>, but even so, the field's default initial value of <code>0</code> is visible in the <code>calculate</code> method at the point where <code>this.x</code> is printed. If the field wasn't zeroed out before the constructor was invoked, then the <code>calculate</code> method would be able to observe the contents of uninitialised memory, which would be non-deterministic behaviour and have potential security concerns.</p>
     <p>The alternative would be to forbid the method call <code>calculate()</code> at this point in the code where the field isn't yet definitely assigned. But that would be inconvenient; it is useful to be able to call methods from the constructor like this. The convenience of being able to do that is worth more than the tiny performance cost of zeroing out the memory for the fields before invoking the constructor.</p>
     <p>Note that this reasoning does not apply to local variables, because a method's uninitialised local variables are not visible from other methods; because they are local.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Kieran Senior</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Jan 2009 at 08:10</span>
     </div>
    </div>
    <div>
     <p>Eclipse even gives you warnings of uninitialized variables, so it becomes quite obvious anyway. Personally I think it's a good thing that this is the default behaviour, otherwise your application may use unexpected values, and instead of the compiler throwing an error it won't do anything (but perhaps give a warning) and then you'll be scratching your head as to why certain things don't quite behave the way they should.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Re <i>"Eclipse even gives you warnings"</i>: Isn't it the compiler (not specific to Eclipse)? - <i>"<a href="https://stackoverflow.com/questions/9687634/variable-default-value-in-java/9687671#9687671">Accessing an uninitialized local variable will result in a compile-time error.</a>"</i></span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">7 Jan 2021 at 16:31</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>David Santamaria</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Jan 2009 at 16:50</span>
     </div>
    </div>
    <div>
     <p>The local variables are stored on a stack, but instance variables are stored on the heap, so there are some chances that a previous value on the stack will be read instead of a default value as happens in the heap.</p>
     <p>For that reason the JVM doesn't allow to use a local variable without initializing it.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span>Flat out wrong...all Java non-primitives are stored in the heap regardless of when and how they are constructed</span> <span> - </span> <span class="display-name">gshauger</span> <span> </span> <span class="date">25 Mar 2010 at 15:54</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Before Java 7, instance variables are stored on the heap and local variables are found on the stack. However, any object that a local variable references will be found in the heap. As of Java 7, the "Java Hotspot Server Compiler" might perform "escape analysis" and decide to allocate some objects on the stack instead of the heap.</span> <span> - </span> <span class="display-name">mamills</span> <span> </span> <span class="date">11 Apr 2013 at 16:57</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>htlbydgod</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Aug 2017 at 05:45</span>
     </div>
    </div>
    <div>
     <p>Instance variable will have default values but the local variables could not have default values. Since local variables basically are in methods/behavior, its main aim is to do some operations or calculations. Therefore, it is not a good idea to set default values for local variables. Otherwise, it is very hard and time-consuming to check the reasons of unexpected answers.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span> <span class="arrow"> <a href="#answer_15">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ankit Mittal</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 May 2021 at 17:07</span>
     </div>
    </div>
    <div>
     <p>Memory stack for methods is created at execution time. The method stack order is decided at execution time.</p>
     <p>There might be a function that may not be called at all. So to instantiate local variables at the time of object instantiation would be a complete wastage of memory. Also, Object variables remain in memory for a complete object lifecycle of a class whereas, local variables and their values become eligible for garbage collection the moment they are popped from the memory stack.</p>
     <p>So, To give memory to the variables of methods that might not even be called or even if called, will not remain inside memory for the lifecycle of an object, would be a completely illogical and memory-waste-worthy</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>who was saying, initialization of local variables would be wished for at object-creation-time? If one had decided to give them a default value, one would certainly do so only at the time of method call.</span> <span> - </span> <span class="display-name">Sebastian</span> <span> </span> <span class="date">16 Aug 2022 at 12:03</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_15"><span>Answer 15</span> <span class="arrow"> <a href="#answer_14">↑</a> </span> <span class="arrow"> <a href="#answer_16">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Akash5288</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Mar 2013 at 10:53</span>
     </div>
    </div>
    <div>
     <p>The answer is instance variables can be initialized in the class constructor or any class method. But in case of local variables, once you defined whatever in the method, that remains forever in the class.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_16"><span>Answer 16</span> <span class="arrow"> <a href="#answer_15">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mitra</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Dec 2014 at 21:20</span>
     </div>
    </div>
    <div>
     <p>I could think of the following two reasons</p>
     <ol>
      <li>As most of the answers said, by putting the constraint of initialising the local variable, it is ensured that the local variable gets assigned a value as the programmer wants and ensures the expected results are computed.</li>
      <li>Instance variables can be hidden by declaring local variables (same name) - to ensure the expected behaviour, local variables are forced to be initialised to a value (I would totally avoid this, though).</li>
     </ol>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Fields can not be overridden. At most, they can be hidden, and I fail to see how hiding would interfere with a check for initialization?</span> <span> - </span> <span class="display-name">meriton</span> <span> </span> <span class="date">30 Dec 2014 at 22:17</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Right hidden.If one decides to create local variable with same name as instance, because of this constraint, local variable will be initialised with puposely selected value (other than the value of instance variable)</span> <span> - </span> <span class="display-name">Mitra</span> <span> </span> <span class="date">31 Dec 2014 at 11:19</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>