<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>Regular expression to match a line that doesn't contain a word</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>Regular expression to match a line that doesn't contain a word</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>5243</span>
    </div>
    <div>
     <span>Asker: </span> <span>knaser</span>
    </div>
    <div>
     <span>Asked: </span> <span>2 Jan 2009 at 07:30</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/406230">source</a>
    </div>
   </div>
   <div>
    <p>I know it's possible to match a word and then reverse the matches using other tools (e.g. <code>grep -v</code>). However, is it possible to match lines that do not contain a specific word, e.g. <code>hede</code>, using a regular expression?</p>
    <h5>Input:</h5>
    <pre><code>hoho
hihi
haha
hede
</code></pre>
    <h5>Code:</h5>
    <pre><code>grep "&lt;Regex for 'doesn't contain hede'&gt;" input
</code></pre>
    <h5>Desired output:</h5>
    <pre><code>hoho
hihi
haha
</code></pre>
   </div>
   <div class="tags">
    <span class="tag">regex</span><span class="tag">pattern-matching</span><span class="tag">regex-negation</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>101</td>
       <td><span>Probably a couple years late, but what's wrong with: <code>([^h]*(h([^e]|$)|he([^d]|$)|hed([^e]|$)))*</code>? The idea is simple. Keep matching until you see the start of the unwanted string, then only match in the N-1 cases where the string is unfinished (where N is the length of the string). These N-1 cases are "h followed by non-e", "he followed by non-d", and "hed followed by non-e". If you managed to pass these N-1 cases, you successfully <i>didn't</i> match the unwanted string so you can start looking for <code>[^h]*</code> again</span> <span> - </span> <span class="display-name">stevendesu</span> <span> </span> <span class="date">29 Sep 2011 at 03:44</span></td>
      </tr>
      <tr>
       <td>421</td>
       <td><span>@stevendesu: try this for 'a-very-very-long-word' or even better half a sentence. Have fun typing. BTW, it is nearly unreadable. Don't know about the performance impact.</span> <span> - </span> <span class="display-name">Peter Schuetze</span> <span> </span> <span class="date">30 Jan 2012 at 18:45</span></td>
      </tr>
      <tr>
       <td>14</td>
       <td><span>@PeterSchuetze: Sure it's not pretty for very very long words, but it is a viable and correct solution. Although I haven't run tests on the performance, I wouldn't imagine it being too slow since most of the latter rules are ignored until you see an h (or the first letter of the word, sentence, etc.). And you could easily generate the regex string for long strings using iterative concatenation. If it works and can be generated quickly, is legibility important? That's what comments are for.</span> <span> - </span> <span class="display-name">stevendesu</span> <span> </span> <span class="date">2 Feb 2012 at 03:14</span></td>
      </tr>
      <tr>
       <td>66</td>
       <td><span>@stevendesu: i'm even later, but that answer is almost completely wrong. for one thing, it requires the subject to contain "h" which it shouldn't have to, given the task is "match lines which [do] not contain a specific word". let us assume you meant to make the inner group optional, and that the pattern is anchored: <code>^([^h]*(h([^e]|$)|he([^d]|$)|hed([^e]|$))?)*$</code> this fails when instances of "hede" are preceded by partial instances of "hede" such as in "hhede".</span> <span> - </span> <span class="display-name">jaytea</span> <span> </span> <span class="date">10 Sep 2012 at 10:41</span></td>
      </tr>
      <tr>
       <td>19</td>
       <td><span>This question has been added to the <a href="http://stackoverflow.com/a/22944075/2736496">Stack Overflow Regular Expression FAQ</a>, under "Advanced Regex-Fu".</span> <span> - </span> <span class="display-name">aliteralmind</span> <span> </span> <span class="date">10 Apr 2014 at 01:30</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Related: <a href="http://stackoverflow.com/q/466053/4279">Regex: Matching by exclusion, without look-ahead - is it possible?</a></span> <span> - </span> <span class="display-name">jfs</span> <span> </span> <span class="date">7 Dec 2016 at 16:53</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7236</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Bart Kiers</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Jan 2009 at 09:55</span>
     </div>
    </div>
    <div>
     <p>The notion that regex doesn't support inverse matching is not entirely true. You can mimic this behavior by using negative look-arounds:</p>
     <pre><code>^((?!hede).)*$
</code></pre>
     <p>The regex above will match any string, or line without a line break, <strong>not</strong> containing the (sub)string 'hede'. As mentioned, this is not something regex is "good" at (or should do), but still, it <em>is</em> possible.</p>
     <p>And if you need to match line break chars as well, use the <a href="http://perldoc.perl.org/perlre.html#Modifiers" rel="noreferrer">DOT-ALL modifier</a> (the trailing <code>s</code> in the following pattern):</p>
     <pre><code>/^((?!hede).)*$/s
</code></pre>
     <p>or use it inline:</p>
     <pre><code>/(?s)^((?!hede).)*$/
</code></pre>
     <p><em>(where the <code>/.../</code> are the regex delimiters, i.e., not part of the pattern)</em></p>
     <p>If the DOT-ALL modifier is not available, you can mimic the same behavior with the character class <code>[\s\S]</code>:</p>
     <pre><code>/^((?!hede)[\s\S])*$/
</code></pre>
     <h2>Explanation</h2>
     <p>A string is just a list of <code>n</code> characters. Before, and after each character, there's an empty string. So a list of <code>n</code> characters will have <code>n+1</code> empty strings. Consider the string <code>"ABhedeCD"</code>:</p>
     <pre><code>    ┌──┬───┬──┬───┬──┬───┬──┬───┬──┬───┬──┬───┬──┬───┬──┬───┬──┐
S = │e1│ A │e2│ B │e3│ h │e4│ e │e5│ d │e6│ e │e7│ C │e8│ D │e9│
    └──┴───┴──┴───┴──┴───┴──┴───┴──┴───┴──┴───┴──┴───┴──┴───┴──┘
    
index    0      1      2      3      4      5      6      7
</code></pre>
     <p>where the <code>e</code>'s are the empty strings. The regex <code>(?!hede).</code> looks ahead to see if there's no substring <code>"hede"</code> to be seen, and if that is the case (so something else is seen), then the <code>.</code> (dot) will match any character except a line break. Look-arounds are also called <em>zero-width-assertions</em> because they don't <em>consume</em> any characters. They only assert/validate something.</p>
     <p>So, in my example, every empty string is first validated to see if there's no <code>"hede"</code> up ahead, before a character is consumed by the <code>.</code> (dot). The regex <code>(?!hede).</code> will do that only once, so it is wrapped in a group, and repeated zero or more times: <code>((?!hede).)*</code>. Finally, the start- and end-of-input are anchored to make sure the entire input is consumed: <code>^((?!hede).)*$</code></p>
     <p>As you can see, the input <code>"ABhedeCD"</code> will fail because on <code>e3</code>, the regex <code>(?!hede)</code> fails (there <em>is</em> <code>"hede"</code> up ahead!).</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>41</td>
        <td><span>I would not go so far as to say that this is something regex is bad at. The convenience of this solution is pretty obvious and the performance hit compared to a programmatic search is often going to be unimportant.</span> <span> - </span> <span class="display-name">Archimaredes</span> <span> </span> <span class="date">3 Mar 2016 at 16:09</span></td>
       </tr>
       <tr>
        <td>53</td>
        <td><span>Strictly speaking negative loook-ahead makes you regular expression not-regular.</span> <span> - </span> <span class="display-name">Peter K</span> <span> </span> <span class="date">18 Nov 2016 at 15:03</span></td>
       </tr>
       <tr>
        <td>96</td>
        <td><span>@PeterK, sure, but this is SO, not MathOverflow or CS-Stackexchange. People asking a question here are generally looking for a practical answer. Most libraries or tools (like <code>grep</code>, which the OP mentions) with regex-support all have features that mke them non-regular in a theoretical sense.</span> <span> - </span> <span class="display-name">Bart Kiers</span> <span> </span> <span class="date">18 Nov 2016 at 15:08</span></td>
       </tr>
       <tr>
        <td>25</td>
        <td><span>@Bart Kiers, no offense to you answer, just this abuse of terminology irritates me a bit. The really confusing part here is that regular expressions in the strict sense can very much do what OP wants, but the common language to write them does not allow it, which leads to (mathematically ugly) workarounds like look-aheads. Please see <a href="http://stackoverflow.com/questions/406230/regular-expression-to-match-line-that-doesnt-contain-a-word/31825535#31825535">this answer</a> below and my comment there for (theoretically aligned) proper way of doing it. Needless to say it works faster on large inputs.</span> <span> - </span> <span class="display-name">Peter K</span> <span> </span> <span class="date">18 Nov 2016 at 15:33</span></td>
       </tr>
       <tr>
        <td>23</td>
        <td><span>In case you ever wondered how to do this in vim: <code>^\(\(hede\)\@!.\)*$</code></span> <span> - </span> <span class="display-name">baldrs</span> <span> </span> <span class="date">24 Nov 2016 at 11:58</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span><a href="https://stackoverflow.com/a/1687663/4561047">This answer</a> worked better for me. Can you explain the difference between <code>^((?!hede).)*$</code> and <code>^(?!hede).*$</code>?</span> <span> - </span> <span class="display-name">intcreator</span> <span> </span> <span class="date">8 Jun 2017 at 23:11</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@Z.Khullah You're missing the <code>m</code> flag. Adding it in your regex didn't do the trick, but creating a new test with <code>m</code> did work on Regexr: <a href="https://regexr.com/3hj1b" rel="nofollow noreferrer">regexr.com/3hj1b</a> In short: it's a bug in Regexr.</span> <span> - </span> <span class="display-name">Bart Kiers</span> <span> </span> <span class="date">5 Dec 2017 at 20:34</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Lookbacks/lookarounds are only supported in <code>pcre</code> <a href="https://superuser.com/a/596499/658319">superuser.com/a/596499/658319</a>. Perhaps a disclaimer should be added.</span> <span> - </span> <span class="display-name">alpha_989</span> <span> </span> <span class="date">26 Mar 2018 at 17:32</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@alpha_989 true, but I don't think a disclaimer is needed. This is SO, not Math Overflow or CS-SE, and nearly all popular programming languages with regex-support are PCRE (is close to it).</span> <span> - </span> <span class="display-name">Bart Kiers</span> <span> </span> <span class="date">26 Mar 2018 at 18:04</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>same with word boundaries: <code>^((?!\bhede\b).)*$</code></span> <span> - </span> <span class="display-name">SL5net</span> <span> </span> <span class="date">11 Jan 2019 at 20:19</span></td>
       </tr>
       <tr>
        <td>12</td>
        <td><span>Why are so many answers saying <code>^((?!hede).)*$</code> ? Is it not more efficient to use <code>^(?!.*hede).*$</code> ? It does the same thing but in fewer steps.</span> <span> - </span> <span class="display-name">JackPRead</span> <span> </span> <span class="date">15 Jan 2019 at 10:52</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>A little extension, I know it was not in the question but might be useful. What if you want to filter more than one words, the same time match for these words separately, and remove spaces and line breaks in addition. I tested it in Python: <code>import re; exp = re.compile(r'(?!\s)(?:AND|OR|NOT|\(|\)|(?:(?!OR|AND|NOT|\s{2‌​:})(?:[-\w: ]))+)(?&lt;!\s)'); exp.findall('foobar AND (foo loves bar OR NOT bla bla)')</code> results: <code>['foobar', 'AND', '(', 'foo loves bar', 'OR', 'NOT', 'bla bla', ')']</code></span> <span> - </span> <span class="display-name">deeenes</span> <span> </span> <span class="date">22 Jan 2019 at 16:08</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>What about if we want to include <code>\n</code> aka line break too in the match?</span> <span> - </span> <span class="display-name">curiouscheese</span> <span> </span> <span class="date">6 Jun 2022 at 07:30</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This throws <code>-bash: !ERROR: event not found</code>? If you do not want the <code>-v</code> parameter, the negative lookahead in grep can be done, see <a href="https://stackoverflow.com/a/41005190/11154841">this answer below</a>.</span> <span> - </span> <span class="display-name">questionto42</span> <span> </span> <span class="date">25 Oct 2022 at 16:48</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Can you elaborate on why RegEx "should not" do negative searches in this manner? <code>^((?!hede).)*$</code> or @JackPRead <code>^(?!.*hede).*$</code> looks pretty elegant to a layperson looking to narrow down lines that DONT contain something. OP never elaborated on why RegEx is inappropriate for this. Ordinary find search tools cannot not do this.</span> <span> - </span> <span class="display-name">Jon Grah</span> <span> </span> <span class="date">12 Nov 2022 at 08:46</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@JonGrah my solution, <code>^((?!hede).)*</code> (which is different than <code>(?!.*hede).*</code>), works like this: from every position in the string, look ahead to the end of the string to see if "hede" can be seen. So, if your string is 10 chars long, and does not contain "hede", it will look ahead <code>11 + 10 + 9 + ... + 2 + 1</code> times (which equals 66). And if your string is of size <code>N</code> (and <code>N</code> is very large), it will perform <code>(N * (N + 1)) / 2</code> lookahead steps. Hence my remark "should not" do it.</span> <span> - </span> <span class="display-name">Bart Kiers</span> <span> </span> <span class="date">12 Nov 2022 at 10:59</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@JackPRead <code>^(?!.*?hede).*</code> is a lot more efficient in many implementations, for example in JS when applied to very big string inputs is runs quite fast, while the other solution (lookahead at each position) will just break with "maximum call stack exceeded".</span> <span> - </span> <span class="display-name">Falco</span> <span> </span> <span class="date">18 Nov 2022 at 13:14</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@BartKiers I think it could be useful for many readers to include the alternative <code>^(?!.*?hede).*</code> which will in fact just perform an optimized fast forward search for the keyword, without any backtracking and then match the whole line. which should be just as fast as any manually programmed solution.</span> <span> - </span> <span class="display-name">Falco</span> <span> </span> <span class="date">18 Nov 2022 at 13:17</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Shouldn't this be <code>^(.(?!hede))*$</code>? @Falco, I doubt a simple fixed length negative lookahead will cause troubles to any regex engine. But these negative lookups are rarely supported. Even some engines reject non-fixed sized negative lookbehinds.</span> <span> - </span> <span class="display-name">akostadinov</span> <span> </span> <span class="date">21 Mar 2023 at 19:39</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@akostadinov Just tried your Regex with a 9M character long string in the Browser Console: "Error: maximum call stack size exceeded" - while my alternative succeeds in milliseconds - a single complex variable length look-ahead is currently in e.g. JS Regex-Engine better optimized than 9 Million lookaheads with backtracking</span> <span> - </span> <span class="display-name">Falco</span> <span> </span> <span class="date">23 Mar 2023 at 09:36</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Something like <code>^(?!.*hede).*$</code> and <code>^((?!hede).)*$</code> do completely different things. If <code>^(?!.*hede).*$</code> works for your use case, then that will indeed be much faster (and thus the way to go).</span> <span> - </span> <span class="display-name">Bart Kiers</span> <span> </span> <span class="date">23 Mar 2023 at 09:59</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Falco, which browser and what expression are you running? I tried in Ruby with a 9M chars string and I see no noticeable difference between these regular expressions. I see no reason to backtrack because after a dot is matched, I see no reason for backtracking to it. I payed more at your regular expression though and I like it more. In case regex engine supports variable length look-ahead, it's neat.</span> <span> - </span> <span class="display-name">akostadinov</span> <span> </span> <span class="date">23 Mar 2023 at 20:18</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>And actually my suggested regexp is invalid and will miss <code>hede</code>. Because dot is in front. regexp are just a necessary evil.</span> <span> - </span> <span class="display-name">akostadinov</span> <span> </span> <span class="date">23 Mar 2023 at 20:22</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@BartKiers can you provide an example where both regexes are different? They seem to match exactly the same set on first intuition?</span> <span> - </span> <span class="display-name">Falco</span> <span> </span> <span class="date">26 Mar 2023 at 10:02</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@akostadinov Just run this in the Chrome DevTools Console: <code>/^((?!hede).)*$/.exec('Lorem Ipsum'.repeat(1000000))</code> - gives Callstack exceeded error</span> <span> - </span> <span class="display-name">Falco</span> <span> </span> <span class="date">28 Mar 2023 at 07:52</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Falco, Firefox also throws <code>Uncaught InternalError: too much recursion</code>.</span> <span> - </span> <span class="display-name">akostadinov</span> <span> </span> <span class="date">28 Mar 2023 at 14:11</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@akostadinov and this doesn't happen with <code>^(?!.*?hede).*$</code> the engine will try to find the word once, starting at the beginning of the string and immediately fail the whole regex if it is found. If not the regex immediately matches the whole string (most Engines have a shortcut for <code>.*</code>) Running it on the same 9M char string in the Browser returns in miliseconds: <code>/^(?!.*?hede).*$/.exec('Lorem Ipsum'.repeat(1000000))</code></span> <span> - </span> <span class="display-name">Falco</span> <span> </span> <span class="date">28 Mar 2023 at 17:40</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>936</span>
     </div>
     <div>
      <span>Answerer: </span> <span>JoshuaDavid</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Mar 2011 at 04:21</span>
     </div>
    </div>
    <div>
     <p>Note that the solution to <strong>does not <em>start with</em> “hede”</strong>:</p>
     <pre><code>^(?!hede).*$
</code></pre>
     <p>is generally much more efficient than the solution to <strong>does not <em>contain</em> “hede”</strong>:</p>
     <pre><code>^((?!hede).)*$
</code></pre>
     <p>The former checks for “hede” only at the input string’s first position, rather than at every position.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span><code>^((?!hede).)*$</code> worked for me using the jQuery DataTable plugin to exclude a string from the dataset</span> <span> - </span> <span class="display-name">Alex</span> <span> </span> <span class="date">26 Jun 2015 at 10:34</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>Hello! I can't compose <b>does not <i>end</i> with "hede"</b> regex. Can you help with it?</span> <span> - </span> <span class="display-name">Aleks Ya</span> <span> </span> <span class="date">18 Oct 2015 at 21:33</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@AleksYa: just use the "contain" version, and include the end anchor into the search string: change the string to "not match" from "hede" to "hede$"</span> <span> - </span> <span class="display-name">Nyerguds</span> <span> </span> <span class="date">4 May 2016 at 10:42</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>To match lines that <b>does not <i>end</i> with "hede"</b>, one way is to use <code>^.*(?!hede).{4}</code>. The number in braces should match the length of non-matching text you want (e.g. "hede" is length 4).</span> <span> - </span> <span class="display-name">doubleDown</span> <span> </span> <span class="date">6 Feb 2017 at 06:09</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span>@AleksYa: the does not end version could be done using negative lookbehind as: <code>(.*)(?&lt;!hede)$</code>. @Nyerguds' version would work as well but completely misses the point on performance the answer mentions.</span> <span> - </span> <span class="display-name">thisismydesign</span> <span> </span> <span class="date">14 Sep 2017 at 16:53</span></td>
       </tr>
       <tr>
        <td>11</td>
        <td><span>Why are so many answers saying <code>^((?!hede).)*$</code> ? Is it not more efficient to use <code>^(?!.*hede).*$</code> ? It does the same thing but in fewer steps</span> <span> - </span> <span class="display-name">JackPRead</span> <span> </span> <span class="date">15 Jan 2019 at 10:53</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>244</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Athena</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Jan 2009 at 07:41</span>
     </div>
    </div>
    <div>
     <p><em>If</em> you're just using it for grep, you can use <code>grep -v hede</code> to get all lines which do not contain hede.</p>
     <p>ETA Oh, rereading the question, <code>grep -v</code> is probably what you meant by "tools options".</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>31</td>
        <td><span>Tip: for progressively filtering out what you don't want: grep -v "hede" | grep -v "hihi" | ...etc.</span> <span> - </span> <span class="display-name">Olivier Lalonde</span> <span> </span> <span class="date">5 May 2014 at 22:08</span></td>
       </tr>
       <tr>
        <td>61</td>
        <td><span>Or using only one process <code>grep -v -e hede -e hihi -e ...</code></span> <span> - </span> <span class="display-name">Olaf Dietsche</span> <span> </span> <span class="date">26 Apr 2015 at 05:42</span></td>
       </tr>
       <tr>
        <td>23</td>
        <td><span>Or just <code>grep -v "hede\|hihi"</code> :)</span> <span> - </span> <span class="display-name">Putnik</span> <span> </span> <span class="date">9 Dec 2016 at 15:29</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span>If you have many patterns that you want to filter out, put them in a file and use <code>grep -vf pattern_file file</code></span> <span> - </span> <span class="display-name">codeforester</span> <span> </span> <span class="date">11 Mar 2018 at 18:35</span></td>
       </tr>
       <tr>
        <td>14</td>
        <td><span>Or simply <code>egrep</code> or <code>grep -Ev "hede|hihi|etc"</code> to avoid the awkward escaping.</span> <span> - </span> <span class="display-name">Amit Naidu</span> <span> </span> <span class="date">3 Jun 2018 at 10:54</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>The <code>egrep</code> one: <code>egrep -v "hede|hihi|etc"</code></span> <span> - </span> <span class="display-name">Roald</span> <span> </span> <span class="date">21 Aug 2020 at 08:07</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>237</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Jessica</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 May 2014 at 16:36</span>
     </div>
    </div>
    <div>
     <p><strong>Answer:</strong></p>
     <pre><code>^((?!hede).)*$
</code></pre>
     <p><strong>Explanation:</strong></p>
     <p><code>^</code>the beginning of the string, <code>(</code> group and capture to \1 (0 or more times (matching the most amount possible)),<br><code>(?!</code> look ahead to see if there is not,</p>
     <p><code>hede</code> your string,</p>
     <p><code>)</code> end of look-ahead, <code>.</code> any character except \n,<br><code>)*</code> end of \1 (Note: because you are using a quantifier on this capture, only the LAST repetition of the captured pattern will be stored in \1)<br><code>$</code> before an optional \n, and the end of the string</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>21</td>
        <td><span>awesome that worked for me in sublime text 2 using multiple words '<code>^((?!DSAU_PW8882WEB2|DSAU_PW8884WEB2|DSAU_PW8884WEB).)*$</code>'</span> <span> - </span> <span class="display-name">Damodar Bashyal</span> <span> </span> <span class="date">11 Aug 2015 at 02:07</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>115</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Hades32</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Sep 2011 at 15:53</span>
     </div>
    </div>
    <div>
     <p>The given answers are perfectly fine, just an academic point:</p>
     <p>Regular Expressions in the meaning of theoretical computer sciences <em>ARE NOT ABLE</em> do it like this. For them it had to look something like this:</p>
     <pre><code>^([^h].*$)|(h([^e].*$|$))|(he([^h].*$|$))|(heh([^e].*$|$))|(hehe.+$) 
</code></pre>
     <p>This only does a FULL match. Doing it for sub-matches would even be more awkward.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>Important to note this only uses basic POSIX.2 regular expressions and thus whilst terse is more portable for when PCRE is not available.</span> <span> - </span> <span class="display-name">Steve-o</span> <span> </span> <span class="date">19 Feb 2014 at 17:25</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span>I agree. Many if not most regular expressions are not regular languages and could not be recognized by a finite automata.</span> <span> - </span> <span class="display-name">ThomasMcLeod</span> <span> </span> <span class="date">22 Mar 2014 at 21:36</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@ThomasMcLeod, Hades32: Is it within the realms of any possible regular language to be able to say ‘<b>not</b>’ and ‘<b>and</b>’ as well as the ‘<b>or</b>’ of an expression such as ‘<code>(hede|Hihi)</code>’? <i>(This maybe a question for CS.)</i></span> <span> - </span> <span class="display-name">James Haigh</span> <span> </span> <span class="date">13 Jun 2014 at 16:54</span></td>
       </tr>
       <tr>
        <td>8</td>
        <td><span>@JohnAllen: <b>ME!!!</b> …Well, not the actual regex but the academic reference, which also relates closely to computational complexity; PCREs fundamentally can not guarantee the same efficiency as POSIX regular expressions.</span> <span> - </span> <span class="display-name">James Haigh</span> <span> </span> <span class="date">13 Jun 2014 at 17:04</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@JamesHaigh, not &lt;string&gt; is definitely regular but does and make sense? Ask a new question and notify me in a comment and I'll try to answer it.</span> <span> - </span> <span class="display-name">ThomasMcLeod</span> <span> </span> <span class="date">13 Jun 2014 at 19:50</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>Sorry -this answer just doesn't work, it will match hhehe and even match hehe partially (the second half)</span> <span> - </span> <span class="display-name">Falco</span> <span> </span> <span class="date">13 Aug 2014 at 12:57</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This can be syntactically simplified to <code>^([^h].*|h([^e].*)?|he([^h].*)?|heh([^e].*)?|hehe.+)$</code> or <code>^(([^h]|h[^e]|he[^h]|heh[^e]|hehe.).*|h|he|heh)$</code>.</span> <span> - </span> <span class="display-name">Bernhard Barker</span> <span> </span> <span class="date">13 Jul 2015 at 18:59</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>See my answer for how to do it for submatches too. As for inverting a RE, the inverse always exists without needing extra operators. Grail has a tool to find it, the one I used in my answer.</span> <span> - </span> <span class="display-name">Pedro Gimeno</span> <span> </span> <span class="date">29 Jan 2018 at 21:59</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>77</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Roy Tinker</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Jan 2013 at 21:22</span>
     </div>
    </div>
    <div>
     <p>If you want the regex test to <strong>only</strong> fail if the <em>entire string</em> matches, the following will work:</p>
     <pre><code>^(?!hede$).*
</code></pre>
     <p>e.g. -- If you want to allow all values except "foo" (i.e. "foofoo", "barfoo", and "foobar" will pass, but "foo" will fail), use: <code>^(?!foo$).*</code></p>
     <p>Of course, if you're checking for <em>exact</em> equality, a better general solution in this case is to check for string equality, i.e.</p>
     <pre><code>myStr !== 'foo'
</code></pre>
     <p>You could even put the negation <em>outside</em> the test if you need any regex features (here, case insensitivity and range matching):</p>
     <pre><code>!/^[a-f]oo$/i.test(myStr)
</code></pre>
     <p>The regex solution at the top of this answer may be helpful, however, in situations where a positive regex test is required (perhaps by an API).</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>what about trailing whitespaces? Eg, if I want test to fail with string <code>" hede "</code>?</span> <span> - </span> <span class="display-name">eagor</span> <span> </span> <span class="date">12 May 2017 at 09:45</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@eagor the <code>\s</code> directive matches a single whitespace character</span> <span> - </span> <span class="display-name">Roy Tinker</span> <span> </span> <span class="date">12 May 2017 at 21:07</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>thanks, but I didn't manage to update the regex to make this work.</span> <span> - </span> <span class="display-name">eagor</span> <span> </span> <span class="date">13 May 2017 at 19:22</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@eagor: <code>^(?!\s*hede\s*$).*</code></span> <span> - </span> <span class="display-name">Roy Tinker</span> <span> </span> <span class="date">15 May 2017 at 17:33</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>68</span>
     </div>
     <div>
      <span>Answerer: </span> <span>akim</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Aug 2015 at 07:02</span>
     </div>
    </div>
    <div>
     <p>FWIW, since regular languages (aka rational languages) are closed under complementation, it's always possible to find a regular expression (aka rational expression) that negates another expression. But not many tools implement this.</p>
     <p><a href="http://vcsn.lrde.epita.fr" rel="noreferrer" title="Vcsn home page">Vcsn</a> supports this operator (which it denotes <code>{c}</code>, postfix).</p>
     <p>You first define the type of your expressions: labels are letter (<code>lal_char</code>) to pick from <code>a</code> to <code>z</code> for instance (defining the alphabet when working with complementation is, of course, very important), and the "value" computed for each word is just a Boolean: <code>true</code> the word is accepted, <code>false</code>, rejected.</p>
     <p>In Python:</p>
     <pre><code>In [5]: import vcsn
        c = vcsn.context('lal_char(a-z), b')
        c
Out[5]: {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z} → 𝔹
</code></pre>
     <p>then you enter your expression:</p>
     <pre><code>In [6]: e = c.expression('(hede){c}'); e
Out[6]: (hede)^c
</code></pre>
     <p>convert this expression to an automaton:</p>
     <pre><code>In [7]: a = e.automaton(); a
</code></pre>
     <p><a href="https://i.stack.imgur.com/C3P8C.png" rel="noreferrer"><img src="https://i.stack.imgur.com/C3P8C.png" alt="The corresponding automaton"></a></p>
     <p>finally, convert this automaton back to a simple expression.</p>
     <pre><code>In [8]: print(a.expression())
        \e+h(\e+e(\e+d))+([^h]+h([^e]+e([^d]+d([^e]+e[^]))))[^]*
</code></pre>
     <p>where <code>+</code> is usually denoted <code>|</code>, <code>\e</code> denotes the empty word, and <code>[^]</code> is usually written <code>.</code> (any character). So, with a bit of rewriting <code>()|h(ed?)?|([^h]|h([^e]|e([^d]|d([^e]|e.)))).*</code>.</p>
     <p>You can see this example <a href="https://stackoverflow.com/questions/406230" title="Regular expression to match text that doesn't contain a word?">here</a>, and try Vcsn online <a href="http://vcsn-sandbox.lrde.epita.fr/tree" rel="noreferrer" title="Vcsn Sandbox">there</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>9</td>
        <td><span>True, but ugly, and only doable for small character sets. You don't want to do this with Unicode strings :-)</span> <span> - </span> <span class="display-name">reinierpost</span> <span> </span> <span class="date">8 Nov 2015 at 23:43</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The regexp <code>()|h(ed?)?|([^h]|h([^e]|e([^d]|d([^e]|e.)))).*</code> didn't work for me using <code>egrep</code>. It matches <code>hede</code>. I also tried anchoring it to the beginning and end, and it still didn't work.</span> <span> - </span> <span class="display-name">Pedro Gimeno</span> <span> </span> <span class="date">6 Dec 2016 at 23:18</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@PedroGimeno When you anchored, you made sure to put this regex in parens first? Otherwise the precedences between anchors and <code>|</code> won't play nicely. <code>'^(()|h(ed?)?|([^h]|h([^e]|e([^d]|d([^e]|e.)))).*)$'</code>.</span> <span> - </span> <span class="display-name">akim</span> <span> </span> <span class="date">8 Dec 2016 at 09:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@akim That seemed to be the problem, thanks and sorry (see my answer for a full substring match). And forgot to say, the graph doesn't have [^d] anywhere. I suspect that's a mistake.</span> <span> - </span> <span class="display-name">Pedro Gimeno</span> <span> </span> <span class="date">9 Dec 2016 at 15:45</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@PedroGimeno Thanks for pointing this out. When I first answered I read incorrectly and thought that <code>hehe</code> was to reject. I fixed the text, but forgot to fix the snapshot.</span> <span> - </span> <span class="display-name">akim</span> <span> </span> <span class="date">11 Dec 2016 at 07:02</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>I think it's worth remarking that this method is for matching lines that <i>are not</i> the word 'hede', rather than lines than <i>don't contain</i> the word 'hede' which is what the OP asked for. See my answer for the latter.</span> <span> - </span> <span class="display-name">Pedro Gimeno</span> <span> </span> <span class="date">29 Jan 2019 at 00:05</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>67</span>
     </div>
     <div>
      <span>Answerer: </span> <span>amobiz</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Jul 2014 at 18:21</span>
     </div>
    </div>
    <div>
     <p>With negative lookahead, regular expression can match something not contains specific pattern. This is answered and explained by Bart Kiers. Great explanation!</p>
     <p>However, with Bart Kiers' answer, the lookahead part will test 1 to 4 characters ahead while matching any single character. We can avoid this and let the lookahead part check out the whole text, ensure there is no 'hede', and then the normal part (.*) can eat the whole text all at one time.</p>
     <p>Here is the improved regex:</p>
     <pre><code>/^(?!.*?hede).*$/
</code></pre>
     <p>Note the (*?) lazy quantifier in the negative lookahead part is optional, you can use (*) greedy quantifier instead, depending on your data: if 'hede' does present and in the beginning half of the text, the lazy quantifier can be faster; otherwise, the greedy quantifier be faster. However if 'hede' does not present, both would be equal slow.</p>
     <p>Here is the <a href="http://jsfiddle.net/pvJL5/3/">demo code</a>.</p>
     <p>For more information about lookahead, please check out the great article: <a href="http://www.rexegg.com/regex-lookarounds.html">Mastering Lookahead and Lookbehind</a>.</p>
     <p>Also, please check out <a href="https://github.com/amobiz/regexgen.js">RegexGen.js</a>, a JavaScript Regular Expression Generator that helps to construct complex regular expressions. With RegexGen.js, you can construct the regex in a more readable way:</p>
     <pre><code>var _ = regexGen;

var regex = _(
    _.startOfLine(),             
    _.anything().notContains(       // match anything that not contains:
        _.anything().lazy(), 'hede' //   zero or more chars that followed by 'hede',
                                    //   i.e., anything contains 'hede'
    ), 
    _.endOfLine()
);
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>so to simply check if given string does not contain str1 and str2: <code>^(?!.*(str1|str2)).*$</code></span> <span> - </span> <span class="display-name">S.Serpooshan</span> <span> </span> <span class="date">1 Mar 2017 at 07:20</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>Yes, or you can use lazy quantifier: <code>^(?!.*?(?:str1|str2)).*$</code>, depending on your data. Added the <code>?:</code> since we don't need to capture it.</span> <span> - </span> <span class="display-name">amobiz</span> <span> </span> <span class="date">2 Mar 2017 at 09:59</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>This is by far the best answer by a factor of 10xms. If you added your jsfiddle code and results onto the answer people might notice it. I wonder why the lazy version is faster than the greedy version when there is no hede. Shouldn't they take the same amount of time?</span> <span> - </span> <span class="display-name">user5389726598465</span> <span> </span> <span class="date">23 Jul 2017 at 09:06</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Yes, they take the same amount of time since they both tests the whole text.</span> <span> - </span> <span class="display-name">amobiz</span> <span> </span> <span class="date">3 Aug 2017 at 03:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@user5389726598465 the lazy version is most likely faster because of the underlying implementation and optimizations in the engine. computers are usually good at accessing data linearly from start to finish, caching and branch prediction may be optimized for this sort of access.</span> <span> - </span> <span class="display-name">Falco</span> <span> </span> <span class="date">18 Nov 2022 at 13:21</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>66</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Josh Lee</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Jan 2009 at 08:03</span>
     </div>
    </div>
    <div>
     <p>Here's <a href="http://www.perlmonks.org/?node_id=588315#588368" rel="noreferrer">a good explanation</a> of why it's not easy to negate an arbitrary regex. I have to agree with the other answers, though: if this is anything other than a hypothetical question, then a regex is not the right choice here.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>12</td>
        <td><span>Some tools, and specifically mysqldumpslow, only offer this way to filter data, so in such a case, finding a regex to do this is the best solution apart from rewriting the tool (various patches for this have not been included by MySQL AB / Sun / Oracle.</span> <span> - </span> <span class="display-name">FGM</span> <span> </span> <span class="date">7 Aug 2012 at 12:21</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Exactly analagous to my situation. Velocity template engine uses regular expressions to decide when to apply a transformation (escape html) and I want it to always work EXCEPT in one situation.</span> <span> - </span> <span class="display-name">Henno Vermeulen</span> <span> </span> <span class="date">18 Oct 2013 at 14:43</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>What alternative is there? Ive never encountered anything that could do precise string matching besides regex. If OP is using a programming language, there may be other tools available, but if he/she is using not writing code, there probably isnt any other choice.</span> <span> - </span> <span class="display-name">kingfrito_5005</span> <span> </span> <span class="date">20 Oct 2016 at 18:32</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>One of many non-hypothetical scenarios where a regex is the best available choice: I'm in an IDE (Android Studio) that shows log output, and the only filtering tools provided are: plain strings, and regex. Trying to do this with plain strings would be a complete fail.</span> <span> - </span> <span class="display-name">LarsH</span> <span> </span> <span class="date">5 Dec 2016 at 16:11</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>53</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Falco</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 Aug 2014 at 14:58</span>
     </div>
    </div>
    <div>
     <h1>Benchmarks</h1>
     <p>I decided to evaluate some of the presented Options and compare their performance, as well as use some new Features. Benchmarking on .NET Regex Engine: <a href="http://regexhero.net/tester/" rel="nofollow noreferrer">http://regexhero.net/tester/</a></p>
     <h2>Benchmark Text:</h2>
     <p>The first 7 lines should not match, since they contain the searched Expression, while the lower 7 lines should match!</p>
     <pre><code>Regex Hero is a real-time online Silverlight Regular Expression Tester.
XRegex Hero is a real-time online Silverlight Regular Expression Tester.
Regex HeroRegex HeroRegex HeroRegex HeroRegex Hero is a real-time online Silverlight Regular Expression Tester.
Regex Her Regex Her Regex Her Regex Her Regex Her Regex Her Regex Hero is a real-time online Silverlight Regular Expression Tester.
Regex Her is a real-time online Silverlight Regular Expression Tester.Regex Hero
egex Hero egex Hero egex Hero egex Hero egex Hero egex Hero Regex Hero is a real-time online Silverlight Regular Expression Tester.
RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRegex Hero is a real-time online Silverlight Regular Expression Tester.

Regex Her
egex Hero
egex Hero is a real-time online Silverlight Regular Expression Tester.
Regex Her is a real-time online Silverlight Regular Expression Tester.
Regex Her Regex Her Regex Her Regex Her Regex Her Regex Her is a real-time online Silverlight Regular Expression Tester.
Nobody is a real-time online Silverlight Regular Expression Tester.
Regex Her o egex Hero Regex  Hero Reg ex Hero is a real-time online Silverlight Regular Expression Tester.
</code></pre>
     <h2>Results:</h2>
     <p>Results are Iterations per second as the median of 3 runs - <strong>Bigger Number = Better</strong></p>
     <pre><code>01: ^((?!Regex Hero).)*$                    3.914   // Accepted Answer
02: ^(?:(?!Regex Hero).)*$                  5.034   // With Non-Capturing group
03: ^(?!.*?Regex Hero).*                   7.356   // Lookahead at the beginning, if not found match everything
04: ^(?&gt;[^R]+|R(?!egex Hero))*$             6.137   // Lookahead only on the right first letter
05: ^(?&gt;(?:.*?Regex Hero)?)^.*$             7.426   // Match the word and check if you're still at linestart
06: ^(?(?=.*?Regex Hero)(?#fail)|.*)$       7.371   // Logic Branch: Find Regex Hero? match nothing, else anything

P1: ^(?(?=.*?Regex Hero)(*FAIL)|(*ACCEPT))  ?????   // Logic Branch in Perl - Quick FAIL
P2: .*?Regex Hero(*COMMIT)(*FAIL)|(*ACCEPT) ?????   // Direct COMMIT &amp; FAIL in Perl
</code></pre>
     <p>Since .NET doesn't support action Verbs (*FAIL, etc.) I couldn't test the solutions P1 and P2.</p>
     <h2>Summary:</h2>
     <p>The overall most readable and performance-wise fastest solution seems to be 03 with a simple negative lookahead. This is also the fastest solution for JavaScript, since JS does not support the more advanced Regex Features for the other solutions.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>6</td>
        <td><span>You should time <code>^(?!.*hede)</code> too. /// Also, it's probably better to rank the expressions for the matching corpus and the non-matching corpus separately because it's usually a case that most line match or most lines don't.</span> <span> - </span> <span class="display-name">ikegami</span> <span> </span> <span class="date">23 Aug 2016 at 00:07</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>36</span>
     </div>
     <div>
      <span>Answerer: </span> <span>kiwalk</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Feb 2011 at 14:00</span>
     </div>
    </div>
    <div>
     <p>Not regex, but I've found it logical and useful to use serial greps with pipe to eliminate noise.</p>
     <p>eg. search an apache config file without all the comments-</p>
     <pre><code>grep -v '\#' /opt/lampp/etc/httpd.conf      # this gives all the non-comment lines
</code></pre>
     <p>and</p>
     <pre><code>grep -v '\#' /opt/lampp/etc/httpd.conf |  grep -i dir
</code></pre>
     <p>The logic of serial grep's is (not a comment) and (matches dir)</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>I think he is asking for the regex version of the <code>grep -v</code></span> <span> - </span> <span class="display-name">Angel.King.47</span> <span> </span> <span class="date">12 Jul 2011 at 15:27</span></td>
       </tr>
       <tr>
        <td>9</td>
        <td><span>This is dangerous. Also misses lines like <code>good_stuff #comment_stuff</code></span> <span> - </span> <span class="display-name">Xavi Montero</span> <span> </span> <span class="date">1 Mar 2013 at 19:54</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>34</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Pedro Gimeno</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Dec 2016 at 21:24</span>
     </div>
    </div>
    <div>
     <p>Since no one else has given a direct answer to the question <em>that was asked</em>, I'll do it.</p>
     <p>The answer is that with POSIX <code>grep</code>, it's impossible to literally satisfy this request:</p>
     <pre><code>grep "&lt;Regex for 'doesn't contain hede'&gt;" input
</code></pre>
     <p>The reason is that with no flags, POSIX <code>grep</code> is only required to work with <a href="http://pubs.opengroup.org/onlinepubs/7908799/xbd/re.html#tag_007_003" rel="nofollow noreferrer">Basic Regular Expressions</a> (BREs), which are simply not powerful enough for accomplishing that task, because of lack of alternation in subexpressions. The only kind of alternation it supports involves providing multiple regular expressions separated by newlines, and that doesn't cover all regular languages, e.g. there's no finite collection of BREs that matches the same regular language as the <a href="http://pubs.opengroup.org/onlinepubs/7908799/xbd/re.html#tag_007_004" rel="nofollow noreferrer">extended regular expression</a> (ERE) <code>^(ab|cd)*$</code>.</p>
     <p><em>However</em>, GNU <code>grep</code> implements extensions that allow it. In particular, <code>\|</code> is the alternation operator in GNU's implementation of BREs. If your regular expression engine supports alternation, parentheses and the Kleene star, and is able to anchor to the beginning and end of the string, that's all you need for this approach. Note however that negative sets <code>[^ ... ]</code> are very convenient in addition to those, because otherwise, you need to replace them with an expression of the form <code>(a|b|c| ... )</code> that lists every character that is not in the set, which is extremely tedious and overly long, even more so if the whole character set is Unicode.</p>
     <p>Thanks to formal language theory, we get to see how such an expression looks like. With GNU <code>grep</code>, the answer would be something like:</p>
     <pre><code>grep "^\([^h]\|h\(h\|eh\|edh\)*\([^eh]\|e[^dh]\|ed[^eh]\)\)*\(\|h\(h\|eh\|edh\)*\(\|e\|ed\)\)$" input
</code></pre>
     <p>(found with <a href="http://web.archive.org/web/20021212105838/http://www.csd.uwo.ca/research/grail/" rel="nofollow noreferrer">Grail</a> and some further optimizations made by hand).</p>
     <p>You can also use a tool that implements EREs, like <code>egrep</code>, to get rid of the backslashes, or equivalently, pass the <code>-E</code> flag to POSIX <code>grep</code> (although I was under the impression that the question required avoiding any flags to <code>grep</code> whatsoever):</p>
     <pre><code>egrep "^([^h]|h(h|eh|edh)*([^eh]|e[^dh]|ed[^eh]))*(|h(h|eh|edh)*(|e|ed))$" input
</code></pre>
     <p>Here's a script to test it (note it generates a file <code>testinput.txt</code> in the current directory). Several of the expressions presented in other answers fail this test.</p>
     <pre><code>#!/bin/bash
REGEX="^\([^h]\|h\(h\|eh\|edh\)*\([^eh]\|e[^dh]\|ed[^eh]\)\)*\(\|h\(h\|eh\|edh\)*\(\|e\|ed\)\)$"

# First four lines as in OP's testcase.
cat &gt; testinput.txt &lt;&lt;EOF
hoho
hihi
haha
hede

h
he
ah
head
ahead
ahed
aheda
ahede
hhede
hehede
hedhede
hehehehehehedehehe
hedecidedthat
EOF
diff -s -u &lt;(grep -v hede testinput.txt) &lt;(grep "$REGEX" testinput.txt)
</code></pre>
     <p>In my system it prints:</p>
     <pre><code>Files /dev/fd/63 and /dev/fd/62 are identical
</code></pre>
     <p>as expected.</p>
     <p>For those interested in the details, the technique employed is to convert the regular expression that matches the word into a finite automaton, then invert the automaton by changing every acceptance state to non-acceptance and vice versa, and then converting the resulting FA back to a regular expression.</p>
     <p>As everyone has noted, if your regular expression engine supports negative lookahead, the regular expression is much simpler. For example, with GNU grep:</p>
     <pre><code>grep -P '^((?!hede).)*$' input
</code></pre>
     <p>However, this approach has the disadvantage that it requires a backtracking regular expression engine. This makes it unsuitable in installations that are using secure regular expression engines like <a href="https://github.com/google/re2/wiki/WhyRE2" rel="nofollow noreferrer">RE2</a>, which is one reason to prefer the generated approach in some circumstances.</p>
     <p>Using Kendall Hopkins' excellent <a href="https://github.com/KendallHopkins/FormalTheory" rel="nofollow noreferrer">FormalTheory</a> library, written in PHP, which provides a functionality similar to Grail, and a simplifier written by myself, I've been able to write an online generator of negative regular expressions given an input phrase (only alphanumeric and space characters currently supported, and the length is limited): <a href="http://www.formauri.es/personal/pgimeno/misc/non-match-regex/" rel="nofollow noreferrer">http://www.formauri.es/personal/pgimeno/misc/non-match-regex/</a></p>
     <p>For <code>hede</code> it outputs:</p>
     <pre><code>^([^h]|h(h|e(h|dh))*([^eh]|e([^dh]|d[^eh])))*(h(h|e(h|dh))*(ed?)?)?$
</code></pre>
     <p>which is equivalent to the above.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>This is the only answer that tries to answer the question.</span> <span> - </span> <span class="display-name">questionto42</span> <span> </span> <span class="date">25 Oct 2022 at 16:44</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>31</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Casimir et Hippolyte</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Apr 2013 at 03:04</span>
     </div>
    </div>
    <div>
     <p>with this, you avoid to test a lookahead on each positions:</p>
     <pre><code>/^(?:[^h]+|h++(?!ede))*+$/
</code></pre>
     <p>equivalent to (for .net):</p>
     <pre><code>^(?&gt;(?:[^h]+|h+(?!ede))*)$
</code></pre>
     <p>Old answer:</p>
     <pre><code>/^(?&gt;[^h]+|h+(?!ede))*$/
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>8</td>
        <td><span>Good point; I'm surprised nobody mentioned this approach before. However, that particular regex is prone to <a href="http://www.regular-expressions.info/catastrophic.html" rel="nofollow noreferrer">catastrophic backtracking</a> when applied to text that doesn't match. Here's how I would do it: <code>/^[^h]*(?:h+(?!ede)[^h]*)*$/</code></span> <span> - </span> <span class="display-name">Alan Moore</span> <span> </span> <span class="date">14 Apr 2013 at 05:26</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>...or you can just make all the quantifiers possessive. ;)</span> <span> - </span> <span class="display-name">Alan Moore</span> <span> </span> <span class="date">15 Apr 2013 at 15:17</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Alan Moore - I'm surprised too. I saw your comment (and best regex in the pile) here only after posting this same pattern in an answer below.</span> <span> - </span> <span class="display-name">ridgerunner</span> <span> </span> <span class="date">20 Dec 2013 at 03:08</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@ridgerunner, doesn't have to be the best tho. I've seen benchmarks where the top answer performs better. (I was surprised about that tho.)</span> <span> - </span> <span class="display-name">Qtax</span> <span> </span> <span class="date">20 Feb 2014 at 13:10</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span> <span class="arrow"> <a href="#answer_15">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>30</span>
     </div>
     <div>
      <span>Answerer: </span> <span>ikegami</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Aug 2016 at 00:03</span>
     </div>
    </div>
    <div>
     <p>Aforementioned <code>(?:(?!hede).)*</code> is great because it can be anchored.</p>
     <pre><code>^(?:(?!hede).)*$               # A line without hede

foo(?:(?!hede).)*bar           # foo followed by bar, without hede between them
</code></pre>
     <p>But the following would suffice in this case:</p>
     <pre><code>^(?!.*hede)                    # A line without hede
</code></pre>
     <p>This simplification is ready to have "AND" clauses added:</p>
     <pre><code>^(?!.*hede)(?=.*foo)(?=.*bar)   # A line with foo and bar, but without hede
^(?!.*hede)(?=.*foo).*bar       # Same
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_15"><span>Answer 15</span> <span class="arrow"> <a href="#answer_14">↑</a> </span> <span class="arrow"> <a href="#answer_16">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>28</span>
     </div>
     <div>
      <span>Answerer: </span> <span>staafl</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Nov 2018 at 18:26</span>
     </div>
    </div>
    <div>
     <p>An, in my opinon, more readable variant of the top answer:</p>
     <pre><code>^(?!.*hede)
</code></pre>
     <p>Basically, "match at the beginning of the line if and only if it does not have 'hede' in it" - so the requirement translated almost directly into regex.</p>
     <p>Of course, it's possible to have multiple failure requirements:</p>
     <pre><code>^(?!.*(hede|hodo|hada))
</code></pre>
     <p><strong>Details:</strong> The ^ anchor ensures the regex engine doesn't retry the match at every location in the string, which would match every string.</p>
     <p>The ^ anchor in the beginning is meant to represent the beginning of the line. The grep tool matches each line one at a time, in contexts where you're working with a multiline string, you can use the "m" flag:</p>
     <pre><code>/^(?!.*hede)/m # JavaScript syntax
</code></pre>
     <p>or</p>
     <pre><code>(?m)^(?!.*hede) # Inline flag
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>One difference from top answer is that this does not match anything, and that matches the whole line if without "hede"</span> <span> - </span> <span class="display-name">Bernardo Dal Corno</span> <span> </span> <span class="date">20 Aug 2019 at 19:33</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@BernardoDalCorno This can easily be changed by adding <code>.*</code> to the expression: <code>^(?!.*hede).*</code> the match will then contain all text.</span> <span> - </span> <span class="display-name">Falco</span> <span> </span> <span class="date">18 Nov 2022 at 12:41</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This answer seems to be the most efficient one for JavaScript, since all other answers will run into "max call stack size exceeded" on really big input. This answer uses no groups, just a simple lookahead.</span> <span> - </span> <span class="display-name">Falco</span> <span> </span> <span class="date">18 Nov 2022 at 12:43</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_16"><span>Answer 16</span> <span class="arrow"> <a href="#answer_15">↑</a> </span> <span class="arrow"> <a href="#answer_17">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>24</span>
     </div>
     <div>
      <span>Answerer: </span> <span>ridgerunner</span>
     </div>
     <div>
      <span> Answered: </span> <span>20 Dec 2013 at 03:03</span>
     </div>
    </div>
    <div>
     <p>Here's how I'd do it:</p>
     <pre><code>^[^h]*(h(?!ede)[^h]*)*$
</code></pre>
     <p>Accurate and more efficient than the other answers. It implements Friedl's <em>"unrolling-the-loop"</em> efficiency technique and requires much less backtracking.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>What if the search word contains 2 more more of the same first letter? like <code>hhede</code> or <code>hedhe</code>??</span> <span> - </span> <span class="display-name">Jon Grah</span> <span> </span> <span class="date">12 Nov 2022 at 09:24</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_17"><span>Answer 17</span> <span class="arrow"> <a href="#answer_16">↑</a> </span> <span class="arrow"> <a href="#answer_18">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>21</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Emma</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Aug 2019 at 02:36</span>
     </div>
    </div>
    <div>
     <p>Another option is that to add a positive look-ahead and check if <code>hede</code> is anywhere in the input line, then we would negate that, with an expression similar to:</p>
     <pre><code>^(?!(?=.*\bhede\b)).*$
</code></pre>
     <p>with word boundaries.</p>
     <hr>
     <p>The expression is explained on the top right panel of <a href="https://regex101.com/r/S127jy/1/" rel="noreferrer">regex101.com</a>, if you wish to explore/simplify/modify it, and in <a href="https://regex101.com/r/S127jy/1/debugger" rel="noreferrer">this link</a>, you can watch how it would match against some sample inputs, if you like.</p>
     <hr>
     <h3>RegEx Circuit</h3>
     <p><a href="https://jex.im/regulex/#!flags=&amp;re=%5E(a%7Cb)*%3F%24" rel="noreferrer">jex.im</a> visualizes regular expressions:</p>
     <p><a href="https://i.stack.imgur.com/ShAAv.png" rel="noreferrer"><img src="https://i.stack.imgur.com/ShAAv.png" alt="enter image description here"></a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>5</td>
        <td><span>I don't understand how the "inner" positive lookahead is useful.</span> <span> - </span> <span class="display-name">Scratte</span> <span> </span> <span class="date">5 Feb 2021 at 11:15</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>It is a camouflaged <code>^(?!.*\bhede\b).*$</code></span> <span> - </span> <span class="display-name">Wiktor Stribiżew</span> <span> </span> <span class="date">22 Oct 2021 at 12:41</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_18"><span>Answer 18</span> <span class="arrow"> <a href="#answer_17">↑</a> </span> <span class="arrow"> <a href="#answer_19">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>20</span>
     </div>
     <div>
      <span>Answerer: </span> <span>diyism</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Mar 2012 at 07:24</span>
     </div>
    </div>
    <div>
     <p>If you want to match a character to negate a word similar to negate character class:</p>
     <p>For example, a string:</p>
     <pre><code>&lt;?
$str="aaa        bbb4      aaa     bbb7";
?&gt;
</code></pre>
     <p>Do not use:</p>
     <pre><code>&lt;?
preg_match('/aaa[^bbb]+?bbb7/s', $str, $matches);
?&gt;
</code></pre>
     <p>Use:</p>
     <pre><code>&lt;?
preg_match('/aaa(?:(?!bbb).)+?bbb7/s', $str, $matches);
?&gt;
</code></pre>
     <p>Notice <code>"(?!bbb)."</code> is neither lookbehind nor lookahead, it's lookcurrent, for example:</p>
     <pre><code>"(?=abc)abcde", "(?!abc)abcde"
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span>There is no "lookcurrent" in perl regexp's. This is truly a negative lookahead (prefix <code>(?!</code>). Positive lookahead's prefix would be <code>(?=</code> while the corresponding lookbehind prefixes would be <code>(?&lt;!</code> and <code>(?&lt;=</code> respectively. A lookahead means that you read the next characters (hence “ahead”) without consuming them. A lookbehind means that you check characters that have already been consumed.</span> <span> - </span> <span class="display-name">Didier L</span> <span> </span> <span class="date">21 May 2012 at 16:35</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Not sure how <code>(?!abc)abcde</code> makes any sense at all.</span> <span> - </span> <span class="display-name">Scratte</span> <span> </span> <span class="date">5 Feb 2021 at 10:18</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_19"><span>Answer 19</span> <span class="arrow"> <a href="#answer_18">↑</a> </span> <span class="arrow"> <a href="#answer_20">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>15</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Kevin Fegan</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Apr 2013 at 22:28</span>
     </div>
    </div>
    <div>
     <p>The OP did not specify or <b><kbd>Tag</kbd></b> the post to indicate the context (programming language, editor, tool) the Regex will be used within.</p>
     <p>For me, I sometimes need to do this while editing a file using <strong><code>Textpad</code></strong>.</p>
     <p><strong><code>Textpad</code></strong> supports some Regex, but does not support lookahead or lookbehind, so it takes a few steps.</p>
     <p>If I am looking to retain all lines that <b><i>Do NOT</i></b> contain the string <strong><code>hede</code></strong>, I would do it like this:</p>
     <blockquote>
      <p>1. Search/replace the entire file to add a unique "Tag" to the beginning of each line containing any text.</p>
     </blockquote>
     <p></p>
     <pre><code>    Search string:^(.)  
    Replace string:&lt;@#-unique-#@&gt;\1  
    Replace-all  
</code></pre>
     <blockquote>
      <p>2. Delete all lines that contain the string <strong><code>hede</code></strong> (replacement string is empty):</p>
     </blockquote>
     <p></p>
     <pre><code>    Search string:&lt;@#-unique-#@&gt;.*hede.*\n  
    Replace string:&lt;nothing&gt;  
    Replace-all  
</code></pre>
     <p></p>
     <blockquote>
      <p>3. At this point, all remaining lines <b><i>Do NOT</i></b> contain the string <strong><code>hede</code></strong>. Remove the unique "Tag" from all lines (replacement string is empty):</p>
     </blockquote>
     <p></p>
     <pre><code>    Search string:&lt;@#-unique-#@&gt;
    Replace string:&lt;nothing&gt;  
    Replace-all  
</code></pre>
     <p>Now you have the original text with all lines containing the string <strong><code>hede</code></strong> removed. <br></p>
     <hr>
     <p>If I am looking to <b><i>Do Something Else</i></b> to only lines that <b><i>Do NOT</i></b> contain the string <strong><code>hede</code></strong>, I would do it like this:</p>
     <blockquote>
      <p>1. Search/replace the entire file to add a unique "Tag" to the beginning of each line containing any text.</p>
     </blockquote>
     <p></p>
     <pre><code>    Search string:^(.)  
    Replace string:&lt;@#-unique-#@&gt;\1  
    Replace-all  
</code></pre>
     <blockquote>
      <p>2. For all lines that contain the string <strong><code>hede</code></strong>, remove the unique "Tag":</p>
     </blockquote>
     <p></p>
     <pre><code>    Search string:&lt;@#-unique-#@&gt;(.*hede)
    Replace string:\1  
    Replace-all  
</code></pre>
     <p></p>
     <blockquote>
      <p>3. At this point, all lines that begin with the unique "Tag", <b><i>Do NOT</i></b> contain the string <strong><code>hede</code></strong>. I can now do my <b><i>Something Else</i></b> to only those lines.</p>
     </blockquote>
     <p></p>
     <blockquote>
      <p>4. When I am done, I remove the unique "Tag" from all lines (replacement string is empty):</p>
     </blockquote>
     <p></p>
     <pre><code>    Search string:&lt;@#-unique-#@&gt;
    Replace string:&lt;nothing&gt;  
    Replace-all  
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_20"><span>Answer 20</span> <span class="arrow"> <a href="#answer_19">↑</a> </span> <span class="arrow"> <a href="#answer_21">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>13</span>
     </div>
     <div>
      <span>Answerer: </span> <span>aelor</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Mar 2017 at 13:42</span>
     </div>
    </div>
    <div>
     <p>Since the introduction of ruby-2.4.1, we can use the new <a href="https://github.com/k-takata/Onigmo/issues/82" rel="noreferrer">Absent Operator</a> in Ruby’s Regular Expressions</p>
     <p>from the official <a href="https://github.com/k-takata/Onigmo/commit/8d0f9d3c20134e204e6913b9f1e7779f49f9d58f" rel="noreferrer">doc</a></p>
     <pre><code>(?~abc) matches: "", "ab", "aab", "cccc", etc.
It doesn't match: "abc", "aabc", "ccccabc", etc.
</code></pre>
     <p>Thus, in your case <code>^(?~hede)$</code> does the job for you</p>
     <pre><code>2.4.1 :016 &gt; ["hoho", "hihi", "haha", "hede"].select{|s| /^(?~hede)$/.match(s)}
 =&gt; ["hoho", "hihi", "haha"]
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_21"><span>Answer 21</span> <span class="arrow"> <a href="#answer_20">↑</a> </span> <span class="arrow"> <a href="#answer_22">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>12</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Avinash Raj</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Oct 2014 at 07:00</span>
     </div>
    </div>
    <div>
     <p><strong>Through PCRE verb <code>(*SKIP)(*F)</code></strong></p>
     <pre><code>^hede$(*SKIP)(*F)|^.*$
</code></pre>
     <p>This would completely skips the line which contains the exact string <code>hede</code> and matches all the remaining lines.</p>
     <p><a href="http://regex101.com/r/kR0tO2/1" rel="noreferrer">DEMO</a></p>
     <p><strong>Execution of the parts:</strong></p>
     <p>Let us consider the above regex by splitting it into two parts.</p>
     <ol>
      <li>
       <p>Part before the <code>|</code> symbol. Part <strong>shouldn't be matched</strong>.</p>
       <pre><code>^hede$(*SKIP)(*F)
</code></pre></li>
      <li>
       <p>Part after the <code>|</code> symbol. Part <strong>should be matched</strong>.</p>
       <pre><code>^.*$
</code></pre></li>
     </ol>
     <p><strong>PART 1</strong></p>
     <p>Regex engine will start its execution from the first part.</p>
     <pre><code>^hede$(*SKIP)(*F)
</code></pre>
     <p><strong>Explanation:</strong></p>
     <ul>
      <li><code>^</code> Asserts that we are at the start.</li>
      <li><code>hede</code> Matches the string <code>hede</code></li>
      <li><code>$</code> Asserts that we are at the line end.</li>
     </ul>
     <p>So the line which contains the string <code>hede</code> would be matched. Once the regex engine sees the following <code>(*SKIP)(*F)</code> (<em>Note: You could write <code>(*F)</code> as <code>(*FAIL)</code></em>) verb, it skips and make the match to fail. <code>|</code> called alteration or logical OR operator added next to the PCRE verb which inturn matches all the boundaries exists between each and every character on all the lines except the line contains the exact string <code>hede</code>. See the demo <a href="http://regex101.com/r/kR0tO2/2" rel="noreferrer">here</a>. That is, it tries to match the characters from the remaining string. Now the regex in the second part would be executed.</p>
     <p><strong>PART 2</strong></p>
     <pre><code>^.*$
</code></pre>
     <p><strong>Explanation:</strong></p>
     <ul>
      <li><code>^</code> Asserts that we are at the start. ie, it matches all the line starts except the one in the <code>hede</code> line. See the demo <a href="http://regex101.com/r/kR0tO2/3" rel="noreferrer">here</a>.</li>
      <li>
       <p><code>.*</code> In the Multiline mode, <code>.</code> would match any character except newline or carriage return characters. And <code>*</code> would repeat the previous character zero or more times. So <code>.*</code> would match the whole line. See the demo <a href="http://regex101.com/r/kR0tO2/4" rel="noreferrer">here</a>.</p>
       <p><strong>Hey why you added .* instead of .+ ?</strong></p>
       <p>Because <code>.*</code> would match a blank line but <code>.+</code> won't match a blank. We want to match all the lines except <code>hede</code> , there may be a possibility of blank lines also in the input . so you must use <code>.*</code> instead of <code>.+</code> . <code>.+</code> would repeat the previous character one or more times. See <code>.*</code> matches a blank line <a href="http://regex101.com/r/kR0tO2/5" rel="noreferrer">here</a>.</p></li>
      <li>
       <p><code>$</code> End of the line anchor is not necessary here.</p></li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_22"><span>Answer 22</span> <span class="arrow"> <a href="#answer_21">↑</a> </span> <span class="arrow"> <a href="#answer_23">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Kaz</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Jun 2014 at 01:23</span>
     </div>
    </div>
    <div>
     <p>The <a href="http://www.nongnu.org/txr/" rel="noreferrer">TXR Language</a> supports regex negation.</p>
     <pre><code>$ txr -c '@(repeat)
@{nothede /~hede/}
@(do (put-line nothede))
@(end)'  Input
</code></pre>
     <p>A more complicated example: match all lines that start with <code>a</code> and end with <code>z</code>, but do not contain the substring <code>hede</code>:</p>
     <pre><code>$ txr -c '@(repeat)
@{nothede /a.*z&amp;~.*hede.*/}
@(do (put-line nothede))
@(end)' -
az         &lt;- echoed
az
abcz       &lt;- echoed
abcz
abhederz   &lt;- not echoed; contains hede
ahedez     &lt;- not echoed; contains hede
ace        &lt;- not echoed; does not end in z
ahedz      &lt;- echoed
ahedz
</code></pre>
     <p>Regex negation is not particularly useful on its own but when you also have intersection, things get interesting, since you have a full set of boolean set operations: you can express "the set which matches this, except for things which match that".</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Note that it is also the solution for ElasticSearch Lucene based regex.</span> <span> - </span> <span class="display-name">Wiktor Stribiżew</span> <span> </span> <span class="date">19 Feb 2018 at 07:30</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_23"><span>Answer 23</span> <span class="arrow"> <a href="#answer_22">↑</a> </span> <span class="arrow"> <a href="#answer_24">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>andrew pate</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Feb 2015 at 11:45</span>
     </div>
    </div>
    <div>
     <p>It may be more maintainable to two regexes in your code, one to do the first match, and then if it matches run the second regex to check for outlier cases you wish to block for example <code>^.*(hede).*</code> then have appropriate logic in your code.</p>
     <p>OK, I admit this is not really an answer to the posted question posted and it may also use slightly more processing than a single regex. But for developers who came here looking for a fast emergency fix for an outlier case then this solution should not be overlooked.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_24"><span>Answer 24</span> <span class="arrow"> <a href="#answer_23">↑</a> </span> <span class="arrow"> <a href="#answer_25">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Daniel Nyamasyo</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Dec 2016 at 04:55</span>
     </div>
    </div>
    <div>
     <p>The below function will help you get your desired output</p>
     <pre><code>&lt;?PHP
      function removePrepositions($text){

            $propositions=array('/\bfor\b/i','/\bthe\b/i'); 

            if( count($propositions) &gt; 0 ) {
                foreach($propositions as $exceptionPhrase) {
                    $text = preg_replace($exceptionPhrase, '', trim($text));

                }
            $retval = trim($text);

            }
        return $retval;
    }


?&gt;
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_25"><span>Answer 25</span> <span class="arrow"> <a href="#answer_24">↑</a> </span> <span class="arrow"> <a href="#answer_26">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Matthew Rideout</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Apr 2020 at 18:53</span>
     </div>
    </div>
    <div>
     <p>I wanted to add another example for if you are trying to match an entire line that contains string <strong>X</strong>, but does not also contain string <strong>Y</strong>.</p>
     <p>For example, let's say we want to check if our URL / string contains "<strong>tasty-treats</strong>", so long as it does not also contain "<strong>chocolate</strong>" anywhere.</p>
     <p>This regex pattern would work (works in JavaScript too)</p>
     <pre><code>^(?=.*?tasty-treats)((?!chocolate).)*$
</code></pre>
     <p><em>(global, multiline flags in example)</em></p>
     <p><strong>Interactive Example: <a href="https://regexr.com/53gv4" rel="noreferrer">https://regexr.com/53gv4</a></strong></p>
     <h3>Matches</h3>
     <p><em>(These urls contain "tasty-treats" and also do not contain "chocolate")</em></p>
     <ul>
      <li>example.com/tasty-treats/strawberry-ice-cream</li>
      <li>example.com/desserts/tasty-treats/banana-pudding</li>
      <li>example.com/tasty-treats-overview</li>
     </ul>
     <h3>Does Not Match</h3>
     <p><em>(These urls contain "chocolate" somewhere - so they won't match even though they contain "tasty-treats")</em></p>
     <ul>
      <li>example.com/tasty-treats/chocolate-cake</li>
      <li>example.com/home-cooking/oven-roasted-chicken</li>
      <li>example.com/tasty-treats/banana-chocolate-fudge</li>
      <li>example.com/desserts/chocolate/tasty-treats</li>
      <li>example.com/chocolate/tasty-treats/desserts</li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_26"><span>Answer 26</span> <span class="arrow"> <a href="#answer_25">↑</a> </span> <span class="arrow"> <a href="#answer_27">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Anas R.</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Jun 2020 at 11:02</span>
     </div>
    </div>
    <div>
     <p>As long as you are dealing with <em>lines</em>, simply <strong>mark the negative matches and target the rest</strong>.</p>
     <p>In fact, I use this trick with sed because <code>^((?!hede).)*$</code> looks not supported by it.</p>
     <h1>For the desired output</h1>
     <ol>
      <li>
       <p>Mark the negative match: (e.g. lines with <code>hede</code>), using a character not included in the whole text at all. An emoji could probably be a good choice for this purpose.</p>
       <pre class="lang-sh prettyprint-override"><code>s/(.*hede)/🔒\1/g
</code></pre></li>
      <li>
       <p>Target the rest (the unmarked strings: e.g. lines without <code>hede</code>). Suppose you want to <em>keep only the target</em> and delete the rest (as you want):</p>
       <pre class="lang-sh prettyprint-override"><code>s/^🔒.*//g
</code></pre></li>
     </ol>
     <h1>For a better understanding</h1>
     <p>Suppose you want to <em>delete the target</em>:</p>
     <ol>
      <li>
       <p>Mark the negative match: (e.g. lines with <code>hede</code>), using a character not included in the whole text at all. An emoji could probably be a good choice for this purpose.</p>
       <pre class="lang-sh prettyprint-override"><code>s/(.*hede)/🔒\1/g
</code></pre></li>
      <li>
       <p>Target the rest (the unmarked strings: e.g. lines without <code>hede</code>). Suppose you want to <em>delete the target</em>:</p>
       <pre class="lang-sh prettyprint-override"><code>s/^[^🔒].*//g
</code></pre></li>
      <li>
       <p>Remove the mark:</p>
       <pre class="lang-sh prettyprint-override"><code>s/🔒//g
</code></pre></li>
     </ol>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_27"><span>Answer 27</span> <span class="arrow"> <a href="#answer_26">↑</a> </span> <span class="arrow"> <a href="#answer_28">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>cloudhopperpilot</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Mar 2019 at 12:21</span>
     </div>
    </div>
    <div>
     <p><code>^((?!hede).)*$</code> is an elegant solution, except since it consumes characters you won't be able to combine it with other criteria. For instance, say you wanted to check for the non-presence of "hede" and the presence of "haha." This solution would work because it won't consume characters:</p>
     <pre><code>^(?!.*\bhede\b)(?=.*\bhaha\b) 
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_28"><span>Answer 28</span> <span class="arrow"> <a href="#answer_27">↑</a> </span> <span class="arrow"> <a href="#answer_29">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>JohnP2</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 Sep 2016 at 13:52</span>
     </div>
    </div>
    <div>
     <p>A simpler solution is to use the not operator <strong>!</strong></p>
     <p>Your <strong><em>if</em></strong> statement will need to match "contains" and not match "excludes".</p>
     <pre><code>var contains = /abc/;
var excludes =/hede/;

if(string.match(contains) &amp;&amp; !(string.match(excludes))){  //proceed...
</code></pre>
     <p>I believe the designers of RegEx anticipated the use of not operators.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_29"><span>Answer 29</span> <span class="arrow"> <a href="#answer_28">↑</a> </span> <span class="arrow"> <a href="#answer_30">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>jaytea</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Oct 2017 at 10:12</span>
     </div>
    </div>
    <div>
     <h2>How to use PCRE's backtracking control verbs to match a line not containing a word</h2>
     <p>Here's a method that I haven't seen used before:</p>
     <pre><code>/.*hede(*COMMIT)^|/
</code></pre>
     <h2>How it works</h2>
     <p>First, it tries to find "hede" somewhere in the line. If successful, at this point, <code>(*COMMIT)</code> tells the engine to, not only not backtrack in the event of a failure, but also not to attempt any further matching in that case. Then, we try to match something that cannot possibly match (in this case, <code>^</code>).</p>
     <p>If a line does not contain "hede" then the second alternative, an empty subpattern, successfully matches the subject string.</p>
     <p>This method is no more efficient than a negative lookahead, but I figured I'd just throw it on here in case someone finds it nifty and finds a use for it for other, more interesting applications.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_30"><span>Answer 30</span> <span class="arrow"> <a href="#answer_29">↑</a> </span> <span class="arrow"> <a href="#answer_31">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>BrunoF</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Apr 2018 at 18:15</span>
     </div>
    </div>
    <div>
     <p>Maybe you'll find this on Google while trying to write a regex that is able to match segments of a line (as opposed to entire lines) which do <strong>not</strong> contain a substring. Tooke me a while to figure out, so I'll share:</p>
     <p>Given a string: <code> &lt;span class="good"&gt;bar&lt;/span&gt;&lt;span class="bad"&gt;foo&lt;/span&gt;&lt;span class="ugly"&gt;baz&lt;/span&gt; </code></p>
     <p>I want to match <code>&lt;span&gt;</code> tags which do not contain the substring "bad".</p>
     <p><code>/&lt;span(?:(?!bad).)*?&gt;</code> will match <code>&lt;span class=\"good\"&gt;</code> and <code>&lt;span class=\"ugly\"&gt;</code>.</p>
     <p>Notice that there are two sets (layers) of parentheses:</p>
     <ul>
      <li>The innermost one is for the negative lookahead (it is not a capture group)</li>
      <li>The outermost was interpreted by Ruby as capture group but we don't want it to be a capture group, so I added ?: at it's beginning and it is no longer interpreted as a capture group.</li>
     </ul>
     <p>Demo in Ruby:</p>
     <pre><code>s = '&lt;span class="good"&gt;bar&lt;/span&gt;&lt;span class="bad"&gt;foo&lt;/span&gt;&lt;span class="ugly"&gt;baz&lt;/span&gt;'
s.scan(/&lt;span(?:(?!bad).)*?&gt;/)
# =&gt; ["&lt;span class=\"good\"&gt;", "&lt;span class=\"ugly\"&gt;"]
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_31"><span>Answer 31</span> <span class="arrow"> <a href="#answer_30">↑</a> </span> <span class="arrow"> <a href="#answer_32">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Donald</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Jul 2018 at 17:08</span>
     </div>
    </div>
    <div>
     <p>With <a href="https://www.conyedit.com" rel="nofollow noreferrer">ConyEdit</a>, you can use the command line <code>cc.gl !/hede/</code> to get lines that do not contain the regex matching, or use the command line <code>cc.dl /hede/</code> to delete lines that contain the regex matching. They have the same result.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Similarly, but less obscurely, <code>awk '!/hede/'</code> or <code>grep -v 'hede'</code></span> <span> - </span> <span class="display-name">tripleee</span> <span> </span> <span class="date">20 Mar 2023 at 16:59</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_32"><span>Answer 32</span> <span class="arrow"> <a href="#answer_31">↑</a> </span> <span class="arrow"> <a href="#answer_33">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Benny</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Dec 2022 at 14:26</span>
     </div>
    </div>
    <div>
     <p>Simplest thing that I could find would be</p>
     <pre><code>[^(hede)]
</code></pre>
     <p>Tested at <a href="https://regex101.com/" rel="nofollow noreferrer">https://regex101.com/</a></p>
     <p>You can also add unit-test cases on that site</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Not works on visual code</span> <span> - </span> <span class="display-name">JRichardsz</span> <span> </span> <span class="date">15 Feb 2023 at 15:11</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>This simply finds a single character which is not <code>(</code>, <code>h</code>, <code>e</code>, <code>d</code>, or <code>)</code>.</span> <span> - </span> <span class="display-name">tripleee</span> <span> </span> <span class="date">20 Mar 2023 at 16:57</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_33"><span>Answer 33</span> <span class="arrow"> <a href="#answer_32">↑</a> </span> <span class="arrow"> <a href="#answer_34">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>admin</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 May 2022 at 01:38</span>
     </div>
    </div>
    <div>
     <pre><code># 一个简单的方式
import re
skip_word = 'hede'
stranger_char = '虩'
content = '''hoho
hihi
haha
hede'''
print(
    '\n'.join(re.findall(
        '([^{}]*?)\n'.format(stranger_char), 
        content.replace(skip_word, stranger_char)
    )).replace(stranger_char, skip_word) 
)

# hoho
# hihi
# haha
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_34"><span>Answer 34</span> <span class="arrow"> <a href="#answer_33">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Brandon Wegner</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Feb 2023 at 23:49</span>
     </div>
    </div>
    <div>
     <p>Using (?&lt;!hede) is a better answer. (?&lt;!whateverYouDontWantToMatch) is a negative look behind as opposed to (?!whateverYouDontWantToMatch) which is a negative look ahead. which means that with (?&lt;!) it will check right at the current position of the string instead of only looking after the match. So for example. You will run into issues using (?!) and it only works in this case because of the anchor.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>