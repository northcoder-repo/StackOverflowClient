<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>Loop (for each) over an array in JavaScript</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>Loop (for each) over an array in JavaScript</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>5602</span>
    </div>
    <div>
     <span>Asker: </span> <span>Dante1986</span>
    </div>
    <div>
     <span>Asked: </span> <span>17 Feb 2012 at 13:51</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/9329446">source</a>
    </div>
   </div>
   <div>
    <p>How can I loop through all the entries in an array using JavaScript?</p>
   </div>
   <div class="tags">
    <span class="tag">javascript</span><span class="tag">arrays</span><span class="tag">loops</span><span class="tag">foreach</span><span class="tag">iteration</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td></td>
       <td><span>Use for...of loop. See <a href="https://www.w3schools.com/JS/js_loop_forof.asp" rel="nofollow noreferrer">w3schools.com/JS/js_loop_forof.asp</a></span> <span> - </span> <span class="display-name">user19690494</span> <span> </span> <span class="date">25 Aug 2022 at 15:28</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Near duplicate of (but slightly more general than) "<a href="/q/3010840/90527">Loop through an array in JavaScript</a>".</span> <span> - </span> <span class="display-name">outis</span> <span> </span> <span class="date">17 Oct 2022 at 02:15</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8302</span>
     </div>
     <div>
      <span>Answerer: </span> <span>T.J. Crowder</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Feb 2012 at 13:53</span>
     </div>
    </div>
    <div>
     <p><strong>TL;DR</strong></p>
     <ul>
      <li>
       <p><strong>Your best bets</strong> are usually</p>
       <ul>
        <li>a <code>for-of</code> loop (ES2015+ only; <a href="https://tc39.es/ecma262/#sec-for-in-and-for-of-statements" rel="noreferrer">spec</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" rel="noreferrer">MDN</a>) - simple and <code>async</code>-friendly 
         <pre class="lang-js prettyprint-override"><code>for (const element of theArray) {
    // ...use `element`...
}
</code></pre></li>
        <li><code>forEach</code> (ES5+ only; <a href="https://tc39.es/ecma262/#sec-array.prototype.foreach" rel="noreferrer">spec</a> | <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noreferrer">MDN</a>) (or its relatives <code>some</code> and such) - <strong>not</strong> <code>async</code>-friendly (but see details) 
         <pre class="lang-js prettyprint-override"><code>theArray.forEach(element =&gt; {
    // ...use `element`...
});
</code></pre></li>
        <li>a simple old-fashioned <code>for</code> loop - <code>async</code>-friendly 
         <pre class="lang-js prettyprint-override"><code>for (let index = 0; index &lt; theArray.length; ++index) {
    const element = theArray[index];
    // ...use `element`...
}
</code></pre></li>
        <li><em>(rarely)</em> <code>for-in</code> <em>with safeguards</em> - <code>async</code>-friendly 
         <pre class="lang-js prettyprint-override"><code>for (const propertyName in theArray) {
    if (/*...is an array element property (see below)...*/) {
        const element = theArray[propertyName];
        // ...use `element`...
    }
}
</code></pre></li>
       </ul></li>
      <li>
       <p>Some quick "don't"s:</p>
       <ul>
        <li><strong>Don't use <code>for-in</code></strong> unless you use it with safeguards or are at least aware of why it might bite you.</li>
        <li><strong>Don't use <code>map</code> if you're not using its return value</strong>.<br><em>(There's sadly someone out there teaching <code>map</code> [<a href="https://tc39.es/ecma262/#sec-array.prototype.map" rel="noreferrer">spec</a> / <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noreferrer">MDN</a>] as though it were <code>forEach</code>&nbsp;— but as I write on my blog, <a href="https://thenewtoys.dev/blog/2021/04/17/misusing-map/" rel="noreferrer">that's not what it's for</a>. If you aren't using the array it creates, don't use <code>map</code>.)</em></li>
        <li><strong>Don't use <code>forEach</code></strong> if the callback does asynchronous work and you want the <code>forEach</code> to wait until that work is done (because it won't).</li>
       </ul></li>
     </ul>
     <p>But there's <strong>lots</strong> more to explore, read on...</p>
     <hr>
     <p>JavaScript has powerful semantics for looping through arrays and array-like objects. I've split the answer into two parts: Options for genuine arrays, and options for things that are just array-<em>like</em>, such as the <code>arguments</code> object, other iterable objects (ES2015+), DOM collections, and so on.</p>
     <p>Okay, let's look at our options:</p>
     <h2>For Actual Arrays</h2>
     <p>You have five options (two supported basically forever, another added by ECMAScript&nbsp;5 ["ES5"], and two more added in ECMAScript&nbsp;2015 ("ES2015", aka "ES6"):</p>
     <ol>
      <li>Use <code>for-of</code> (use an iterator implicitly) (ES2015+)</li>
      <li>Use <code>forEach</code> and related (ES5+)</li>
      <li>Use a simple <code>for</code> loop</li>
      <li>Use <code>for-in</code> <em>correctly</em></li>
      <li>Use an iterator explicitly (ES2015+)</li>
     </ol>
     <p>(You can see those old specs here: <a href="http://ecma-international.org/ecma-262/5.1/" rel="noreferrer">ES5</a>, <a href="http://www.ecma-international.org/ecma-262/6.0/index.html" rel="noreferrer">ES2015</a>, but both have been superceded; the current editor's draft is always <a href="https://tc39.github.io/ecma262/" rel="noreferrer">here</a>.)</p>
     <p>Details:</p>
     <h3>1. Use <code>for-of</code> (use an iterator implicitly) (ES2015+)</h3>
     <p>ES2015 added <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noreferrer"><em>iterators and iterables</em></a> to JavaScript. Arrays are iterable (so are strings, <code>Map</code>s, and <code>Set</code>s, as well as DOM collections and lists, as you'll see later). Iterable objects provide iterators for their values. The new <code>for-of</code> statement loops through the values returned by an iterator:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>const a = ["a", "b", "c"];
for (const element of a) { // You can use `let` instead of `const` if you like
    console.log(element);
}
// a
// b
// c</code></pre>
      </div>
     </div>
     <p></p>
     <p>It doesn't get simpler than that! Under the covers, that gets an iterator from the array and loops through the values the iterator returns. The iterator provided by arrays provides the values of the array elements, in order beginning to end.</p>
     <p>Notice how <code>element</code> is scoped to each loop iteration; trying to use <code>element</code> after the end of the loop would fail because it doesn't exist outside the loop body.</p>
     <p>In theory, a <code>for-of</code> loop involves several function calls (one to get the iterator, then one to get each value from it). Even when that's true, it's nothing to worry about, function calls are <em><strong>very</strong></em> cheap in modern JavaScript engines (it bothered me for <code>forEach</code> [below] until I looked into it; <a href="http://blog.niftysnippets.org/2012/02/foreach-and-runtime-cost.html" rel="noreferrer">details</a>). But additionally, JavaScript engines optimize those calls away (in performance-critical code) when dealing with native iterators for things like arrays.</p>
     <p><code>for-of</code> is entirely <code>async</code>-friendly. If you need the work in a loop body to be done in series (not in parallel), an <code>await</code> in the loop body will wait for the promise to settle before continuing. Here's a silly example:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
      <div class="snippet-code snippet-currently-hidden">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function delay(ms) {
    return new Promise(resolve =&gt; {
        setTimeout(resolve, ms);
    });
}

async function showSlowly(messages) {
    for (const message of messages) {
        await delay(400);
        console.log(message);
    }
}

showSlowly([
    "So", "long", "and", "thanks", "for", "all", "the", "fish!"
]);
// `.catch` omitted because we know it never rejects</code></pre>
      </div>
     </div>
     <p></p>
     <p>Note how the words appear with a delay before each one.</p>
     <p>It's a matter of coding style, but <code>for-of</code> is the first thing I reach for when looping through anything iterable.</p>
     <h3>2. Use <code>forEach</code> and related</h3>
     <p>In any even vaguely-modern environment (so, not IE8) where you have access to the <code>Array</code> features added by ES5, you can use <code>forEach</code> (<a href="https://tc39.es/ecma262/#sec-array.prototype.foreach" rel="noreferrer">spec</a> | <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noreferrer">MDN</a>) if you're only dealing with synchronous code (or you don't need to wait for an asynchronous process to finish during the loop):</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>const a = ["a", "b", "c"];
a.forEach((element) =&gt; {
    console.log(element);
});</code></pre>
      </div>
     </div>
     <p></p>
     <p><code>forEach</code> accepts a callback function and, optionally, a value to use as <code>this</code> when calling that callback (not used above). The callback is called for each element in the array, in order, skipping non-existent elements in sparse arrays. Although I only used one parameter above, the callback is called with three arguments: The element for that iteration, the index of that element, and a reference to the array you're iterating over (in case your function doesn't already have it handy).</p>
     <p>Like <code>for-of</code>, <code>forEach</code> has the advantage that you don't have to declare indexing and value variables in the containing scope; in this case, they're supplied as arguments to the iteration function, and so nicely scoped to just that iteration.</p>
     <p>Unlike <code>for-of</code>, <code>forEach</code> has the disadvantage that it doesn't understand <code>async</code> functions and <code>await</code>. If you use an <code>async</code> function as the callback, <code>forEach</code> does <strong>not</strong> wait for that function's promise to settle before continuing. Here's the <code>async</code> example from <code>for-of</code> using <code>forEach</code> instead&nbsp;— notice how there's an initial delay, but then all the text appears right away instead of waiting:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
      <div class="snippet-code snippet-currently-hidden">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function delay(ms) {
    return new Promise(resolve =&gt; {
        setTimeout(resolve, ms);
    });
}

async function showSlowly(messages) {
    // INCORRECT, doesn't wait before continuing,
    // doesn't handle promise rejections
    messages.forEach(async message =&gt; {
        await delay(400);
        console.log(message);
    });
}

showSlowly([
    "So", "long", "and", "thanks", "for", "all", "the", "fish!"
]);
// `.catch` omitted because we know it never rejects</code></pre>
      </div>
     </div>
     <p></p>
     <p><code>forEach</code> is the "loop through them all" function, but ES5 defined several other useful "work your way through the array and do things" functions, including:</p>
     <ul>
      <li><code>every</code> (<a href="https://tc39.es/ecma262/#sec-array.prototype.every" rel="noreferrer">spec</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every" rel="noreferrer">MDN</a>) - stops looping the first time the callback returns a falsy value</li>
      <li><code>some</code> (<a href="https://tc39.es/ecma262/#sec-array.prototype.some" rel="noreferrer">spec</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some" rel="noreferrer">MDN</a>) - stops looping the first time the callback returns a truthy value</li>
      <li><code>filter</code> (<a href="https://tc39.es/ecma262/#sec-array.prototype.filter" rel="noreferrer">spec</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noreferrer">MDN</a>) - creates a new array including elements where the callback returns a truthy value, omitting the ones where it doesn't</li>
      <li><code>map</code> (<a href="https://tc39.es/ecma262/#sec-array.prototype.map" rel="noreferrer">spec</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noreferrer">MDN</a>) - creates a new array from the values returned by the callback</li>
      <li><code>reduce</code> (<a href="https://tc39.es/ecma262/#sec-array.prototype.reduce" rel="noreferrer">spec</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noreferrer">MDN</a>) - builds up a value by repeatedly calling the callback, passing in previous values; see the spec for the details</li>
      <li><code>reduceRight</code> (<a href="https://tc39.es/ecma262/#sec-array.prototype.reduceright" rel="noreferrer">spec</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight" rel="noreferrer">MDN</a>) - like <code>reduce</code>, but works in descending rather than ascending order</li>
     </ul>
     <p>As with <code>forEach</code>, if you use an <code>async</code> function as your callback, none of those waits for the function's promise to settle. That means:</p>
     <ul>
      <li>Using an <code>async</code> function callback is never appropriate with <code>every</code>, <code>some</code>, and <code>filter</code> since they will treat the returned promise as though it were a truthy value; they <strong>don't</strong> wait for the promise to settle and then use the fulfillment value.</li>
      <li>Using an <code>async</code> function callback is often appropriate with <code>map</code>, <strong>if</strong> the goal is to turn an array of something into an array of <em>promises</em>, perhaps for passing to one of the promise combinator functions (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noreferrer"><code>Promise.all</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race" rel="noreferrer"><code>Promise.race</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled" rel="noreferrer"><code>promise.allSettled</code></a>, or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any" rel="noreferrer"><code>Promise.any</code></a>).</li>
      <li>Using an <code>async</code> function callback is rarely appropriate with <code>reduce</code> or <code>reduceRight</code>, because (again) the callback will always return a promise. But there is an idiom of building a chain of promises from an array that uses <code>reduce</code> (<code>const promise = array.reduce((p, element) =&gt; p.then(/*...something using `element`...*/));</code>), but usually in those cases a <code>for-of</code> or <code>for</code> loop in an <code>async</code> function will be clearer and easier to debug.</li>
     </ul>
     <h3>3. Use a simple <code>for</code> loop</h3>
     <p>Sometimes the old ways are the best:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>const a = ["a", "b", "c"];
for (let index = 0; index &lt; a.length; ++index) {
    const element = a[index];
    console.log(element);
}</code></pre>
      </div>
     </div>
     <p></p>
     <p>If the length of the array won't change during the loop, and it's in highly performance-sensitive code, a slightly more complicated version grabbing the length up front might be a <em><strong>tiny</strong></em> bit faster:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>const a = ["a", "b", "c"];
for (let index = 0, len = a.length; index &lt; len; ++index) {
    const element = a[index];
    console.log(element);
}</code></pre>
      </div>
     </div>
     <p></p>
     <p>And/or counting backward:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>const a = ["a", "b", "c"];
for (let index = a.length - 1; index &gt;= 0; --index) {
    const element = a[index];
    console.log(element);
}</code></pre>
      </div>
     </div>
     <p></p>
     <p>But with modern JavaScript engines, it's rare you need to eke out that last bit of juice.</p>
     <p>Before ES2015, the loop variable had to exist in the containing scope, because <code>var</code> only has function-level scope, not block-level scope. But as you saw in the examples above, you can use <code>let</code> within the <code>for</code> to scope the variables to just the loop. And when you do that, the <code>index</code> variable is recreated for each loop iteration, meaning closures created in the loop body keep a reference to the <code>index</code> for that specific iteration, which solves the old "closures in loops" problem:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
      <div class="snippet-code snippet-currently-hidden">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>// (The `NodeList` from `querySelectorAll` is array-like)
const divs = document.querySelectorAll("div");
for (let index = 0; index &lt; divs.length; ++index) {
    divs[index].addEventListener('click', e =&gt; {
        console.log("Index is: " + index);
    });
}</code></pre>
       <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;div&gt;zero&lt;/div&gt;
&lt;div&gt;one&lt;/div&gt;
&lt;div&gt;two&lt;/div&gt;
&lt;div&gt;three&lt;/div&gt;
&lt;div&gt;four&lt;/div&gt;</code></pre>
      </div>
     </div>
     <p></p>
     <p>In the above, you get "Index is: 0" if you click the first and "Index is: 4" if you click the last. This does <strong>not</strong> work if you use <code>var</code> instead of <code>let</code> (you'd always see "Index is: 5").</p>
     <p>Like <code>for-of</code>, <code>for</code> loops work well in <code>async</code> functions. Here's the earlier example using a <code>for</code> loop:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
      <div class="snippet-code snippet-currently-hidden">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function delay(ms) {
    return new Promise(resolve =&gt; {
        setTimeout(resolve, ms);
    });
}

async function showSlowly(messages) {
    for (let i = 0; i &lt; messages.length; ++i) {
        const message = messages[i];
        await delay(400);
        console.log(message);
    }
}

showSlowly([
    "So", "long", "and", "thanks", "for", "all", "the", "fish!"
]);
// `.catch` omitted because we know it never rejects</code></pre>
      </div>
     </div>
     <p></p>
     <h3>4. Use <code>for-in</code> <em>correctly</em></h3>
     <p><code>for-in</code> isn't for looping through arrays, it's for looping through the names of an object's properties. It does often seem to work for looping through arrays as a by-product of the fact that arrays are objects, but it doesn't just loop through the array indexes, it loops through <strong>all</strong> enumerable properties of the object (including inherited ones). (It also used to be that the order wasn't specified; it is now [details in <a href="https://stackoverflow.com/a/30919039/157247">this other answer</a>], but even though the order is specified now, the rules are complex, there are exceptions, and relying on the order is not best practice.)</p>
     <p>The only real use cases for <code>for-in</code> on an array are:</p>
     <ul>
      <li>It's a <a href="http://en.wikipedia.org/wiki/Sparse_array" rel="noreferrer"><em>sparse</em> array</a> with <strong>massive</strong> gaps in it, or</li>
      <li>You're using non-element properties on the array object and you want to include them in the loop</li>
     </ul>
     <p>Looking only at that first example: You can use <code>for-in</code> to visit those sparse array elements if you use appropriate safeguards:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>// `a` is a sparse array
const a = [];
a[0] = "a";
a[10] = "b";
a[10000] = "c";
for (const name in a) {
    if (Object.hasOwn(a, name) &amp;&amp;       // These checks are
        /^0$|^[1-9]\d*$/.test(name) &amp;&amp;  // explained
        name &lt;= 4294967294              // below
       ) {
        const element = a[name];
        console.log(a[name]);
    }
}</code></pre>
      </div>
     </div>
     <p></p>
     <p>Note the three checks:</p>
     <ol>
      <li>
       <p>That the object has its <em>own</em> property by that name (not one it inherits from its prototype; this check is also often written as <code>a.hasOwnProperty(name)</code> but ES2022 adds <a href="https://github.com/tc39/proposal-accessible-object-hasownproperty" rel="noreferrer"><code>Object.hasOwn</code></a> which can be more reliable), and</p></li>
      <li>
       <p>That the name is all decimal digits (e.g., normal string form, not scientific notation), and</p></li>
      <li>
       <p>That the name's value when coerced to a number is &lt;= 2^32 - 2 (which is 4,294,967,294). Where does that number come from? It's part of the definition of an array index <a href="https://tc39.es/ecma262/#array-index" rel="noreferrer">in the specification</a>. Other numbers (non-integers, negative numbers, numbers greater than 2^32 - 2) are not array indexes. The reason it's 2^32 - <strong>2</strong> is that that makes the greatest index value one lower than 2^32 - <strong>1</strong>, which is the maximum value an array's <code>length</code> can have. (E.g., an array's length fits in a 32-bit unsigned integer.)</p></li>
     </ol>
     <p>...although with that said, most code only does the <code>hasOwnProperty</code> check.</p>
     <p>You wouldn't do that in inline code, of course. You'd write a utility function. Perhaps:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
      <div class="snippet-code snippet-currently-hidden">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>// Utility function for antiquated environments without `forEach`
const hasOwn = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);
const rexNum = /^0$|^[1-9]\d*$/;
function sparseEach(array, callback, thisArg) {
    for (const name in array) {
        const index = +name;
        if (hasOwn(a, name) &amp;&amp;
            rexNum.test(name) &amp;&amp;
            index &lt;= 4294967294
           ) {
            callback.call(thisArg, array[name], index, array);
        }
    }
}

const a = [];
a[5] = "five";
a[10] = "ten";
a[100000] = "one hundred thousand";
a.b = "bee";

sparseEach(a, (value, index) =&gt; {
    console.log("Value at " + index + " is " + value);
});</code></pre>
      </div>
     </div>
     <p></p>
     <p>Like <code>for</code>, <code>for-in</code> works well in asynchronous functions if the work within it needs to be done in series.</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
      <div class="snippet-code snippet-currently-hidden">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function delay(ms) {
    return new Promise(resolve =&gt; {
        setTimeout(resolve, ms);
    });
}

async function showSlowly(messages) {
    for (const name in messages) {
        if (messages.hasOwnProperty(name)) { // Almost always this is the only check people do
            const message = messages[name];
            await delay(400);
            console.log(message);
        }
    }
}

showSlowly([
    "So", "long", "and", "thanks", "for", "all", "the", "fish!"
]);
// `.catch` omitted because we know it never rejects</code></pre>
      </div>
     </div>
     <p></p>
     <h3>5. Use an iterator explicitly (ES2015+)</h3>
     <p><code>for-of</code> uses an iterator implicitly, doing all the scut work for you. Sometimes, you might want to use an iterator <em>explicitly</em>. It looks like this:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>const a = ["a", "b", "c"];
const it = a.values(); // Or `const it = a[Symbol.iterator]();` if you like
let entry;
while (!(entry = it.next()).done) {
    const element = entry.value;
    console.log(element);
}</code></pre>
      </div>
     </div>
     <p></p>
     <p>An iterator is an object matching the Iterator definition in the specification. Its <code>next</code> method returns a new <em>result object</em> each time you call it. The result object has a property, <code>done</code>, telling us whether it's done, and a property <code>value</code> with the value for that iteration. (<code>done</code> is optional if it would be <code>false</code>, <code>value</code> is optional if it would be <code>undefined</code>.)</p>
     <p>What you get for <code>value</code> varies depending on the iterator. On arrays, the default iterator provides the value of each array element (<code>"a"</code>, <code>"b"</code>, and <code>"c"</code> in the example earlier). Arrays also have three other methods that return iterators:</p>
     <ul>
      <li><code>values()</code>: This is an alias for the <code>[Symbol.iterator]</code> method that returns the default iterator.</li>
      <li><code>keys()</code>: Returns an iterator that provides each key (index) in the array. In the example above, it would provide <code>"0"</code>, then <code>"1"</code>, then <code>"2"</code> (yes, as strings).</li>
      <li><code>entries()</code>: Returns an iterator that provides <code>[key, value]</code> arrays.</li>
     </ul>
     <p>Since iterator objects don't advance until you call <code>next</code>, they work well in <code>async</code> function loops. Here's the earlier <code>for-of</code> example using the iterator explicitly:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
      <div class="snippet-code snippet-currently-hidden">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function delay(ms) {
    return new Promise(resolve =&gt; {
        setTimeout(resolve, ms);
    });
}

async function showSlowly(messages) {
    const it = messages.values()
    while (!(entry = it.next()).done) {
        await delay(400);
        const element = entry.value;
        console.log(element);
    }
}

showSlowly([
    "So", "long", "and", "thanks", "for", "all", "the", "fish!"
]);
// `.catch` omitted because we know it never rejects</code></pre>
      </div>
     </div>
     <p></p>
     <h2>For Array-Like Objects</h2>
     <p>Aside from true arrays, there are also <em>array-like</em> objects that have a <code>length</code> property and properties with all-digits names: <a href="https://dom.spec.whatwg.org/#interface-nodelist" rel="noreferrer"><code>NodeList</code> instances</a>, <a href="https://dom.spec.whatwg.org/#interface-htmlcollection" rel="noreferrer"><code>HTMLCollection</code> instances</a>, the <code>arguments</code> object, etc. How do we loop through their contents?</p>
     <h3>Use most of the options above</h3>
     <p>At least some, and possibly most or even all, of the array approaches above apply equally well to array-like objects:</p>
     <ol>
      <li>
       <p><strong>Use <code>for-of</code> (use an iterator implicitly) (ES2015+)</strong></p>
       <p><code>for-of</code> uses the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noreferrer">iterator</a> provided by the object (if any). That includes host-provided objects (like DOM collections and lists). For instance, <code>HTMLCollection</code> instances from <code>getElementsByXYZ</code> methods and <code>NodeList</code>s instances from <code>querySelectorAll</code> both support iteration. (This is defined <strong>quite</strong> subtly by the HTML and DOM specifications. Basically, any object with <code>length</code> and indexed access is automatically iterable. It <strong>doesn't</strong> have to be marked <code>iterable</code>; that is used only for collections that, in addition to being iterable, support <code>forEach</code>, <code>values</code>, <code>keys</code>, and <code>entries</code> methods. <code>NodeList</code> does; <code>HTMLCollection</code> doesn't, but both are iterable.)</p>
       <p>Here's an example of looping through <code>div</code> elements:</p></li>
     </ol>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
      <div class="snippet-code snippet-currently-hidden">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>const divs = document.querySelectorAll("div");
for (const div of divs) {
    div.textContent = Math.random();
}</code></pre>
       <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;div&gt;zero&lt;/div&gt;
&lt;div&gt;one&lt;/div&gt;
&lt;div&gt;two&lt;/div&gt;
&lt;div&gt;three&lt;/div&gt;
&lt;div&gt;four&lt;/div&gt;</code></pre>
      </div>
     </div>
     <p></p>
     <ol start="2">
      <li>
       <p><strong>Use <code>forEach</code> and related (ES5+)</strong></p>
       <p>The various functions on <code>Array.prototype</code> are "intentionally generic" and can be used on array-like objects via <code>Function#call</code> (<a href="https://tc39.es/ecma262/#sec-function.prototype.call" rel="noreferrer">spec</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" rel="noreferrer">MDN</a>) or <code>Function#apply</code> (<a href="https://tc39.es/ecma262/#sec-function.prototype.apply" rel="noreferrer">spec</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" rel="noreferrer">MDN</a>). (If you have to deal with IE8 or earlier [ouch], see the "Caveat for host-provided objects" at the end of this answer, but it's not an issue with vaguely-modern browsers.)</p>
       <p>Suppose you wanted to use <code>forEach</code> on a <code>Node</code>'s <code>childNodes</code> collection (which, being an <code>HTMLCollection</code>, doesn't have <code>forEach</code> natively). You'd do this:</p>
       <pre><code>Array.prototype.forEach.call(node.childNodes, (child) =&gt; {
    // Do something with `child`
});
</code></pre>
       <p>(Note, though, that you could just use <code>for-of</code> on <code>node.childNodes</code>.)</p>
       <p>If you're going to do that a lot, you might want to grab a copy of the function reference into a variable for reuse, e.g.:</p>
       <pre><code>// (This is all presumably in a module or some scoping function)
const forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);

// Then later...
forEach(node.childNodes, (child) =&gt; {
    // Do something with `child`
});
</code></pre></li>
      <li>
       <p><strong>Use a simple <code>for</code> loop</strong></p>
       <p>Perhaps obviously, a simple <code>for</code> loop works for array-like objects.</p></li>
      <li>
       <p><strong>Use an iterator explicitly (ES2015+)</strong></p>
       <p>See #1.</p></li>
     </ol>
     <p>You <em><strong>may</strong></em> be able to get away with <code>for-in</code> (with safeguards), but with all of these more appropriate options, there's no reason to try.</p>
     <h3>Create a true array</h3>
     <p>Other times, you may want to convert an array-like object into a true array. Doing that is surprisingly easy:</p>
     <ol>
      <li>
       <p><strong>Use <code>Array.from</code></strong></p>
       <p><code>Array.from</code> <a href="https://tc39.es/ecma262/#sec-array.from" rel="noreferrer">(spec)</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from" rel="noreferrer">(MDN)</a> (ES2015+, but easily polyfilled) creates an array from an array-like object, optionally passing the entries through a mapping function first. So:</p>
       <pre><code>const divs = Array.from(document.querySelectorAll("div"));
</code></pre>
       <p>...takes the <code>NodeList</code> from <code>querySelectorAll</code> and makes an array from it.</p>
       <p>The mapping function is handy if you were going to map the contents in some way. For instance, if you wanted to get an array of the tag names of the elements with a given class:</p>
       <pre><code>// Typical use (with an arrow function):
const divs = Array.from(document.querySelectorAll(".some-class"), element =&gt; element.tagName);

// Traditional function (since `Array.from` can be polyfilled):
var divs = Array.from(document.querySelectorAll(".some-class"), function(element) {
    return element.tagName;
});
</code></pre></li>
      <li>
       <p><strong>Use spread syntax (<code>...</code>)</strong></p>
       <p>It's also possible to use ES2015's <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noreferrer">spread syntax</a>. Like <code>for-of</code>, this uses the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noreferrer">iterator</a> provided by the object (see #1 in the previous section):</p>
       <pre><code>const trueArray = [...iterableObject];
</code></pre>
       <p>So for instance, if we want to convert a <code>NodeList</code> into a true array, with spread syntax this becomes quite succinct:</p>
       <pre><code>const divs = [...document.querySelectorAll("div")];
</code></pre></li>
      <li>
       <p><strong>Use the <code>slice</code> method of arrays</strong></p>
       <p>We can use the <a href="https://tc39.es/ecma262/#sec-array.prototype.slice" rel="noreferrer"><code>slice</code></a> method of arrays, which like the other methods mentioned above is "intentionally generic" and so can be used with array-like objects, like this:</p>
       <pre><code>const trueArray = Array.prototype.slice.call(arrayLikeObject);
</code></pre>
       <p>So for instance, if we want to convert a <code>NodeList</code> into a true array, we could do this:</p>
       <pre><code>const divs = Array.prototype.slice.call(document.querySelectorAll("div"));
</code></pre>
       <p>(If you still have to handle IE8 [ouch], will fail; IE8 didn't let you use host-provided objects as <code>this</code> like that.)</p></li>
     </ol>
     <h3>Caveat for host-provided objects</h3>
     <p>If you use <code>Array.prototype</code> functions with <em>host-provided</em> array-like objects (for example, DOM collections and such provided by the browser rather than the JavaScript engine), obsolete browsers like IE8 didn't necessarily handle that way, so if you have to support them, be sure to test in your target environments. But it's not an issue with vaguely-modern browsers. (For non-browser environments, naturally it'll depend on the environment.)</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>What do you mean by non-element properties?</span> <span> - </span> <span class="display-name">Aalexander</span> <span> </span> <span class="date">9 Dec 2020 at 13:08</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@Alex - Properties on the array that don't represent array elements. For example: <code>const a = ["a", "b"]; a.example = 42;</code> That array has three properties (other than the ones all arrays have), whose names are the strings <code>"0"</code>, <code>"1"</code>, and <code>"example"</code>. The property named <code>"example"</code> is a non-element property. The other two are element properties, because they represent the elements of the array.</span> <span> - </span> <span class="display-name">T.J. Crowder</span> <span> </span> <span class="date">9 Dec 2020 at 13:18</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>None of these options address traversing associative arrays in which the index names are just as important as the values.</span> <span> - </span> <span class="display-name">Peter Kionga-Kamau</span> <span> </span> <span class="date">14 Oct 2021 at 10:29</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@PeterKionga-Kamau - JavaScript doesn't have associative arrays. But re indexes, three of the TL;DR "best bets" provide them: <code>forEach</code>, a simple old-fashioned <code>for</code> loop, and <code>for-in</code> with safeguards.</span> <span> - </span> <span class="display-name">T.J. Crowder</span> <span> </span> <span class="date">14 Oct 2021 at 10:36</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Wow, @captain-yossarian, that was generous! Not sure what prompted it, and it wasn't necessary (the answer's more than done enough for my rep, and I have the luxury of having enough rep not to care about it anymore), but it was a kind thing to do, thanks!</span> <span> - </span> <span class="display-name">T.J. Crowder</span> <span> </span> <span class="date">9 Nov 2021 at 10:08</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@T.J.Crowder sure it does <code>var arr = new Array(); arr = {"test":"testval", "test2":"test2val"};</code></span> <span> - </span> <span class="display-name">Peter Kionga-Kamau</span> <span> </span> <span class="date">16 Nov 2021 at 12:31</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@PeterKionga-Kamau - That's not an associative array, it's an object. The array you're creating in <code>var arr = new Array();</code> is thrown away and replaced by the object you're creating in <code>arr = {"test":"testval", "test2":"test2val"};</code>. That code should be just <code>var arr = {"test":"testval", "test2":"test2val"};</code> (well, not <code>var</code>, but <code>let</code> or <code>const</code>). Granted, by some definitions objects might be considered associative arrays, but by others they aren't and I avoid the term in JS because it has specific meaning in PHP, which is JavaScript-adjacent due to their both being used a lot in web work.</span> <span> - </span> <span class="display-name">T.J. Crowder</span> <span> </span> <span class="date">16 Nov 2021 at 12:36</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@T.J.Crowder so pedanticism aside, still unclear how to access the index of an associative <i>object</i></span> <span> - </span> <span class="display-name">Peter Kionga-Kamau</span> <span> </span> <span class="date">16 Nov 2021 at 12:43</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@PeterKionga-Kamau - The question and answer are about arrays, not (other) objects. But: Object properties don't have indexes, so objects don't have indexed access; instead they have <i>keyed</i> access (<code>theObject.propName</code>, <code>theObject["propName"]</code>, <code>theObject[propKeySymbol]</code>, etc.). The concept of indexed access isn't useful with regard to objects. It's very indirectly possible, though. 🙂 Object properties do have an order now (ES2015+, with tweaks in a couple of later specs), but the order is complicated, and it depends on the order of property creation, the type of the property key, ...</span> <span> - </span> <span class="display-name">T.J. Crowder</span> <span> </span> <span class="date">16 Nov 2021 at 14:26</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>...the value (!) of the property key if it's a string, and whether the property is inherited or "own," so it's poor practice to rely on property order. If one wanted to do it anyway, there's no one operation that provides all of the property keys in order, but <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys" rel="nofollow noreferrer"><code>Reflect.ownKeys</code></a> provides an array of the object's <i>own</i> property keys in order (skipping inherited ones). So if that suits the use case, you can get an array from that (<code>const keys = Reflect.ownKeys(theObject);</code>). ...</span> <span> - </span> <span class="display-name">T.J. Crowder</span> <span> </span> <span class="date">16 Nov 2021 at 14:26</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>... Then "indexed" access would be indexing into that array for the key, then getting the value from the object using the key: <code>theObject[keys[index]]</code>. I can't imagine a use case for it, though. If you want all of the object's properties (inherited + own), it's more complicated, you have to loop up through the prototype chain appending properties you haven't seen yet (<code>Set</code> is probably useful there, because <code>Set</code> is strictly ordered by value insertion and doesn't allow duplication): ...</span> <span> - </span> <span class="display-name">T.J. Crowder</span> <span> </span> <span class="date">16 Nov 2021 at 14:26</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>... <code>let keys = []; for (let obj = theObject; obj; obj = Object.getPrototypeOf(obj)) { keys.push(...Reflect.ownKeys(obj)); } keys = [...new Set(keys)];</code> That works because inherited properties that haven't been shadowed by own properties appear after own properties in the defined order; so we build an array containing the own properties of the target object, then the own properties of its prototype, then <i>its</i> prototype, etc. That array will have duplicates if both an object and one of its prototypes have a property, but the "own" one will come first in the array; when we...</span> <span> - </span> <span class="display-name">T.J. Crowder</span> <span> </span> <span class="date">16 Nov 2021 at 14:26</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>...pass it through <code>Set</code>, those earlier ones "win" in the order of the resulting <code>Set</code> and later ones are dropped, as per spec (<a href="https://tc39.es/ecma262/#sec-enumerate-object-properties" rel="nofollow noreferrer">details here</a>). Hope that helps! 🙂</span> <span> - </span> <span class="display-name">T.J. Crowder</span> <span> </span> <span class="date">16 Nov 2021 at 14:27</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@PeterKionga-Kamau - Very belatedly I realize you might find this useful: <a href="https://stackoverflow.com/questions/684672/how-do-i-loop-through-or-enumerate-a-javascript-object" title="how do i loop through or enumerate a javascript object">stackoverflow.com/questions/684672/…</a></span> <span> - </span> <span class="display-name">T.J. Crowder</span> <span> </span> <span class="date">16 Nov 2021 at 14:33</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>is the map better than forEach</span> <span> - </span> <span class="display-name">Houssem TRABELSI</span> <span> </span> <span class="date">23 Dec 2021 at 16:53</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@HoussemTRABELSI - No, they're just different, they serve different purposes. <code>map</code> is for when you want to create a new array from the elements of the original array (one for one), for instance if you had an array of strings (<code>["a", "b", "c"]</code>) and you wanted to get an array of those same strings capitalized (<code>["A", "B", "C"</code>]<code>), </code>map` would be the right tool to use. If you don't want to create a new array, <code>map</code> is not the right tool. More in my blog post <a href="https://thenewtoys.dev/blog/2021/04/17/misusing-map/" rel="nofollow noreferrer">here</a>.</span> <span> - </span> <span class="display-name">T.J. Crowder</span> <span> </span> <span class="date">24 Dec 2021 at 14:30</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Why do I need to declare the element? Why <code>for (Array(10) { console.log('1'); }</code> does not work. Nor <code>Array(10).forEach(()=&gt; console.log('1'))</code>...</span> <span> - </span> <span class="display-name">Fred Guth</span> <span> </span> <span class="date">8 Jul 2022 at 13:02</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@FredGuth - That first is invalid syntax. The second doesn't (seem to) do anything because <code>forEach</code> doesn't visit holes in sparse arrays. <code>Array(10)</code> creates an empty array with a <code>length</code> of <code>10</code>. So it's a sparse array that only has holes, no elements, so there's nothing for <code>forEach</code> to visit. (I mention this only very briefly in passing in the answer above: <i>"The callback is called for each element in the array, in order, skipping non-existent elements in sparse arrays."</i>) Other mechanisms may handle holes differently. For instance, <code>for-of</code> will act like holes are elements with ...</span> <span> - </span> <span class="display-name">T.J. Crowder</span> <span> </span> <span class="date">8 Jul 2022 at 13:25</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>... <code>undefined</code> in them, as will <code>Array.from</code>. For instance, <code>Array.from({length:10}, () =&gt; { console.log(1); });</code> will log <code>1</code> ten times in the process of creating a non-sparse array.</span> <span> - </span> <span class="display-name">T.J. Crowder</span> <span> </span> <span class="date">8 Jul 2022 at 13:27</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>568</span>
     </div>
     <div>
      <span>Answerer: </span> <span>PatrikAkerstrand</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Feb 2012 at 13:55</span>
     </div>
    </div>
    <div>
     <p><strong>Note</strong>: This answer is hopelessly out-of-date. For a more modern approach, look at <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noreferrer">the methods available on an array</a>. Methods of interest might be:</p>
     <ul>
      <li>forEach</li>
      <li>map</li>
      <li>filter</li>
      <li>zip</li>
      <li>reduce</li>
      <li>every</li>
      <li>some</li>
     </ul>
     <hr>
     <p>The standard way to iterate an array in <a href="http://en.wikipedia.org/wiki/JavaScript" rel="noreferrer">JavaScript</a> is a vanilla <code>for</code>-loop:</p>
     <pre><code>var length = arr.length,
    element = null;
for (var i = 0; i &lt; length; i++) {
  element = arr[i];
  // Do something with element
}
</code></pre>
     <p>Note, however, that this approach is only good if you have a dense array, and each index is occupied by an element. If the array is sparse, then you can run into performance problems with this approach, since you will iterate over a lot of indices that do not <em>really</em> exist in the array. In this case, a <code>for .. in</code>-loop might be a better idea. <strong>However</strong>, you must use the appropriate safeguards to ensure that only the desired properties of the array (that is, the array elements) are acted upon, since the <code>for..in</code>-loop will also be enumerated in legacy browsers, or if the additional properties are defined as <code>enumerable</code>.</p>
     <p>In <a href="https://en.wikipedia.org/wiki/ECMAScript#ECMAScript.2C_5th_Edition" rel="noreferrer">ECMAScript 5</a> there will be a forEach method on the array prototype, but it is not supported in legacy browsers. So to be able to use it consistently you must either have an environment that supports it (for example, <a href="http://en.wikipedia.org/wiki/Node.js" rel="noreferrer">Node.js</a> for server side JavaScript), or use a "Polyfill". The Polyfill for this functionality is, however, trivial and since it makes the code easier to read, it is a good polyfill to include.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Is there a way to do it in just one line of code. For example in facebook I like to speed up videos with <code>document.getElementsByTagName("video")[28].playbackRate = 2.2</code>. If I could easily map across all elements then I could avoid having to identify which video (e.g. index 28 in this case). Any ideas?</span> <span> - </span> <span class="display-name">stevec</span> <span> </span> <span class="date">5 Sep 2020 at 19:39</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@stevec: Array.from(document.querySelectorAll('video')).forEach(video =&gt; video.playbackRate = 2.2);</span> <span> - </span> <span class="display-name">PatrikAkerstrand</span> <span> </span> <span class="date">14 Sep 2020 at 06:24</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="nofollow noreferrer">Your link to the methods available on an array</a> doesn't provide anything for <code>.zip</code> - how does it work? Analogous to Python?</span> <span> - </span> <span class="display-name">Cadoiz</span> <span> </span> <span class="date">22 May 2023 at 12:37</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>274</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Poonam</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Feb 2012 at 14:01</span>
     </div>
    </div>
    <div>
     <p>If you’re using the <a href="http://jquery.com/" rel="noreferrer"><strong>jQuery</strong></a> library, you can use <a href="http://api.jquery.com/jQuery.each/" rel="noreferrer"><strong>jQuery.each</strong></a>:</p>
     <pre class="lang-js prettyprint-override"><code>$.each(yourArray, function(index, value) {
  // do your stuff here
});
</code></pre>
     <p><strong>EDIT :</strong></p>
     <p>As per question, user want code in javascript instead of jquery so the edit is</p>
     <pre class="lang-js prettyprint-override"><code>var length = yourArray.length;   
for (var i = 0; i &lt; length; i++) {
  // Do something with yourArray[i].
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>150</span>
     </div>
     <div>
      <span>Answerer: </span> <span>joeytwiddle</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 May 2014 at 14:21</span>
     </div>
    </div>
    <div>
     <h1>Loop backwards</h1>
     <p>I think the <em>reverse</em> for loop deserves a mention here:</p>
     <pre><code>for (var i = array.length; i--; ) {
     // process array[i]
}
</code></pre>
     <h2>Advantages:</h2>
     <ul>
      <li>You do not need to declare a temporary <code>len</code> variable, or compare against <code>array.length</code> on each iteration, either of which might be a minute optimisation.</li>
      <li><strong>Removing siblings</strong> from the DOM in reverse order is usually <strong>more efficient</strong>. (The browser needs to do less shifting of elements in its internal arrays.)</li>
      <li>If you <strong>modify the array</strong> while looping, at or after index <em>i</em> (for example you remove or insert an item at <code>array[i]</code>), then a forward loop would skip the item that shifted left into position <em>i</em>, or re-process the <em>i</em>th item that was shifted right. In a traditional for loop, you <em>could</em> update <em>i</em> to point to the next item that needs processing - 1, but simply reversing the direction of iteration is often a <strong>simpler</strong> and <a href="https://stackoverflow.com/questions/23186254/javascript-splice-changing-earlier-values-in-an-array/23186450#23186450">more elegant solution</a>.</li>
      <li>Similarly, when modifying or removing <strong>nested</strong> DOM elements, processing in reverse can <strong>circumvent errors</strong>. For example, consider modifying the innerHTML of a parent node before handling its children. By the time the child node is reached it will be detached from the DOM, having been replaced by a newly created child when the parent's innerHTML was written.</li>
      <li>It is <strong>shorter</strong> to type, and <strong>read</strong>, than some of the other options available. Although it loses to <code>forEach()</code> and to ES6's <code>for ... of</code>.</li>
     </ul>
     <h2>Disadvantages:</h2>
     <ul>
      <li>It processes the items in reverse order. If you were building a new array from the results, or printing things on screen, naturally <strong>the output will be reversed</strong> with respect to the original order.</li>
      <li>Repeatedly inserting siblings into the DOM as a first child in order to retain their order is <strong>less efficient</strong>. (The browser would keep having to shift things right.) To create DOM nodes efficiently and in order, just loop forwards and append as normal (and also use a "document fragment").</li>
      <li>The reverse loop is <strong>confusing</strong> to junior developers. (You may consider that an advantage, depending on your outlook.)</li>
     </ul>
     <hr>
     <h2>Should I always use it?</h2>
     <p>Some developers use the reverse for loop <em>by default</em>, unless there is a good reason to loop forwards.</p>
     <p>Although the performance gains are usually insignificant, it sort of screams:</p>
     <blockquote>
      <p>"Just do this to every item in the list, I don't care about the order!"</p>
     </blockquote>
     <p>However in practice that is <strong>not</strong> actually a reliable indication of intent, since it is indistinguishable from those occasions when you <strong><em>do</em></strong> care about the order, and really do <strong><em>need</em></strong> to loop in reverse. So in fact another construct would be needed to accurately express the "don't care" intent, something currently unavailable in most languages, including ECMAScript, but which could be called, for example, <code>forEachUnordered()</code>.</p>
     <p>If order doesn't matter, and <strong>efficiency</strong> is a concern (in the innermost loop of a game or animation engine), then it may be acceptable to use the reverse for loop as your go-to pattern. Just remember that seeing a reverse for loop in existing code <strong>does not necessarily mean</strong> that the order irrelevant!</p>
     <h3>It was better to use forEach()</h3>
     <p>In general for higher level code where <strong>clarity and safety</strong> are greater concerns, I previously recommended using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noreferrer"><code>Array::forEach</code></a> as your default pattern for looping (although these days I prefer to use <code>for..of</code>). Reasons to prefer <code>forEach</code> over a reverse loop are:</p>
     <ul>
      <li>It is clearer to read.</li>
      <li>It indicates that <em>i</em> is not going to be shifted within the block (which is always a possible surprise hiding in long <code>for</code> and <code>while</code> loops).</li>
      <li>It gives you a free scope for closures.</li>
      <li>It reduces leakage of local variables and accidental collision with (and mutation of) outer variables.</li>
     </ul>
     <p>Then when you do see the reverse for loop in your code, that is a hint that it is reversed for a good reason (perhaps one of the reasons described above). And seeing a traditional forward for loop may indicate that shifting can take place.</p>
     <p>(If the discussion of intent makes no sense to you, then you and your code may benefit from watching Crockford's lecture on <a href="https://www.youtube.com/watch?v=taaEzHI9xyY&amp;t=480" rel="noreferrer">Programming Style &amp; Your Brain</a>.)</p>
     <h3>It is now even better to use for..of!</h3>
     <p>There is a debate about whether <code>for..of</code> or <code>forEach()</code> are preferable:</p>
     <ul>
      <li>
       <p>For maximum browser support, <code>for..of</code> <a href="https://github.com/airbnb/javascript/issues/1122#issuecomment-471169142" rel="noreferrer">requires a polyfill</a> for iterators, making your app slightly slower to execute and slightly larger to download.</p></li>
      <li>
       <p>For that reason (and to encourage use of <code>map</code> and <code>filter</code>), <a href="https://github.com/airbnb/javascript#iterators-and-generators" rel="noreferrer">some front-end style guides</a> ban <code>for..of</code> completely!</p></li>
      <li>
       <p>But the above concerns is not applicable to Node.js applications, where <code>for..of</code> is now well supported.</p></li>
      <li>
       <p>And furthermore <code>await</code> <a href="https://gist.github.com/joeytwiddle/37d2085425c049629b80956d3c618971" rel="noreferrer">does not work</a> inside <code>forEach()</code>. Using <code>for..of</code> is <a href="https://github.com/airbnb/javascript/issues/1122#issuecomment-259876436" rel="noreferrer">the clearest pattern</a> in this case.</p></li>
     </ul>
     <p>Personally, I tend to use whatever looks easiest to read, unless performance or minification has become a major concern. So these days I prefer to use <code>for..of</code> instead of <code>forEach()</code>, but I will always use <code>map</code> or <code>filter</code> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find" rel="noreferrer"><code>find</code></a> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some" rel="noreferrer"><code>some</code></a> when applicable. (For the sake of my colleagues, I rarely use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noreferrer"><code>reduce</code></a>.)</p>
     <hr>
     <h2>How does it work?</h2>
     <pre><code>for (var i = 0; i &lt; array.length; i++) { ... }   // Forwards

for (var i = array.length; i--; )    { ... }   // Reverse
</code></pre>
     <p>You will notice that <code>i--</code> is the middle clause (where we usually see a comparison) and the last clause is empty (where we usually see <code>i++</code>). That means that <code>i--</code> is also used as the <em>condition</em> for continuation. Crucially, it is executed and checked <em>before</em> each iteration.</p>
     <ul>
      <li>
       <p><strong>How can it start at <code>array.length</code> without exploding?</strong></p>
       <p>Because <code>i--</code> runs <em>before</em> each iteration, on the first iteration we will actually be accessing the item at <code>array.length - 1</code> which avoids any issues with <strike>Array-out-of-bounds</strike> <code>undefined</code> items.</p></li>
      <li>
       <p><strong>Why doesn't it stop iterating before index 0?</strong></p>
       <p>The loop will stop iterating when the condition <code>i--</code> evaluates to a falsey value (when it yields 0).</p>
       <p>The trick is that unlike <code>--i</code>, the trailing <code>i--</code> operator decrements <code>i</code> but yields the value <strong><em>before</em></strong> the decrement. Your console can demonstrate this:</p>
       <p><code>&gt; var i = 5; [i, i--, i];</code></p>
       <p><code>[5, 5, 4]</code></p>
       <p>So on the final iteration, <em>i</em> was previously <strong>1</strong> and the <code>i--</code> expression changes it to <strong>0</strong> but actually yields <strong>1</strong> (truthy), and so the condition passes. On the next iteration <code>i--</code> changes <em>i</em> to <strong>-1</strong> but yields <strong>0</strong> (falsey), causing execution to immediately drop out of the bottom of the loop.</p>
       <p>In the traditional forwards for loop, <code>i++</code> and <code>++i</code> are interchangeable (as Douglas Crockford points out). However in the reverse for loop, because our decrement is also our condition expression, we must stick with <code>i--</code> if we want to process the item at index 0.</p></li>
     </ul>
     <hr>
     <h2>Trivia</h2>
     <p>Some people like to draw a little arrow in the reverse <code>for</code> loop, and end with a wink:</p>
     <pre><code>for (var i = array.length; i --&gt; 0 ;) {
</code></pre>
     <hr>
     <p><em>Credits go to WYL for showing me the benefits and horrors of the reverse for loop.</em></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>99</span>
     </div>
     <div>
      <span>Answerer: </span> <span>zzzzBov</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Feb 2012 at 14:00</span>
     </div>
    </div>
    <div>
     <p>Some <a href="http://en.wikipedia.org/wiki/C_%28programming_language%29" rel="noreferrer">C</a>-style languages use <code>foreach</code> to loop through enumerations. In JavaScript this is done with the <a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for...in" rel="noreferrer"><code>for..in</code> loop structure</a>:</p>
     <pre><code>var index,
    value;
for (index in obj) {
    value = obj[index];
}
</code></pre>
     <p>There is a catch. <code>for..in</code> will loop through each of the object's enumerable members, and the members on its prototype. To avoid reading values that are inherited through the object's prototype, simply check if the property belongs to the object:</p>
     <pre><code>for (i in obj) {
    if (obj.hasOwnProperty(i)) {
        //do stuff
    }
}
</code></pre>
     <p>Additionally, <a href="https://en.wikipedia.org/wiki/ECMAScript#ECMAScript.2C_5th_Edition" rel="noreferrer">ECMAScript 5</a> has added a <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach" rel="noreferrer"><code>forEach</code></a> method to <code>Array.prototype</code> which can be used to enumerate over an array using a calback (the polyfill is in the docs so you can still use it for older browsers):</p>
     <pre><code>arr.forEach(function (val, index, theArray) {
    //do stuff
});
</code></pre>
     <p>It's important to note that <code>Array.prototype.forEach</code> doesn't break when the callback returns <code>false</code>. <a href="http://en.wikipedia.org/wiki/JQuery" rel="noreferrer">jQuery</a> and <a href="http://en.wikipedia.org/wiki/Underscore.js" rel="noreferrer">Underscore.js</a> provide their own variations on <code>each</code> to provide loops that can be short-circuited.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>79</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Felipe Chernicharo</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Aug 2021 at 19:15</span>
     </div>
    </div>
    <div>
     <h1>for...of &nbsp; | &nbsp; forEach &nbsp; | &nbsp; map</h1>
     <h3>Using modern JavaScript syntax to iterate through arrays</h3>
     <pre><code>const fruits = ['🍎', '🍋', '🍌' ]
</code></pre>
     <p>👉🏽 &nbsp; for...of</p>
     <pre><code>for (const fruit of fruits) {
    console.log(fruit)  // '🍎', '🍋', '🍌'
}
</code></pre>
     <p>👉🏽 &nbsp; forEach</p>
     <pre><code>fruits.forEach(fruit =&gt; {
    console.log(fruit)  // '🍎', '🍋', '🍌'
})
</code></pre>
     <p>👉🏽 &nbsp; map</p>
     <p>*Different from the two above, map() <em>creates</em> a new array and expects you to <em>return</em> something after each iteration.</p>
     <pre><code>fruits.map(fruit =&gt; fruit)   // ['🍎', '🍋', '🍌' ]
</code></pre>
     <p>🛑&nbsp; <em><strong>Important</strong></em>: As <strong>map()</strong> is meant to return a value at each iteration, it is an ideal method for transforming elements in arrays:</p>
     <pre><code>fruits.map(fruit =&gt; 'cool ' + fruit)   // ['cool 🍎', 'cool 🍋', 'cool 🍌' ]
</code></pre>
     <p>On the other hand, <b>for...of</b> and <b>forEach( )</b> don't need to return anything and that's why we typically use them to perform logic tasks that manipulate stuff outside.</p>
     <p>So to speak, you're going to find if () statements, side effects, and logging activities in these two.</p>
     <p>👌🏾&nbsp; TIP: you can also have the index (as well as the whole array) in each iteration in your .map() or .forEach() functions.</p>
     <p>Just pass additional arguments to them:</p>
     <pre><code>fruits.map((fruit, i) =&gt;  i + '  ' + fruit)

// ['0 🍎', '1 🍋', '2 🍌' ]

fruits.forEach((f, i, arr) =&gt; {
    console.log( f + ' ' + i + ' ' +  arr )
})

// 🍎  0  🍎, 🍋, 🍌,
// 🍋  1  🍎, 🍋, 🍌,
// 🍌  2  🍎, 🍋, 🍌,
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>55</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Quentin</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Feb 2012 at 13:55</span>
     </div>
    </div>
    <div>
     <p>If you want to loop over an array, use the standard three-part <code>for</code> loop.</p>
     <pre><code>for (var i = 0; i &lt; myArray.length; i++) {
    var arrayItem = myArray[i];
}
</code></pre>
     <p>You can get some performance optimisations by caching <code>myArray.length</code> or iterating over it backwards.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>43</span>
     </div>
     <div>
      <span>Answerer: </span> <span>gaby de wilde</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Mar 2013 at 02:37</span>
     </div>
    </div>
    <div>
     <p>If you don't mind emptying the array:</p>
     <pre><code>var x;

while(x = y.pop()){ 

    alert(x); //do something 

}
</code></pre>
     <p><code>x</code> will contain the last value of <code>y</code> and it will be removed from the array. You can also use <code>shift()</code> which will give and remove the first item from <code>y</code>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>40</span>
     </div>
     <div>
      <span>Answerer: </span> <span>nmoliveira</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Apr 2013 at 00:26</span>
     </div>
    </div>
    <div>
     <p>A <strong>forEach</strong> implementation (<a href="http://jsfiddle.net/nmoliveira/zNsyB/" rel="noreferrer">see in jsFiddle</a>):</p>
     <pre><code>function forEach(list,callback) {
  var length = list.length;
  for (var n = 0; n &lt; length; n++) {
    callback.call(list[n]);
  }
}

var myArray = ['hello','world'];

forEach(
  myArray,
  function(){
    alert(this); // do something
  }
);
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>40</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user2359695</span>
     </div>
     <div>
      <span> Answered: </span> <span>20 Jun 2014 at 22:56</span>
     </div>
    </div>
    <div>
     <p>I know this is an old post, and there are so many great answers already. For a little more completeness I figured I'd throw in another one using <a href="https://angularjs.org/" rel="noreferrer">AngularJS</a>. Of course, this only applies if you're using Angular, obviously, nonetheless I'd like to put it anyway.</p>
     <p><code>angular.forEach</code> takes 2 arguments and an optional third argument. The first argument is the object (array) to iterate over, the second argument is the iterator function, and the optional third argument is the object context (basically referred to inside the loop as 'this'.</p>
     <p>There are different ways to use the forEach loop of angular. The simplest and probably most used is</p>
     <pre><code>var temp = [1, 2, 3];
angular.forEach(temp, function(item) {
    //item will be each element in the array
    //do something
});
</code></pre>
     <p>Another way that is useful for copying items from one array to another is</p>
     <pre><code>var temp = [1, 2, 3];
var temp2 = [];
angular.forEach(temp, function(item) {
    this.push(item); //"this" refers to the array passed into the optional third parameter so, in this case, temp2.
}, temp2);
</code></pre>
     <p>Though, you don't have to do that, you can simply do the following and it's equivalent to the previous example:</p>
     <pre><code>angular.forEach(temp, function(item) {
    temp2.push(item);
});
</code></pre>
     <p>Now there are pros and cons of using the <code>angular.forEach</code> function as opposed to the built in vanilla-flavored <code>for</code> loop.</p>
     <p><strong>Pros</strong></p>
     <ul>
      <li>Easy readability</li>
      <li>Easy writability</li>
      <li>If available, <code>angular.forEach</code> will use the ES5 forEach loop. Now, I will get to efficientcy in the cons section, as the forEach loops are <em>much</em> slower than the for loops. I mention this as a pro because it's nice to be consistent and standardized.</li>
     </ul>
     <p>Consider the following 2 nested loops, which do exactly the same thing. Let's say that we have 2 arrays of objects and each object contains an array of results, each of which has a Value property that's a string (or whatever). And let's say we need to iterate over each of the results and if they're equal then perform some action:</p>
     <pre><code>angular.forEach(obj1.results, function(result1) {
    angular.forEach(obj2.results, function(result2) {
        if (result1.Value === result2.Value) {
            //do something
        }
    });
});

//exact same with a for loop
for (var i = 0; i &lt; obj1.results.length; i++) {
    for (var j = 0; j &lt; obj2.results.length; j++) {
        if (obj1.results[i].Value === obj2.results[j].Value) {
            //do something
        }
    }
}
</code></pre>
     <p>Granted this is a very simple hypothetical example, but I've written triple embedded for loops using the second approach and it was <em>very</em> hard to read, and write for that matter.</p>
     <p><strong>Cons</strong></p>
     <ul>
      <li>Efficiency. <code>angular.forEach</code>, and the native <code>forEach</code>, for that matter, are both <em>so much</em> slower than the normal <code>for</code> loop....about <a href="http://jsperf.com/angular-foreach-vs-native-for-loop/3" rel="noreferrer">90% slower</a>. So for large data sets, best to stick to the native <code>for</code> loop.</li>
      <li>No break, continue, or return support. <code>continue</code> is actually supported by "<a href="https://github.com/angular/angular.js/issues/263" rel="noreferrer">accident</a>", to continue in an <code>angular.forEach</code> you simple put a <code>return;</code> statement in the function like <code>angular.forEach(array, function(item) { if (someConditionIsTrue) return; });</code> which will cause it to continue out of the function for that iteration. This is also due to the fact that the native <code>forEach</code> does not support break or continue either.</li>
     </ul>
     <p>I'm sure there's various other pros and cons as well, and please feel free to add any that you see fit. I feel that, bottom line, if you need efficiency, stick with just the native <code>for</code> loop for your looping needs. But, if your datasets are smaller and a some efficiency is okay to give up in exchange for readability and writability, then by all means throw an <code>angular.forEach</code> in that bad boy.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>38</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Zaz</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 May 2016 at 16:14</span>
     </div>
    </div>
    <div>
     <p><strong>As of ECMAScript&nbsp;6:</strong></p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>list = [0, 1, 2, 3]
for (let obj of list) {
    console.log(obj)
}</code></pre>
      </div>
     </div>
     <p></p>
     <p>Where <code>of</code> avoids the oddities associated with <code>in</code> and makes it work like the <code>for</code> loop of any other language, and <code>let</code> binds <code>i</code> within the loop as opposed to within the function.</p>
     <p>The braces (<code>{}</code>) can be omitted when there is only one command (e.g. in the example above).</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>34</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Federico Piragua</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Nov 2013 at 02:23</span>
     </div>
    </div>
    <div>
     <p>Probably the <code>for(i = 0; i &lt; array.length; i++)</code> loop is not the best choice. Why? If you have this:</p>
     <pre><code>var array = new Array();
array[1] = "Hello";
array[7] = "World";
array[11] = "!";
</code></pre>
     <p>The method will call from <code>array[0]</code> to <code>array[2]</code>. First, this will first reference variables you don't even have, second you would not have the variables in the array, and third this will make the code bolder. Look here, it's what I use:</p>
     <pre><code>for(var i in array){
    var el = array[i];
    //If you want 'i' to be INT just put parseInt(i)
    //Do something with el
}
</code></pre>
     <p>And if you want it to be a function, you can do this:</p>
     <pre><code>function foreach(array, call){
    for(var i in array){
        call(array[i]);
    }
}
</code></pre>
     <p>If you want to break, a little more logic:</p>
     <pre><code>function foreach(array, call){
    for(var i in array){
        if(call(array[i]) == false){
            break;
        }
    }
}
</code></pre>
     <p>Example:</p>
     <pre><code>foreach(array, function(el){
    if(el != "!"){
        console.log(el);
    } else {
        console.log(el+"!!");
    }
});
</code></pre>
     <p>It returns:</p>
     <pre><code>//Hello
//World
//!!!
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>34</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Rajesh Paul</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Dec 2013 at 16:14</span>
     </div>
    </div>
    <div>
     <p>There are three implementations of <code>foreach</code> in <a href="http://en.wikipedia.org/wiki/JQuery">jQuery</a> as follows.</p>
     <pre><code>var a = [3,2];

$(a).each(function(){console.log(this.valueOf())}); //Method 1
$.each(a, function(){console.log(this.valueOf())}); //Method 2
$.each($(a), function(){console.log(this.valueOf())}); //Method 3
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span> <span class="arrow"> <a href="#answer_15">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>33</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Micka</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Jul 2013 at 09:07</span>
     </div>
    </div>
    <div>
     <p>An easy solution now would be to use the <a href="https://en.wikipedia.org/wiki/Underscore.js">underscore.js library</a>. It's providing many useful tools, such as <code>each</code> and will automatically delegate the job to the native <code>forEach</code> if available.</p>
     <p><a href="http://codepen.io/Micka33/pen/nbyxf">A CodePen example</a> of how it works is:</p>
     <pre><code>var arr = ["elemA", "elemB", "elemC"];
_.each(arr, function(elem, index, ar)
{
...
});
</code></pre>
     <h3>See also</h3>
     <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Documentation for native <code>Array.prototype.forEach()</code></a>.</li>
      <li>In <em><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for_each...in">for_each...in</a></em> (MDN) it is explained that <code>for each (variable in object)</code> is deprecated as the part of ECMA-357 (<a href="https://developer.mozilla.org/en-US/docs/E4X">EAX</a>) standard.</li>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of">for...of</a> (MDN) describes the next way of iterating using <code>for (variable of object)</code> as the part of the Harmony (ECMAScript&nbsp;6) proposal.</li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_15"><span>Answer 15</span> <span class="arrow"> <a href="#answer_14">↑</a> </span> <span class="arrow"> <a href="#answer_16">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>28</span>
     </div>
     <div>
      <span>Answerer: </span> <span>joidegn</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Feb 2012 at 13:58</span>
     </div>
    </div>
    <div>
     <p>There isn't any <code>for each</code> loop in native <a href="http://en.wikipedia.org/wiki/JavaScript" rel="noreferrer">JavaScript</a>. You can either use libraries to get this functionality (I recommend <a href="http://en.wikipedia.org/wiki/Underscore.js" rel="noreferrer">Underscore.js</a>), use a simple <code>for</code> in loop.</p>
     <pre><code>for (var instance in objects) {
   ...
}
</code></pre>
     <p>However, note that there may be reasons to use an even simpler <code>for</code> loop (see Stack Overflow question <em><a href="https://stackoverflow.com/questions/500504">Why is using “for…in” with array iteration such a bad idea?</a></em>)</p>
     <pre><code>var instance;
for (var i=0; i &lt; objects.length; i++) {
    var instance = objects[i];
    ...
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_16"><span>Answer 16</span> <span class="arrow"> <a href="#answer_15">↑</a> </span> <span class="arrow"> <a href="#answer_17">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>26</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Anil Arya</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Apr 2017 at 16:51</span>
     </div>
    </div>
    <div>
     <p>ECMAScript&nbsp;5 (the version on JavaScript) to work with Arrays:</p>
     <p><strong>forEach</strong> - Iterates through every item in the array and do whatever you need with each item.</p>
     <pre><code>['C', 'D', 'E'].forEach(function(element, index) {
  console.log(element + " is #" + (index+1) + " in the musical scale");
});

// Output
// C is the #1 in musical scale
// D is the #2 in musical scale
// E is the #3 in musical scale
</code></pre>
     <p>In case, more interested on operation on array using some inbuilt feature.</p>
     <p><strong>map</strong> - It creates a new array with the result of the callback function. This method is good to be used when you need to format the elements of your array.</p>
     <pre><code>// Let's upper case the items in the array
['bob', 'joe', 'jen'].map(function(elem) {
  return elem.toUpperCase();
});

// Output: ['BOB', 'JOE', 'JEN']
</code></pre>
     <p><strong>reduce</strong> - As the name says, it reduces the array to a single value by calling the given function passing in the current element and the result of the previous execution.</p>
     <pre><code>[1,2,3,4].reduce(function(previous, current) {
  return previous + current;
});
// Output: 10
// 1st iteration: previous=1, current=2 =&gt; result=3
// 2nd iteration: previous=3, current=3 =&gt; result=6
// 3rd iteration: previous=6, current=4 =&gt; result=10
</code></pre>
     <p><strong>every</strong> - Returns true or false if all the elements in the array pass the test in the callback function.</p>
     <pre><code>// Check if everybody has 18 years old of more.
var ages = [30, 43, 18, 5];
ages.every(function(elem) {
  return elem &gt;= 18;
});

// Output: false
</code></pre>
     <p><strong>filter</strong> - Very similar to every except that filter returns an array with the elements that return true to the given function.</p>
     <pre><code>// Finding the even numbers
[1,2,3,4,5,6].filter(function(elem){
  return (elem % 2 == 0)
});

// Output: [2,4,6]
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_17"><span>Answer 17</span> <span class="arrow"> <a href="#answer_16">↑</a> </span> <span class="arrow"> <a href="#answer_18">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>25</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Alireza</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 May 2017 at 14:32</span>
     </div>
    </div>
    <div>
     <p>There are <strong>a few ways</strong> to loop through an array in JavaScript, as below:</p>
     <p><strong>for</strong> - it's <strong>the most common one</strong>. Full block of code for looping <br></p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>var languages = ["Java", "JavaScript", "C#", "Python"];
var i, len, text;
for (i = 0, len = languages.length, text = ""; i &lt; len; i++) {
    text += languages[i] + "&lt;br&gt;";
}
document.getElementById("example").innerHTML = text;</code></pre>
       <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;p id="example"&gt;&lt;/p&gt;</code></pre>
      </div>
     </div>
     <p></p>
     <p><strong>while</strong> - loop while a condition is through. It seems to be the fastest loop <br></p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>var text = "";
var i = 0;
while (i &lt; 10) {
    text +=  i + ") something&lt;br&gt;";
    i++;
}
document.getElementById("example").innerHTML = text;</code></pre>
       <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;p id="example"&gt;&lt;/p&gt;</code></pre>
      </div>
     </div>
     <p></p>
     <p><strong>do/while</strong> - also loop through a block of code while the condition is true, will run at least one time <br></p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>var text = ""
var i = 0;

do {
    text += i + ") something &lt;br&gt;";
    i++;
}
while (i &lt; 10);

document.getElementById("example").innerHTML = text;</code></pre>
       <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;p id="example"&gt;&lt;/p&gt;</code></pre>
      </div>
     </div>
     <p></p>
     <p><strong>Functional loops</strong> - <code>forEach</code>, <code>map</code>, <code>filter</code>, also <code>reduce</code> (they loop through the function, but they are used if you need to do something with your array, etc.</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>// For example, in this case we loop through the number and double them up using the map function
var numbers = [65, 44, 12, 4];
document.getElementById("example").innerHTML = numbers.map(function(num){return num * 2});</code></pre>
       <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;p id="example"&gt;&lt;/p&gt;</code></pre>
      </div>
     </div>
     <p></p>
     <p>For more information and examples about functional programming on arrays, look at the blog post <em><a href="http://cryto.net/~joepie91/blog/2015/05/04/functional-programming-in-javascript-map-filter-reduce/" rel="noreferrer">Functional programming in JavaScript: map, filter and reduce</a></em>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_18"><span>Answer 18</span> <span class="arrow"> <a href="#answer_17">↑</a> </span> <span class="arrow"> <a href="#answer_19">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>24</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Tim</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Jan 2014 at 15:25</span>
     </div>
    </div>
    <div>
     <p>This is an iterator for NON-sparse list where the index starts at 0, which is the typical scenario when dealing with document.getElementsByTagName or document.querySelectorAll)</p>
     <pre><code>function each( fn, data ) {

    if(typeof fn == 'string')
        eval('fn = function(data, i){' + fn + '}');

    for(var i=0, L=this.length; i &lt; L; i++) 
        fn.call( this[i], data, i );   

    return this;
}

Array.prototype.each = each;  
</code></pre>
     <p><strong>Examples of usage:</strong></p>
     <p><strong>Example #1</strong></p>
     <pre><code>var arr = [];
[1, 2, 3].each( function(a){ a.push( this * this}, arr);
arr = [1, 4, 9]
</code></pre>
     <p><strong>Example #2</strong></p>
     <pre><code>each.call(document.getElementsByTagName('p'), "this.className = data;",'blue');
</code></pre>
     <p>Each p tag gets <code>class="blue"</code></p>
     <p><strong>Example #3</strong></p>
     <pre><code>each.call(document.getElementsByTagName('p'), 
    "if( i % 2 == 0) this.className = data;",
    'red'
);
</code></pre>
     <p>Every other p tag gets <code>class="red"</code>&gt;</p>
     <p><strong>Example #4</strong></p>
     <pre><code>each.call(document.querySelectorAll('p.blue'), 
    function(newClass, i) {
        if( i &lt; 20 )
            this.className = newClass;
    }, 'green'
);
</code></pre>
     <p>And finally the first 20 blue p tags are changed to green</p>
     <p>Caution when using string as function: the function is created out-of-context and ought to be used only where you are certain of variable scoping. Otherwise, better to pass functions where scoping is more intuitive.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_19"><span>Answer 19</span> <span class="arrow"> <a href="#answer_18">↑</a> </span> <span class="arrow"> <a href="#answer_20">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>20</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Priyanshu Chauhan</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Jul 2015 at 07:07</span>
     </div>
    </div>
    <div>
     <p>There's no inbuilt ability to break in <code>forEach</code>. To interrupt execution use the <code>Array#some</code> like below:</p>
     <pre><code>[1,2,3].some(function(number) {
    return number === 1;
});
</code></pre>
     <p>This works because <code>some</code> returns true as soon as any of the callbacks, executed in array order, returns true, short-circuiting the execution of the rest. <a href="https://stackoverflow.com/questions/2641347/how-to-short-circuit-array-foreach-like-calling-break">Original Answer</a> see Array prototype for <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.17" rel="noreferrer">some</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_20"><span>Answer 20</span> <span class="arrow"> <a href="#answer_19">↑</a> </span> <span class="arrow"> <a href="#answer_21">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>19</span>
     </div>
     <div>
      <span>Answerer: </span> <span>mdmundo</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 Jul 2022 at 10:08</span>
     </div>
    </div>
    <div>
     <h3>Use <code>for...of</code> where possible</h3>
     <div class="s-table-container">
      <table class="s-table">
       <thead>
        <tr>
         <th style="text-align: center;"></th>
         <th style="text-align: center;"><code>async</code>/<code>await</code> support</th>
         <th style="text-align: center;">Skips non-numeric props</th>
         <th style="text-align: center;">Immutable index</th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td style="text-align: center;"><a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/for...of" rel="nofollow noreferrer"><code>for...of</code></a></td>
         <td style="text-align: center;">👍</td>
         <td style="text-align: center;">👍</td>
         <td style="text-align: center;">👍</td>
        </tr>
        <tr>
         <td style="text-align: center;"><a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="nofollow noreferrer"><code>forEach()</code></a></td>
         <td style="text-align: center;">❌</td>
         <td style="text-align: center;">👍</td>
         <td style="text-align: center;">👍</td>
        </tr>
        <tr>
         <td style="text-align: center;"><a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/for...in" rel="nofollow noreferrer"><code>for...in</code></a></td>
         <td style="text-align: center;">👍</td>
         <td style="text-align: center;">❌</td>
         <td style="text-align: center;">👍</td>
        </tr>
        <tr>
         <td style="text-align: center;">Regular <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/for" rel="nofollow noreferrer"><code>for</code></a></td>
         <td style="text-align: center;">👍</td>
         <td style="text-align: center;">👍</td>
         <td style="text-align: center;">❌</td>
        </tr>
       </tbody>
      </table>
     </div>
     <p>As one can see in the table above, <code>for...of</code> should be used wherever it fits. Since it supports async functions, skips non-numeric properties and prevents messing up the loop by accidentally modifying the loop index.</p>
     <h4>Syntax</h4>
     <pre class="lang-js prettyprint-override"><code>const nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
for (const num of nums) {
  /* Do something with num */
}
</code></pre>
     <p>See <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/for...of" rel="nofollow noreferrer"><code>for...of</code></a> reference for more examples, link to specification and difference between <code>for...of</code> and <code>for...in</code>. Or maybe check this <a href="https://masteringjs.io/tutorials/fundamentals/array-iterate" rel="nofollow noreferrer">tutorial</a> for some explanation on how they differ.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>Does this advice apply to sparse arrays? Seems like for/of will visit the undefined members, while for/in will only visit the members that have been set to a value. I would have thought for/in would be more convenient in this case.</span> <span> - </span> <span class="display-name">djna</span> <span> </span> <span class="date">8 Sep 2022 at 14:02</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Not friendly for red-green blindness. Can I add checks and crosses or something like this?</span> <span> - </span> <span class="display-name">Cadoiz</span> <span> </span> <span class="date">22 May 2023 at 12:34</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_21"><span>Answer 21</span> <span class="arrow"> <a href="#answer_20">↑</a> </span> <span class="arrow"> <a href="#answer_22">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>18</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Volkan Seçkin Akbayır</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Aug 2015 at 07:27</span>
     </div>
    </div>
    <div>
     <p>I also would like to add this as a composition of a reverse loop and an answer above for someone that would like this syntax too.</p>
     <pre><code>var foo = [object,object,object];
for (var i = foo.length, item; item = foo[--i];) {
    console.log(item);
}
</code></pre>
     <p><strong>Pros:</strong></p>
     <p>The benefit for this: You have the reference already in the first like that won't need to be declared later with another line. It is handy when looping trough the object array.</p>
     <p><strong>Cons:</strong></p>
     <p>This will break whenever the reference is false - falsey (undefined, etc.). It can be used as an advantage though. However, it would make it a little bit harder to read. And also depending on the browser it can be "not" optimized to work faster than the original one.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_22"><span>Answer 22</span> <span class="arrow"> <a href="#answer_21">↑</a> </span> <span class="arrow"> <a href="#answer_23">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>12</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Daniel W.</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Apr 2014 at 11:15</span>
     </div>
    </div>
    <div>
     <p>jQuery way using <code>$.map</code>:</p>
     <pre><code>var data = [1, 2, 3, 4, 5, 6, 7];

var newData = $.map(data, function(element) {
    if (element % 2 == 0) {
        return element;
    }
});

// newData = [2, 4, 6];
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_23"><span>Answer 23</span> <span class="arrow"> <a href="#answer_22">↑</a> </span> <span class="arrow"> <a href="#answer_24">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>11</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Willem van der Veen</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Sep 2018 at 07:55</span>
     </div>
    </div>
    <div>
     <h2>Summary:</h2>
     <p>When iterating over an array, we often want to accomplish one of the following goals:</p>
     <ol>
      <li>
       <p>We want to iterate over the array and create a new array:</p>
       <p><code>Array.prototype.map</code> <br><br></p></li>
      <li>
       <p>We want to iterate over the array and don't create a new array:</p>
       <p><code>Array.prototype.forEach</code> <br><br><code>for..of</code> <strong>loop</strong></p></li>
     </ol>
     <p>In JavaScript, there are many ways of accomplishing both of these goals. However, some are more convenient than others. Below you can find some commonly used methods (the most convenient IMO) to accomplish array iteration in JavaScript.</p>
     <h2>Creating new array: <code>Map</code></h2>
     <p><code>map()</code> is a function located on <code>Array.prototype</code> which can transform every element of an array and then returns a <strong>new</strong> array. <code>map()</code> takes as an argument a callback function and works in the following manner:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>let arr = [1, 2, 3, 4, 5];

let newArr = arr.map((element, index, array) =&gt; {
  return element * 2;
})

console.log(arr);
console.log(newArr);</code></pre>
      </div>
     </div>
     <p></p>
     <p>The callback which we have passed into <code>map()</code> as an argument gets executed for every element. Then an array gets returned which has the same length as the original array. In this new array element is transformed by the callback function passed in as an argument to <code>map()</code>.</p>
     <p>The distinct difference between <code>map</code> and another loop mechanism like <code>forEach</code> and a <code>for..of</code> loop is that <strong><code>map</code> returns a new array and leaves the old array intact</strong> (except if you explicitly manipulate it with thinks like <code>splice</code>).</p>
     <p>Also, note that the <code>map</code> function's callback provides the index number of the current iteration as a second argument. Furthermore, does the third argument provide the array on which <code>map</code> was called? Sometimes these properties can be very useful.</p>
     <h2>Loop using <code>forEach</code></h2>
     <p><code>forEach</code> is a function which is located on <code>Array.prototype</code> which takes a callback function as an argument. It then executes this callback function for every element in the array. In contrast to the <code>map()</code> function, the forEach function returns nothing (<code>undefined</code>). For example:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>let arr = [1, 2, 3, 4, 5];

arr.forEach((element, index, array) =&gt; {

  console.log(element * 2);

  if (index === 4) {
    console.log(array)
  }
  // index, and oldArray are provided as 2nd and 3th argument by the callback

})

console.log(arr);</code></pre>
      </div>
     </div>
     <p></p>
     <p>Just like the <code>map</code> function, the <code>forEach</code> callback provides the index number of the current iteration as a second argument. Also, does the third argument provide the array on which <code>forEach</code> was called?</p>
     <h2>Loop through elements using <code>for..of</code></h2>
     <p>The <code>for..of</code> loop loops through every element of an array (or any other iterable object). It works in the following manner:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>let arr = [1, 2, 3, 4, 5];

for(let element of arr) {
  console.log(element * 2);
}</code></pre>
      </div>
     </div>
     <p></p>
     <p>In the above example, <code>element</code> stands for an array element and <code>arr</code> is the array which we want to loop. Note that the name <code>element</code> is arbitrary, and we could have picked any other name like 'el' or something more declarative when this is applicable.</p>
     <p>Don't confuse the <code>for..in</code> loop with the <code>for..of</code> loop. <code>for..in</code> will loop through all enumerable properties of the array whereas the <code>for..of</code> loop will only loop through the array elements. For example:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>let arr = [1, 2, 3, 4, 5];

arr.foo = 'foo';

for(let element of arr) {
  console.log(element);
}

for(let element in arr) {
  console.log(element);
}</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_24"><span>Answer 24</span> <span class="arrow"> <a href="#answer_23">↑</a> </span> <span class="arrow"> <a href="#answer_25">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>11</span>
     </div>
     <div>
      <span>Answerer: </span> <span>darklightcode</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Oct 2018 at 20:19</span>
     </div>
    </div>
    <div>
     <p><strong>Using loops with ECMAScript&nbsp;6 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noreferrer">destructuring</a> and the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noreferrer">spread operator</a></strong></p>
     <p>Destructuring and using of the spread operator have proven quite useful for newcomers to ECMAScript&nbsp;6 as being more human-readable/aesthetic, although some JavaScript veterans might consider it messy. Juniors or some other people might find it useful.</p>
     <blockquote>
      <p>The following examples will use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" rel="noreferrer"><code>for...of</code></a> statement and the <a href="https://developer.mozilla.org/ro/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noreferrer"><code>.forEach</code></a> method.</p>
      <p><strong>Examples 6, 7, and 8</strong> can be used with any functional loops like <code>.map</code>, <code>.filter</code>, <code>.reduce</code>, <code>.sort</code>, <code>.every</code>, <code>.some</code>. For more information about these methods, check out the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noreferrer">Array Object</a>.</p>
     </blockquote>
     <p><strong>Example 1:</strong> Normal <code>for...of</code> loop - no tricks here.</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>let arrSimple = ['a', 'b', 'c'];

for (let letter of arrSimple) {
  console.log(letter);
}</code></pre>
      </div>
     </div>
     <p></p>
     <p><strong>Example 2:</strong> Split words to characters</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>let arrFruits = ['apple', 'orange', 'banana'];

for (let [firstLetter, ...restOfTheWord] of arrFruits) {
  // Create a shallow copy using the spread operator
  let [lastLetter] = [...restOfTheWord].reverse();
  console.log(firstLetter, lastLetter, restOfTheWord);
}</code></pre>
      </div>
     </div>
     <p></p>
     <p><strong>Example 3:</strong> Looping with a <code>key</code> and <code>value</code></p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>// let arrSimple = ['a', 'b', 'c'];

// Instead of keeping an index in `i` as per example `for(let i = 0 ; i&lt;arrSimple.length;i++)`
// this example will use a multi-dimensional array of the following format type:
// `arrWithIndex: [number, string][]`

let arrWithIndex = [
  [0, 'a'],
  [1, 'b'],
  [2, 'c'],
];

// Same thing can be achieved using `.map` method
// let arrWithIndex = arrSimple.map((i, idx) =&gt; [idx, i]);

// Same thing can be achieved using `Object.entries`
// NOTE: `Object.entries` method doesn't work on Internet Explorer  unless it's polyfilled
// let arrWithIndex = Object.entries(arrSimple);

for (let [key, value] of arrWithIndex) {
  console.log(key, value);
}</code></pre>
      </div>
     </div>
     <p></p>
     <p><strong>Example 4:</strong> Get object properties inline</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>let arrWithObjects = [{
    name: 'Jon',
    age: 32
  },
  {
    name: 'Elise',
    age: 33
  }
];

for (let { name, age: aliasForAge } of arrWithObjects) {
  console.log(name, aliasForAge);
}</code></pre>
      </div>
     </div>
     <p></p>
     <p><strong>Example 5:</strong> Get deep object properties of what you need</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>let arrWithObjectsWithArr = [{
    name: 'Jon',
    age: 32,
    tags: ['driver', 'chef', 'jogger']
  },
  {
    name: 'Elise',
    age: 33,
    tags: ['best chef', 'singer', 'dancer']
  }
];

for (let { name, tags: [firstItemFromTags, ...restOfTags] } of arrWithObjectsWithArr) {
  console.log(name, firstItemFromTags, restOfTags);
}</code></pre>
      </div>
     </div>
     <p></p>
     <p><strong>Example 6:</strong> Is <strong>Example 3</strong> used with <code>.forEach</code></p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>let arrWithIndex = [
  [0, 'a'],
  [1, 'b'],
  [2, 'c'],
];

// Not to be confused here, `forEachIndex` is the real index
// `mappedIndex` was created by "another user", so you can't really trust it

arrWithIndex.forEach(([mappedIndex, item], forEachIndex) =&gt; {
  console.log(forEachIndex, mappedIndex, item);
});</code></pre>
      </div>
     </div>
     <p></p>
     <p><strong>Example 7:</strong> Is <strong>Example 4</strong> used with <code>.forEach</code></p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>let arrWithObjects = [{
    name: 'Jon',
    age: 32
  },
  {
    name: 'Elise',
    age: 33
  }
];
// NOTE: Destructuring objects while using shorthand functions
// are required to be surrounded by parentheses
arrWithObjects.forEach( ({ name, age: aliasForAge }) =&gt; {
  console.log(name, aliasForAge)
});</code></pre>
      </div>
     </div>
     <p></p>
     <p><strong>Example 8:</strong> Is <strong>Example 5</strong> used with <code>.forEach</code></p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>let arrWithObjectsWithArr = [{
    name: 'Jon',
    age: 32,
    tags: ['driver', 'chef', 'jogger']
  },
  {
    name: 'Elise',
    age: 33,
    tags: ['best chef', 'singer', 'dancer']
  }
];

arrWithObjectsWithArr.forEach(({
  name,
  tags: [firstItemFromTags, ...restOfTags]
}) =&gt; {
  console.log(name, firstItemFromTags, restOfTags);
});</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_25"><span>Answer 25</span> <span class="arrow"> <a href="#answer_24">↑</a> </span> <span class="arrow"> <a href="#answer_26">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>10</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Kamil Kiełczewski</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Dec 2019 at 17:09</span>
     </div>
    </div>
    <div>
     <h2>Performance</h2>
     <p>Today (2019-12-18) I perform test on my <a href="https://en.wikipedia.org/wiki/MacOS_High_Sierra" rel="noreferrer">macOS v10.13.6</a> (High Sierra), on Chrome v 79.0, Safari v13.0.4 and Firefox v71.0 (64 bit) - conclusions about optimisation (and <em><a href="https://stackoverflow.com/questions/3470990/is-micro-optimization-worth-the-time/3471000#3471000">micro-optimisation</a></em> which usually is not worth to introduce it to code because the benefit is small, but code complexity grows).</p>
     <ul>
      <li>
       <p>It looks like the traditional <code>for i</code> (<strong>Aa</strong>) is a good choice to write fast code on all browsers.</p></li>
      <li>
       <p>The other solutions, like <code>for-of</code> (<strong>Ad</strong>), all in group <strong>C.</strong>... are usually 2 - 10 (and more) times slower than <strong>Aa</strong>, but for small arrays it is ok to use it - for the sake of increase code clarity.</p></li>
      <li>
       <p>The loops with array length cached in <code>n</code> (<strong>Ab, Bb, Be</strong>) are sometimes faster, sometimes not. Probably compilers automatically detect this situation and introduce caching. The speed differences between the cached and no-cached versions (<strong>Aa, Ba, Bd</strong>) are about ~1%, so it looks like introduce <code>n</code> is a <em><a href="https://stackoverflow.com/questions/3470990/is-micro-optimization-worth-the-time/3471000#3471000">micro-optimisation</a></em>.</p></li>
      <li>
       <p>The <code>i--</code> like solutions where the loop starts from the last array element (<strong>Ac, Bc</strong>) are usually ~30% slower than forward solutions - probably the reason is the way of <a href="https://stackoverflow.com/questions/1950878/c-for-loop-indexing-is-forward-indexing-faster-in-new-cpus">CPU memory cache working</a> - forward memory reading is more optimal for CPU caching). <strong>Is recommended to NOT USE such solutions.</strong></p></li>
     </ul>
     <h2>Details</h2>
     <p>In tests we calculate the sum of array elements. I perform a test for small arrays (10 elements) and big arrays (1M elements) and divide them into three groups:</p>
     <ul>
      <li><strong>A</strong> - <code>for</code> tests</li>
      <li><strong>B</strong> - <code>while</code> tests</li>
      <li><strong>C</strong> - other/alternative methods</li>
     </ul>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
      <div class="snippet-code snippet-currently-hidden">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
//let arr = Array.from(Array(1000000), (x, i) =&gt; i%10);

function Aa(a, s=0) {
  for(let i=0; i&lt;a.length; i++) {
    s += a[i];
  }
  console.log('Aa=', s);
}

function Ab(a, s=0) {
  let n = a.length;
  for(let i=0; i&lt;n; i++) {
    s += a[i];
  }
  console.log('Ab=', s);
}

function Ac(a, s=0) {
  for(let i=a.length; i--;) {
    s += a[i];
  }
  console.log('Ac=', s);
}

function Ad(a, s=0) {
  for(let x of a) {
    s += x;
  }
  console.log('Ad=', s);
}

function Ae(a, s=0) {
  for(let i in a) if (a.hasOwnProperty(i)) {
    s += a[i];
  }
  console.log('Ae=', s);
}

function Ba(a, s=0) {
  let i = -1;
  while(++i &lt; a.length) {
    s+= a[i];
  }
  console.log('Ba=', s);
}

function Bb(a, s=0) {
  let i = -1;
  let n = a.length;
  while(++i &lt; n) {
    s+= a[i];
  }
  console.log('Bb=', s);
}

function Bc(a, s=0) {
  let i = a.length;
  while(i--) {
    s += a[i];
  }
  console.log('Bc=', s);
}

function Bd(a, s=0) {
  let i = 0;
  do {
    s+= a[i]
  } while (++i &lt; a.length);
  console.log('Bd=', s);
}

function Be(a, s=0) {
  let i = 0;
  let n = a.length;
  do {
    s += a[i]
  } while (++i &lt; n);
  console.log('Be=', s);
}

function Bf(a, s=0) {
  const it = a.values(); 
  let e;
  while (!(e = it.next()).done) { 
    s+= e.value; 
  }
  console.log('Bf=', s);
}

function Ca(a, s=0) {
  a.map(x =&gt; { s+=x });
  console.log('Ca=', s);
}

function Cb(a, s=0) {
  a.forEach(x =&gt; { s+=x });
  console.log('Cb=', s);
}

function Cc(a, s=0) {
  a.every(x =&gt; (s += x, 1));
  console.log('Cc=', s);
}

function Cd(a, s=0) {
  a.filter(x =&gt; { s+=x });
  console.log('Cd=',s);
}

function Ce(a, s=0) {
  a.reduce((z, c) =&gt; { s+=c }, 0);
  console.log('Ce=', s);
}

function Cf(a, s=0) {
  a.reduceRight((z, c) =&gt; { s += c }, 0);
  console.log('Cf=', s);
}

function Cg(a, s=0) {
  a.some(x =&gt; { s += x } );
  console.log('Cg=', s);
}

function Ch(a, s=0) {
  Array.from(a, x=&gt; s += x);
  console.log('Cc=', s);
}


Aa(arr);
Ab(arr);
Ac(arr);
Ad(arr);
Ae(arr);

Ba(arr);
Bb(arr);
Bc(arr);
Bd(arr);
Be(arr);
Bf(arr);

Ca(arr);
Cb(arr);
Cc(arr);
Cd(arr);
Ce(arr);
Cf(arr);
Cg(arr);
Ch(arr);</code></pre>
       <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;p style="color: red"&gt;This snippets only PRESENTS code used for benchmark - it not perform test itself&lt;/p&gt;</code></pre>
      </div>
     </div>
     <p></p>
     <p><strong>Cross browser results</strong></p>
     <p>Results for all tested browsers</p>
     <p><a href="https://i.stack.imgur.com/bSXp2.png" rel="noreferrer"><img src="bSXp2.png" alt="Enter image description here"></a>browsers**</p>
     <p><strong>Array with 10 elements</strong></p>
     <p>Results for Chrome. You can perform the test on your machine <a href="https://jsbench.me/pxk4bicjru" rel="noreferrer">here</a>.</p>
     <p><a href="https://i.stack.imgur.com/VuCMw.png" rel="noreferrer"><img src="VuCMw.png" alt="Enter image description here"></a></p>
     <p><strong>Array with 1,000,000 elements</strong></p>
     <p>Results for Chrome. You can perform the test on your machine <a href="https://jsbench.me/9uk4bj4svg" rel="noreferrer">here</a></p>
     <p><a href="https://i.stack.imgur.com/8JQf6.png" rel="noreferrer"><img src="8JQf6.png" alt="Enter image description here"></a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_26"><span>Answer 26</span> <span class="arrow"> <a href="#answer_25">↑</a> </span> <span class="arrow"> <a href="#answer_27">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>9</span>
     </div>
     <div>
      <span>Answerer: </span> <span>anteAdamovic</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Nov 2017 at 15:31</span>
     </div>
    </div>
    <div>
     <p>A way closest to your idea would be to use <code>Array.forEach()</code> which accepts a closure function which will be executed for each element of the array.</p>
     <pre><code>myArray.forEach(
  (item) =&gt; {
    // Do something
    console.log(item);
  }
);
</code></pre>
     <p>Another viable way would be to use <code>Array.map()</code> which works in the same way, but it also takes all values that you return and returns them in a new array (essentially mapping each element to a new one), like this:</p>
     <pre><code>var myArray = [1, 2, 3];
myArray = myArray.map(
  (item) =&gt; {
    return item + 1;
  }
);

console.log(myArray); // [2, 3, 4]
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_27"><span>Answer 27</span> <span class="arrow"> <a href="#answer_26">↑</a> </span> <span class="arrow"> <a href="#answer_28">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>9</span>
     </div>
     <div>
      <span>Answerer: </span> <span>ankitkanojia</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Jan 2020 at 08:14</span>
     </div>
    </div>
    <div>
     <p>As per the new updated feature ECMAScript 6 (ES6) and ECMAScript 2015, you can use the following options with loops:</p>
     <blockquote>
      <p><strong>for loops</strong></p>
     </blockquote>
     <pre><code>for(var i = 0; i &lt; 5; i++){
  console.log(i);
}

// Output: 0,1,2,3,4
</code></pre>
     <blockquote>
      <p><strong>for...in loops</strong></p>
     </blockquote>
     <pre><code>let obj = {"a":1, "b":2}

for(let k in obj){
  console.log(k)
}

// Output: a,b
</code></pre>
     <blockquote>
      <p><strong>Array.forEach()</strong></p>
     </blockquote>
     <pre><code>let array = [1,2,3,4]

array.forEach((x) =&gt; {
  console.log(x);
})

// Output: 1,2,3,4
</code></pre>
     <blockquote>
      <p><strong>for...of loops</strong></p>
     </blockquote>
     <pre><code>let array = [1,2,3,4]

for(let x of array){
  console.log(x);
}

// Output: 1,2,3,4
</code></pre>
     <blockquote>
      <p><strong>while loops</strong></p>
     </blockquote>
     <pre><code>let x = 0

while(x &lt; 5){
  console.log(x)
  x++
}

// Output: 1,2,3,4
</code></pre>
     <blockquote>
      <p><strong>do...while loops</strong></p>
     </blockquote>
     <pre><code>let x = 0

do{
  console.log(x)
  x++
}while(x &lt; 5)

// Output: 1,2,3,4
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_28"><span>Answer 28</span> <span class="arrow"> <a href="#answer_27">↑</a> </span> <span class="arrow"> <a href="#answer_29">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Murtuza Husain</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Nov 2017 at 06:16</span>
     </div>
    </div>
    <div>
     <p>The lambda syntax doesn't usually work in Internet&nbsp;Explorer&nbsp;10 or below.</p>
     <p>I usually use the</p>
     <pre><code>[].forEach.call(arrayName,function(value,index){
    console.log("value of the looped element" + value);
    console.log("index of the looped element" + index);
});
</code></pre>
     <p>If you are a jQuery <em>fan</em> and already have a jQuery file running, you should reverse the positions of the index and value parameters</p>
     <pre><code>$("#ul&gt;li").each(function(**index, value**){
    console.log("value of the looped element" + value);
    console.log("index of the looped element" + index);
});
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_29"><span>Answer 29</span> <span class="arrow"> <a href="#answer_28">↑</a> </span> <span class="arrow"> <a href="#answer_30">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Nouman Dilshad</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Jul 2018 at 12:30</span>
     </div>
    </div>
    <div>
     <p>You can call forEach like this:</p>
     <p><code>forEach</code> will iterate over the array you provide and for each iteration it will have <code>element</code> which holds the value of that iteration. If you need index you can get the current index by passing the <code>i</code> as the second parameter in the callback function for forEach.</p>
     <p>Foreach is basically a High Order Function, Which takes another function as its parameter.</p>
     <pre><code>let theArray= [1,3,2];

theArray.forEach((element) =&gt; {
  // Use the element of the array
  console.log(element)
}
</code></pre>
     <p>Output:</p>
     <pre><code>1
3
2
</code></pre>
     <p>You can also iterate over an array like this:</p>
     <pre><code>for (let i=0; i&lt;theArray.length; i++) {
  console.log(i); // i will have the value of each index
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_30"><span>Answer 30</span> <span class="arrow"> <a href="#answer_29">↑</a> </span> <span class="arrow"> <a href="#answer_31">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Harun Or Rashid</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 May 2018 at 09:05</span>
     </div>
    </div>
    <div>
     <p>If you want to use <code>forEach()</code>, it will look like -</p>
     <pre><code>theArray.forEach ( element =&gt; {
    console.log(element);
});
</code></pre>
     <p>If you want to use <code>for()</code>, it will look like -</p>
     <pre><code>for(let idx = 0; idx &lt; theArray.length; idx++){
    let element = theArray[idx];
    console.log(element);
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_31"><span>Answer 31</span> <span class="arrow"> <a href="#answer_30">↑</a> </span> <span class="arrow"> <a href="#answer_32">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>subhashish negi</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Mar 2019 at 14:04</span>
     </div>
    </div>
    <div>
     <p>If you want to loop through an array of objects with the arrow function:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>let arr = [{name:'john', age:50}, {name:'clark', age:19}, {name:'mohan', age:26}];

arr.forEach((person)=&gt;{
  console.log('I am ' + person.name + ' and I am ' + person.age + ' old');
})</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_32"><span>Answer 32</span> <span class="arrow"> <a href="#answer_31">↑</a> </span> <span class="arrow"> <a href="#answer_33">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>BlackBeard</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Jul 2018 at 07:11</span>
     </div>
    </div>
    <div>
     <p>If you have a massive array you should use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators" rel="noreferrer"><strong><code>iterators</code></strong></a> to gain some efficiency. Iterators are a property of certain JavaScript collections (like <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noreferrer"><code>Map</code></a>, <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noreferrer"><code>Set</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String" rel="noreferrer"><code>String</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noreferrer"><code>Array</code></a>). Even, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" rel="noreferrer"><strong><code>for..of</code></strong></a> uses <strong><code>iterator</code></strong> under-the-hood.</p>
     <p>Iterators improve efficiency by letting you consume the items in a list one at a time as if they were a stream. What makes an iterator special is how it traverses a collection. Other loops need to load the entire collection up front in order to iterate over it, whereas an iterator only needs to know the current position in the collection.</p>
     <p>You access the current item by calling the iterator’s <code>next</code> method. The next method will return the <strong><code>value</code></strong> of the current item and a <strong><code>boolean</code></strong> to indicate when you have reached the end of the collection. The following is an example of creating an iterator from an array.</p>
     <p>Transform your regular array to iterator using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values" rel="noreferrer"><code>values()</code></a> method like this:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>    const myArr = [2,3,4]

let it = myArr.values();

console.log(it.next());
console.log(it.next());
console.log(it.next());
console.log(it.next());</code></pre>
      </div>
     </div>
     <p></p>
     <p>You can also transform your regular array to iterator using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator" rel="noreferrer"><code>Symbol.iterator</code></a> like this:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>const myArr = [2,3,4]

let it = myArr[Symbol.iterator]();

console.log(it.next());
console.log(it.next());
console.log(it.next());
console.log(it.next());</code></pre>
      </div>
     </div>
     <p></p>
     <p>You can also transform your regular <code>array</code> to an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators" rel="noreferrer"><code>iterator</code></a> like this:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>let myArr = [8, 10, 12];

function makeIterator(array) {
    var nextIndex = 0;
    
    return {
       next: function() {
           return nextIndex &lt; array.length ?
               {value: array[nextIndex++], done: false} :
               {done: true};
       }
    };
};

var it = makeIterator(myArr);

console.log(it.next().value);   // {value: 8, done: false}
console.log(it.next().value);   // {value: 10, done: false}
console.log(it.next().value);   // {value: 12, done: false}
console.log(it.next().value);   // {value: undefined, done: true}</code></pre>
      </div>
     </div>
     <p></p>
     <p><strong>NOTE</strong>:</p>
     <ul>
      <li>Iterators are exhaustible in nature.</li>
      <li>Objects are not <code>iterable</code> by default. Use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in" rel="noreferrer"><code>for..in</code></a> in that case because instead of values it works with keys.</li>
     </ul>
     <p>You can read more about <code>iteration protocol</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noreferrer">here</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_33"><span>Answer 33</span> <span class="arrow"> <a href="#answer_32">↑</a> </span> <span class="arrow"> <a href="#answer_34">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mustafa Kunwa</span>
     </div>
     <div>
      <span> Answered: </span> <span>19 Dec 2019 at 12:26</span>
     </div>
    </div>
    <div>
     <p>You can use:</p>
     <ol>
      <li>
       <p>ForEach</p>
       <pre><code>theArray.forEach(function (array, index) {
    console.log(index);
    console.log(array);
});
</code></pre></li>
      <li>
       <p>for</p>
       <pre><code>for(var i=0; i&lt;theArray.length; i++) {
    console.log(i)
}
</code></pre></li>
      <li>
       <p>map</p>
       <pre><code>theArray.map(x =&gt; console.log(x));
</code></pre></li>
      <li>
       <p>map</p>
       <pre><code>theArray.filter(x =&gt; console.log(x));
</code></pre></li>
     </ol>
     <p>And there are many others for iteration.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_34"><span>Answer 34</span> <span class="arrow"> <a href="#answer_33">↑</a> </span> <span class="arrow"> <a href="#answer_35">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>vkarpov15</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Dec 2019 at 19:31</span>
     </div>
    </div>
    <div>
     <p>I'd argue that <code>for/of</code> is the way to go:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>const arr = ['a', 'b', 'c'];

for (const v of arr) {
  console.log(v); // Prints "a", "b", "c"
}</code></pre>
      </div>
     </div>
     <p></p>
     <ul>
      <li>
       <p>Unlike <code>for/in</code>, <code>for/of</code> skips non-numeric properties on the array. For example, if you set <code>arr.foo = 'test'</code>, <code>for (var v in arr)</code> will loop through the <code>'foo'</code> key.</p></li>
      <li>
       <p>Unlike <code>forEach()</code>, <code>for/of</code> doesn't skip "holes" in arrays. <code>const arr = ['a',, 'c']</code> is valid JavaScript, just the 2nd element is a "hole". The array is functionally equivalent to <code>['a', undefined, 'c']</code>.</p></li>
     </ul>
     <p>You can read more in <a href="https://thecodebarbarian.com/for-vs-for-each-vs-for-in-vs-for-of-in-javascript" rel="nofollow noreferrer">this blog post on <code>for/of</code> vs <code>forEach()</code>.</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_35"><span>Answer 35</span> <span class="arrow"> <a href="#answer_34">↑</a> </span> <span class="arrow"> <a href="#answer_36">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>alejoko</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Feb 2019 at 15:13</span>
     </div>
    </div>
    <div>
     <p>If you want to keep your code in the functional way, use <code>map</code>:</p>
     <pre><code>theArray.map(instance =&gt; do_something);
</code></pre>
     <p>In this way you will generate a new array to future operation and will skip any not desirable side effect.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_36"><span>Answer 36</span> <span class="arrow"> <a href="#answer_35">↑</a> </span> <span class="arrow"> <a href="#answer_37">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Muhammad Waqas</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Mar 2020 at 22:53</span>
     </div>
    </div>
    <div>
     <p>Suppose we have an array of subjects:</p>
     <pre><code>let ddl = new Array();
if (subjects) {
    subjects.forEach(function (s) {ddl.push({"id": s.id, "label": s.name});});
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>An explanation would be in order. E.g., what is the idea/gist? From <a href="https://stackoverflow.com/help/promotion">the Help Center</a>: <i>"...always explain why the solution you're presenting is appropriate and how it works"</i>. Please respond by <a href="https://stackoverflow.com/posts/60908003/edit">editing (changing) your answer</a>, not here in comments (<b><i>without</i></b> "Edit:", "Update:", or similar - the answer should appear as if it was written today).</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">5 Jan 2022 at 20:44</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_37"><span>Answer 37</span> <span class="arrow"> <a href="#answer_36">↑</a> </span> <span class="arrow"> <a href="#answer_38">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>arul prince</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Jan 2019 at 13:08</span>
     </div>
    </div>
    <div>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>// Looping through arrays using the foreach ECMAScript 6 way

var data = new Array(1, 2, 3, 4, 5);
data.forEach((val,index) =&gt; {
    console.log("index: ", index); // Index
    console.log("value: ", val); // Value
});</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_38"><span>Answer 38</span> <span class="arrow"> <a href="#answer_37">↑</a> </span> <span class="arrow"> <a href="#answer_39">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>John</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Jan 2018 at 18:03</span>
     </div>
    </div>
    <div>
     <pre><code>var a = ["car", "bus", "truck"]
a.forEach(function(item, index) {
    console.log("Index" + index);
    console.log("Element" + item);
})
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_39"><span>Answer 39</span> <span class="arrow"> <a href="#answer_38">↑</a> </span> <span class="arrow"> <a href="#answer_40">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Zia</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Apr 2023 at 02:54</span>
     </div>
    </div>
    <div>
     <p>I do like this.</p>
     <p>foreach</p>
     <pre><code>const arr = ["apple", "banana", "orange", "pear", "grape"];

arr.forEach(function(element) {
  console.log(element);
});
</code></pre>
     <p>for..of</p>
     <pre><code>const arr = ["apple", "banana", "orange", "pear", "grape"];

for (const element of arr) {
  console.log(element);
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_40"><span>Answer 40</span> <span class="arrow"> <a href="#answer_39">↑</a> </span> <span class="arrow"> <a href="#answer_41">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Peko Chan</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Dec 2018 at 11:06</span>
     </div>
    </div>
    <div>
     <p>I come from Python, and I found this way much clearer.</p>
     <p>theArray being the array, and <code>instance</code> being the elements of the array:</p>
     <pre><code>for (let instance of theArray)
{
    console.log("The instance", instance);
}
</code></pre>
     <p>or</p>
     <pre><code>for (instance in theArray)
{
    console.log("The instance", instance);
}
</code></pre>
     <p>compare to:</p>
     <pre><code>theArray.forEach(function(instance) {
    console.log(instance);
});
</code></pre>
     <p>But at the end of the day both are doing the same thing.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span><code>for (instance in theArray)</code> does not do the same as <code>for (let instance of theArray)</code>. The former iterates over <i>keys</i> while the latter over <i>values</i>. So if <code>theArray = ["a", "b", "c"]</code> then <code>for..in</code> will print <code>0</code>, <code>1</code>, <code>2</code> while <code>for..of</code> will print <code>"a"</code>, <code>"b"</code>, <code>"c"</code>.</span> <span> - </span> <span class="display-name">VLAZ -on strike-</span> <span> </span> <span class="date">12 Jul 2022 at 10:48</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_41"><span>Answer 41</span> <span class="arrow"> <a href="#answer_40">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>antelove</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Dec 2019 at 10:24</span>
     </div>
    </div>
    <div>
     <p><a href="https://developer.mozilla.org/id/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="nofollow noreferrer">Mozilla documentation</a></p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>/* Get all forms */
document.querySelectorAll( "form" ).forEach( form =&gt; {

  /* For each form, add the onsubmit event */
  form.addEventListener( "submit", event =&gt; {
    event.preventDefault(); // Return false

    /* Display it */
    alert(event.target.action);
    console.log(event.target);
  } );

} );</code></pre>
       <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;form action="form1.php" &gt;
  &lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;
&lt;form action="form2.php" &gt;
  &lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;
&lt;form action="form3.php" &gt;
  &lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>