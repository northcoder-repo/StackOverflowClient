<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Difference between &lt;? super T&gt; and &lt;? extends T&gt; in Java</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>Difference between &lt;? super T&gt; and &lt;? extends T&gt; in Java</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>1028</span>
    </div>
    <div>
     <span>Asker: </span> <span>Anand</span>
    </div>
    <div>
     <span>Asked: </span> <span>3 Dec 2010 at 06:57</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/4343202/difference-between-super-t-and-extends-t-in-java">source</a>
    </div>
   </div>
   <div>
    <p>What is the difference between <code>List&lt;? super T&gt;</code> and <code>List&lt;? extends T&gt;</code> ?</p>
    <p>I used to use <code>List&lt;? extends T&gt;</code>, but it does not allow me to add elements to it <code>list.add(e)</code>, whereas the <code>List&lt;? super T&gt;</code> does.</p>
   </div>
   <div class="tags">
    <span class="tag">java</span><span class="tag">generics</span><span class="tag">collections</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>37</td>
       <td><span>Check out this excellent talk : <a href="https://youtu.be/V1vQf4qyMXg?t=22m24s" rel="nofollow noreferrer">youtu.be/V1vQf4qyMXg?t=22m24s</a></span> <span> - </span> <span class="display-name">abksrv</span> <span> </span> <span class="date">19 Aug 2017 at 04:57</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>here null we can add</span> <span> - </span> <span class="display-name">spandey</span> <span> </span> <span class="date">7 Nov 2017 at 10:21</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>A very good explanation with an example @ youtube.com/watch?v=34oiEq9nD0M&amp;feature=youtu.be&amp;t=1630 which explains &lt;? super T&gt; part but, gives an idea of another.</span> <span> - </span> <span class="display-name">lupchiazoem</span> <span> </span> <span class="date">20 Jan 2019 at 06:21</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>upper bounded: <a href="https://docs.oracle.com/javase/tutorial/java/generics/upperBounded.html" rel="nofollow noreferrer">docs.oracle.com/javase/tutorial/java/generics/upperBounded.h‌​tml</a> lower bounded: <a href="https://docs.oracle.com/javase/tutorial/java/generics/lowerBounded.html" rel="nofollow noreferrer">docs.oracle.com/javase/tutorial/java/generics/lowerBounded.h‌​tml</a></span> <span> - </span> <span class="display-name">ROY</span> <span> </span> <span class="date">26 Jul 2020 at 01:52</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>I think of it like this: List&lt;? extends B&gt; means List whose elements have more than equal feature than B(all it's sub classes). List&lt;? super B&gt; means List whose elements have less than equal feature than B(all it's super classes).</span> <span> - </span> <span class="display-name">Abhishek Kumar</span> <span> </span> <span class="date">28 May 2022 at 16:26</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2011</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Bert F</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Dec 2010 at 08:03</span>
     </div>
    </div>
    <div>
     <h3><code>extends</code></h3>
     <p>The wildcard declaration of <code>List&lt;? extends Number&gt; foo3</code> means that any of these are legal assignments:</p>
     <pre><code>List&lt;? extends Number&gt; foo3 = new ArrayList&lt;Number&gt;();  // Number "extends" Number (in this context)
List&lt;? extends Number&gt; foo3 = new ArrayList&lt;Integer&gt;(); // Integer extends Number
List&lt;? extends Number&gt; foo3 = new ArrayList&lt;Double&gt;();  // Double extends Number
</code></pre>
     <ol>
      <li>
       <p><strong>Reading</strong> - Given the above possible assignments, what type of object are you guaranteed to read from <code>List foo3</code>:</p>
       <ul>
        <li>You can read a <strong><code>Number</code></strong> because any of the lists that could be assigned to <code>foo3</code> contain a <code>Number</code> or a subclass of <code>Number</code>.</li>
        <li>You can't read an <code>Integer</code> because <code>foo3</code> could be pointing at a <code>List&lt;Double&gt;</code>.</li>
        <li>You can't read a <code>Double</code> because <code>foo3</code> could be pointing at a <code>List&lt;Integer&gt;</code>.</li>
       </ul></li>
      <li>
       <p><strong>Writing</strong> - Given the above possible assignments, what type of object could you add to <code>List foo3</code> that would be legal for <strong>all</strong> the above possible <code>ArrayList</code> assignments:</p>
       <ul>
        <li>You can't add an <code>Integer</code> because <code>foo3</code> could be pointing at a <code>List&lt;Double&gt;</code>.</li>
        <li>You can't add a <code>Double</code> because <code>foo3</code> could be pointing at a <code>List&lt;Integer&gt;</code>.</li>
        <li>You can't add a <code>Number</code> because <code>foo3</code> could be pointing at a <code>List&lt;Integer&gt;</code>.</li>
       </ul></li>
     </ol>
     <p><em>You can't add any object to <code>List&lt;? extends T&gt;</code> because you can't guarantee what kind of <code>List</code> it is really pointing to, so you can't guarantee that the object is allowed in that <code>List</code>. The only "guarantee" is that you can only read from it and you'll get a <code>T</code> or subclass of <code>T</code>.</em></p>
     <h3><code>super</code></h3>
     <p>Now consider <code>List &lt;? super T&gt;</code>.</p>
     <p>The wildcard declaration of <code>List&lt;? super Integer&gt; foo3</code> means that any of these are legal assignments:</p>
     <pre><code>List&lt;? super Integer&gt; foo3 = new ArrayList&lt;Integer&gt;();  // Integer is a "superclass" of Integer (in this context)
List&lt;? super Integer&gt; foo3 = new ArrayList&lt;Number&gt;();   // Number is a superclass of Integer
List&lt;? super Integer&gt; foo3 = new ArrayList&lt;Object&gt;();   // Object is a superclass of Integer
</code></pre>
     <ol>
      <li>
       <p><strong>Reading</strong> - Given the above possible assignments, what type of object are you guaranteed to receive when you read from <code>List foo3</code>:</p>
       <ul>
        <li>You aren't guaranteed an <code>Integer</code> because <code>foo3</code> could be pointing at a <code>List&lt;Number&gt;</code> or <code>List&lt;Object&gt;</code>.</li>
        <li>You aren't guaranteed a <code>Number</code> because <code>foo3</code> could be pointing at a <code>List&lt;Object&gt;</code>.</li>
        <li>The <strong>only</strong> guarantee is that you will get an instance of an <strong><code>Object</code></strong> or subclass of <code>Object</code> (but you don't know what subclass).</li>
       </ul></li>
      <li>
       <p><strong>Writing</strong> - Given the above possible assignments, what type of object could you add to <code>List foo3</code> that would be legal for <strong>all</strong> the above possible <code>ArrayList</code> assignments:</p>
       <ul>
        <li>You can add an <code>Integer</code> because an <code>Integer</code> is allowed in any of above lists.</li>
        <li>You can add an instance of a subclass of <code>Integer</code> because an instance of a subclass of <code>Integer</code> is allowed in any of the above lists.</li>
        <li>You can't add a <code>Double</code> because <code>foo3</code> could be pointing at an <code>ArrayList&lt;Integer&gt;</code>.</li>
        <li>You can't add a <code>Number</code> because <code>foo3</code> could be pointing at an <code>ArrayList&lt;Integer&gt;</code>.</li>
        <li>You can't add an <code>Object</code> because <code>foo3</code> could be pointing at an <code>ArrayList&lt;Integer&gt;</code>.</li>
       </ul></li>
     </ol>
     <h3>PECS</h3>
     <p>Remember <em>PECS</em>: <strong>"Producer Extends, Consumer Super"</strong>.</p>
     <ul>
      <li>
       <p><strong>"Producer Extends"</strong> - If you need a <code>List</code> to produce <code>T</code> values (you want to read <code>T</code>s from the list), you need to declare it with <code>? extends T</code>, e.g. <code>List&lt;? extends Integer&gt;</code>. But you cannot add to this list.</p></li>
      <li>
       <p><strong>"Consumer Super"</strong> - If you need a <code>List</code> to consume <code>T</code> values (you want to write <code>T</code>s into the list), you need to declare it with <code>? super T</code>, e.g. <code>List&lt;? super Integer&gt;</code>. But there are no guarantees what type of object you may read from this list.</p></li>
      <li>
       <p>If you need to both read from and write to a list, you need to declare it exactly with no wildcards, e.g. <code>List&lt;Integer&gt;</code>.</p></li>
     </ul>
     <h3>Example</h3>
     <p>Note <a href="http://www.angelikalanger.com/GenericsFAQ/FAQSections/TypeArguments.html#FAQ103" rel="noreferrer">this example from the Java Generics FAQ</a>. Note how the source list <code>src</code> (the producing list) uses <code>extends</code>, and the destination list <code>dest</code> (the consuming list) uses <code>super</code>:</p>
     <pre><code>public class Collections { 
  public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) {
      for (int i = 0; i &lt; src.size(); i++) 
        dest.set(i, src.get(i)); 
  } 
}
</code></pre>
     <p>Also see <a href="https://stackoverflow.com/questions/2776975/how-can-i-add-to-list-extends-number-data-structures/2777297#2777297">How can I add to List&lt;? extends Number&gt; data structures?</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>I have a doubt here: If I need to add to a generic list and then get data from it, what should i do?</span> <span> - </span> <span class="display-name">Anand</span> <span> </span> <span class="date">3 Dec 2010 at 08:40</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@Anand - See the 3rd bullet under <code>PECS</code> above. You'll probably need to use a specific generic parameters (no wildcard, e.g. <code>List&lt;T&gt;</code>). Unfortunately, you can't have everything. You can either create a flexible reference to list by using a generic wildcard (e.g. <code>&lt;? super T&gt;</code> or <code>&lt;? extends T&gt;</code> and suffer limitations with respect to what you can add or read from it. Or else you can a less flexible reference to a list with a specific type (e.g. <code>List&lt;T&gt;</code>) and get better guarantees as to what you can read /write from it.</span> <span> - </span> <span class="display-name">Bert F</span> <span> </span> <span class="date">3 Dec 2010 at 14:02</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>as an example you can see Collections copy method public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) { @ <a href="http://www.docjar.com/html/api/java/util/Collections.java.html" rel="nofollow noreferrer">docjar.com/html/api/java/util/Collections.java.html</a></span> <span> - </span> <span class="display-name">AZ_</span> <span> </span> <span class="date">18 Feb 2013 at 15:06</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>@BertF: great explanation.one correction (if it ) do you mean to say<code>List&lt;? super Integer&gt; foo3</code> instead of <code>List&lt;? super Number&gt; foo3</code> below <code>super</code> ?</span> <span> - </span> <span class="display-name">brain storm</span> <span> </span> <span class="date">12 Feb 2014 at 23:00</span></td>
       </tr>
       <tr>
        <td>17</td>
        <td><span>I have reached this answer a couple of times. I whish I could vote more than once. Do you know that you are #1 in <a href="https://www.google.es/search?q=Difference%20between%20%3C?%20super%20T%3E%20and%20%3C?%20extends%20T%3E%20in%20Java" rel="nofollow noreferrer">google search results</a>?</span> <span> - </span> <span class="display-name">rpax</span> <span> </span> <span class="date">25 Apr 2015 at 21:12</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span><i>You can add an instance of a subclass of Integer</i> this is wrong : Integer is a final class</span> <span> - </span> <span class="display-name">leokom</span> <span> </span> <span class="date">7 Oct 2015 at 07:04</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>Beautiful answer! I have 1 question though, you wrote 'You can add an instance of a subclass of Integer because an instance of a subclass of Integer is allowed in any of the above lists' - I thought you can only add a supertype of Integer because of &lt;? super Integer&gt;?</span> <span> - </span> <span class="display-name">IntelliData</span> <span> </span> <span class="date">1 Dec 2015 at 20:54</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@IntelliData - For the declaration <code>List&lt;? super X&gt; foo</code>, the <code>&lt;? super X&gt;</code> part of the declaration <i>DOES NOT</i> describe what you can add to the list - it describes what kinds of lists that the variable <code>foo</code> can point to. As an implication of all the different kinds of lists that <code>foo</code> can legally point to, only certain types of objects can be added to <code>foo</code> that is guaranteed to be acceptable to <i>ANY</i> type of list that <code>foo</code> may be pointed to.</span> <span> - </span> <span class="display-name">Bert F</span> <span> </span> <span class="date">4 Dec 2015 at 01:35</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@IntelliData - Said another way: if <code>List&lt;? super VEGETABLES&gt; foo</code> is a special box that can contain a person with a special diet, i.e. a vegetarian who consumes only VEGETABLES and subclasses of VEGETABLES (i.e. <code>List&lt;VEGETABLES&gt;</code>) or that can contain a person with a "normal" diet -can eat vegetables, meat, dairy, or whatever (i.e. <code>List&lt;Object&gt;</code>), then what kind of food can I throw in the box that I'm sure that whoever is in the box will eat it? Only VEGETABLES or subclasses of VEGETABLES can be fed to the box <code>foo</code> since only they are edible to whichever person/List is really in the box.</span> <span> - </span> <span class="display-name">Bert F</span> <span> </span> <span class="date">4 Dec 2015 at 01:54</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Bert F I still don't get it: if 'Only VEGETABLES or subclasses of VEGETABLES can be fed to the box foo', then what does '&lt;? super VEGETABLES&gt; mean?</span> <span> - </span> <span class="display-name">IntelliData</span> <span> </span> <span class="date">4 Dec 2015 at 14:58</span></td>
       </tr>
       <tr>
        <td>9</td>
        <td><span>@Bert F '&lt;? super VEGETABLE&gt;' does <i>NOT</i> describe what things you can add to 'foo' - it describes the kinds of Lists that 'foo' can point to. 'List&lt;? super VEGETABLE&gt; foo' means 'foo' is pointing at either List&lt;VEGETABLE&gt; or LIST&lt;FOOD&gt; at any given time, but you don't know which. Therefore you can only give 'foo' stuff that both would like. Both lists are okay to be given a VEGETABLE or subclass of VEGETABLE, but you can't give FOOD or MEAT (because List&lt;VEGETABLE&gt; can't eat FOOD or MEAT - has be a VEGETABLE).</span> <span> - </span> <span class="display-name">Bert F</span> <span> </span> <span class="date">4 Dec 2015 at 23:10</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>For completness, List&lt;? extends Number&gt; foo3, In the writing part, you can actually write null, as in: foo3.add(null);</span> <span> - </span> <span class="display-name">user1529412</span> <span> </span> <span class="date">12 Jan 2016 at 04:28</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>after reading your answer I had to try it out on my own. I did a simple class A{} class B extends A{} class C extends B{} and convinced myself that I had a totally wrong view about generics! :) Thank you so much!</span> <span> - </span> <span class="display-name">moldovean</span> <span> </span> <span class="date">25 Oct 2016 at 18:39</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Very good explanation! A tiny little note: <i>"You can add an instance of a subclass of Integer because an instance of a subclass of Integer is allowed in any of the above lists."</i> — correct, except that the <code>Integer</code> class is declared final and therefore cannot be extended.</span> <span> - </span> <span class="display-name">MC Emperor</span> <span> </span> <span class="date">10 Mar 2017 at 08:43</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>What is the usage doing like this List&lt;Number&gt; can allow to do all operation what List&lt;? super Number &gt; can do and List&lt;Number&gt; can allow all operation what List&lt;? extends Number &gt; can do</span> <span> - </span> <span class="display-name">saeed</span> <span> </span> <span class="date">13 Apr 2017 at 07:25</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Can't figure out what would be wrong if instead of &lt;? super T&gt; in the copy method it is &lt;T&gt; i.e. ` class Test { static &lt;T&gt; void copy(List&lt;T&gt; dest, List&lt;? extends T&gt; src) { for (int i = 0; i &lt; src.size(); i++) dest.set(i, src.get(i)); } public static void main(String[] args) { List&lt;Integer&gt; src = new ArrayList&lt;&gt;(Arrays.asList(1, 2)); List&lt;Number&gt; dest = new ArrayList&lt;&gt;(Arrays.asList(3, 4)); copy(dest, src); System.out.println(dest); } } `</span> <span> - </span> <span class="display-name">Nasif Md. Tanjim</span> <span> </span> <span class="date">13 Oct 2017 at 12:24</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Since <code>Number</code> is not widely used, it would be useful to add a comment about the relationship between <code>Number</code>, <code>Integer</code> and <code>Double</code> to complete this answer. (<code>Integer</code> and <code>Double</code> both extend <code>Number</code>.)</span> <span> - </span> <span class="display-name">Luke Hutchison</span> <span> </span> <span class="date">21 Jun 2018 at 07:31</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>I get no error when I execute the code: List&lt;? extends Number&gt; foo3 = new ArrayList&lt;Integer&gt;(); ((List&lt;Double&gt;) foo3).add(1.2); System.out.println(foo3.get(0)); That's to the point "You can't add a Double because foo3 could be pointing at a List&lt;Integer&gt;."</span> <span> - </span> <span class="display-name">ka3ak</span> <span> </span> <span class="date">1 Sep 2019 at 08:26</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>As mentioned by @Danon, a very nice explaination of genrics in Java 8 - <a href="https://nofluffjuststuff.com/magazine/2016/09/time_to_really_learn_generics_a_java_8_perspective" rel="nofollow noreferrer">nofluffjuststuff.com/magazine/2016/09/…</a></span> <span> - </span> <span class="display-name">Narendra Pandey</span> <span> </span> <span class="date">13 Sep 2019 at 21:27</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@BertF it is valid to say in <b>extends</b>, on <b>reading</b> "You can read a Object (or something above Number) because any of the lists that could be assigned to foo3 contain a Number or a subclass of Number." maybe you could add that on the bulltets</span> <span> - </span> <span class="display-name">Victor</span> <span> </span> <span class="date">14 Dec 2019 at 16:46</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Thanks, the last example explains everything! so, <code>we "read" from "producer"</code> and <code>"write" to "consumer"</code>. I have no idea where these vague producer&amp;consumer wording came from... Anyways I'll come back here in the future again.. :)</span> <span> - </span> <span class="display-name">starriet</span> <span> </span> <span class="date">18 Nov 2020 at 02:02</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span><a href="https://medium.com/@isuru89/java-producer-extends-consumer-super-9fbb0e7dd268" rel="nofollow noreferrer">This site</a> elaborates in a concise way on this answer.</span> <span> - </span> <span class="display-name">Aron Hoogeveen</span> <span> </span> <span class="date">20 Nov 2020 at 20:58</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Bert F In the producer concept, why can not Java have a mechanism to check the instance type just before adding the element? Let's say, in the Number type collection, you need to add a Number type element Then, do a instance check on the collection type and accordingly add it. it might not be elegant, still, it looks like a possible solution. Thanks!!</span> <span> - </span> <span class="display-name">A srinivas</span> <span> </span> <span class="date">14 Apr 2021 at 14:35</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@BertF If <code>&lt;? extends Foo&gt;</code> becomes <code>&lt;Foo&gt;</code>, then does <code>&lt;? super Foo&gt;</code> become <code>&lt;Object&gt;</code>?</span> <span> - </span> <span class="display-name">John Strood</span> <span> </span> <span class="date">7 Jan 2022 at 18:53</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>I want to emphasize how important it is to really understand the difference between <code>List&lt;? extends T&gt;</code> (or <code>List&lt;? super T&gt;</code>) and <code>List&lt;T&gt;</code>. There's really nothing left that needs explaining; prior comments, as well as the OP, are both incredibly well-written. The point I'm trying to drive home is that if you don't immediately know the difference without thinking about it, it's probably an indicator that you should do more work with ALL types of generics until they are all second nature.</span> <span> - </span> <span class="display-name">TacoManStan</span> <span> </span> <span class="date">11 Feb 2022 at 22:05</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@BertF Can I double confirm my understanding with you on this PECS concept? ie PE: <code>? extends T</code> meaning ? is a subclass of T and the you can read whatever T/? from the list, and CS: <code>? super T</code> means that whatever ? is, it is a super class of T or T itself and because of this, you can only write T or whatever subclass of T to the list</span> <span> - </span> <span class="display-name">Tan Yu Hau Sean</span> <span> </span> <span class="date">4 Sep 2022 at 14:01</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>332</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Luigi Cortese</span>
     </div>
     <div>
      <span> Answered: </span> <span>20 Oct 2015 at 21:16</span>
     </div>
    </div>
    <div>
     <p>Imagine having this hierarchy</p>
     <p><a href="https://i.stack.imgur.com/4U72V.png" rel="noreferrer"><img src="/question/stackoverflow/4343202/4U72V.png" alt="enter image description here"></a></p>
     <h1>1. Extends</h1>
     <p>By writing</p>
     <pre><code>    List&lt;? extends C2&gt; list;
</code></pre>
     <p>you are saying that <code>list</code> will be able to reference an object of type (for example) <code>ArrayList</code> whose generic type is one of the 7 <strong>subtypes</strong> of <code>C2</code> (<code>C2</code> included):</p>
     <ol>
      <li><em>C2:</em> <code>new ArrayList&lt;C2&gt;();</code>, (an object that can store C2 or subtypes) or</li>
      <li><em>D1:</em> <code>new ArrayList&lt;D1&gt;();</code>, (an object that can store D1 or subtypes) or</li>
      <li><em>D2:</em> <code>new ArrayList&lt;D2&gt;();</code>, (an object that can store D2 or subtypes) or...</li>
     </ol>
     <p>and so on. Seven different cases:</p>
     <pre><code>    1) new ArrayList&lt;C2&gt;(): can store C2 D1 D2 E1 E2 E3 E4
    2) new ArrayList&lt;D1&gt;(): can store    D1    E1 E2  
    3) new ArrayList&lt;D2&gt;(): can store       D2       E3 E4
    4) new ArrayList&lt;E1&gt;(): can store          E1             
    5) new ArrayList&lt;E2&gt;(): can store             E2             
    6) new ArrayList&lt;E3&gt;(): can store                E3             
    7) new ArrayList&lt;E4&gt;(): can store                   E4             
</code></pre>
     <p>We have a set of "storable" types for each possible case: 7 (red) sets here graphically represented</p>
     <p><a href="https://i.stack.imgur.com/UpmXo.png" rel="noreferrer"><img src="/question/stackoverflow/4343202/UpmXo.png" alt="enter image description here"></a></p>
     <p>As you can see, there is not a <em>safe type</em> that is common to every case:</p>
     <ul>
      <li>you cannot <code>list.add(new C2(){});</code> because it could be <code>list = new ArrayList&lt;D1&gt;();</code></li>
      <li>you cannot <code>list.add(new D1(){});</code> because it could be <code>list = new ArrayList&lt;D2&gt;();</code></li>
     </ul>
     <p>and so on.</p>
     <h1>2. Super</h1>
     <p>By writing</p>
     <pre><code>    List&lt;? super C2&gt; list;
</code></pre>
     <p>you are saying that <code>list</code> will be able to reference an object of type (for example) <code>ArrayList</code> whose generic type is one of the 7 <strong>supertypes</strong> of <code>C2</code> (<code>C2</code> included):</p>
     <ul>
      <li><em>A1:</em> <code>new ArrayList&lt;A1&gt;();</code>, (an object that can store A1 or subtypes) or</li>
      <li><em>A2:</em> <code>new ArrayList&lt;A2&gt;();</code>, (an object that can store A2 or subtypes) or</li>
      <li><em>A3:</em> <code>new ArrayList&lt;A3&gt;();</code>, (an object that can store A3 or subtypes) or...</li>
     </ul>
     <p>and so on. Seven different cases:</p>
     <pre><code>    1) new ArrayList&lt;A1&gt;(): can store A1          B1 B2       C1 C2    D1 D2 E1 E2 E3 E4
    2) new ArrayList&lt;A2&gt;(): can store    A2          B2       C1 C2    D1 D2 E1 E2 E3 E4
    3) new ArrayList&lt;A3&gt;(): can store       A3          B3       C2 C3 D1 D2 E1 E2 E3 E4
    4) new ArrayList&lt;A4&gt;(): can store          A4       B3 B4    C2 C3 D1 D2 E1 E2 E3 E4
    5) new ArrayList&lt;B2&gt;(): can store                B2       C1 C2    D1 D2 E1 E2 E3 E4
    6) new ArrayList&lt;B3&gt;(): can store                   B3       C2 C3 D1 D2 E1 E2 E3 E4
    7) new ArrayList&lt;C2&gt;(): can store                            C2    D1 D2 E1 E2 E3 E4
</code></pre>
     <p>We have a set of "storable" types for each possible case: 7 (red) sets here graphically represented</p>
     <p><a href="https://i.stack.imgur.com/FfVcl.png" rel="noreferrer"><img src="/question/stackoverflow/4343202/FfVcl.png" alt="enter image description here"></a></p>
     <p>As you can see, here we have seven <em>safe types</em> that are common to every case: <code>C2</code>, <code>D1</code>, <code>D2</code>, <code>E1</code>, <code>E2</code>, <code>E3</code>, <code>E4</code>.</p>
     <ul>
      <li>you can <code>list.add(new C2(){});</code> because, regardless of the kind of List we're referencing, <code>C2</code> is allowed</li>
      <li>you can <code>list.add(new D1(){});</code> because, regardless of the kind of List we're referencing, <code>D1</code> is allowed</li>
     </ul>
     <p>and so on. You probably noticed that these types correspond to the hierarchy starting from type <code>C2</code>.</p>
     <h1>Notes</h1>
     <p>Here the complete hierarchy if you wish to make some tests</p>
     <pre><code>interface A1{}
interface A2{}
interface A3{}
interface A4{}

interface B1 extends A1{}
interface B2 extends A1,A2{}
interface B3 extends A3,A4{}
interface B4 extends A4{}

interface C1 extends B2{}
interface C2 extends B2,B3{}
interface C3 extends B3{}

interface D1 extends C1,C2{}
interface D2 extends C2{}

interface E1 extends D1{}
interface E2 extends D1{}
interface E3 extends D2{}
interface E4 extends D2{}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Looks like B1, B4, C1 and C3 should not be colored on the second picture. Because those are not included in the list above the picture.</span> <span> - </span> <span class="display-name">Mike</span> <span> </span> <span class="date">13 May 2016 at 11:14</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@Mike I'm not sure what you mean, those nodes are blue in the second picture, not being part of any set/case</span> <span> - </span> <span class="display-name">Luigi Cortese</span> <span> </span> <span class="date">13 May 2016 at 11:20</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@LuigiCortese Ok, you got me, I was wrong. What I wrote was about the last (third) picture not about the second picture. B1, B4, C1 and C3 should not be red on the last picture.</span> <span> - </span> <span class="display-name">Mike</span> <span> </span> <span class="date">13 May 2016 at 12:38</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Good post overall but I have to -1 because the last picture seems incorrect and I got no clarification about that.</span> <span> - </span> <span class="display-name">Mike</span> <span> </span> <span class="date">19 May 2016 at 11:16</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Mike B1 is part of case 1, B4 is part of case 4, C1 is part of cases 1-2-5, C3 is part of cases 3-4-6. Is it possible that you're misinterpreting something?</span> <span> - </span> <span class="display-name">Luigi Cortese</span> <span> </span> <span class="date">19 May 2016 at 11:21</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Let us <a href="http://chat.stackoverflow.com/rooms/112707/discussion-between-luigi-cortese-and-mike">continue this discussion in chat</a>.</span> <span> - </span> <span class="display-name">Luigi Cortese</span> <span> </span> <span class="date">23 May 2016 at 16:49</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I spent a bit of time confused by image 3 as well, but I think I figured it out and it makes sense: There are only 7 <code>ArrayList&lt;x&gt;</code> values, which are listed - B1 is not one of them, it will be a compiler error. But A1 <i>is</i> valid, and it can (in principle) hold both B1 and everything under B2, which is why B1 is in the same highlight as A1. The compiler will not let you <code>list.add(new B1(){});</code> though (nor B2) because <code>list</code> could be e.g. a B3. You can only <code>add</code> C2 and sublasses because they work with all possible containers.</span> <span> - </span> <span class="display-name">Groxx</span> <span> </span> <span class="date">27 Nov 2016 at 22:11</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>151</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Michael Dausmann</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Dec 2015 at 22:05</span>
     </div>
    </div>
    <div>
     <p>I love the answer from @Bert F but this is the way my brain sees it.</p>
     <p>I have an X in my hand. If I want to <strong>write</strong> my X into a List, that List needs to be either a List of X or a List of things that my X can be upcast to as I write them in i.e. any <strong>superclass</strong> of X...</p>
     <pre><code>List&lt;? super   X&gt;
</code></pre>
     <p>If I get a List and I want to <strong>read</strong> an X out of that List, that better be a List of X or a List of things that can be upcast to X as I read them out, i.e. anything that <strong>extends</strong> X</p>
     <pre><code>List&lt;? extends X&gt;
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>46</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Oleksandr Pyrohov</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Sep 2018 at 17:46</span>
     </div>
    </div>
    <div>
     <p>I'd like to visualize the difference. Suppose we have:</p>
     <pre><code>class A { }
class B extends A { }
class C extends B { }
</code></pre>
     <p><code>List&lt;? extends T&gt;</code> - reading and assigning:</p>
     <pre><code>|-------------------------|-------------------|---------------------------------|
|         wildcard        |        get        |              assign             |
|-------------------------|-------------------|---------------------------------|
|    List&lt;? extends C&gt;    |    A    B    C    |                       List&lt;C&gt;   |
|-------------------------|-------------------|---------------------------------|
|    List&lt;? extends B&gt;    |    A    B         |             List&lt;B&gt;   List&lt;C&gt;   |
|-------------------------|-------------------|---------------------------------|
|    List&lt;? extends A&gt;    |    A              |   List&lt;A&gt;   List&lt;B&gt;   List&lt;C&gt;   |
|-------------------------|-------------------|---------------------------------|
</code></pre>
     <p><code>List&lt;? super T&gt;</code> - writing and assigning:</p>
     <pre><code>|-------------------------|-------------------|-------------------------------------------|
|         wildcard        |        add        |                   assign                  |
|-------------------------|-------------------|-------------------------------------------|
|     List&lt;? super C&gt;     |              C    |  List&lt;Object&gt;  List&lt;A&gt;  List&lt;B&gt;  List&lt;C&gt;  |
|-------------------------|-------------------|-------------------------------------------|
|     List&lt;? super B&gt;     |         B    C    |  List&lt;Object&gt;  List&lt;A&gt;  List&lt;B&gt;           |
|-------------------------|-------------------|-------------------------------------------|
|     List&lt;? super A&gt;     |    A    B    C    |  List&lt;Object&gt;  List&lt;A&gt;                    |
|-------------------------|-------------------|-------------------------------------------|
</code></pre>
     <p>In all of the cases:</p>
     <ul>
      <li>you can always <strong>get</strong> <code>Object</code> from a list regardless of the wildcard.<br></li>
      <li>you can always <strong>add</strong> <code>null</code> to a mutable list regardless of the wildcard.</li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>32</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Sushant</span>
     </div>
     <div>
      <span> Answered: </span> <span>19 Mar 2016 at 08:08</span>
     </div>
    </div>
    <div>
     <p>Based on <a href="https://stackoverflow.com/a/4343547/3378714">Bert F's answer</a> I would like to explain my understanding.</p>
     <p>Lets say we have 3 classes as</p>
     <pre><code>public class Fruit{}

public class Melon extends Fruit{}

public class WaterMelon extends Melon{}
</code></pre>
     <p>Here We have</p>
     <pre><code>List&lt;? extends Fruit&gt; fruitExtendedList = …

//Says that I can be a list of any object as long as this object extends Fruit.
</code></pre>
     <p>Ok now lets try to get some value from fruitExtendedList</p>
     <pre><code>Fruit fruit = fruitExtendedList.get(position)

//This is valid as it can only return Fruit or its subclass.
</code></pre>
     <p>Again lets try</p>
     <pre><code>Melon melon = fruitExtendedList.get(position)

//This is not valid because fruitExtendedList can be a list of Fruit only, it may not be 
//list of Melon or WaterMelon and in java we cannot assign sub class object to 
//super class object reference without explicitly casting it.
</code></pre>
     <p>Same is the case for</p>
     <pre><code>WaterMelon waterMelon = fruitExtendedList.get(position)
</code></pre>
     <p>Now lets try to set some object in fruitExtendedList</p>
     <p>Adding fruit object</p>
     <pre><code>fruitExtendedList.add(new Fruit())

//This in not valid because as we know fruitExtendedList can be a list of any 
//object as long as this object extends Fruit. So what if it was the list of  
//WaterMelon or Melon you cannot add Fruit to the list of WaterMelon or Melon.
</code></pre>
     <p>Adding Melon object</p>
     <pre><code>fruitExtendedList.add(new Melon())

//This would be valid if fruitExtendedList was the list of Fruit but it may 
//not be, as it can also be the list of WaterMelon object. So, we see an invalid 
//condition already.
</code></pre>
     <p>Finally let try to add WaterMelon object</p>
     <pre><code>fruitExtendedList.add(new WaterMelon())

//Ok, we got it now we can finally write to fruitExtendedList as WaterMelon 
//can be added to the list of Fruit or Melon as any superclass reference can point 
//to its subclass object.
</code></pre>
     <p><strong><em>But wait</em></strong><em> what if someone decides to make a new type of Lemon lets say for arguments sake SaltyLemon as</em></p>
     <pre><code>public class SaltyLemon extends Lemon{}
</code></pre>
     <p><em>Now fruitExtendedList can be list of Fruit, Melon, WaterMelon or SaltyLemon.</em></p>
     <p>So, our statement</p>
     <pre><code>fruitExtendedList.add(new WaterMelon())
</code></pre>
     <p>is not valid either.</p>
     <p><strong>Basically we can say that we cannot write anything to a fruitExtendedList.</strong></p>
     <p><strong>This sums up <code>List&lt;? extends Fruit&gt;</code></strong></p>
     <p>Now lets see</p>
     <pre><code>List&lt;? super Melon&gt; melonSuperList= …

//Says that I can be a list of anything as long as its object has super class of Melon.
</code></pre>
     <p>Now lets try to get some value from melonSuperList</p>
     <pre><code>Fruit fruit = melonSuperList.get(position)

//This is not valid as melonSuperList can be a list of Object as in java all 
//the object extends from Object class. So, Object can be super class of Melon and 
//melonSuperList can be a list of Object type
</code></pre>
     <p><em>Similarly Melon, WaterMelon or any other object cannot be read.</em></p>
     <p>But note that we can read Object type instances</p>
     <pre><code>Object myObject = melonSuperList.get(position)

//This is valid because Object cannot have any super class and above statement 
//can return only Fruit, Melon, WaterMelon or Object they all can be referenced by
//Object type reference.
</code></pre>
     <p>Now, lets try to set some value from melonSuperList.</p>
     <p>Adding Object type object</p>
     <pre><code>melonSuperList.add(new Object())

//This is not valid as melonSuperList can be a list of Fruit or Melon.
//Note that Melon itself can be considered as super class of Melon.
</code></pre>
     <p>Adding Fruit type object</p>
     <pre><code>melonSuperList.add(new Fruit())

//This is also not valid as melonSuperList can be list of Melon
</code></pre>
     <p>Adding Melon type object</p>
     <pre><code>melonSuperList.add(new Melon())

//This is valid because melonSuperList can be list of Object, Fruit or Melon and in 
//this entire list we can add Melon type object.
</code></pre>
     <p>Adding WaterMelon type object</p>
     <pre><code>melonSuperList.add(new WaterMelon())

//This is also valid because of same reason as adding Melon
</code></pre>
     <p><strong>To sum it up we can add Melon or its subclass in melonSuperList and read only Object type object.</strong></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>21</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Istao</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Dec 2010 at 07:04</span>
     </div>
    </div>
    <div>
     <p>super is a lower bound, and extends is an upper bound.</p>
     <p>According to <a href="http://download.oracle.com/javase/tutorial/extra/generics/morefun.html" rel="noreferrer">http://download.oracle.com/javase/tutorial/extra/generics/morefun.html</a> :</p>
     <blockquote>
      <p>The solution is to use a form of bounded wildcard we haven't seen yet: wildcards with a lower bound. The syntax ? super T denotes an unknown type that is a supertype of T (or T itself; remember that the supertype relation is reflexive). It is the dual of the bounded wildcards we've been using, where we use ? extends T to denote an unknown type that is a subtype of T.</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>13</span>
     </div>
     <div>
      <span>Answerer: </span> <span>elyor</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Sep 2017 at 12:44</span>
     </div>
    </div>
    <div>
     <p>Adding an item to the list:</p>
     <ul>
      <li>
       <p><strong>List&lt; ? extends X &gt;</strong> doesn't allow to add anything, except for <code>null</code> into the list.</p></li>
      <li>
       <p><strong>List&lt; ? super X &gt;</strong> allows to add anything that is-a X (X or its subtype), or null.</p></li>
     </ul>
     <p>Getting an item from the list:</p>
     <ul>
      <li>When you get an item from <strong>List&lt; ? extends X &gt;</strong>, you can assign it to a variable of type X or any supertype of X, including Object.</li>
      <li>When you get an item from <strong>List&lt; ? super X &gt;</strong>, you can only assign it to a variable of type <code>Object</code>.</li>
     </ul>
     <p>Some examples:</p>
     <pre><code>    List&lt;? extends Number&gt; list1 = new ArrayList&lt;Integer&gt;();
    list1.add(null);  //OK
    Number n = list1.get(0);  //OK
    Serializable s = list1.get(0);  //OK
    Object o = list1.get(0);  //OK

    list1.add(2.3);  //ERROR
    list1.add(5);  //ERROR
    list1.add(new Object());  //ERROR
    Integer i = list1.get(0);  //ERROR
</code></pre>
     <hr>
     <pre><code>    List&lt;? super Number&gt; list2 = new ArrayList&lt;Number&gt;();
    list2.add(null);  //OK
    list2.add(2.3);  //OK
    list2.add(5);  //OK
    Object o = list2.get(0);  //OK

    list2.add(new Object());  //ERROR
    Number n = list2.get(0);  //ERROR
    Serializable s = list2.get(0);  //ERROR
    Integer i = list2.get(0);  //ERROR
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Shailesh Pratapwar</span>
     </div>
     <div>
      <span> Answered: </span> <span>31 Mar 2018 at 04:20</span>
     </div>
    </div>
    <div>
     <p>The up voted answers covers the details on many aspects. However, I would try to answer this in different way.</p>
     <p>There are 2 things we need to consider,</p>
     <h2><strong>1. Assignment to the list variable</strong></h2>
     <p><code>List&lt;? extends X&gt; listvar;</code></p>
     <p>Here, any <strong>list of X or list of subclasses of X can be assigned</strong> to listvar.</p>
     <p><code>List&lt;? extends Number&gt; listvar; listvar = new ArrayList&lt;Number&gt;(); listvar = new ArrayList&lt;Integer&gt;();</code></p>
     <hr>
     <p><code>List&lt;? super X&gt; listvar;</code></p>
     <p>Here, any <strong>list of X or list of superclasses of X can be assigned</strong> to listvar.</p>
     <p><code>List&lt;? super Number&gt; listvar; listvar = new ArrayList&lt;Number&gt;(); listvar = new ArrayList&lt;Object&gt;();</code></p>
     <h2>2. Perform Read or Write operation on the list variable</h2>
     <pre><code>`List&lt;? extends X&gt; listvar;`
</code></pre>
     <p>You can use this feature to accept a list in method arguments and perform any operations on <strong>type X</strong> (Note: You can <strong>only read objects of type X</strong> from the list).</p>
     <pre><code>`List&lt;? super Number&gt; listvar;
</code></pre>
     <p>You can use this feature to accept a list in method arguments and perform any operations on <strong>type Object</strong> as You can <strong>only read objects of type Object</strong> from the list. <strong>But yes, additional thing here is , you can add objects of type X into the list.</strong></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Sai Sunder</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Jan 2014 at 06:51</span>
     </div>
    </div>
    <div>
     <p>Using <strong>extends</strong> you can only get from the collection. You cannot put into it. Also, though <strong>super</strong> allows to both get and put, the return type during get is <strong>? super T</strong>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>jforex78</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Aug 2017 at 21:05</span>
     </div>
    </div>
    <div>
     <p>You can go through all the answers above to understand why the <code>.add()</code> is restricted to <code>'&lt;?&gt;'</code>, <code>'&lt;? extends&gt;'</code>, and partly to <code>'&lt;? super&gt;'</code>.</p>
     <p>But here's the conclusion of it all if you want to remember it, and dont want to go exploring the answer every time:</p>
     <p><code>List&lt;? extends A&gt;</code> means this will accept any <code>List</code> of <code>A</code> and subclass of <code>A</code>. But you cannot add anything to this list. Not even objects of type <code>A</code>.</p>
     <p><code>List&lt;? super A&gt;</code> means this will accept any list of <code>A</code> and superclass of <code>A</code>. You can add objects of type <code>A</code> and its subclasses.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>18446744073709551615</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Jul 2016 at 15:11</span>
     </div>
    </div>
    <div>
     <p>The most confusing thing here is that whatever type restrictions we specify, assignment works only one way:</p>
     <pre><code>baseClassInstance = derivedClassInstance;
</code></pre>
     <p>You may think that <code>Integer extends Number</code> and that an <code>Integer</code> would do as a <code>&lt;? extends Number&gt;</code>, but the compiler will tell you that <code>&lt;? extends Number&gt; cannot be converted to Integer</code> (that is, in human parlance, <em>it is wrong that anything that extends number can be converted to Integer</em>):</p>
     <pre><code>class Holder&lt;T&gt; {
    T v;
    T get() { return v; }
    void set(T n) { v=n; }
}
class A {
    public static void main(String[]args) {
        Holder&lt;? extends Number&gt; he = new Holder();
        Holder&lt;? super Number&gt; hs = new Holder();

        Integer i;
        Number n;
        Object o;

        // Producer Super: always gives an error except
        //       when consumer expects just Object
        i = hs.get(); // &lt;? super Number&gt; cannot be converted to Integer
        n = hs.get(); // &lt;? super Number&gt; cannot be converted to Number
                      // &lt;? super Number&gt; cannot be converted to ... (but
                      //       there is no class between Number and Object)
        o = hs.get();

        // Consumer Super
        hs.set(i);
        hs.set(n);
        hs.set(o); // Object cannot be converted to &lt;? super Number&gt;

        // Producer Extends
        i = he.get(); // &lt;? extends Number&gt; cannot be converted to Integer
        n = he.get();
        o = he.get();

        // Consumer Extends: always gives an error
        he.set(i); // Integer cannot be converted to &lt;? extends Number&gt;
        he.set(n); // Number cannot be converted to &lt;? extends Number&gt;
        he.set(o); // Object cannot be converted to &lt;? extends Number&gt;
    }
}
</code></pre>
     <p><code>hs.set(i);</code> is ok because <em><code>Integer</code> can be converted to any superclass of <code>Number</code></em> (and not because <code>Integer</code> is a superclass of <code>Number</code>, which is not true).</p>
     <p>EDIT added a comment about Consumer Extends and Producer Super -- they are not meaningful because they specify, correspondingly, <em>nothing</em> and just <em><code>Object</code></em>. You are advised to remember PECS because CEPS is never useful.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Crox</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Jul 2018 at 17:57</span>
     </div>
    </div>
    <div>
     <p>Example, Order of inheritance is assumed as O &gt; S &gt; T &gt; U &gt; V</p>
     <p><strong>Using extends Keyword ,</strong></p>
     <p><strong><em>Correct:</em></strong></p>
     <pre><code>List&lt;? extends T&gt; Object = new List&lt;T&gt;();
List&lt;? extends T&gt; Object = new List&lt;U&gt;();
List&lt;? extends T&gt; Object = new List&lt;V&gt;();
</code></pre>
     <p><strong><em>InCorrect:</em></strong></p>
     <pre><code>List&lt;? extends T&gt; Object = new List&lt;S&gt;();
List&lt;? extends T&gt; Object = new List&lt;O&gt;();
</code></pre>
     <p><strong>super Keyword:</strong></p>
     <p><strong><em>Correct:</em></strong></p>
     <pre><code>List&lt;? super T&gt; Object = new List&lt;T&gt;();
List&lt;? super T&gt; Object = new List&lt;S&gt;();
List&lt;? super T&gt; Object = new List&lt;O&gt;();
</code></pre>
     <p><strong><em>InCorrect:</em></strong></p>
     <pre><code>List&lt;? super T&gt; Object = new List&lt;U&gt;();
List&lt;? super T&gt; Object = new List&lt;V&gt;();
</code></pre>
     <p>Adding object: List Object = new List();</p>
     <pre><code>Object.add(new T()); //error
</code></pre>
     <p>But Why error ? Let's look at the Possibilities of initializations of List Object</p>
     <pre><code>List&lt;? extends T&gt; Object = new List&lt;T&gt;();
List&lt;? extends T&gt; Object = new List&lt;U&gt;();
List&lt;? extends T&gt; Object = new List&lt;V&gt;();
</code></pre>
     <p>If we use Object.add(new T()); then it will be correct only if</p>
     <pre><code>List&lt;? extends T&gt; Object = new List&lt;T&gt;(); 
</code></pre>
     <p>But there are extra two possibilities</p>
     <p>List Object = new List(); List Object = new List(); If we try to add (new T()) to the above two possibilities it will give an error because T is the superior class of U and V . we try to add a T object [which is (new T()) ] to List of type U and V . Higher class object(Base class) cannot be passed to lower class Object(Sub class).</p>
     <p>Due to the extra two possibilities , Java gives you error even if you use the correct possilibity as Java don't know what Object you are referring to .So you can't add objects to List Object = new List(); as there are possibilities that are not valid.</p>
     <p>Adding object: List Object = new List();</p>
     <pre><code>Object.add(new T()); // compiles fine without error
Object.add(new U()); // compiles fine without error
Object.add(new V()); // compiles fine without error

Object.add(new S()); //  error
Object.add(new O()); //  error
</code></pre>
     <p>But why error occurs in the above two ? we can use Object.add(new T()); only on the below possibilities,</p>
     <pre><code>List&lt;? super T&gt; Object = new List&lt;T&gt;();
List&lt;? super T&gt; Object = new List&lt;S&gt;();
List&lt;? super T&gt; Object = new List&lt;O&gt;();
</code></pre>
     <p>If we Tried to use Object.add(new T()) in List Object = new List(); and List Object = new List(); then it will give error This is because We can't add T object[which is new T()] to the List Object = new List(); because it is an object of type U . We can't add a T object[which is new T()] to U Object because T is a base class and U is a sub class . We can't add base class to subclass and that's why error occurs . This is same for the another case .</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>not sure why this was downvoted... other than for the naming of variables in a .net fashion. I corrected the -1, but you probably should conform to the normal naming convention :) <a href="https://www.oracle.com/technetwork/java/codeconventions-135099.html" rel="nofollow noreferrer">oracle.com/technetwork/java/codeconventions-135099.html</a></span> <span> - </span> <span class="display-name">Taugenichts</span> <span> </span> <span class="date">22 Oct 2018 at 21:59</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Vaibhav Gupta</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Aug 2015 at 13:25</span>
     </div>
    </div>
    <div>
     <p>The generic wildcards target two primary needs:</p>
     <p>Reading from a generic collection Inserting into a generic collection There are three ways to define a collection (variable) using generic wildcards. These are:</p>
     <pre><code>List&lt;?&gt;           listUknown = new ArrayList&lt;A&gt;();
List&lt;? extends A&gt; listUknown = new ArrayList&lt;A&gt;();
List&lt;? super   A&gt; listUknown = new ArrayList&lt;A&gt;();
</code></pre>
     <p><code>List&lt;?&gt;</code> means a list typed to an unknown type. This could be a <code>List&lt;A&gt;</code>, a <code>List&lt;B&gt;</code>, a <code>List&lt;String&gt;</code> etc.</p>
     <p><code>List&lt;? extends A&gt;</code> means a List of objects that are instances of the <code>class A</code>, or <code>subclasses of A</code> (e.g. B and C). <code>List&lt;? super A&gt;</code> means that the list is typed to either the <code>A class</code>, or a <code>superclass of A</code>.</p>
     <p>Read more : <a href="http://tutorials.jenkov.com/java-generics/wildcards.html" rel="nofollow">http://tutorials.jenkov.com/java-generics/wildcards.html</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Kevin STS</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Jun 2017 at 22:20</span>
     </div>
    </div>
    <div>
     <p><strong><em>When to use extends and super</em></strong></p>
     <p>Wildcards are most useful in method parameters. They allow for the necessary flexibility in method interfaces.</p>
     <p>People are often confused when to use extends and when to use super bounds. The rule of thumb is the get-put principle. If you get something from a parametrized container, use extends.</p>
     <pre><code>int totalFuel(List&lt;? extends Vehicle&gt; list) {
int total = 0;
for(Vehicle v : list) {
    total += v.getFuel();
}
return total;}
</code></pre>
     <p>The method totalFuel gets Vehicles from the list, asks them about how much fuel they have, and computes the total. If you put objects into a parameterized container, use super.</p>
     <pre><code>int totalValue(Valuer&lt;? super Vehicle&gt; valuer) {
int total = 0;
for(Vehicle v : vehicles) {
    total += valuer.evaluate(v);
}
return total;}
</code></pre>
     <p>The method totalValue puts Vehicles into the Valuer. It's useful to know that extends bound is much more common than super.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>