<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>How do I return the response from an asynchronous call?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>How do I return the response from an asynchronous call?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>6598</span>
    </div>
    <div>
     <span>Asker: </span> <span>Felix Kling</span>
    </div>
    <div>
     <span>Asked: </span> <span>8 Jan 2013 at 17:06</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/14220321">source</a>
    </div>
   </div>
   <div>
    <p>How do I return the response/result from a function <code>foo</code> that makes an asynchronous request?</p>
    <p>I am trying to return the value from the callback, as well as assigning the result to a local variable inside the function and returning that one, but none of those ways actually return the response — they all return <code>undefined</code> or whatever the initial value of the variable <code>result</code> is.</p>
    <p><strong>Example of an asynchronous function that accepts a callback</strong> (using jQuery's <code>ajax</code> function):</p>
    <pre><code>function foo() {
    var result;

    $.ajax({
        url: '...',
        success: function(response) {
            result = response;
            // return response; // &lt;- I tried that one as well
        }
    });

    return result; // It always returns `undefined`
}
</code></pre>
    <p><strong>Example using Node.js:</strong></p>
    <pre><code>function foo() {
    var result;

    fs.readFile("path/to/file", function(err, data) {
        result = data;
        // return data; // &lt;- I tried that one as well
    });

    return result; // It always returns `undefined`
}
</code></pre>
    <p><strong>Example using the <code>then</code> block of a promise:</strong></p>
    <pre><code>function foo() {
    var result;

    fetch(url).then(function(response) {
        result = response;
        // return response; // &lt;- I tried that one as well
    });

    return result; // It always returns `undefined`
}
</code></pre>
   </div>
   <div class="tags">
    <span class="tag">javascript</span><span class="tag">ajax</span><span class="tag">asynchronous</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td></td>
       <td><span>use deasync like this <a href="https://stackoverflow.com/a/47051880/2083877">stackoverflow.com/a/47051880/2083877</a></span> <span> - </span> <span class="display-name">Sunil Kumar</span> <span> </span> <span class="date">8 Sep 2021 at 11:26</span></td>
      </tr>
      <tr>
       <td>15</td>
       <td><span>@SunilKumar I don't think this is useful. OP made this question and self-answer to document how to get the response from async calls. Suggesting a 3rd party module defeats such purpose, and IMO the paradigm introduced by that module is not good practice.</span> <span> - </span> <span class="display-name">Seblor</span> <span> </span> <span class="date">10 Sep 2021 at 09:14</span></td>
      </tr>
      <tr>
       <td>6</td>
       <td><span>@Liam: It's just an example for an asynchronous function that accepts a callback.</span> <span> - </span> <span class="display-name">Felix Kling</span> <span> </span> <span class="date">15 Oct 2021 at 14:13</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6562</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Felix Kling</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Jan 2013 at 17:06</span>
     </div>
    </div>
    <div>
     <blockquote>
      <p><em>→ For a more general explanation of asynchronous behaviour with different examples, see</em> <a href="https://stackoverflow.com/q/23667086/218196">Why is my variable unaltered after I modify it inside of a function? - Asynchronous code reference</a></p>
      <p><em>→ If you already understand the problem, skip to the possible solutions below.</em></p>
     </blockquote>
     <h1>The problem</h1>
     <p>The <strong>A</strong> in <a href="https://en.wikipedia.org/wiki/Ajax_(programming)" rel="noreferrer">Ajax</a> stands for <a href="https://www.merriam-webster.com/dictionary/asynchronous" rel="noreferrer"><strong>asynchronous</strong></a>. That means sending the request (or rather receiving the response) is taken out of the normal execution flow. In your example, <code>$.ajax</code> returns immediately and the next statement, <code>return result;</code>, is executed before the function you passed as <code>success</code> callback was even called.</p>
     <p>Here is an analogy which hopefully makes the difference between synchronous and asynchronous flow clearer:</p>
     <h2>Synchronous</h2>
     <p>Imagine you make a phone call to a friend and ask him to look something up for you. Although it might take a while, you wait on the phone and stare into space, until your friend gives you the answer that you needed.</p>
     <p>The same is happening when you make a function call containing "normal" code:</p>
     <pre><code>function findItem() {
    var item;
    while(item_not_found) {
        // search
    }
    return item;
}

var item = findItem();

// Do something with item
doSomethingElse();
</code></pre>
     <p>Even though <code>findItem</code> might take a long time to execute, any code coming after <code>var item = findItem();</code> has to <em>wait</em> until the function returns the result.</p>
     <h2>Asynchronous</h2>
     <p>You call your friend again for the same reason. But this time you tell him that you are in a hurry and he should <em>call you back</em> on your mobile phone. You hang up, leave the house, and do whatever you planned to do. Once your friend calls you back, you are dealing with the information he gave to you.</p>
     <p>That's exactly what's happening when you do an Ajax request.</p>
     <pre><code>findItem(function(item) {
    // Do something with the item
});
doSomethingElse();
</code></pre>
     <p>Instead of waiting for the response, the execution continues immediately and the statement after the Ajax call is executed. To get the response eventually, you provide a function to be called once the response was received, a <em>callback</em> (notice something? <em>call back</em> ?). Any statement coming after that call is executed before the callback is called.</p>
     <hr>
     <h1>Solution(s)</h1>
     <p><strong>Embrace the asynchronous nature of JavaScript!</strong> While certain asynchronous operations provide synchronous counterparts (so does "Ajax"), it's generally discouraged to use them, especially in a browser context.</p>
     <p>Why is it bad do you ask?</p>
     <p>JavaScript runs in the UI thread of the browser and any long-running process will lock the UI, making it unresponsive. Additionally, there is an upper limit on the execution time for JavaScript and the browser will ask the user whether to continue the execution or not.</p>
     <p>All of this results in a really bad user experience. The user won't be able to tell whether everything is working fine or not. Furthermore, the effect will be worse for users with a slow connection.</p>
     <p>In the following we will look at three different solutions that are all building on top of each other:</p>
     <ul>
      <li><strong>Promises with <code>async/await</code></strong> (ES2017+, available in older browsers if you use a transpiler or regenerator)</li>
      <li><strong>Callbacks</strong> (popular in node)</li>
      <li><strong>Promises with <code>then()</code></strong> (ES2015+, available in older browsers if you use one of the many promise libraries)</li>
     </ul>
     <p><strong>All three are available in current browsers, and node 7+.</strong></p>
     <hr>
     <h2>ES2017+: Promises with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noreferrer"><code>async/await</code></a></h2>
     <p>The ECMAScript version released in 2017 introduced <em>syntax-level support</em> for asynchronous functions. With the help of <code>async</code> and <code>await</code>, you can write asynchronous in a "synchronous style". The code is still asynchronous, but it's easier to read/understand.</p>
     <p><code>async/await</code> builds on top of promises: an <code>async</code> function always returns a promise. <code>await</code> "unwraps" a promise and either result in the value the promise was resolved with or throws an error if the promise was rejected.</p>
     <p><strong>Important:</strong> You can only use <code>await</code> inside an <code>async</code> function or in a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" rel="noreferrer">JavaScript module</a>. Top-level <code>await</code> is not supported outside of modules, so you might have to make an async IIFE (<a href="https://en.wikipedia.org/wiki/Immediately_invoked_function_expression" rel="noreferrer">Immediately Invoked Function Expression</a>) to start an <code>async</code> context if not using a module.</p>
     <p>You can read more about <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noreferrer"><code>async</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" rel="noreferrer"><code>await</code></a> on MDN.</p>
     <p>Here is an example that elaborates the <em>delay</em> function <code>findItem()</code> above:</p>
     <pre><code>// Using 'superagent' which will return a promise.
var superagent = require('superagent')

// This is isn't declared as `async` because it already returns a promise
function delay() {
  // `delay` returns a promise
  return new Promise(function(resolve, reject) {
    // Only `delay` is able to resolve or reject the promise
    setTimeout(function() {
      resolve(42); // After 3 seconds, resolve the promise with value 42
    }, 3000);
  });
}

async function getAllBooks() {
  try {
    // GET a list of book IDs of the current user
    var bookIDs = await superagent.get('/user/books');
    // wait for 3 seconds (just for the sake of this example)
    await delay();
    // GET information about each book
    return superagent.get('/books/ids='+JSON.stringify(bookIDs));
  } catch(error) {
    // If any of the awaited promises was rejected, this catch block
    // would catch the rejection reason
    return null;
  }
}

// Start an IIFE to use `await` at the top level
(async function(){
  let books = await getAllBooks();
  console.log(books);
})();
</code></pre>
     <p>Current <a href="https://kangax.github.io/compat-table/es2016plus/#test-async_functions" rel="noreferrer">browser</a> and <a href="http://node.green/#ES2017-features-async-functions" rel="noreferrer">node</a> versions support <code>async/await</code>. You can also support older environments by transforming your code to ES5 with the help of <a href="https://github.com/facebook/regenerator" rel="noreferrer">regenerator</a> (or tools that use regenerator, such as <a href="https://babeljs.io/" rel="noreferrer">Babel</a>).</p>
     <hr>
     <h2>Let functions accept <em>callbacks</em></h2>
     <p>A callback is when function 1 is passed to function 2. Function 2 can call function 1 whenever it is ready. In the context of an asynchronous process, the callback will be called whenever the asynchronous process is done. Usually, the result is passed to the callback.</p>
     <p>In the example of the question, you can make <code>foo</code> accept a callback and use it as <code>success</code> callback. So this</p>
     <pre><code>var result = foo();
// Code that depends on 'result'
</code></pre>
     <p>becomes</p>
     <pre><code>foo(function(result) {
    // Code that depends on 'result'
});
</code></pre>
     <p>Here we defined the function "inline" but you can pass any function reference:</p>
     <pre><code>function myCallback(result) {
    // Code that depends on 'result'
}

foo(myCallback);
</code></pre>
     <p><code>foo</code> itself is defined as follows:</p>
     <pre><code>function foo(callback) {
    $.ajax({
        // ...
        success: callback
    });
}
</code></pre>
     <p><code>callback</code> will refer to the function we pass to <code>foo</code> when we call it and we pass it on to <code>success</code>. I.e. once the Ajax request is successful, <code>$.ajax</code> will call <code>callback</code> and pass the response to the callback (which can be referred to with <code>result</code>, since this is how we defined the callback).</p>
     <p>You can also process the response before passing it to the callback:</p>
     <pre><code>function foo(callback) {
    $.ajax({
        // ...
        success: function(response) {
            // For example, filter the response
            callback(filtered_response);
        }
    });
}
</code></pre>
     <p>It's easier to write code using callbacks than it may seem. After all, JavaScript in the browser is heavily event-driven (DOM events). Receiving the Ajax response is nothing else but an event. Difficulties could arise when you have to work with third-party code, but most problems can be solved by just thinking through the application flow.</p>
     <hr>
     <h2>ES2015+: Promises with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noreferrer">then()</a></h2>
     <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noreferrer">Promise API</a> is a new feature of ECMAScript 6 (ES2015), but it has good <a href="http://caniuse.com/#feat=promises" rel="noreferrer" title="caniuse">browser support</a> already. There are also many libraries which implement the standard Promises API and provide additional methods to ease the use and composition of asynchronous functions (e.g., <a href="https://github.com/petkaantonov/bluebird" rel="noreferrer">bluebird</a>).</p>
     <p>Promises are containers for <em>future</em> values. When the promise receives the value (it is <em>resolved</em>) or when it is canceled (<em>rejected</em>), it notifies all of its "listeners" who want to access this value.</p>
     <p>The advantage over plain callbacks is that they allow you to decouple your code and they are easier to compose.</p>
     <p>Here is an example of using a promise:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function delay() {
  // `delay` returns a promise
  return new Promise(function(resolve, reject) {
    // Only `delay` is able to resolve or reject the promise
    setTimeout(function() {
      resolve(42); // After 3 seconds, resolve the promise with value 42
    }, 3000);
  });
}

delay()
  .then(function(v) { // `delay` returns a promise
    console.log(v); // Log the value once it is resolved
  })
  .catch(function(v) {
    // Or do something else if it is rejected
    // (it would not happen in this example, since `reject` is not called).
  });</code></pre>
       <pre class="snippet-code-css lang-css prettyprint-override"><code>.as-console-wrapper { max-height: 100% !important; top: 0; }</code></pre>
      </div>
     </div>
     <p></p>
     <p>Applied to our Ajax call we could use promises like this:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function ajax(url) {
  return new Promise(function(resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.onload = function() {
      resolve(this.responseText);
    };
    xhr.onerror = reject;
    xhr.open('GET', url);
    xhr.send();
  });
}

ajax("https://jsonplaceholder.typicode.com/todos/1")
  .then(function(result) {
    console.log(result); // Code depending on result
  })
  .catch(function() {
    // An error occurred
  });</code></pre>
       <pre class="snippet-code-css lang-css prettyprint-override"><code>.as-console-wrapper { max-height: 100% !important; top: 0; }</code></pre>
      </div>
     </div>
     <p></p>
     <p>Describing all the advantages that promise offer is beyond the scope of this answer, but if you write new code, you should seriously consider them. They provide a great abstraction and separation of your code.</p>
     <p>More information about promises: <a href="http://www.html5rocks.com/en/tutorials/es6/promises/" rel="noreferrer">HTML5 rocks - JavaScript Promises</a>.</p>
     <h3>Side note: jQuery's deferred objects</h3>
     <p><a href="https://stackoverflow.com/questions/4866721/what-are-deferred-objects">Deferred objects</a> are jQuery's custom implementation of promises (before the Promise API was standardized). They behave almost like promises but expose a slightly different API.</p>
     <p>Every Ajax method of jQuery already returns a "deferred object" (actually a promise of a deferred object) which you can just return from your function:</p>
     <pre><code>function ajax() {
    return $.ajax(...);
}

ajax().done(function(result) {
    // Code depending on result
}).fail(function() {
    // An error occurred
});
</code></pre>
     <h3>Side note: Promise gotchas</h3>
     <p>Keep in mind that promises and deferred objects are just <em>containers</em> for a future value, they are not the value itself. For example, suppose you had the following:</p>
     <pre><code>function checkPassword() {
    return $.ajax({
        url: '/password',
        data: {
            username: $('#username').val(),
            password: $('#password').val()
        },
        type: 'POST',
        dataType: 'json'
    });
}

if (checkPassword()) {
    // Tell the user they're logged in
}
</code></pre>
     <p>This code misunderstands the above asynchronous issues. Specifically, <code>$.ajax()</code> doesn't freeze the code while it checks the '/password' page on your server - it sends a request to the server and while it waits, it immediately returns a jQuery Ajax Deferred object, not the response from the server. That means the <code>if</code> statement is going to always get this Deferred object, treat it as <code>true</code>, and proceed as though the user is logged in. Not good.</p>
     <p>But the fix is easy:</p>
     <pre><code>checkPassword()
.done(function(r) {
    if (r) {
        // Tell the user they're logged in
    } else {
        // Tell the user their password was bad
    }
})
.fail(function(x) {
    // Tell the user something bad happened
});
</code></pre>
     <hr>
     <h2>Not recommended: Synchronous "Ajax" calls</h2>
     <p>As I mentioned, some(!) asynchronous operations have synchronous counterparts. I don't advocate their use, but for completeness' sake, here is how you would perform a synchronous call:</p>
     <h3>Without jQuery</h3>
     <p>If you directly use a <a href="https://xhr.spec.whatwg.org/" rel="noreferrer"><code>XMLHttpRequest</code></a> object, pass <code>false</code> as third argument to <a href="https://xhr.spec.whatwg.org/#the-open()-method" rel="noreferrer"><code>.open</code></a>.</p>
     <h3>jQuery</h3>
     <p>If you use <a href="http://api.jquery.com/jQuery.ajax/" rel="noreferrer">jQuery</a>, you can set the <code>async</code> option to <code>false</code>. Note that this option is <em>deprecated</em> since jQuery 1.8. You can then either still use a <code>success</code> callback or access the <code>responseText</code> property of the <a href="http://api.jquery.com/jQuery.ajax/#jqXHR" rel="noreferrer">jqXHR object</a>:</p>
     <pre><code>function foo() {
    var jqXHR = $.ajax({
        //...
        async: false
    });
    return jqXHR.responseText;
}
</code></pre>
     <p>If you use any other jQuery Ajax method, such as <code>$.get</code>, <code>$.getJSON</code>, etc., you have to change it to <code>$.ajax</code> (since you can only pass configuration parameters to <code>$.ajax</code>).</p>
     <p><strong>Heads up!</strong> It is not possible to make a synchronous <a href="https://stackoverflow.com/questions/2067472/please-explain-jsonp">JSONP</a> request. JSONP by its very nature is always asynchronous (one more reason to not even consider this option).</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>94</td>
        <td><span>@Pommy: If you want to use jQuery, you have to include it. Please refer to <a href="http://docs.jquery.com/Tutorials:Getting_Started_with_jQuery" rel="nofollow noreferrer">docs.jquery.com/Tutorials:Getting_Started_with_jQuery</a>.</span> <span> - </span> <span class="display-name">Felix Kling</span> <span> </span> <span class="date">17 Jan 2013 at 10:47</span></td>
       </tr>
       <tr>
        <td>23</td>
        <td><span>In Solution 1, sub jQuery, I could not understand this line: <code>If you use any other jQuery AJAX method, such as $.get, $.getJSON, etc., you have them to $.ajax.</code> (Yes, I realize my nick is a tad ironic in this case)</span> <span> - </span> <span class="display-name">cssyphus</span> <span> </span> <span class="date">6 Feb 2013 at 21:07</span></td>
       </tr>
       <tr>
        <td>46</td>
        <td><span>@gibberish: Mmmh, I don't know how it can be made clearer. Do you see how <code>foo</code> is called and a function is passed to it (<code>foo(function(result) {....});</code>)? <code>result</code> is used inside this function and is the response of the Ajax request. To refer to this function, the first parameter of foo is called <code>callback</code> and assigned to <code>success</code> instead of an anonymous function. So, <code>$.ajax</code> will call <code>callback</code> when the request was successful. I tried to explain it a bit more.</span> <span> - </span> <span class="display-name">Felix Kling</span> <span> </span> <span class="date">6 Feb 2013 at 23:29</span></td>
       </tr>
       <tr>
        <td>56</td>
        <td><span>The Chat for this question is dead so I'm not sure where to propose outlined changes, but I propose: 1) Change the synchronous part to a simple discussion of why it's bad with no code example of how to do it. 2) Remove/merge the callback examples to only show the more flexible Deferred approach, which I think may also be a little easier to follow for those learning Javascript.</span> <span> - </span> <span class="display-name">Chris Moschini</span> <span> </span> <span class="date">16 Apr 2013 at 02:45</span></td>
       </tr>
       <tr>
        <td>23</td>
        <td><span>@Jessi: I think you misunderstood that part of the answer. You cannot use <code>$.getJSON</code> if you want the Ajax request to be synchronous. However, you should not event want the request to be synchronous, so that doesn't apply. You should be using callbacks or promises to handle the response, as it is explained earlier in the answer.</span> <span> - </span> <span class="display-name">Felix Kling</span> <span> </span> <span class="date">8 Oct 2015 at 17:44</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@MadaraUchiha, I strongly disagree with your recent edit (the large TL;DR: Use Promises). This question is a dup target for a <i>large</i> number of general async-issue questions (how to return a variable). Putting that code/info at the start is confusing to the people who we are telling this is a duplicate of their problem. The code you provided only shows how to use the Promise that is auto-returned by jQuery's <code>$.ajax()</code> when you don't provide a callback. You have changed a general purpose answer into one which is now only specific to <code>$.ajax()</code>, or functions which auto-return a Promise.(cont)</span> <span> - </span> <span class="display-name">Makyen</span> <span> </span> <span class="date">17 Dec 2016 at 02:38</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@MadaraUchiha:(cont) This is now seen by newbies as too specific and not applicable to their question (which could be for any async function, not just <code>$.ajax()</code>). <code>$.ajax()</code> is just used as an example of the more general issue. Note that I am only here at this question/answer now because what I describe as the response newbies is what has happened when I suggested this as a dup target on a question. If you were not a moderator, I would just revert the edit while we discuss it, but I don't want to, potentially, get into a rollback contest with a moderator.</span> <span> - </span> <span class="display-name">Makyen</span> <span> </span> <span class="date">17 Dec 2016 at 02:38</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>So I must wrap the main function in an async function and then use await in order to get a value from an async function, right?</span> <span> - </span> <span class="display-name">Kadio</span> <span> </span> <span class="date">30 Dec 2021 at 18:18</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Kadio: Not necessarily. An async function returns a promise, so you can also pass a callback to the promise's <code>then</code> method: <code>asyncFunction().then(result =&gt; ...)</code>.</span> <span> - </span> <span class="display-name">Felix Kling</span> <span> </span> <span class="date">31 Dec 2021 at 09:43</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span><code>return await</code> is a mistake and should <b>always</b> be avoided</span> <span> - </span> <span class="display-name">Christian Vincenzo Traina</span> <span> </span> <span class="date">21 Mar 2022 at 09:15</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>The only thing I can see is: JavaScript is an enemy to clean code/architecture. As soon as you need to call anything returning a promise, bid farewell to any separation of concerns in your code: any such module or code will need to end up in a callback hell which ends up outputting data (whatever would be the now-toilet-flushed objective of the module or class, it will now obey the Single-Responsibility-Plus-Output Principle).</span> <span> - </span> <span class="display-name">César Rodriguez</span> <span> </span> <span class="date">26 Apr 2022 at 21:47</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This answer has lots of great information, but I don't think it has a solution to my problem. I'm using the jQuery validator plugin. The plugin has you call its addMethod() function to define a function that it will call on an input element whose name attribute you specify. The function you define must return true or false. But I need to use $.ajax to check with the server if a value is valid. So I need the method called by the validator to return the result of the $.ajax call. I don't have the option of passing in a function to my validator to be called on ajax completion. (cont'd)</span> <span> - </span> <span class="display-name">sootsnoot</span> <span> </span> <span class="date">20 Jan 2023 at 23:14</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The only solution I could come up with was to use the async: false option to $.ajax. And I have been roundly scolded for doing that because it is an anti-pattern, and referred to this post. But I cannot find a different solution in this post!</span> <span> - </span> <span class="display-name">sootsnoot</span> <span> </span> <span class="date">20 Jan 2023 at 23:17</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I asked a <a href="https://stackoverflow.com/questions/75215159/jquery-validation-plugin-validation-custom-method-needs-to-return-result-of-aj">specific question</a> about the jQuery validator plugin, which got an excellent answer. Basically, the interface for custom validation methods for that plugin requires that the method it calls return a boolean, and therefore the method cannot use ajax unless it specifies <code>async: false</code>. In order to avoid making a synchronous call, you must use the plugin's builtin <code>remote</code> method. That method can internally make an async call, because the result is (cont'd)</span> <span> - </span> <span class="display-name">sootsnoot</span> <span> </span> <span class="date">26 Jan 2023 at 19:26</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>only used to make changes to the DOM, it doesn't need to set a value to be returned from the function making the ajax request.</span> <span> - </span> <span class="display-name">sootsnoot</span> <span> </span> <span class="date">26 Jan 2023 at 19:29</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1213</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Benjamin Gruenbaum</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 May 2013 at 23:30</span>
     </div>
    </div>
    <div>
     <h1>If you're <em>not</em> using jQuery in your code, this answer is for you</h1>
     <p>Your code should be something along the lines of this:</p>
     <pre><code>function foo() {
    var httpRequest = new XMLHttpRequest();
    httpRequest.open('GET', "/echo/json");
    httpRequest.send();
    return httpRequest.responseText;
}

var result = foo(); // Always ends up being 'undefined'
</code></pre>
     <p><a href="https://stackoverflow.com/questions/14220321/how-do-i-return-the-response-from-an-asynchronous-call/14220323#14220323">Felix Kling did a fine job</a> writing an answer for people using jQuery for AJAX, but I've decided to provide an alternative for people who aren't.</p>
     <p>(<a href="https://stackoverflow.com/a/30180679/1348195">Note, for those using the new <code>fetch</code> API, Angular or promises I've added another answer below</a>)</p>
     <hr>
     <h1>What you're facing</h1>
     <p>This is a short summary of "Explanation of the problem" from the other answer, if you're not sure after reading this, read that.</p>
     <p>The <strong>A</strong> in AJAX stands for <strong>asynchronous</strong>. That means sending the request (or rather receiving the response) is taken out of the normal execution flow. In your example, <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#send%28%29" rel="noreferrer"><code>.send</code></a> returns immediately and the next statement, <code>return result;</code>, is executed before the function you passed as <code>success</code> callback was even called.</p>
     <p>This means when you're returning, the listener you've defined did not execute yet, which means the value you're returning has not been defined.</p>
     <p>Here is a simple analogy:</p>
     <pre><code>function getFive(){
    var a;
    setTimeout(function(){
         a=5;
    },10);
    return a;
}
</code></pre>
     <p><a href="http://jsfiddle.net/7RK3k/" rel="noreferrer">(Fiddle)</a></p>
     <p>The value of <code>a</code> returned is <code>undefined</code> since the <code>a=5</code> part has not executed yet. AJAX acts like this, you're returning the value before the server got the chance to tell your browser what that value is.</p>
     <p>One possible solution to this problem is to code <em>re-actively</em> , telling your program what to do when the calculation completed.</p>
     <pre><code>function onComplete(a){ // When the code completes, do this
    alert(a);
}

function getFive(whenDone){
    var a;
    setTimeout(function(){
         a=5;
         whenDone(a);
    },10);
}
</code></pre>
     <p>This is called <a href="http://en.wikipedia.org/wiki/Continuation-passing_style" rel="noreferrer">CPS</a>. Basically, we're passing <code>getFive</code> an action to perform when it completes, we're telling our code how to react when an event completes (like our AJAX call, or in this case the timeout).</p>
     <p>Usage would be:</p>
     <pre><code>getFive(onComplete);
</code></pre>
     <p>Which should alert "5" to the screen. <a href="http://jsfiddle.net/PAjZR/" rel="noreferrer">(Fiddle)</a>.</p>
     <h1>Possible solutions</h1>
     <p>There are basically two ways how to solve this:</p>
     <ol>
      <li>Make the AJAX call synchronous (let’s call it SJAX).</li>
      <li>Restructure your code to work properly with callbacks.</li>
     </ol>
     <h2>1. Synchronous AJAX - Don't do it!!</h2>
     <p>As for synchronous AJAX, <strong>don't do it!</strong> Felix's answer raises some compelling arguments about why it's a bad idea. To sum it up, it'll freeze the user's browser until the server returns the response and create a very bad user experience. Here is another short summary taken from MDN on why:</p>
     <blockquote>
      <p>XMLHttpRequest supports both synchronous and asynchronous communications. In general, however, asynchronous requests should be preferred to synchronous requests for performance reasons.</p>
      <p>In short, synchronous requests block the execution of code... ...this can cause serious issues...</p>
     </blockquote>
     <p>If you <em>have</em> to do it, you can pass a flag. <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests#Synchronous_request" rel="noreferrer">Here is how</a>:</p>
     <pre><code>var request = new XMLHttpRequest();
request.open('GET', 'yourURL', false);  // `false` makes the request synchronous
request.send(null);

if (request.status === 200) {// That's HTTP for 'ok'
  console.log(request.responseText);
}
</code></pre>
     <h2>2. Restructure code</h2>
     <p>Let your function accept a callback. In the example code <code>foo</code> can be made to accept a callback. We'll be telling our code how to <em>react</em> when <code>foo</code> completes.</p>
     <p>So:</p>
     <pre><code>var result = foo();
// Code that depends on `result` goes here
</code></pre>
     <p>Becomes:</p>
     <pre><code>foo(function(result) {
    // Code that depends on `result`
});
</code></pre>
     <p>Here we passed an anonymous function, but we could just as easily pass a reference to an existing function, making it look like:</p>
     <pre><code>function myHandler(result) {
    // Code that depends on `result`
}
foo(myHandler);
</code></pre>
     <p>For more details on how this sort of callback design is done, check Felix's answer.</p>
     <p>Now, let's define foo itself to act accordingly</p>
     <pre><code>function foo(callback) {
    var httpRequest = new XMLHttpRequest();
    httpRequest.onload = function(){ // When the request is loaded
       callback(httpRequest.responseText);// We're calling our method
    };
    httpRequest.open('GET', "/echo/json");
    httpRequest.send();
}
</code></pre>
     <p><a href="http://jsfiddle.net/DAcWT/" rel="noreferrer">(fiddle)</a></p>
     <p>We have now made our <em>foo</em> function accept an action to run when the AJAX completes successfully. We can extend this further by checking if the response status is not 200 and acting accordingly (create a fail handler and such). Effectively it is solving our issue.</p>
     <p>If you're still having a hard time understanding this, <a href="https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started" rel="noreferrer">read the AJAX getting started guide</a> at MDN.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>32</td>
        <td><span>"synchronous requests block the execution of code and can leak memory and events" how can a synchronous request leak memory?</span> <span> - </span> <span class="display-name">Matthew G</span> <span> </span> <span class="date">16 Aug 2013 at 05:54</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>447</span>
     </div>
     <div>
      <span>Answerer: </span> <span>cocco</span>
     </div>
     <div>
      <span> Answered: </span> <span>19 Aug 2013 at 08:06</span>
     </div>
    </div>
    <div>
     <p><strong><a href="http://en.wikipedia.org/wiki/XMLHttpRequest" rel="noreferrer">XMLHttpRequest</a> 2</strong> (first of all, read the answers from <a href="https://stackoverflow.com/a/16825593/19068">Benjamin Gruenbaum</a> and <a href="https://stackoverflow.com/a/14220323/19068">Felix Kling</a>)</p>
     <p>If you don't use jQuery and want a nice short XMLHttpRequest 2 which works in the modern browsers and also in the mobile browsers, I suggest to use it this way:</p>
     <pre><code>function ajax(a, b, c){ // URL, callback, just a placeholder
  c = new XMLHttpRequest;
  c.open('GET', a);
  c.onload = b;
  c.send()
}
</code></pre>
     <p>As you can see:</p>
     <ol>
      <li>It's shorter than all other functions Listed.</li>
      <li>The callback is set directly (so no extra unnecessary closures).</li>
      <li>It uses the new onload (so you don't have to check for readystate &amp;&amp; status)</li>
      <li>There are some other situations, which I don't remember, that make the XMLHttpRequest 1 annoying.</li>
     </ol>
     <p>There are two ways to get the response of this Ajax call (three using the XMLHttpRequest var name):</p>
     <p>The simplest:</p>
     <pre><code>this.response
</code></pre>
     <p>Or if for some reason you <code>bind()</code> the callback to a class:</p>
     <pre><code>e.target.response
</code></pre>
     <p>Example:</p>
     <pre><code>function callback(e){
  console.log(this.response);
}
ajax('URL', callback);
</code></pre>
     <p>Or (the above one is better anonymous functions are always a problem):</p>
     <pre><code>ajax('URL', function(e){console.log(this.response)});
</code></pre>
     <p>Nothing easier.</p>
     <p>Now some people will probably say that it's better to use onreadystatechange or the even the XMLHttpRequest variable name. That's wrong.</p>
     <p>Check out <a href="http://caniuse.com/xhr2" rel="noreferrer">XMLHttpRequest advanced features</a>.</p>
     <p>It supported all *modern browsers. And I can confirm as I have been using this approach since XMLHttpRequest 2 was created. I never had any type of problem in any browsers I used.</p>
     <p>onreadystatechange is only useful if you want to get the headers on state 2.</p>
     <p>Using the <code>XMLHttpRequest</code> variable name is another big error as you need to execute the callback inside the onload/oreadystatechange closures, or else you lost it.</p>
     <hr>
     <p>Now if you want something more complex using <a href="https://en.wikipedia.org/wiki/POST_%28HTTP%29" rel="noreferrer">POST</a> and FormData you can easily extend this function:</p>
     <pre><code>function x(a, b, e, d, c){ // URL, callback, method, formdata or {key:val},placeholder
  c = new XMLHttpRequest;
  c.open(e||'get', a);
  c.onload = b;
  c.send(d||null)
}
</code></pre>
     <p>Again ... it's a very short function, but it does <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods" rel="noreferrer">GET</a> and POST.</p>
     <p>Examples of usage:</p>
     <pre><code>x(url, callback); // By default it's GET so no need to set
x(url, callback, 'post', {'key': 'val'}); // No need to set POST data
</code></pre>
     <p>Or pass a full form element (<code>document.getElementsByTagName('form')[0]</code>):</p>
     <pre><code>var fd = new FormData(form);
x(url, callback, 'post', fd);
</code></pre>
     <p>Or set some custom values:</p>
     <pre><code>var fd = new FormData();
fd.append('key', 'val')
x(url, callback, 'post', fd);
</code></pre>
     <p>As you can see, I didn't implement sync... it's a bad thing.</p>
     <p>Having said that ... why don't we do it the easy way?</p>
     <hr>
     <p>As mentioned in the comment, the use of error &amp;&amp; synchronous does completely break the point of the answer. Which is a nice short way to use Ajax in the proper way?</p>
     <p><em>Error handler</em></p>
     <pre><code>function x(a, b, e, d, c){ // URL, callback, method, formdata or {key:val}, placeholder
  c = new XMLHttpRequest;
  c.open(e||'get', a);
  c.onload = b;
  c.onerror = error;
  c.send(d||null)
}

function error(e){
  console.log('--Error--', this.type);
  console.log('this: ', this);
  console.log('Event: ', e)
}
function displayAjax(e){
  console.log(e, this);
}
x('WRONGURL', displayAjax);
</code></pre>
     <p>In the above script, you have an error handler which is statically defined, so it does not compromise the function. The error handler can be used for other functions too.</p>
     <p>But to really get out an error, the <strong>only</strong> way is to write a wrong URL in which case every browser throws an error.</p>
     <p>Error handlers are maybe useful if you set custom headers, set the responseType to blob array buffer, or whatever...</p>
     <p>Even if you pass 'POSTAPAPAP' as the method it won't throw an error.</p>
     <p>Even if you pass 'fdggdgilfdghfldj' as formdata it won't throw an error.</p>
     <p>In the first case the error is inside the <code>displayAjax()</code> under <code>this.statusText</code> as <code>Method not Allowed</code>.</p>
     <p>In the second case, it simply works. You have to check at the server side if you passed the right post data.</p>
     <p>Cross-domain not allowed throws an error automatically.</p>
     <p>In the error response, there aren't any error codes.</p>
     <p>There is only the <code>this.type</code> which is set to <em>error</em>.</p>
     <p>Why add an error handler if you totally don't have any control over errors? Most of the errors are returned inside this in the callback function <code>displayAjax()</code>.</p>
     <p>So: There isn't any need for error checks if you're able to copy and paste the URL properly. ;)</p>
     <p><em>PS: As the first test I wrote x('x', displayAjax)..., and it totally got a response...??? So I checked the folder where the HTML is located, and there was a file called 'x.xml'. So even if you forget the extension of your file XMLHttpRequest 2 WILL FIND IT</em>. I LOL'd</p>
     <hr>
     <p><em>Read a file synchronous</em></p>
     <p><strong>Don't do that.</strong></p>
     <p>If you want to block the browser for a while load a nice big <code>.txt</code> file synchronous.</p>
     <pre><code>function omg(a, c){ // URL
  c = new XMLHttpRequest;
  c.open('GET', a, true);
  c.send();
  return c; // Or c.response
}
</code></pre>
     <p>Now you can do</p>
     <pre><code> var res = omg('thisIsGonnaBlockThePage.txt');
</code></pre>
     <p>There is no other way to do this in a non-asynchronous way. (Yeah, with setTimeout loop... but seriously?)</p>
     <p>Another point is... if you work with APIs or just your own list's files or whatever you always use different functions for each request...</p>
     <p>Only if you have a page where you load always the same XML/JSON or whatever you need only one function. In that case, modify a little the Ajax function and replace b with your special function.</p>
     <hr>
     <p>The functions above are for basic use.</p>
     <p>If you want to <em>extend</em> the function...</p>
     <p>Yes, you can.</p>
     <p>I'm using a lot of APIs and one of the first functions I integrate into every HTML page is the first Ajax function in this answer, with GET only...</p>
     <p>But you can do a lot of stuff with XMLHttpRequest 2:</p>
     <p>I made a download manager (using ranges on both sides with resume, filereader, and filesystem), various image resizers converters using canvas, populate web SQL databases with base64images and much more...</p>
     <p>But in these cases you should create a function only for that purpose... sometimes you need a blob, array buffers, you can set headers, override mimetype and there is a lot more...</p>
     <p>But the question here is how to return an Ajax response... (I added an easy way.)</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>22</td>
        <td><span>While this answer is nice (And we all <i>love</i> XHR2 and posting file data and multipart data is totally awesome) - this shows syntactic sugar for posting XHR with JavaScript - you might want to put this in a blog post (I'd like it) or even in a library (not sure about the name <code>x</code>, <code>ajax</code> or <code>xhr</code> might be nicer :)). I don't see how it addresses returning the response from an AJAX call. (someone could still do <code>var res = x("url")</code> and not understand why it doesn't work ;)). On a side note - it would be cool if you returned <code>c</code> from the method so users can hook on <code>error</code> etc.</span> <span> - </span> <span class="display-name">Benjamin Gruenbaum</span> <span> </span> <span class="date">23 Aug 2013 at 05:56</span></td>
       </tr>
       <tr>
        <td>33</td>
        <td><span><code>2.ajax is meant to be async.. so NO var res=x('url')..</code> That's the entire point of this question and answers :)</span> <span> - </span> <span class="display-name">Benjamin Gruenbaum</span> <span> </span> <span class="date">23 Aug 2013 at 17:28</span></td>
       </tr>
       <tr>
        <td>21</td>
        <td><span>@cocco So you wrote misleading, unreadable code in a SO <i>answer</i> in order to save a few keystrokes? Please don't do that.</span> <span> - </span> <span class="display-name">stone</span> <span> </span> <span class="date">8 Oct 2017 at 06:20</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>370</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Benjamin Gruenbaum</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 May 2015 at 02:22</span>
     </div>
    </div>
    <div>
     <h2>If you're using promises, this answer is for you.</h2>
     <p>This means AngularJS, jQuery (with deferred), native <a href="https://en.wikipedia.org/wiki/XMLHttpRequest" rel="noreferrer">XHR</a>'s replacement (fetch), <a href="https://en.wikipedia.org/wiki/Ember.js" rel="noreferrer">Ember.js</a>, <a href="https://en.wikipedia.org/wiki/Backbone.js" rel="noreferrer">Backbone.js</a>'s save or any <a href="https://en.wikipedia.org/wiki/Node.js" rel="noreferrer">Node.js</a> library that returns promises.</p>
     <p>Your code should be something along the lines of this:</p>
     <pre><code>function foo() {
    var data;
    // Or $.get(...).then, or request(...).then, or query(...).then
    fetch("/echo/json").then(function(response){
        data = response.json();
    });
    return data;
}

var result = foo(); // 'result' is always undefined no matter what.
</code></pre>
     <p><a href="https://stackoverflow.com/questions/14220321/how-do-i-return-the-response-from-an-asynchronous-call/14220323#14220323">Felix Kling did a fine job</a> writing an answer for people using jQuery with callbacks for Ajax. I have an answer for native XHR. This answer is for generic usage of promises either on the frontend or backend.</p>
     <hr>
     <h2>The core issue</h2>
     <p>The JavaScript concurrency model in the browser and on the server with Node.js/io.js is <em>asynchronous</em> and <em>reactive</em>.</p>
     <p>Whenever you call a method that returns a promise, the <code>then</code> handlers are <em>always</em> executed asynchronously - that is, <strong>after</strong> the code below them that is not in a <code>.then</code> handler.</p>
     <p>This means when you're returning <code>data</code> the <code>then</code> handler you've defined did not execute yet. This in turn means that the value you're returning has not been set to the correct value in time.</p>
     <p>Here is a simple analogy for the issue:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="false" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>    function getFive(){
        var data;
        setTimeout(function(){ // Set a timer for one second in the future
           data = 5; // After a second, do this
        }, 1000);
        return data;
    }
    document.body.innerHTML = getFive(); // `undefined` here and not 5</code></pre>
      </div>
     </div>
     <p></p>
     <p>The value of <code>data</code> is <code>undefined</code> since the <code>data = 5</code> part has not executed yet. It will likely execute in a second, but by that time it is irrelevant to the returned value.</p>
     <p>Since the operation did not happen yet (Ajax, server call, I/O, and timer) you're returning the value before the request got the chance to tell your code what that value is.</p>
     <p>One possible solution to this problem is to code <em>re-actively</em>, telling your program what to do when the calculation completed. Promises actively enable this by being temporal (time-sensitive) in nature.</p>
     <h3>Quick recap on promises</h3>
     <p>A Promise is a <em>value over time</em>. Promises have state. They start as pending with no value and can settle to:</p>
     <ul>
      <li><strong>fulfilled</strong> meaning that the computation completed successfully.</li>
      <li><strong>rejected</strong> meaning that the computation failed.</li>
     </ul>
     <p>A promise can only change states <em>once</em> after which it will always stay at the same state forever. You can attach <code>then</code> handlers to promises to extract their value and handle errors. <code>then</code> handlers allow <a href="https://stackoverflow.com/questions/22539815/arent-promises-just-callbacks">chaining</a> of calls. Promises are created by <a href="https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises">using APIs that return them</a>. For example, the more modern Ajax replacement <code>fetch</code> or jQuery's <code>$.get</code> return promises.</p>
     <p>When we call <code>.then</code> on a promise and <em>return</em> something from it - we get a promise for <em>the processed value</em>. If we return another promise we'll get amazing things, but let's hold our horses.</p>
     <h3>With promises</h3>
     <p>Let's see how we can solve the above issue with promises. First, let's demonstrate our understanding of promise states from above by using the <a href="https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Promise" rel="noreferrer">Promise constructor</a> for creating a delay function:</p>
     <pre><code>function delay(ms){ // Takes amount of milliseconds
    // Returns a new promise
    return new Promise(function(resolve, reject){
        setTimeout(function(){ // When the time is up,
            resolve(); // change the promise to the fulfilled state
        }, ms);
    });
}
</code></pre>
     <p>Now, after we <a href="http://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises">converted setTimeout</a> to use promises, we can use <code>then</code> to make it count:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="false" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function delay(ms){ // Takes amount of milliseconds
  // Returns a new promise
  return new Promise(function(resolve, reject){
    setTimeout(function(){ // When the time is up,
      resolve(); // change the promise to the fulfilled state
    }, ms);
  });
}

function getFive(){
  // We're RETURNING the promise. Remember, a promise is a wrapper over our value
  return delay(100).then(function(){ // When the promise is ready,
      return 5; // return the value 5. Promises are all about return values
  })
}
// We _have_ to wrap it like this in the call site, and we can't access the plain value
getFive().then(function(five){
   document.body.innerHTML = five;
});</code></pre>
      </div>
     </div>
     <p></p>
     <p>Basically, instead of returning a <em>value</em> which we can't do because of the concurrency model - we're returning a <em>wrapper</em> for a value that we can <em>unwrap</em> with <code>then</code>. It's like a box you can open with <code>then</code>.</p>
     <h3>Applying this</h3>
     <p>This stands the same for your original API call, you can:</p>
     <pre><code>function foo() {
    // RETURN the promise
    return fetch("/echo/json").then(function(response){
        return response.json(); // Process it inside the `then`
    });
}

foo().then(function(response){
    // Access the value inside the `then`
})
</code></pre>
     <p>So this works just as well. We've learned we can't return values from already asynchronous calls, but we can use promises and chain them to perform processing. We now know how to return the response from an asynchronous call.</p>
     <h2>ES2015 (ES6)</h2>
     <p>ES6 introduces <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" rel="noreferrer">generators</a> which are functions that can return in the middle and then resume the point they were at. This is typically useful for sequences, for example:</p>
     <pre><code>function* foo(){ // Notice the star. This is ES6, so new browsers, Nodes.js, and io.js only
    yield 1;
    yield 2;
    while(true) yield 3;
}
</code></pre>
     <p>Is a function that returns an <em>iterator</em> over the sequence <code>1,2,3,3,3,3,....</code> which can be iterated. While this is interesting on its own and opens room for a lot of possibility, there is one particular interesting case.</p>
     <p>If the sequence we're producing is a sequence of actions rather than numbers - we can pause the function whenever an action is yielded and wait for it before we resume the function. So instead of a sequence of numbers, we need a sequence of <em>future</em> values - that is: promises.</p>
     <p>This somewhat a tricky, but very powerful trick let’s us write asynchronous code in a synchronous manner. There are several "runners" that do this for you. Writing one is a short few lines of code, but it is beyond the scope of this answer. I'll be using Bluebird's <code>Promise.coroutine</code> here, but there are other wrappers like <code>co</code> or <code>Q.async</code>.</p>
     <pre><code>var foo = coroutine(function*(){
    var data = yield fetch("/echo/json"); // Notice the yield
    // The code here only executes _after_ the request is done
    return data.json(); // 'data' is defined
});
</code></pre>
     <p>This method returns a promise itself, which we can consume from other coroutines. For example:</p>
     <pre><code>var main = coroutine(function*(){
   var bar = yield foo(); // Wait our earlier coroutine. It returns a promise
   // The server call is done here, and the code below executes when done
   var baz = yield fetch("/api/users/" + bar.userid); // Depends on foo's result
   console.log(baz); // Runs after both requests are done
});
main();
</code></pre>
     <h2>ES2016 (ES7)</h2>
     <p>In ES7, this is further standardized. There are several proposals right now, but in all of them you can <code>await</code> promise. This is just "sugar" (nicer syntax) for the ES6 proposal above by adding the <code>async</code> and <code>await</code> keywords. Making the above example:</p>
     <pre><code>async function foo(){
    var data = await fetch("/echo/json"); // Notice the await
    // code here only executes _after_ the request is done
    return data.json(); // 'data' is defined
}
</code></pre>
     <p>It still returns a promise just the same :)</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>In short, async functions can either: 1) assign meaningless 'pending' promises or 'undefined' variables to synchronous flow (common gotchas) 2) extract the response body from the fulfilled promise for their own or callback processing 3) return the promise up the 'chain' to another calling async function</span> <span> - </span> <span class="display-name">DWB</span> <span> </span> <span class="date">17 Apr 2023 at 15:57</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>285</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Nic</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 May 2014 at 02:05</span>
     </div>
    </div>
    <div>
     <p>You are using Ajax incorrectly. The idea is not to have it return anything, but instead hand off the data to something called a callback function, which handles the data.</p>
     <p>That is:</p>
     <pre><code>function handleData( responseData ) {

    // Do what you want with the data
    console.log(responseData);
}

$.ajax({
    url: "hi.php",
    ...
    success: function ( data, status, XHR ) {
        handleData(data);
    }
});
</code></pre>
     <p>Returning anything in the submit handler will not do anything. You must instead either hand off the data, or do what you want with it directly inside the success function.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>21</td>
        <td><span>This answer is completely semantic... your success method is just a callback within a callback. You could just have <code>success: handleData</code> and it would work.</span> <span> - </span> <span class="display-name">Jacques ジャック</span> <span> </span> <span class="date">4 Jan 2016 at 15:49</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>278</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Johannes Fahrenkrug</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Aug 2016 at 14:17</span>
     </div>
    </div>
    <div>
     <p>I will answer with a horrible-looking, hand-drawn comic. The second image is the reason why <code>result</code> is <code>undefined</code> in your code example.</p>
     <p><a href="https://i.imgur.com/v5ksbBC.jpg"><img src="https://i.imgur.com/v5ksbBC.jpg" alt="enter image description here"></a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>47</td>
        <td><span><b>A picture is worth a thousand words</b>, <b>Person A</b> - Ask's person B details to fix his car, in turn <b>Person B</b> - Makes Ajax Call and waits for response from server for car fixing details, when response is received, Ajax Success function calls the Person B function and passes the response as argument to it, Person A receives the answer.</span> <span> - </span> <span class="display-name">Shaiju T</span> <span> </span> <span class="date">31 Oct 2016 at 17:48</span></td>
       </tr>
       <tr>
        <td>23</td>
        <td><span>Would be great if you added lines of code with each image to illustrate the concepts.</span> <span> - </span> <span class="display-name">Hassan Baig</span> <span> </span> <span class="date">5 Feb 2018 at 00:32</span></td>
       </tr>
       <tr>
        <td>11</td>
        <td><span>Meanwhile, the guy with the car is stuck on the side of the road. He <i>requires</i> the car is fixed before continuing. He is now alone on the side of the road waiting... He would rather be on the phone waiting for status changes but the mechanic would not do it... The mechanic said he has to get on with his job and can't simply hang out on the phone. Mechanic promised he would call him back as soon as he could. After about 4 hours, the guy gives up and calls Uber. - Example of timeout.</span> <span> - </span> <span class="display-name">barrypicker</span> <span> </span> <span class="date">22 Oct 2019 at 23:42</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>But with callback functions, I feel like the person on the left in the last frame is being forced <i>not</i> to give the other person their phone number. Instead they have to tell the other person, "Here's everything I want to do with the information from the dude on the phone. Do all that stuff and never tell me." What am I missing?</span> <span> - </span> <span class="display-name">Dan Narsavage</span> <span> </span> <span class="date">10 Apr 2021 at 16:52</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@FingLixon It's not a perfect comic by any stretch :-D. The 2nd image should illustrate what happens when you try to read a value too early (before a callback has occurred). The 3rd image illustrates setting up a callback method: The guy on the left basically IS the callback handler: He will be called with the information once it's available and can then do with it whatever he wants. I now think it was a bad idea to have TWO phone calls in this comic: The call to the shop and the call to the guy on the left. I should have simplified that, sorry about that.</span> <span> - </span> <span class="display-name">Johannes Fahrenkrug</span> <span> </span> <span class="date">12 Apr 2021 at 20:44</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>263</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Hemant Bavle</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Feb 2014 at 18:58</span>
     </div>
    </div>
    <div>
     <p>The simplest solution is to create a JavaScript function and call it for the Ajax <code>success</code> callback.</p>
     <pre><code>function callServerAsync(){
    $.ajax({
        url: '...',
        success: function(response) {

            successCallback(response);
        }
    });
}

function successCallback(responseObj){
    // Do something like read the response and show data
    alert(JSON.stringify(responseObj)); // Only applicable to a JSON response
}

function foo(callback) {

    $.ajax({
        url: '...',
        success: function(response) {
           return callback(null, response);
        }
    });
}

var result = foo(function(err, result){
          if (!err)
           console.log(result);
});
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>11</td>
        <td><span>I don't know who voted it negative. But this is a work around which has worked in fact i used this approach to create a whole application. The jquery.ajax don't return data so its better to use the above approach. If it's wrong then please explain and suggest better way to do it.</span> <span> - </span> <span class="display-name">Hemant Bavle</span> <span> </span> <span class="date">28 Mar 2014 at 18:12</span></td>
       </tr>
       <tr>
        <td>20</td>
        <td><span>Sorry, I forgot to leave a comment (I usually do!). I downvoted it. Downvotes don't indicate factual correctness or lack of, they indicate usefulness in the context or lack of. I don't find your answer useful given Felix's which already explains this only in much more detail. On a side note, why would you stringify the response if it's JSON?</span> <span> - </span> <span class="display-name">Benjamin Gruenbaum</span> <span> </span> <span class="date">10 Apr 2014 at 09:18</span></td>
       </tr>
       <tr>
        <td>11</td>
        <td><span>ok.. @Benjamin i used stringify, to convert a JSON Object to string. And thanks for clarifying your point. Will keep in mind to post more elaborate answers.</span> <span> - </span> <span class="display-name">Hemant Bavle</span> <span> </span> <span class="date">10 Apr 2014 at 10:27</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>182</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Maleen Abewardana</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Aug 2014 at 08:11</span>
     </div>
    </div>
    <div>
     <h2>Angular 1</h2>
     <p>People who are using <a href="http://en.wikipedia.org/wiki/AngularJS" rel="noreferrer">AngularJS</a>, can handle this situation using <em>promises</em>.</p>
     <p><a href="http://liamkaufman.com/blog/2013/09/09/using-angularjs-promises/" rel="noreferrer">Here</a> it says,</p>
     <blockquote>
      <p>Promises can be used to unnest asynchronous functions and allows one to chain multiple functions together.</p>
     </blockquote>
     <p>You can find a nice explanation <a href="http://andyshora.com/promises-angularjs-explained-as-cartoon.html" rel="noreferrer">here</a> also.</p>
     <p>An example found in <a href="https://docs.angularjs.org/api/ng/service/$q" rel="noreferrer">documentation</a> mentioned below.</p>
     <pre><code>  promiseB = promiseA.then(
    function onSuccess(result) {
      return result + 1;
    }
    ,function onError(err) {
      // Handle error
    }
  );

 // promiseB will be resolved immediately after promiseA is resolved
 // and its value will be the result of promiseA incremented by 1.
</code></pre>
     <h2>Angular 2 and later</h2>
     <p>In Angular 2 with look at the following example, but its <a href="https://angular-2-training-book.rangle.io/handout/observables/observables_vs_promises.html" rel="noreferrer">recommended</a> to use <em>observables</em> with Angular 2.</p>
     <pre><code> search(term: string) {
     return this.http
       .get(`https://api.spotify.com/v1/search?q=${term}&amp;type=artist`)
       .map((response) =&gt; response.json())
       .toPromise();
}
</code></pre>
     <p>You can consume that in this way,</p>
     <pre><code>search() {
    this.searchService.search(this.searchField.value)
      .then((result) =&gt; {
    this.result = result.artists.items;
  })
  .catch((error) =&gt; console.error(error));
}
</code></pre>
     <p>See the <a href="https://angular-2-training-book.rangle.io/handout/http/requests_as_promises.html" rel="noreferrer">original</a> post here. But TypeScript does not support <a href="http://www.datchley.name/es6-promises/" rel="noreferrer">native ES6 Promises</a>, if you want to use it, you might need plugin for that.</p>
     <p>Additionally, here is the <a href="https://github.com/promises-aplus/promises-spec" rel="noreferrer">promises specification</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>20</td>
        <td><span>This does not explain how promises would solve this issue at all though.</span> <span> - </span> <span class="display-name">Benjamin Gruenbaum</span> <span> </span> <span class="date">4 Nov 2014 at 02:29</span></td>
       </tr>
       <tr>
        <td>9</td>
        <td><span>jQuery and <a href="https://github.com/github/fetch" rel="nofollow noreferrer">fetch</a> methods both return promises as well. I would suggest revising your answer. Though jQuery's isn't quite the same (then is there, but catch isn't).</span> <span> - </span> <span class="display-name">Tracker1</span> <span> </span> <span class="date">19 Feb 2015 at 19:24</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>182</span>
     </div>
     <div>
      <span>Answerer: </span> <span>T.J. Crowder</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 May 2017 at 16:59</span>
     </div>
    </div>
    <div>
     <p>Most of the answers here give useful suggestions for when you have a single async operation, but sometimes, this comes up when you need to do an asynchronous operation for <em>each</em> entry in an array or other list-like structure. The temptation is to do this:</p>
     <pre><code>// WRONG
var results = [];
theArray.forEach(function(entry) {
    doSomethingAsync(entry, function(result) {
        results.push(result);
    });
});
console.log(results); // E.g., using them, returning them, etc.
</code></pre>
     <p>Example:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
      <div class="snippet-code snippet-currently-hidden">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>// WRONG
var theArray = [1, 2, 3];
var results = [];
theArray.forEach(function(entry) {
    doSomethingAsync(entry, function(result) {
        results.push(result);
    });
});
console.log("Results:", results); // E.g., using them, returning them, etc.

function doSomethingAsync(value, callback) {
    console.log("Starting async operation for " + value);
    setTimeout(function() {
        console.log("Completing async operation for " + value);
        callback(value * 2);
    }, Math.floor(Math.random() * 200));
}</code></pre>
       <pre class="snippet-code-css lang-css prettyprint-override"><code>.as-console-wrapper { max-height: 100% !important; }</code></pre>
      </div>
     </div>
     <p></p>
     <p>The reason that doesn't work is that the callbacks from <code>doSomethingAsync</code> haven't run yet by the time you're trying to use the results.</p>
     <p>So, if you have an array (or list of some kind) and want to do async operations for each entry, you have two options: Do the operations in parallel (overlapping), or in series (one after another in sequence).</p>
     <h3>Parallel</h3>
     <p>You can start all of them and keep track of how many callbacks you're expecting, and then use the results when you've gotten that many callbacks:</p>
     <pre><code>var results = [];
var expecting = theArray.length;
theArray.forEach(function(entry, index) {
    doSomethingAsync(entry, function(result) {
        results[index] = result;
        if (--expecting === 0) {
            // Done!
            console.log("Results:", results); // E.g., using the results
        }
    });
});
</code></pre>
     <p>Example:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
      <div class="snippet-code snippet-currently-hidden">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>var theArray = [1, 2, 3];
var results = [];
var expecting = theArray.length;
theArray.forEach(function(entry, index) {
    doSomethingAsync(entry, function(result) {
        results[index] = result;
        if (--expecting === 0) {
            // Done!
            console.log("Results:", JSON.stringify(results)); // E.g., using the results
        }
    });
});

function doSomethingAsync(value, callback) {
    console.log("Starting async operation for " + value);
    setTimeout(function() {
        console.log("Completing async operation for " + value);
        callback(value * 2);
    }, Math.floor(Math.random() * 200));
}</code></pre>
       <pre class="snippet-code-css lang-css prettyprint-override"><code>.as-console-wrapper { max-height: 100% !important; }</code></pre>
      </div>
     </div>
     <p></p>
     <p><em>(We could do away with <code>expecting</code> and just use <code>results.length === theArray.length</code>, but that leaves us open to the possibility that <code>theArray</code> is changed while the calls are outstanding...)</em></p>
     <p>Notice how we use the <code>index</code> from <code>forEach</code> to save the result in <code>results</code> in the same position as the entry it relates to, even if the results arrive out of order (since async calls don't necessarily complete in the order in which they were started).</p>
     <p>But what if you need to <em>return</em> those results from a function? As the other answers have pointed out, you can't; you have to have your function accept and call a callback (or return a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noreferrer">Promise</a>). Here's a callback version:</p>
     <pre><code>function doSomethingWith(theArray, callback) {
    var results = [];
    var expecting = theArray.length;
    theArray.forEach(function(entry, index) {
        doSomethingAsync(entry, function(result) {
            results[index] = result;
            if (--expecting === 0) {
                // Done!
                callback(results);
            }
        });
    });
}
doSomethingWith(theArray, function(results) {
    console.log("Results:", results);
});
</code></pre>
     <p>Example:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
      <div class="snippet-code snippet-currently-hidden">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function doSomethingWith(theArray, callback) {
    var results = [];
    var expecting = theArray.length;
    theArray.forEach(function(entry, index) {
        doSomethingAsync(entry, function(result) {
            results[index] = result;
            if (--expecting === 0) {
                // Done!
                callback(results);
            }
        });
    });
}
doSomethingWith([1, 2, 3], function(results) {
    console.log("Results:", JSON.stringify(results));
});

function doSomethingAsync(value, callback) {
    console.log("Starting async operation for " + value);
    setTimeout(function() {
        console.log("Completing async operation for " + value);
        callback(value * 2);
    }, Math.floor(Math.random() * 200));
}</code></pre>
       <pre class="snippet-code-css lang-css prettyprint-override"><code>.as-console-wrapper { max-height: 100% !important; }</code></pre>
      </div>
     </div>
     <p></p>
     <p>Or here's a version returning a <code>Promise</code> instead:</p>
     <pre><code>function doSomethingWith(theArray) {
    return new Promise(function(resolve) {
        var results = [];
        var expecting = theArray.length;
        theArray.forEach(function(entry, index) {
            doSomethingAsync(entry, function(result) {
                results[index] = result;
                if (--expecting === 0) {
                    // Done!
                    resolve(results);
                }
            });
        });
    });
}
doSomethingWith(theArray).then(function(results) {
    console.log("Results:", results);
});
</code></pre>
     <p><em>Of course, if <code>doSomethingAsync</code> passed us errors, we'd use <code>reject</code> to reject the promise when we got an error.)</em></p>
     <p>Example:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
      <div class="snippet-code snippet-currently-hidden">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function doSomethingWith(theArray) {
    return new Promise(function(resolve) {
        var results = [];
        var expecting = theArray.length;
        theArray.forEach(function(entry, index) {
            doSomethingAsync(entry, function(result) {
                results[index] = result;
                if (--expecting === 0) {
                    // Done!
                    resolve(results);
                }
            });
        });
    });
}
doSomethingWith([1, 2, 3]).then(function(results) {
    console.log("Results:", JSON.stringify(results));
});

function doSomethingAsync(value, callback) {
    console.log("Starting async operation for " + value);
    setTimeout(function() {
        console.log("Completing async operation for " + value);
        callback(value * 2);
    }, Math.floor(Math.random() * 200));
}</code></pre>
       <pre class="snippet-code-css lang-css prettyprint-override"><code>.as-console-wrapper { max-height: 100% !important; }</code></pre>
      </div>
     </div>
     <p></p>
     <p><em>(Or alternately, you could make a wrapper for <code>doSomethingAsync</code> that returns a promise, and then do the below...)</em></p>
     <p>If <code>doSomethingAsync</code> gives you a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noreferrer">Promise</a>, you can use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noreferrer"><code>Promise.all</code></a>:</p>
     <pre><code>function doSomethingWith(theArray) {
    return Promise.all(theArray.map(function(entry) {
        return doSomethingAsync(entry);
    }));
}
doSomethingWith(theArray).then(function(results) {
    console.log("Results:", results);
});
</code></pre>
     <p>If you know that <code>doSomethingAsync</code> will ignore a second and third argument, you can just pass it directly to <code>map</code> (<code>map</code> calls its callback with three arguments, but most people only use the first most of the time):</p>
     <pre><code>function doSomethingWith(theArray) {
    return Promise.all(theArray.map(doSomethingAsync));
}
doSomethingWith(theArray).then(function(results) {
    console.log("Results:", results);
});
</code></pre>
     <p>Example:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
      <div class="snippet-code snippet-currently-hidden">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function doSomethingWith(theArray) {
    return Promise.all(theArray.map(doSomethingAsync));
}
doSomethingWith([1, 2, 3]).then(function(results) {
    console.log("Results:", JSON.stringify(results));
});

function doSomethingAsync(value) {
    console.log("Starting async operation for " + value);
    return new Promise(function(resolve) {
        setTimeout(function() {
            console.log("Completing async operation for " + value);
            resolve(value * 2);
        }, Math.floor(Math.random() * 200));
    });
}</code></pre>
       <pre class="snippet-code-css lang-css prettyprint-override"><code>.as-console-wrapper { max-height: 100% !important; }</code></pre>
      </div>
     </div>
     <p></p>
     <p>Note that <code>Promise.all</code> resolves its promise with an array of the results of all of the promises you give it when they are all resolved, or rejects its promise when the <em>first</em> of the promises you give it rejects.</p>
     <h3>Series</h3>
     <p>Suppose you don't want the operations to be in parallel? If you want to run them one after another, you need to wait for each operation to complete before you start the next. Here's an example of a function that does that and calls a callback with the result:</p>
     <pre><code>function doSomethingWith(theArray, callback) {
    var results = [];
    doOne(0);
    function doOne(index) {
        if (index &lt; theArray.length) {
            doSomethingAsync(theArray[index], function(result) {
                results.push(result);
                doOne(index + 1);
            });
        } else {
            // Done!
            callback(results);
        }
    }
}
doSomethingWith(theArray, function(results) {
    console.log("Results:", results);
});
</code></pre>
     <p><em>(Since we're doing the work in series, we can just use <code>results.push(result)</code> since we know we won't get results out of order. In the above we could have used <code>results[index] = result;</code>, but in some of the following examples we don't have an index to use.)</em></p>
     <p>Example:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
      <div class="snippet-code snippet-currently-hidden">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function doSomethingWith(theArray, callback) {
    var results = [];
    doOne(0);
    function doOne(index) {
        if (index &lt; theArray.length) {
            doSomethingAsync(theArray[index], function(result) {
                results.push(result);
                doOne(index + 1);
            });
        } else {
            // Done!
            callback(results);
        }
    }
}
doSomethingWith([1, 2, 3], function(results) {
    console.log("Results:", JSON.stringify(results));
});

function doSomethingAsync(value, callback) {
    console.log("Starting async operation for " + value);
    setTimeout(function() {
        console.log("Completing async operation for " + value);
        callback(value * 2);
    }, Math.floor(Math.random() * 200));
}</code></pre>
       <pre class="snippet-code-css lang-css prettyprint-override"><code>.as-console-wrapper { max-height: 100% !important; }</code></pre>
      </div>
     </div>
     <p></p>
     <p><em>(Or, again, build a wrapper for <code>doSomethingAsync</code> that gives you a promise and do the below...)</em></p>
     <p>If <code>doSomethingAsync</code> gives you a Promise, if you can use ES2017+ syntax (perhaps with a transpiler like <a href="http://babeljs.io" rel="noreferrer">Babel</a>), you can use an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noreferrer"><code>async</code> function</a> with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" rel="noreferrer"><code>for-of</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" rel="noreferrer"><code>await</code></a>:</p>
     <pre><code>async function doSomethingWith(theArray) {
    const results = [];
    for (const entry of theArray) {
        results.push(await doSomethingAsync(entry));
    }
    return results;
}
doSomethingWith(theArray).then(results =&gt; {
    console.log("Results:", results);
});
</code></pre>
     <p>Example:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
      <div class="snippet-code snippet-currently-hidden">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>async function doSomethingWith(theArray) {
    const results = [];
    for (const entry of theArray) {
        results.push(await doSomethingAsync(entry));
    }
    return results;
}
doSomethingWith([1, 2, 3]).then(function(results) {
    console.log("Results:", JSON.stringify(results));
});

function doSomethingAsync(value) {
    console.log("Starting async operation for " + value);
    return new Promise(function(resolve) {
        setTimeout(function() {
            console.log("Completing async operation for " + value);
            resolve(value * 2);
        }, Math.floor(Math.random() * 200));
    });
}</code></pre>
       <pre class="snippet-code-css lang-css prettyprint-override"><code>.as-console-wrapper { max-height: 100% !important; }</code></pre>
      </div>
     </div>
     <p></p>
     <p>If you can't use ES2017+ syntax (yet), you can use a variation on the <a href="https://stackoverflow.com/questions/43433643/javascript-how-do-i-reduce-multiple-promise-all">"Promise reduce" pattern</a> (this is more complex than the usual Promise reduce because we're not passing the result from one into the next, but instead gathering up their results in an array):</p>
     <pre><code>function doSomethingWith(theArray) {
    return theArray.reduce(function(p, entry) {
        return p.then(function(results) {
            return doSomethingAsync(entry).then(function(result) {
                results.push(result);
                return results;
            });
        });
    }, Promise.resolve([]));
}
doSomethingWith(theArray).then(function(results) {
    console.log("Results:", results);
});
</code></pre>
     <p>Example:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
      <div class="snippet-code snippet-currently-hidden">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function doSomethingWith(theArray) {
    return theArray.reduce(function(p, entry) {
        return p.then(function(results) {
            return doSomethingAsync(entry).then(function(result) {
                results.push(result);
                return results;
            });
        });
    }, Promise.resolve([]));
}
doSomethingWith([1, 2, 3]).then(function(results) {
    console.log("Results:", JSON.stringify(results));
});

function doSomethingAsync(value) {
    console.log("Starting async operation for " + value);
    return new Promise(function(resolve) {
        setTimeout(function() {
            console.log("Completing async operation for " + value);
            resolve(value * 2);
        }, Math.floor(Math.random() * 200));
    });
}</code></pre>
       <pre class="snippet-code-css lang-css prettyprint-override"><code>.as-console-wrapper { max-height: 100% !important; }</code></pre>
      </div>
     </div>
     <p></p>
     <p>...which is less cumbersome with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noreferrer">ES2015+ arrow functions</a>:</p>
     <pre><code>function doSomethingWith(theArray) {
    return theArray.reduce((p, entry) =&gt; p.then(results =&gt; doSomethingAsync(entry).then(result =&gt; {
        results.push(result);
        return results;
    })), Promise.resolve([]));
}
doSomethingWith(theArray).then(results =&gt; {
    console.log("Results:", results);
});
</code></pre>
     <p>Example:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
      <div class="snippet-code snippet-currently-hidden">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function doSomethingWith(theArray) {
    return theArray.reduce((p, entry) =&gt; p.then(results =&gt; doSomethingAsync(entry).then(result =&gt; {
        results.push(result);
        return results;
    })), Promise.resolve([]));
}
doSomethingWith([1, 2, 3]).then(function(results) {
    console.log("Results:", JSON.stringify(results));
});

function doSomethingAsync(value) {
    console.log("Starting async operation for " + value);
    return new Promise(function(resolve) {
        setTimeout(function() {
            console.log("Completing async operation for " + value);
            resolve(value * 2);
        }, Math.floor(Math.random() * 200));
    });
}</code></pre>
       <pre class="snippet-code-css lang-css prettyprint-override"><code>.as-console-wrapper { max-height: 100% !important; }</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>5</td>
        <td><span>Could you explain how the <code>if (--expecting === 0)</code> part of the code works please? The callback version of your solution is working great for me, I just don't understand how, with that statement, you are checking the number of responses completed. Appreciate it's just lack of knowledge on my part. Is there an alternative way that check could be written?</span> <span> - </span> <span class="display-name">Sarah</span> <span> </span> <span class="date">28 May 2017 at 10:21</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>@Sarah: <code>expecting</code> starts out with the value of <code>array.length</code>, which is how many requests we're going to make. We know the callback won't be called until all of those requests are started. In the callback, <code>if (--expecting === 0)</code> does this: 1. Decrements <code>expecting</code> (we've received a response, so we're expecting one fewer response) and if the value <i>after</i> the decrement is 0 (we're not expecting any more responses), we're done!</span> <span> - </span> <span class="display-name">T.J. Crowder</span> <span> </span> <span class="date">28 May 2017 at 18:31</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@Henke - I think it is indeed personal preference, and while normally I'd prefer to log raw data and let the console handle it, in this specific case I think you're right about the change. Thanks! :-)</span> <span> - </span> <span class="display-name">T.J. Crowder</span> <span> </span> <span class="date">6 May 2021 at 11:27</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Out of convenience for myself (and others?), adding a link to a related answer: <a href="https://stackoverflow.com/a/31426920">How to make many asynchronous calls and wait for them all</a>.</span> <span> - </span> <span class="display-name">Henke</span> <span> </span> <span class="date">1 Jun 2021 at 14:01</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>127</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Francisco Carmona</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Jun 2016 at 08:31</span>
     </div>
    </div>
    <div>
     <p><strong>Have a look at this example:</strong></p>
     <pre><code>var app = angular.module('plunker', []);

app.controller('MainCtrl', function($scope,$http) {

    var getJoke = function(){
        return $http.get('http://api.icndb.com/jokes/random').then(function(res){
            return res.data.value;  
        });
    }

    getJoke().then(function(res) {
        console.log(res.joke);
    });
});
</code></pre>
     <p>As you can see <code>getJoke</code> is <strong>returning a</strong> resolved <strong>promise</strong> (it is resolved when returning <code>res.data.value</code>). So you wait until the <strong>$http.get</strong> request is completed and then <strong>console.log(res.joke)</strong> is executed (as a normal asynchronous flow).</p>
     <p><strong>This is the plnkr:</strong></p>
     <p><a href="http://embed.plnkr.co/XlNR7HpCaIhJxskMJfSg/" rel="noreferrer">http://embed.plnkr.co/XlNR7HpCaIhJxskMJfSg/</a></p>
     <p><strong>ES6 way (async - await)</strong></p>
     <pre><code>(function(){
  async function getJoke(){
    let response = await fetch('http://api.icndb.com/jokes/random');
    let data = await response.json();
    return data.value;
  }

  getJoke().then((joke) =&gt; {
    console.log(joke);
  });
})();
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>126</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Alireza</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 May 2017 at 09:38</span>
     </div>
    </div>
    <div>
     <p>This is one of the places which <strong>two-way data binding</strong> or <strong>store concept</strong> that's used in many new JavaScript frameworks will work great for you...</p>
     <p>So if you are using <a href="https://en.wikipedia.org/wiki/Angular_(web_framework)" rel="noreferrer">Angular</a>, <a href="https://en.wikipedia.org/wiki/React_(web_framework)" rel="noreferrer">React</a>, or any other frameworks which do two-way data binding or store concept, this issue is simply fixed for you, so in easy words, your result is <code>undefined</code> at the first stage, so you have got <code>result = undefined</code> before you receive the data, then as soon as you get the result, it will be updated and get assigned to the new value which response of your Ajax call...</p>
     <p>But how you can do it in pure JavaScript or jQuery for example as you asked in this question?</p>
     <p>You can use a callback, promise and recently observable to handle it for you. For example, in promises we have some function like <code>success()</code> or <code>then()</code> which will be executed when your data is ready for you. The same with callback or the <em>subscribe</em> function on an observable.</p>
     <p>For example, in your case which you are using jQuery, you can do something like this:</p>
     <pre><code>$(document).ready(function(){
    function foo() {
        $.ajax({url: "api/data", success: function(data){
            fooDone(data); // After we have data, we pass it to fooDone
        }});
    };

    function fooDone(data) {
        console.log(data); // fooDone has the data and console.log it
    };

    foo(); // The call happens here
});
</code></pre>
     <p>For more information, study promises and observables which are newer ways to do this async stuff.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span>This is fine at global scope, but in some module context you probably want to ensure right context for the callback e.g. <code>$.ajax({url: "api/data", success: fooDone.bind(this)});</code></span> <span> - </span> <span class="display-name">steve.sims</span> <span> </span> <span class="date">24 Jul 2017 at 06:14</span></td>
       </tr>
       <tr>
        <td>13</td>
        <td><span>This is actually incorrect as React is one-way data binding</span> <span> - </span> <span class="display-name">Matthew Brent</span> <span> </span> <span class="date">4 May 2018 at 15:57</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@MatthewBrent you are not wrong, but not right also, React props are object and if changed, they change throughout the application, but its not a way that React developer recommend to use it...</span> <span> - </span> <span class="display-name">Alireza</span> <span> </span> <span class="date">14 May 2018 at 07:34</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>123</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Anish K.</span>
     </div>
     <div>
      <span> Answered: </span> <span>31 Oct 2017 at 20:12</span>
     </div>
    </div>
    <div>
     <p>It's a very common issue we face while struggling with the 'mysteries' of JavaScript. Let me try demystifying this mystery today.</p>
     <p>Let's start with a simple JavaScript function:</p>
     <pre><code>function foo(){
    // Do something
    return 'wohoo';
}

let bar = foo(); // 'bar' is 'wohoo' here
</code></pre>
     <p>That's a simple synchronous function call (where each line of code is 'finished with its job' before the next one in sequence), and the result is same as expected.</p>
     <p>Now let's add a bit of twist, by introducing a little delay in our function, so that all lines of code are not 'finished' in sequence. Thus, it will emulate the asynchronous behavior of the function:</p>
     <pre><code>function foo(){
    setTimeout( ()=&gt; {
        return 'wohoo';
   }, 1000)
}

let bar = foo() // 'bar' is undefined here
</code></pre>
     <p>So there you go; that delay just broke the functionality we expected! But what exactly happened? Well, it's actually pretty logical if you look at the code.</p>
     <p>The function <code>foo()</code>, upon execution, returns nothing (thus returned value is <code>undefined</code>), but it does start a timer, which executes a function after 1 second to return 'wohoo'. But as you can see, the value that's assigned to bar is the immediately returned stuff from foo(), which is nothing, i.e., just <code>undefined</code>.</p>
     <p><strong>So, how do we tackle this issue?</strong></p>
     <p>Let's ask our function for a <em>promise</em>. Promise is really about what it means: it means that the function guarantees you to provide with any output it gets in future. So let's see it in action for our little problem above:</p>
     <pre><code>function foo(){
   return new Promise((resolve, reject) =&gt; { // I want foo() to PROMISE me something
    setTimeout ( function(){
      // Promise is RESOLVED, when the execution reaches this line of code
       resolve('wohoo') // After 1 second, RESOLVE the promise with value 'wohoo'
    }, 1000 )
  })
}

let bar;
foo().then( res =&gt; {
    bar = res;
    console.log(bar) // Will print 'wohoo'
});
</code></pre>
     <p>Thus, the summary is - to tackle the asynchronous functions like Ajax-based calls, etc., you can use a promise to <code>resolve</code> the value (which you intend to return). Thus, in short you <strong>resolve</strong> value instead of <strong>returning</strong>, in asynchronous functions.</p>
     <h2>UPDATE (Promises with async/await)</h2>
     <p>Apart from using <code>then/catch</code> to work with promises, there exists one more approach. The idea is to <em>recognize an asynchronous function</em> and then <em>wait for the promises</em> to resolve, before moving to the next line of code. It's still just the <code>promises</code> under the hood, but with a different syntactical approach. To make things clearer, you can find a comparison below:</p>
     <h3>then/catch version:</h3>
     <pre><code>function saveUsers(){
     getUsers()
      .then(users =&gt; {
         saveSomewhere(users);
      })
      .catch(err =&gt; {
          console.error(err);
       })
 }
</code></pre>
     <h3>async/await version:</h3>
     <pre><code>  async function saveUsers(){
     try{
        let users = await getUsers()
        saveSomewhere(users);
     }
     catch(err){
        console.error(err);
     }
  }
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>is this still considered the best way to return a value from a promise or async/await?</span> <span> - </span> <span class="display-name">edwardsmarkf</span> <span> </span> <span class="date">26 Sep 2018 at 20:58</span></td>
       </tr>
       <tr>
        <td>8</td>
        <td><span>@edwardsmarkf Personally I don't think there's a best way as such. I use promises with then/catch , async/await as well as generators for async portions of my code. It largely depends on the context of usage.</span> <span> - </span> <span class="display-name">Anish K.</span> <span> </span> <span class="date">3 Oct 2018 at 16:12</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>114</span>
     </div>
     <div>
      <span>Answerer: </span> <span>jsbisht</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Sep 2015 at 12:54</span>
     </div>
    </div>
    <div>
     <p>Another approach to return a value from an asynchronous function, is to pass in an object that will store the result from the asynchronous function.</p>
     <p>Here is an example of the same:</p>
     <pre><code>var async = require("async");

// This wires up result back to the caller
var result = {};
var asyncTasks = [];
asyncTasks.push(function(_callback){
    // some asynchronous operation
    $.ajax({
        url: '...',
        success: function(response) {
            result.response = response;
            _callback();
        }
    });
});

async.parallel(asyncTasks, function(){
    // result is available after performing asynchronous operation
    console.log(result)
    console.log('Done');
});
</code></pre>
     <p>I am using the <code>result</code> object to store the value during the asynchronous operation. This allows the result be available even after the asynchronous job.</p>
     <p>I use this approach a lot. I would be interested to know how well this approach works where wiring the result back through consecutive modules is involved.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>12</td>
        <td><span>There is nothing special about using an object here. It would work as well if you assigned he response directly to <code>result</code>. It works because you are reading the variable <i>after</i> the async function is complete.</span> <span> - </span> <span class="display-name">Felix Kling</span> <span> </span> <span class="date">2 Sep 2015 at 13:18</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span> <span class="arrow"> <a href="#answer_15">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>100</span>
     </div>
     <div>
      <span>Answerer: </span> <span>rohithpr</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Jan 2016 at 17:43</span>
     </div>
    </div>
    <div>
     <p>While promises and callbacks work fine in many situations, it is a pain in the rear to express something like:</p>
     <pre><code>if (!name) {
  name = async1();
}
async2(name);
</code></pre>
     <p>You'd end up going through <code>async1</code>; check if <code>name</code> is undefined or not and call the callback accordingly.</p>
     <pre><code>async1(name, callback) {
  if (name)
    callback(name)
  else {
    doSomething(callback)
  }
}

async1(name, async2)
</code></pre>
     <p>While it is <em>okay</em> in small examples it gets annoying when you have a lot of similar cases and error handling involved.</p>
     <p><code>Fibers</code> helps in solving the issue.</p>
     <pre><code>var Fiber = require('fibers')

function async1(container) {
  var current = Fiber.current
  var result
  doSomething(function(name) {
    result = name
    fiber.run()
  })
  Fiber.yield()
  return result
}

Fiber(function() {
  var name
  if (!name) {
    name = async1()
  }
  async2(name)
  // Make any number of async calls from here
}
</code></pre>
     <p>You can checkout the project <a href="https://github.com/laverdet/node-fibers">here</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span>is this similar to generator functions? <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function" rel="nofollow noreferrer">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/…</a>*</span> <span> - </span> <span class="display-name">Emanegux</span> <span> </span> <span class="date">7 Jun 2017 at 03:19</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>Is this still relevant?</span> <span> - </span> <span class="display-name">Aluan Haddad</span> <span> </span> <span class="date">18 Mar 2018 at 19:43</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>You can make use of <code>async-await</code> if you're using some of the newest versions of node. If someone is stuck with older versions they can use this method.</span> <span> - </span> <span class="display-name">rohithpr</span> <span> </span> <span class="date">20 Mar 2018 at 08:18</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_15"><span>Answer 15</span> <span class="arrow"> <a href="#answer_14">↑</a> </span> <span class="arrow"> <a href="#answer_16">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>95</span>
     </div>
     <div>
      <span>Answerer: </span> <span>loretoparisi</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Apr 2016 at 22:55</span>
     </div>
    </div>
    <div>
     <p>The following example I have written shows how to</p>
     <ul>
      <li>Handle asynchronous HTTP calls;</li>
      <li>Wait for response from each API call;</li>
      <li>Use <a href="https://en.wikipedia.org/wiki/Futures_and_promises" rel="noreferrer">Promise</a> pattern;</li>
      <li>Use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noreferrer">Promise.all</a> pattern to join multiple HTTP calls;</li>
     </ul>
     <p>This working example is self-contained. It will define a simple request object that uses the window <code>XMLHttpRequest</code> object to make calls. It will define a simple function to wait for a bunch of promises to be completed.</p>
     <p>Context. The example is querying the <a href="https://developer.spotify.com/web-api/endpoint-reference/" rel="noreferrer">Spotify Web API</a> endpoint in order to search for <code>playlist</code> objects for a given set of query strings:</p>
     <pre><code>[
 "search?type=playlist&amp;q=%22doom%20metal%22",
 "search?type=playlist&amp;q=Adele"
]
</code></pre>
     <p>For each item, a new Promise will fire a block - <code>ExecutionBlock</code>, parse the result, schedule a new set of promises based on the result array, that is a list of Spotify <code>user</code> objects and execute the new HTTP call within the <code>ExecutionProfileBlock</code> asynchronously.</p>
     <p>You can then see a nested Promise structure, that lets you spawn multiple and completely asynchronous nested HTTP calls, and join the results from each subset of calls through <code>Promise.all</code>.</p>
     <p><strong>NOTE</strong> Recent Spotify <code>search</code> APIs will require an access token to be specified in the request headers:</p>
     <pre><code>-H "Authorization: Bearer {your access token}" 
</code></pre>
     <p>So, you to run the following example you need to put your access token in the request headers:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="false" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>var spotifyAccessToken = "YourSpotifyAccessToken";
var console = {
    log: function(s) {
        document.getElementById("console").innerHTML += s + "&lt;br/&gt;"
    }
}

// Simple XMLHttpRequest
// based on https://davidwalsh.name/xmlhttprequest
SimpleRequest = {
    call: function(what, response) {
        var request;
        if (window.XMLHttpRequest) { // Mozilla, Safari, ...
            request = new XMLHttpRequest();
        } else if (window.ActiveXObject) { // Internet Explorer
            try {
                request = new ActiveXObject('Msxml2.XMLHTTP');
            }
            catch (e) {
                try {
                  request = new ActiveXObject('Microsoft.XMLHTTP');
                } catch (e) {}
            }
        }

        // State changes
        request.onreadystatechange = function() {
            if (request.readyState === 4) { // Done
                if (request.status === 200) { // Complete
                    response(request.responseText)
                }
                else
                    response();
            }
        }
        request.open('GET', what, true);
        request.setRequestHeader("Authorization", "Bearer " + spotifyAccessToken);
        request.send(null);
    }
}

//PromiseAll
var promiseAll = function(items, block, done, fail) {
    var self = this;
    var promises = [],
                   index = 0;
    items.forEach(function(item) {
        promises.push(function(item, i) {
            return new Promise(function(resolve, reject) {
                if (block) {
                    block.apply(this, [item, index, resolve, reject]);
                }
            });
        }(item, ++index))
    });
    Promise.all(promises).then(function AcceptHandler(results) {
        if (done) done(results);
    }, function ErrorHandler(error) {
        if (fail) fail(error);
    });
}; //promiseAll

// LP: deferred execution block
var ExecutionBlock = function(item, index, resolve, reject) {
    var url = "https://api.spotify.com/v1/"
    url += item;
    console.log( url )
    SimpleRequest.call(url, function(result) {
        if (result) {

            var profileUrls = JSON.parse(result).playlists.items.map(function(item, index) {
                return item.owner.href;
            })
            resolve(profileUrls);
        }
        else {
            reject(new Error("call error"));
        }
    })
}

arr = [
    "search?type=playlist&amp;q=%22doom%20metal%22",
    "search?type=playlist&amp;q=Adele"
]

promiseAll(arr, function(item, index, resolve, reject) {
    console.log("Making request [" + index + "]")
    ExecutionBlock(item, index, resolve, reject);
}, function(results) { // Aggregated results

    console.log("All profiles received " + results.length);
    //console.log(JSON.stringify(results[0], null, 2));

    ///// promiseall again

    var ExecutionProfileBlock = function(item, index, resolve, reject) {
        SimpleRequest.call(item, function(result) {
            if (result) {
                var obj = JSON.parse(result);
                resolve({
                    name: obj.display_name,
                    followers: obj.followers.total,
                    url: obj.href
                });
            } //result
        })
    } //ExecutionProfileBlock

    promiseAll(results[0], function(item, index, resolve, reject) {
        //console.log("Making request [" + index + "] " + item)
        ExecutionProfileBlock(item, index, resolve, reject);
    }, function(results) { // aggregated results
        console.log("All response received " + results.length);
        console.log(JSON.stringify(results, null, 2));
    }

    , function(error) { // Error
        console.log(error);
    })

    /////

  },
  function(error) { // Error
      console.log(error);
  });</code></pre>
       <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;div id="console" /&gt;</code></pre>
      </div>
     </div>
     <p></p>
     <p>I have extensively discussed this solution <a href="https://stackoverflow.com/questions/36536245/how-to-search-for-a-user-by-name-using-spotify-web-api/36537774#36537774">here</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_16"><span>Answer 16</span> <span class="arrow"> <a href="#answer_15">↑</a> </span> <span class="arrow"> <a href="#answer_17">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>95</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Pablo Matias Gomez</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Apr 2016 at 14:47</span>
     </div>
    </div>
    <div>
     <p>The short answer is, <strong>you have to implement a callback like this:</strong></p>
     <pre><code>function callback(response) {
    // Here you can do what ever you want with the response object.
    console.log(response);
}

$.ajax({
    url: "...",
    success: callback
});
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_17"><span>Answer 17</span> <span class="arrow"> <a href="#answer_16">↑</a> </span> <span class="arrow"> <a href="#answer_18">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>91</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Aniket Jha</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Feb 2018 at 06:06</span>
     </div>
    </div>
    <div>
     <blockquote>
      <p>JavaScript is single threaded.</p>
     </blockquote>
     <p>The browser can be divided into three parts:</p>
     <ol>
      <li>
       <p>Event Loop</p></li>
      <li>
       <p>Web API</p></li>
      <li>
       <p>Event Queue</p></li>
     </ol>
     <p>The event loop runs for forever, i.e., kind of an infinite loop. The event queue is where all your functions are pushed on some event (example: click).</p>
     <p>This is one by one carried out of queue and put into the event loop which executes this function and prepares itself for the next one after the first one is executed. This means execution of one function doesn't start until the function before it in the queue is executed in the event loop.</p>
     <p>Now let us think we pushed two functions in a queue. One is for getting a data from the server and another utilises that data. We pushed the serverRequest() function in the queue first and then the utiliseData() function. The serverRequest function goes in the event loop and makes a call to server as we never know how much time it will take to get data from server, so this process is expected to take time and so we busy our event loop thus hanging our page.</p>
     <p>That's where Web API come into the role. It takes this function from the event loop and deals with the server making the event loop free, so that we can execute the next function from the queue.</p>
     <p>The next function in the queue is utiliseData() which goes in the loop, but because of no data available, it goes to waste and execution of the next function continues until the end of the queue. (This is called Async calling, i.e., we can do something else until we get data.)</p>
     <p>Let us suppose our serverRequest() function had a return statement in code. When we get back data from the server Web API, it will push it in the queue at the end of queue.</p>
     <p>As it gets pushed at the end of the queue, we cannot utilise its data as there isn't any function left in our queue to utilise this data. <strong>Thus it is not possible to return something from the async call.</strong></p>
     <p>Thus the <em>solution</em> to this is <em>callback</em> or <em>promise</em>.</p>
     <ul>
      <li>An <em>image</em> from <a href="https://stackoverflow.com/questions/14220321/how-do-i-return-the-response-from-an-asynchronous-call/38898933#38898933">one of the answers here</a> correctly explains callback use...*</li>
     </ul>
     <p>We give our function (function utilising data returned from the server) to a function calling the server.</p>
     <p><a href="https://i.stack.imgur.com/UCJgN.png" rel="noreferrer"><img src="https://i.stack.imgur.com/UCJgN.png" alt="Callback"></a></p>
     <pre><code>function doAjax(callbackFunc, method, url) {
    var xmlHttpReq = new XMLHttpRequest();
    xmlHttpReq.open(method, url);
    xmlHttpReq.onreadystatechange = function() {

        if (xmlHttpReq.readyState == 4 &amp;&amp; xmlHttpReq.status == 200) {
            callbackFunc(xmlHttpReq.responseText);
        }
    }
    xmlHttpReq.send(null);
}
</code></pre>
     <p>In my <em>code</em> it is called as:</p>
     <pre><code>function loadMyJson(categoryValue){
    if(categoryValue === "veg")
        doAjax(print, "GET", "http://localhost:3004/vegetables");
    else if(categoryValue === "fruits")
        doAjax(print, "GET", "http://localhost:3004/fruits");
    else
      console.log("Data not found");
}
</code></pre>
     <p><a href="https://javascript.info/callbacks" rel="noreferrer">JavaScript.info callback</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_18"><span>Answer 18</span> <span class="arrow"> <a href="#answer_17">↑</a> </span> <span class="arrow"> <a href="#answer_19">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>87</span>
     </div>
     <div>
      <span>Answerer: </span> <span>mikemaccana</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Jun 2017 at 09:51</span>
     </div>
    </div>
    <div>
     <h1>2017 answer: you can now do exactly what you want in every current browser and <a href="https://en.wikipedia.org/wiki/Node.js" rel="nofollow noreferrer">Node.js</a></h1>
     <p>This is quite simple:</p>
     <ul>
      <li>Return a Promise</li>
      <li>Use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" rel="nofollow noreferrer">'await'</a>, which will tell JavaScript to await the promise to be resolved into a value (like the HTTP response)</li>
      <li>Add the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="nofollow noreferrer">'async'</a> keyword to the parent function</li>
     </ul>
     <p>Here's a working version of your code:</p>
     <pre><code>(async function(){

    var response = await superagent.get('...')
    console.log(response)

})()
</code></pre>
     <p><a href="http://caniuse.com/#search=await" rel="nofollow noreferrer">await is supported in all current browsers and Node.js 8</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>9</td>
        <td><span>Unfortunately, this works only with functions that return promises – for example it doesn't work with Node.js API, which uses callbacks. And I wouldn't recommend using it without Babel, because not everyone uses "current browsers".</span> <span> - </span> <span class="display-name">Michał Perłakowski</span> <span> </span> <span class="date">8 Jun 2017 at 06:47</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>@MichałPerłakowski node 8 includes <a href="https://nodejs.org/api/util.html#util_util_promisify_original" rel="nofollow noreferrer">nodejs.org/api/util.html#util_util_promisify_original</a> which can be used to make the node.js API return promises. Whether you have the time and money to support non-current browsers obviously depends on your situation.</span> <span> - </span> <span class="display-name">mikemaccana</span> <span> </span> <span class="date">9 Jun 2017 at 18:28</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>IE 11 is still a current browser in 2018, sadly and it doesn't support <code>await/async</code></span> <span> - </span> <span class="display-name">Ruan Mendes</span> <span> </span> <span class="date">4 Oct 2018 at 14:51</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>IE11 is not a current browser. It was released 5 years ago, has a worldwide market share of 2.5% according to caniuse, and unless someone is doubling your budget to ignore all current tech then it's not worth most people's time.</span> <span> - </span> <span class="display-name">mikemaccana</span> <span> </span> <span class="date">4 Oct 2018 at 14:57</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_19"><span>Answer 19</span> <span class="arrow"> <a href="#answer_18">↑</a> </span> <span class="arrow"> <a href="#answer_20">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>73</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Vinoth Rajendran</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 May 2016 at 13:26</span>
     </div>
    </div>
    <div>
     <p>You can use this custom library (written using Promise) to make a remote call.</p>
     <pre><code>function $http(apiConfig) {
    return new Promise(function (resolve, reject) {
        var client = new XMLHttpRequest();
        client.open(apiConfig.method, apiConfig.url);
        client.send();
        client.onload = function () {
            if (this.status &gt;= 200 &amp;&amp; this.status &lt; 300) {
                // Performs the function "resolve" when this.status is equal to 2xx.
                // Your logic here.
                resolve(this.response);
            }
            else {
                // Performs the function "reject" when this.status is different than 2xx.
                reject(this.statusText);
            }
        };
        client.onerror = function () {
            reject(this.statusText);
        };
    });
}
</code></pre>
     <p>Simple usage example:</p>
     <pre><code>$http({
    method: 'get',
    url: 'google.com'
}).then(function(response) {
    console.log(response);
}, function(error) {
    console.log(error)
});
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_20"><span>Answer 20</span> <span class="arrow"> <a href="#answer_19">↑</a> </span> <span class="arrow"> <a href="#answer_21">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>73</span>
     </div>
     <div>
      <span>Answerer: </span> <span>amaksr</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 May 2017 at 02:47</span>
     </div>
    </div>
    <div>
     <p>Another solution is to execute code via the sequential executor <a href="https://github.com/amaksr/nsynjs" rel="nofollow noreferrer">nsynjs</a>.</p>
     <h2>If the underlying function is promisified</h2>
     <p>nsynjs will evaluate all promises sequentially, and put the promise result into the <code>data</code> property:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function synchronousCode() {

    var getURL = function(url) {
        return window.fetch(url).data.text().data;
    };
    
    var url = 'https://ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js';
    console.log('received bytes:',getURL(url).length);
    
};

nsynjs.run(synchronousCode,{},function(){
    console.log('synchronousCode done');
});</code></pre>
       <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;script src="https://rawgit.com/amaksr/nsynjs/master/nsynjs.js"&gt;&lt;/script&gt;</code></pre>
      </div>
     </div>
     <p></p>
     <h2>If the underlying function is not promisified</h2>
     <p>Step 1. Wrap the function with a callback into the nsynjs-aware wrapper (if it has a promisified version, you can skip this step):</p>
     <pre><code>var ajaxGet = function (ctx,url) {
    var res = {};
    var ex;
    $.ajax(url)
    .done(function (data) {
        res.data = data;
    })
    .fail(function(e) {
        ex = e;
    })
    .always(function() {
        ctx.resume(ex);
    });
    return res;
};
ajaxGet.nsynjsHasCallback = true;
</code></pre>
     <p>Step 2. Put synchronous logic into function:</p>
     <pre><code>function process() {
    console.log('got data:', ajaxGet(nsynjsCtx, "data/file1.json").data);
}
</code></pre>
     <p>Step 3. Run function in synchronous manner via nsynjs:</p>
     <pre><code>nsynjs.run(process,this,function () {
    console.log("synchronous function finished");
});
</code></pre>
     <p>Nsynjs will evaluate all operators and expressions step-by-step, pausing execution in case if the result of some slow function is not ready.</p>
     <p>More examples are <a href="https://github.com/amaksr/nsynjs/tree/master/examples" rel="nofollow noreferrer">here</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>This is interesting. I like how it allows to code async calls the way you'd do it in other languages. But technically it's not real JavaScript?</span> <span> - </span> <span class="display-name">J Morris</span> <span> </span> <span class="date">16 Jun 2017 at 23:55</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_21"><span>Answer 21</span> <span class="arrow"> <a href="#answer_20">↑</a> </span> <span class="arrow"> <a href="#answer_22">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>45</span>
     </div>
     <div>
      <span>Answerer: </span> <span>James</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Feb 2018 at 15:26</span>
     </div>
    </div>
    <div>
     <p>ECMAScript 6 has 'generators' which allow you to easily program in an asynchronous style.</p>
     <pre><code>function* myGenerator() {
    const callback = yield;
    let [response] = yield $.ajax("https://stackoverflow.com", {complete: callback});
    console.log("response is:", response);

    // examples of other things you can do
    yield setTimeout(callback, 1000);
    console.log("it delayed for 1000ms");
    while (response.statusText === "error") {
        [response] = yield* anotherGenerator();
    }
}
</code></pre>
     <p>To run the above code you do this:</p>
     <pre><code>const gen = myGenerator(); // Create generator
gen.next(); // Start it
gen.next((...args) =&gt; gen.next([...args])); // Set its callback function
</code></pre>
     <p>If you need to target browsers that don't support ES6 you can run the code through Babel or closure-compiler to generate ECMAScript 5.</p>
     <p>The callback <code>...args</code> are wrapped in an array and destructured when you read them so that the pattern can cope with callbacks that have multiple arguments. For example with <a href="https://nodejs.org/api/fs.html" rel="noreferrer">node fs</a>:</p>
     <pre><code>const [err, data] = yield fs.readFile(filePath, "utf-8", callback);
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Do you consider generators / async generators to be an async API solution alone ? Or you would use generators to wrap another asynchronous API like promise/deffered ? I agree it is another strong addition to the async universe but still haven't found the right usage of generators that would make me adopt them.</span> <span> - </span> <span class="display-name">Eva Cohen</span> <span> </span> <span class="date">17 Jan 2021 at 18:52</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_22"><span>Answer 22</span> <span class="arrow"> <a href="#answer_21">↑</a> </span> <span class="arrow"> <a href="#answer_23">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>45</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Henke</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 May 2021 at 10:24</span>
     </div>
    </div>
    <div>
     <h3>1. A first stumbling step</h3>
     <p>As for many others, my encounter with asynchronous calls was puzzling at first.<br>
       I don't remember the details, but I may have tried something like:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>let result;

$.ajax({
  url: 'https://jsonplaceholder.typicode.com/todos/1',
  success: function (response) {
    console.log('\nInside $.ajax:');
    console.log(response);
    result = response;
  }
});

console.log('Finally, the result: ' + result);</code></pre>
       <pre class="snippet-code-css lang-css prettyprint-override"><code>.as-console-wrapper { max-height: 100% !important; top: 0; }</code></pre>
       <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;script src=
"https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"&gt;&lt;/script&gt;</code></pre>
      </div>
     </div>
     <p></p>
     <p><em>Whoops!</em> The output of the line <code>console.log('Finally, the result: ' + result);</code> which I thought would be printed <em>last</em>, is actually printed <em>before</em> the other output! – And it doesn't contain the result: it just prints <code>undefined</code>. <sup>1</sup><br>
       How come?</p>
     <p><strong>A helpful insight</strong></p>
     <p>I distinctly remember my first <em>aha!</em> moment on how to understand asynchronous calls.<br>
       It was <a href="https://stackoverflow.com/q/44298196#comment75602602_44298196">this comment</a> saying:<br><em>you actually don't want to get the data <strong>out</strong> of a callback;<br>
        you want to get your data-needing action <strong>into</strong> the callback!</em> <sup>2</sup><br>
       This is obvious in the example above.<br>
       But is it still possible to write code <em>after</em> the asynchronous call that deals with the response once it has completed?</p>
     <h3>2. Plain JavaScript and a callback function</h3>
     <p>The answer is <em>yes!</em> – It is possible.<br>
       One alternative is the use of a <em>callback</em> function in a continuation-passing style: <sup>3</sup></p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>const url = 'https://jsonplaceholder.typicode.com/todos/2';

function asynchronousCall (callback) {
  const request = new XMLHttpRequest();
  request.open('GET', url);
  request.send();
  request.onload = function () {
    if (request.readyState === request.DONE) {
      console.log('The request is done. Now calling back.');
      callback(request.responseText);
    }
  };
}

asynchronousCall(function (result) {
  console.log('This is the start of the callback function. Result:');
  console.log(result);
  console.log('The callback function finishes on this line. THE END!');
});

console.log('LAST in the code, but executed FIRST!');</code></pre>
       <pre class="snippet-code-css lang-css prettyprint-override"><code>.as-console-wrapper { max-height: 100% !important; top: 0; }</code></pre>
      </div>
     </div>
     <p></p>
     <p>Note how the function <code>asynchronousCall</code> is <code>void</code>. It returns nothing. Instead, by calling <code>asynchronousCall</code> with an anonymous callback function (<code>asynchronousCall(function (result) {...</code>), this function executes the desired actions on the result, but only <em>after</em> the request has completed – when the <code>responseText</code> is available.</p>
     <p>Running the above snippet shows how I will probably not want to write any code <em>after</em> the asynchronous call (such as the line <code>LAST in the code, but executed FIRST!</code>).<br><em>Why?</em> – Because such code will happen <em>before</em> the asynchronous call delivers any response data.<br>
       Doing so is bound to cause confusion when comparing the <em>code</em> with the <em>output</em>.</p>
     <h3>3. Promise with <code>.then()</code> – or <code>async</code>/<code>await</code></h3>
     <p>The <code>.then()</code> construct was introduced in the <em>ECMA-262 6th Edition in June 2015</em>, and the <code>async</code>/<code>await</code> construct was introduced in the <em>ECMA-262 8th Edition in June 2017</em>.<br>
       The code below is still plain JavaScript, replacing the old-school <em>XMLHttpRequest</em> with <em>Fetch</em>. <sup>4</sup></p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>fetch('http://api.icndb.com/jokes/random')
  .then(response =&gt; response.json())
  .then(responseBody =&gt; {
    console.log('.then() - the response body:');
    console.log(JSON.stringify(responseBody) + '\n\n');
  });

async function receiveAndAwaitPromise () {
  const responseBody =
    (await fetch('http://api.icndb.com/jokes/random')).json();
  console.log('async/await:');
  console.log(JSON.stringify(await responseBody) + '\n\n');
}

receiveAndAwaitPromise();</code></pre>
       <pre class="snippet-code-css lang-css prettyprint-override"><code>.as-console-wrapper { max-height: 100% !important; top: 0; }</code></pre>
      </div>
     </div>
     <p></p>
     <p>A word of warning is warranted if you decide to go with the <code>async</code>/<code>await</code> construct. Note in the above snippet how <code>await</code> is needed in <em>two</em> places. If forgotten in the first place, there will be no output. If forgotten in the second place, the only output will be the empty object, <code>{}</code> (or <code>[object Object]</code> or <code>[object Promise]</code>).<br>
       Forgetting the <code>async</code> prefix of the function is maybe the worst of all – the output will be <code>"SyntaxError: missing ) in parenthetical"</code> – no mentioning of the <em>missing</em> <code>async</code> keyword.</p>
     <h3>4. Promise.all – array of URLs <sup>5</sup></h3>
     <p>Suppose we need to request a bunch of URLs. I could send one request, wait till it responds, then send the next request, wait till <em>it</em> responds, and so on ...<br>
       Aargh! – That could take a loong time. Wouldn't it be better if I could send them <em>all</em> at once, and then wait no longer than it takes for the slowest response to arrive?</p>
     <p>As a simplified example, I will use:</p>
     <pre class="lang-js prettyprint-override"><code>urls = ['https://jsonplaceholder.typicode.com/todos/2',
        'https://jsonplaceholder.typicode.com/todos/3']
</code></pre>
     <p>The JSONs of the two URLs:</p>
     <pre class="lang-json prettyprint-override"><code>{"userId":1,"id":2,"title":"quis ut nam facilis et officia qui",
 "completed":false}
{"userId":1,"id":3,"title":"fugiat veniam minus","completed":false}
</code></pre>
     <p>The goal is to get an array of objects, where each object contains the <code>title</code> value from the corresponding URL.</p>
     <p>To make it a little more interesting, I will assume that there is already an array of <em>names</em> that I want the array of URL results (the <em>titles</em>) to be merged with:</p>
     <pre class="lang-js prettyprint-override"><code>namesonly = ['two', 'three']
</code></pre>
     <p>The desired output is a mashup combining <code>namesonly</code> and <code>urls</code> into an <em>array of objects</em>:</p>
     <pre class="lang-js prettyprint-override"><code>[{"name":"two","loremipsum":"quis ut nam facilis et officia qui"},
{"name":"three","loremipsum":"fugiat veniam minus"}]
</code></pre>
     <p>where I have changed the name of <code>title</code> to <code>loremipsum</code>.</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>const namesonly = ['two','three'];

const urls = ['https://jsonplaceholder.typicode.com/todos/2',
  'https://jsonplaceholder.typicode.com/todos/3'];

Promise.all(urls.map(url =&gt; fetch(url)
  .then(response =&gt; response.json())
  .then(responseBody =&gt; responseBody.title)))
  .then(titles =&gt; {
    const names = namesonly.map(value =&gt; ({ name: value }));
    console.log('names: ' + JSON.stringify(names));
    const latins = titles.map(value =&gt; ({ loremipsum: value }));
    console.log('latins:\n' + JSON.stringify(latins));
    const result =
      names.map((item, i) =&gt; Object.assign({}, item, latins[i]));
    console.log('result:\n' + JSON.stringify(result));
  });</code></pre>
       <pre class="snippet-code-css lang-css prettyprint-override"><code>.as-console-wrapper { max-height: 100% !important; top: 0; }</code></pre>
      </div>
     </div>
     <p></p>
     <p>All the above examples are short and succinctly convey how asynchronous calls may be used on toyish APIs.</p>
     <h3>References</h3>
     <ul>
      <li><a href="https://stackoverflow.com/q/14220321">How do I return the response from an asynchronous call?</a></li>
      <li><a href="https://stackoverflow.com/a/67662000">Some questions and answers about asynchronous calls</a></li>
      <li><a href="https://stackoverflow.com/a/16825593">Using plain JavaScript and a callback function</a></li>
      <li><a href="https://en.wikipedia.org/wiki/Continuation-passing_style" rel="nofollow noreferrer">Continuation-passing style</a></li>
      <li><a href="https://stackoverflow.com/a/19247992">XMLHttpRequest: onload vs. onreadystatechange</a></li>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseText" rel="nofollow noreferrer">XMLHttpRequest.responseText</a></li>
      <li><a href="https://stackoverflow.com/a/48415961">An example demonstrating <code>async</code>/<code>await</code></a></li>
      <li><a href="https://github.github.io/fetch" rel="nofollow noreferrer">Fetch</a></li>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="nofollow noreferrer">Promise</a></li>
      <li><a href="https://xhr.spec.whatwg.org" rel="nofollow noreferrer">The XMLHttpRequest Standard</a></li>
      <li><a href="https://fetch.spec.whatwg.org" rel="nofollow noreferrer">The Fetch Standard</a></li>
      <li><a href="https://whatwg.org/news/start" rel="nofollow noreferrer">The Web Hypertext Application Technology Working Group (WHATWG)</a></li>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Language_Resources" rel="nofollow noreferrer">Links to ECMA specifications</a></li>
      <li><a href="https://stackoverflow.com/a/49602789">Convert an array of values to an array of objects</a></li>
      <li><a href="https://stackoverflow.com/a/67671337">How can I fetch an array of URLs with Promise.all?</a></li>
     </ul>
     <hr><sup>
      <p><sup>1</sup> Expressed by the asker of the question as: <em>they all return <code>undefined</code></em>.</p>
      <p><sup>2</sup> If you think asynchronous calls are confusing, consider having a look at <a href="https://stackoverflow.com/a/67662000">some questions and answers about asynchronous calls</a> to see if that helps.</p>
      <p><sup>3</sup> The name <code>XMLHttpRequest</code> is as misleading as the <em>X</em> in <em>AJAX</em> – these days the data format of Web APIs is ubiquitously JSON, not XML.</p>
      <p><sup>4</sup> <a href="https://github.github.io/fetch" rel="nofollow noreferrer">Fetch</a> returns a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="nofollow noreferrer">Promise</a>. I was surprised to learn that neither <em>XMLHttpRequest</em> nor <em>Fetch</em> are part of the <em>ECMAScript</em> standard. The reason JavaScript can access them here is because the web browser provides them. <a href="https://fetch.spec.whatwg.org" rel="nofollow noreferrer">The Fetch Standard</a> and <a href="https://xhr.spec.whatwg.org" rel="nofollow noreferrer">the XMLHttpRequest Standard</a> are both upheld by <a href="https://whatwg.org/news/start" rel="nofollow noreferrer">the Web Hypertext Application Technology Working Group</a> that was formed in June 2004.</p>
      <p><sup>5</sup> This section borrows a lot from <a href="https://stackoverflow.com/a/67671337">How can I fetch an array of URLs with Promise.all?</a>.</p></sup>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_23"><span>Answer 23</span> <span class="arrow"> <a href="#answer_22">↑</a> </span> <span class="arrow"> <a href="#answer_24">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>43</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user663031</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Jan 2016 at 03:28</span>
     </div>
    </div>
    <div>
     <p>We find ourselves in a universe which appears to progress along a dimension we call "time". We don't really understand what time is, but we have developed abstractions and vocabulary that let us reason and talk about it: "past", "present", "future", "before", "after".</p>
     <p>The computer systems we build--more and more--have time as an important dimension. Certain things are set up to happen in the future. Then other things need to happen after those first things eventually occur. This is the basic notion called "asynchronicity". In our increasingly networked world, the most common case of asynchronicity is waiting for some remote system to respond to some request.</p>
     <p>Consider an example. You call the milkman and order some milk. When it comes, you want to put it in your coffee. You can't put the milk in your coffee right now, because it is not here yet. You have to wait for it to come before putting it in your coffee. In other words, the following won't work:</p>
     <pre><code>var milk = order_milk();
put_in_coffee(milk);
</code></pre>
     <p>Because JavaScript has no way to know that it needs to <strong>wait</strong> for <code>order_milk</code> to finish before it executes <code>put_in_coffee</code>. In other words, it does not know that <code>order_milk</code> is <strong>asynchronous</strong>--is something that is not going to result in milk until some future time. JavaScript, and other declarative languages execute one statement after another without waiting.</p>
     <p>The classic JavaScript approach to this problem, taking advantage of the fact that JavaScript supports functions as first-class objects which can be passed around, is to pass a function as a parameter to the asynchronous request, which it will then invoke when it has completed its task sometime in the future. That is the "callback" approach. It looks like this:</p>
     <pre><code>order_milk(put_in_coffee);
</code></pre>
     <p><code>order_milk</code> kicks off, orders the milk, then, when and only when it arrives, it invokes <code>put_in_coffee</code>.</p>
     <p>The problem with this callback approach is that it pollutes the normal semantics of a function reporting its result with <code>return</code>; instead, functions must not reports their results by calling a callback given as a parameter. Also, this approach can rapidly become unwieldy when dealing with longer sequences of events. For example, let's say that I want to wait for the milk to be put in the coffee, and then and only then perform a third step, namely drinking the coffee. I end up needing to write something like this:</p>
     <pre><code>order_milk(function(milk) { put_in_coffee(milk, drink_coffee); }
</code></pre>
     <p>where I am passing to <code>put_in_coffee</code> both the milk to put in it, and also the action (<code>drink_coffee</code>) to execute once the milk has been put in. Such code becomes hard to write, and read, and debug.</p>
     <p>In this case, we could rewrite the code in the question as:</p>
     <pre><code>var answer;
$.ajax('/foo.json') . done(function(response) {
  callback(response.data);
});

function callback(data) {
  console.log(data);
}
</code></pre>
     <h3>Enter promises</h3>
     <p>This was the motivation for the notion of a "promise", which is a particular type of value which represents a <strong>future</strong> or <strong>asynchronous</strong> outcome of some sort. It can represent something that already happened, or that is going to happen in the future, or might never happen at all. Promises have a single method, named <code>then</code>, to which you pass an action to be executed when the outcome the promise represents has been realized.</p>
     <p>In the case of our milk and coffee, we design <code>order_milk</code> to return a promise for the milk arriving, then specify <code>put_in_coffee</code> as a <code>then</code> action, as follows:</p>
     <pre><code>order_milk() . then(put_in_coffee)
</code></pre>
     <p>One advantage of this is that we can string these together to create sequences of future occurrences ("chaining"):</p>
     <pre><code>order_milk() . then(put_in_coffee) . then(drink_coffee)
</code></pre>
     <p>Let's apply promises to your particular problem. We will wrap our request logic inside a function, which returns a promise:</p>
     <pre><code>function get_data() {
  return $.ajax('/foo.json');
}
</code></pre>
     <p>Actually, all we've done is added a <code>return</code> to the call to <code>$.ajax</code>. This works because jQuery's <code>$.ajax</code> already returns a kind of promise-like thing. (In practice, without getting into details, we would prefer to wrap this call so as for return a real promise, or use some alternative to <code>$.ajax</code> that does so.) Now, if we want to load the file and wait for it to finish and then do something, we can simply say</p>
     <pre><code>get_data() . then(do_something)
</code></pre>
     <p>for instance,</p>
     <pre><code>get_data() .
  then(function(data) { console.log(data); });
</code></pre>
     <p>When using promises, we end up passing lots of functions into <code>then</code>, so it's often helpful to use the more compact ES6-style arrow functions:</p>
     <pre><code>get_data() .
  then(data =&gt; console.log(data));
</code></pre>
     <h3>The <code>async</code> keyword</h3>
     <p>But there's still something vaguely dissatisfying about having to write code one way if synchronous and a quite different way if asynchronous. For synchronous, we write</p>
     <pre><code>a();
b();
</code></pre>
     <p>but if <code>a</code> is asynchronous, with promises we have to write</p>
     <pre><code>a() . then(b);
</code></pre>
     <p>Above, we said, "JavaScript has no way to know that it needs to <strong>wait</strong> for the first call to finish before it executes the second". Wouldn't it be nice if there <strong>was</strong> some way to tell JavaScript that? It turns out that there is--the <code>await</code> keyword, used inside a special type of function called an "async" function. This feature is part of the upcoming version of ECMAScript (ES), but it is already available in transpilers such as <a href="https://en.wikipedia.org/wiki/Babel_(transcompiler)" rel="nofollow noreferrer">Babel</a> given the right presets. This allows us to simply write</p>
     <pre><code>async function morning_routine() {
  var milk   = await order_milk();
  var coffee = await put_in_coffee(milk);
  await drink(coffee);
}
</code></pre>
     <p>In your case, you would be able to write something like</p>
     <pre><code>async function foo() {
  data = await get_data();
  console.log(data);
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_24"><span>Answer 24</span> <span class="arrow"> <a href="#answer_23">↑</a> </span> <span class="arrow"> <a href="#answer_25">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>41</span>
     </div>
     <div>
      <span>Answerer: </span> <span>David R Tribble</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Sep 2015 at 22:52</span>
     </div>
    </div>
    <div>
     <p><strong>Short answer</strong>: Your <code>foo()</code> method returns immediately, while the <code>$ajax()</code> call executes asynchronously <em>after the function returns</em>. The problem is then how or where to store the results retrieved by the async call once it returns.</p>
     <p>Several solutions have been given in this thread. Perhaps the easiest way is to pass an object to the <code>foo()</code> method, and to store the results in a member of that object after the async call completes.</p>
     <pre><code>function foo(result) {
    $.ajax({
        url: '...',
        success: function(response) {
            result.response = response;   // Store the async result
        }
    });
}

var result = { response: null };   // Object to hold the async result
foo(result);                       // Returns before the async completes
</code></pre>
     <p>Note that the call to <code>foo()</code> will still return nothing useful. However, the result of the async call will now be stored in <code>result.response</code>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>15</td>
        <td><span>While this works, it's not really better than assigning to a global variable.</span> <span> - </span> <span class="display-name">Felix Kling</span> <span> </span> <span class="date">23 Sep 2015 at 22:53</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_25"><span>Answer 25</span> <span class="arrow"> <a href="#answer_24">↑</a> </span> <span class="arrow"> <a href="#answer_26">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>41</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mohan Dere</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 Aug 2016 at 09:36</span>
     </div>
    </div>
    <div>
     <h2>Here are some approaches to work with asynchronous requests:</h2>
     <ol>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noreferrer">Browser Promise object</a></li>
      <li><a href="https://github.com/kriskowal/q" rel="noreferrer">Q</a> - A promise library for JavaScript</li>
      <li><a href="https://www.promisejs.org/" rel="noreferrer">A+ Promises.js</a></li>
      <li><a href="https://api.jquery.com/jquery.deferred/" rel="noreferrer">jQuery deferred</a></li>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" rel="noreferrer">XMLHttpRequest API</a></li>
      <li>Using callback concept - As implementation in first answer</li>
     </ol>
     <h3>Example: jQuery deferred implementation to work with multiple requests</h3>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>var App = App || {};

App = {
    getDataFromServer: function(){

      var self = this,
                 deferred = $.Deferred(),
                 requests = [];

      requests.push($.getJSON('request/ajax/url/1'));
      requests.push($.getJSON('request/ajax/url/2'));

      $.when.apply(jQuery, requests).done(function(xhrResponse) {
        return deferred.resolve(xhrResponse.result);
      });
      return deferred;
    },

    init: function(){

        this.getDataFromServer().done(_.bind(function(resp1, resp2) {

           // Do the operations which you wanted to do when you
           // get a response from Ajax, for example, log response.
        }, this));
    }
};
App.init();</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Why include a Stack Snippet that outputs an error?</span> <span> - </span> <span class="display-name">Henke</span> <span> </span> <span class="date">9 May 2021 at 15:47</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_26"><span>Answer 26</span> <span class="arrow"> <a href="#answer_25">↑</a> </span> <span class="arrow"> <a href="#answer_27">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>40</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mahfuzur Rahman</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Apr 2017 at 08:09</span>
     </div>
    </div>
    <div>
     <p>Use a <code>callback()</code> function inside the <code>foo()</code> success. Try it in this way. It is simple and easy to understand.</p>
     <pre><code>var lat = "";
var lon = "";

function callback(data) {
    lat = data.lat;
    lon = data.lon;
}

function getLoc() {
    var url = "http://ip-api.com/json"
    $.getJSON(url, function(data) {
        callback(data);
    });
}

getLoc();
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_27"><span>Answer 27</span> <span class="arrow"> <a href="#answer_26">↑</a> </span> <span class="arrow"> <a href="#answer_28">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>34</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Amir Fo</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Dec 2018 at 14:10</span>
     </div>
    </div>
    <div>
     <h1>Using Promise</h1>
     <p>The most perfect answer to this question is using <code>Promise</code>.</p>
     <pre><code>function ajax(method, url, params) {
  return new Promise(function(resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.onload = function() {
      resolve(this.responseText);
    };
    xhr.onerror = reject;
    xhr.open(method, url);
    xhr.send(params);
  });
}
</code></pre>
     <h2>Usage</h2>
     <pre><code>ajax("GET", "/test", "acrive=1").then(function(result) {
    // Code depending on result
})
.catch(function() {
    // An error occurred
});
</code></pre>
     <hr>
     <h1>But wait...!</h1>
     <p>There is a problem with using promises!</p>
     <h2>Why should we use our own custom Promise?</h2>
     <p>I was using this solution for a while until I figured out there is an error in old browsers:</p>
     <blockquote>
      <p>Uncaught ReferenceError: Promise is not defined</p>
     </blockquote>
     <p>So I decided to implement my own Promise class for <strong>ES3 to below</strong> JavaScript compilers if it's not defined. Just add this code before your main code and then safely use Promise!</p>
     <pre><code>if(typeof Promise === "undefined"){
    function _typeof(obj) { "@babel/helpers - typeof"; return 

    _typeof = "function" == typeof Symbol &amp;&amp; "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj &amp;&amp; "function" == typeof Symbol &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
    function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
    function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
    function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" &amp;&amp; o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
    function _iterableToArray(iter) { if (typeof Symbol !== "undefined" &amp;&amp; iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
    function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
    function _arrayLikeToArray(arr, len) { if (len == null || len &gt; arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i &lt; len; i++) arr2[i] = arr[i]; return arr2; }
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    function _defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
    function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
    function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
    var Promise = /*#__PURE__*/function () {
  "use strict";

  function Promise(main) {
    _classCallCheck(this, Promise);
    this.main = main;
    this.mainExecuted = false;
    this.resolved = false;
    this.rejected = false;
    this.promiseChain = [];
    this.handleError = function () {};
    this.onResolve = this.onResolve.bind(this);
    this.onReject = this.onReject.bind(this);
  }
  _createClass(Promise, [{
    key: "then",
    value: function then(handleSuccess) {
      if (this.resolved) {
        if (!this.rejected) {
          this.args = handleSuccess(this.args);
        }
      } else {
        this.promiseChain.push(handleSuccess);
        this.main(this.onResolve, this.onReject);
        this.thenExecuted = true;
      }
      return this;
    }
  }, {
    key: "catch",
    value: function _catch(handleError) {
      this.handleError = handleError;
      if (!this.mainExecuted) {
        this.main(this.onResolve, this.onReject);
        this.thenExecuted = true;
      }
      return this;
    }
  }, {
    key: "onResolve",
    value: function onResolve() {
      var _this = this;
      this.resolved = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key &lt; _len; _key++) {
        args[_key] = arguments[_key];
      }
      this.args = args;
      try {
        this.promiseChain.forEach(function (nextFunction) {
          _this.args = nextFunction.apply(void 0, _toConsumableArray(_this.args));
        });
      } catch (error) {
        this.promiseChain = [];
        this.onReject(error);
      }
    }
  }, {
    key: "onReject",
    value: function onReject(error) {
      this.rejected = true;
      this.handleError(error);
    }
  }]);
  return Promise;
}();
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>I reckon you could also use a callback :D, but this is incredible.</span> <span> - </span> <span class="display-name">Alaska</span> <span> </span> <span class="date">28 Sep 2021 at 18:32</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>core-js existed in 2018. No reason to invent your own promise. Looks cool anyways.</span> <span> - </span> <span class="display-name">TamusJRoyce</span> <span> </span> <span class="date">21 Feb 2023 at 19:28</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_28"><span>Answer 28</span> <span class="arrow"> <a href="#answer_27">↑</a> </span> <span class="arrow"> <a href="#answer_29">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>31</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Khoa Bui</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Jul 2017 at 20:28</span>
     </div>
    </div>
    <div>
     <p>Of course there are many approaches like synchronous request, promise, but from my experience I think you should use the callback approach. It's natural to asynchronous behavior of JavaScript.</p>
     <p>So, your code snippet can be rewritten to be a little different:</p>
     <pre><code>function foo() {
    var result;

    $.ajax({
        url: '...',
        success: function(response) {
            myCallback(response);
        }
    });

    return result;
}

function myCallback(response) {
    // Does something.
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>6</td>
        <td><span>There's nothing inherently asynchronous about callbacks or JavaScript.</span> <span> - </span> <span class="display-name">Aluan Haddad</span> <span> </span> <span class="date">18 Mar 2018 at 19:48</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Why keep <code>var result;</code> and <code>return result;</code>? The latter will still <i>always</i> return <code>undefined</code>!</span> <span> - </span> <span class="display-name">Henke</span> <span> </span> <span class="date">9 May 2021 at 12:21</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_29"><span>Answer 29</span> <span class="arrow"> <a href="#answer_28">↑</a> </span> <span class="arrow"> <a href="#answer_30">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>31</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Pieter Jan Bonestroo</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 Jan 2018 at 19:13</span>
     </div>
    </div>
    <div>
     <p>The question was:</p>
     <blockquote>
      <p>How do I return the response from an asynchronous call?</p>
     </blockquote>
     <p>which <em>can</em> be interpreted as:</p>
     <blockquote>
      <p>How to make <strong>asynchronous</strong> code look <strong>synchronous</strong>?</p>
     </blockquote>
     <p>The solution will be to avoid callbacks, and use a combination of <strong>Promises</strong> and <strong>async/await</strong>.</p>
     <p>I would like to give an example for an Ajax request.</p>
     <p>(Although it can be written in JavaScript, I prefer to write it in Python, and compile it to JavaScript using <a href="https://github.com/QQuick/Transcrypt" rel="nofollow noreferrer">Transcrypt</a>. It will be clear enough.)</p>
     <p>Let’s first enable jQuery usage, to have <code>$</code> available as <code>S</code>:</p>
     <pre><code>__pragma__ ('alias', 'S', '$')
</code></pre>
     <p>Define a function which returns a <strong>Promise</strong>, in this case an Ajax call:</p>
     <pre><code>def read(url: str):
    deferred = S.Deferred()
    S.ajax({'type': "POST", 'url': url, 'data': { },
        'success': lambda d: deferred.resolve(d),
        'error': lambda e: deferred.reject(e)
    })
    return deferred.promise()
</code></pre>
     <p>Use the <strong>asynchronous</strong> code as if it were <strong>synchronous</strong>:</p>
     <pre><code>async def readALot():
    try:
        result1 = await read("url_1")
        result2 = await read("url_2")
    except Exception:
        console.warn("Reading a lot failed")
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Anyone interested in using <code>async</code> / <code>await</code> will likely also want to read <a href="https://stackoverflow.com/a/48415961">this answer</a> (and possibly my comment below it :-).</span> <span> - </span> <span class="display-name">Henke</span> <span> </span> <span class="date">11 May 2021 at 12:25</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_30"><span>Answer 30</span> <span class="arrow"> <a href="#answer_29">↑</a> </span> <span class="arrow"> <a href="#answer_31">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>31</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Fernando Carvajal</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Jan 2018 at 06:18</span>
     </div>
    </div>
    <div>
     <p>Using ES2017 you should have this as the function declaration.</p>
     <pre><code>async function foo() {
  var response = await $.ajax({url: '...'})
  return response;
}
</code></pre>
     <p>And executing it like this.</p>
     <pre><code>(async function() {
  try {
    var result = await foo()
    console.log(result)
  } catch (e) {}
})()
</code></pre>
     <p>Or the Promise syntax.</p>
     <pre><code>foo().then(response =&gt; {
  console.log(response)

}).catch(error =&gt; {
  console.log(error)

})
</code></pre>
     <p>Stack Snippet that demonstrates the code above.</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>// The function declaration:
async function foo() {
  var response = await $.ajax({
    url: 'https://jsonplaceholder.typicode.com/todos/1'
  })
  return response;
}

// Execute it like this:
(async function() {
  try {
    var result = await foo()
    console.log(result)
  } catch (e) {}
})()

// Or use Promise syntax:
foo().then(response =&gt; {
  console.log(response)
}).catch(error =&gt; {
  console.log(error)
})</code></pre>
       <pre class="snippet-code-css lang-css prettyprint-override"><code>.as-console-wrapper { max-height: 100% !important; top: 0; }</code></pre>
       <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;script src=
"https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"&gt;&lt;/script&gt;</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>could that second function to reuseable??</span> <span> - </span> <span class="display-name">Zum Dummi</span> <span> </span> <span class="date">17 Feb 2019 at 02:02</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>How do you use the results if oncolse,log is called? Doesn't everything just go to the console at that point?</span> <span> - </span> <span class="display-name">Ken Ingram</span> <span> </span> <span class="date">29 Jun 2019 at 06:47</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This is a fine and helpful answer that clearly demonstrates how to correctly use the <code>async</code> - <code>await</code> duality feature. One thing to note is that <code>async</code> and <code>await</code> are actually not needed in the function <code>foo()</code>. (Remove them both and the code still runs just fine.) This is because <code>foo()</code> returns a Promise, and as long as the code receiving the Promise <i>awaits</i> it, everything will be fine. ~ * ~ * ~ * ~ Note: the <code>async</code> - <code>await</code> feature was introduced in the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Language_Resources" rel="nofollow noreferrer">ECMA-262 8th Edition in June 2017</a>.</span> <span> - </span> <span class="display-name">Henke</span> <span> </span> <span class="date">11 May 2021 at 12:14</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I have a requirement to return some data after calculation from the callback function. How could i do that</span> <span> - </span> <span class="display-name">RAUSHAN KUMAR</span> <span> </span> <span class="date">21 Sep 2021 at 15:15</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>It's not possible.</span> <span> - </span> <span class="display-name">CherryDT</span> <span> </span> <span class="date">29 Oct 2021 at 10:16</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_31"><span>Answer 31</span> <span class="arrow"> <a href="#answer_30">↑</a> </span> <span class="arrow"> <a href="#answer_32">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>30</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Matthew Brent</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 May 2018 at 15:56</span>
     </div>
    </div>
    <div>
     <p>Rather than throwing code at you, there are two concepts that are key to understanding how JavaScript handles callbacks and asynchronicity (is that even a word?)</p>
     <h2><strong><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" rel="nofollow noreferrer">The Event Loop and Concurrency Model</a></strong></h2>
     <p>There are three things you need to be aware of; <strong>The queue; <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#Event_loop" rel="nofollow noreferrer">the event loop</a> and the stack</strong></p>
     <p>In broad, simplistic terms, the event loop is like the project manager, it is constantly listening for any functions that want to run and communicates between the queue and the stack.</p>
     <pre><code>while (queue.waitForMessage()) {
  queue.processNextMessage();
}
</code></pre>
     <p>Once it receives a message to run something it adds it to the queue. The queue is the list of things that are waiting to execute (like your AJAX request). imagine it like this:</p>
     <ol>
      <li>call foo.com/api/bar using foobarFunc</li>
      <li>Go perform an infinite loop ... and so on</li>
     </ol>
     <p>When one of these messages is going to execute it pops the message from the queue and creates a stack, the stack is everything JavaScript needs to execute to perform the instruction in the message. So in our example it's being told to call <code>foobarFunc</code></p>
     <pre><code>function foobarFunc (var) {
  console.log(anotherFunction(var));
}
</code></pre>
     <p>So anything that foobarFunc needs to execute (in our case <code>anotherFunction</code>) will get pushed onto the stack. executed, and then forgotten about - the event loop will then move onto the next thing in the queue (or listen for messages)</p>
     <p><strong>The key thing here is the order of execution. That is</strong></p>
     <h2><strong>WHEN is something going to run</strong></h2>
     <p>When you make a call using AJAX to an external party or run any asynchronous code (a setTimeout for example), JavaScript is dependant upon a response before it can proceed.</p>
     <p>The big question is when will it get the response? The answer is we don't know - so the event loop is waiting for that message to say "hey run me". If JavaScript just waited around for that message synchronously your app would freeze and it will suck. So JavaScript carries on executing the next item in the queue whilst waiting for the message to get added back to the queue.</p>
     <p>That's why with asynchronous functionality we use things called <strong>callbacks</strong>. - A function or handler that, when passed into another function, will be executed at a later date. A <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="nofollow noreferrer">promise</a> uses callbacks (functions passed to <code>.then()</code> for example) as a way to reason about this asynchronous behaviour in a more linear way. The promise is a way of saying "I <em>promise to return something at some point</em>" and the callback is how we handle that value that is eventually returned. jQuery uses specific callbacks called <code>deffered.done</code> <code>deffered.fail</code> and <code>deffered.always</code> (amongst others). You can see them all <a href="https://api.jquery.com/category/deferred-object/" rel="nofollow noreferrer">here</a></p>
     <p>So what you need to do is pass a function that is promised to execute at some point with data that is passed to it.</p>
     <p>Because a callback is not executed immediately but at a later time it's important to pass the reference to the function not it executed. so</p>
     <pre><code>function foo(bla) {
  console.log(bla)
}
</code></pre>
     <p>so most of the time (but not always) you'll pass <code>foo</code> not <code>foo()</code></p>
     <p>Hopefully that will make some sense. When you encounter things like this that seem confusing - i highly recommend reading the documentation fully to at least get an understanding of it. It will make you a much better developer.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>I am struggling to accept "callbacks are kind of like promises". it's like saying "flour is kind of like bread" but it is not. you use flour, water and other incredients, mix them and eventually after a process, bread is the results.</span> <span> - </span> <span class="display-name">Eva Cohen</span> <span> </span> <span class="date">17 Jan 2021 at 19:08</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>This is true - I think I was try to say something that doesnt quite read what I was meaning. A promise in JS evidently represents something different to a callback, however when programming any kind asynchronous functionality you are going to be executing a callback. A promise represents the value but the callback is what we need to do something with that value, at some point in the future, when it returns.</span> <span> - </span> <span class="display-name">Matthew Brent</span> <span> </span> <span class="date">18 Jan 2021 at 15:58</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>A promise is mostly useless (but not always) without a callback to do something with the resolved value</span> <span> - </span> <span class="display-name">Matthew Brent</span> <span> </span> <span class="date">18 Jan 2021 at 15:59</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_32"><span>Answer 32</span> <span class="arrow"> <a href="#answer_31">↑</a> </span> <span class="arrow"> <a href="#answer_33">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>30</span>
     </div>
     <div>
      <span>Answerer: </span> <span>SanjiMika</span>
     </div>
     <div>
      <span> Answered: </span> <span>19 Jan 2020 at 22:23</span>
     </div>
    </div>
    <div>
     <p>After reading all the responses here and with my experiences, I would like to resume the detail of <code>callback, promise and async/await</code> for the asynchronous programming in JavaScript.</p>
     <p><strong>1) Callback:</strong> The fundamental reason for a callback is to run code in response of an event (see the example below). We use callback in JavaScript every time.</p>
     <pre><code>const body = document.getElementsByTagName('body')[0];
function callback() {
  console.log('Hello');
}
body.addEventListener('click', callback);
</code></pre>
     <p>But if you must use many nested callbacks in the example below, it will be fairy terrible for the code refactoring.</p>
     <pre><code>asyncCallOne(function callback1() {
  asyncCallTwo(function callback2() {
    asyncCallThree(function callback3() {
        ...
    })
  })
})
</code></pre>
     <p><strong>2) Promise:</strong> a syntax ES6 - Promise resolves the callback hell issue!</p>
     <pre><code>const myFirstPromise = new Promise((resolve, reject) =&gt; {
  // We call resolve(...) when what we were doing asynchronously was successful, and reject(...) when it failed.
  // In this example, we use setTimeout(...) to simulate async code.
  // In reality, you will probably be using something like XHR request or an HTML5 API.
  setTimeout(() =&gt; {
    resolve("Success!")  // Yay! Everything went well!
  }, 250)
})

myFirstPromise
  .then((res) =&gt; {
    return res.json();
  })
  .then((data) =&gt; {
    console.log(data);
  })
  .catch((e) =&gt; {
    console.log(e);
  });
</code></pre>
     <p>myFirstPromise is a Promise instance that represents the process of async codes. The resolve function signals that the Promise instance has finished. Afterwards, we can call .then() (a chain of .then as you want) and .catch() on the promise instance:</p>
     <pre><code>then — Runs a callback you pass to it when the promise has fulfilled.
catch — Runs a callback you pass to it when something went wrong.
</code></pre>
     <p><strong>3) Async/Await:</strong> a new syntax ES6 - Await is basically syntactic sugar for Promise!</p>
     <p>The Async function provides us with a clean and concise syntax that enables us to write less code to accomplish the same outcome we would get with promises. <strong>Async/Await looks similar to synchronous code</strong>, and synchronous code is much easier to read and write. To catch errors with Async/Await, we can use the block <code>try...catch</code>. In here, you don't need to write a chain of .then() of Promise syntax.</p>
     <pre><code>const getExchangeRate = async () =&gt; {
  try {
    const res = await fetch('https://getExchangeRateData');
    const data = await res.json();
    console.log(data);
  } catch (err) {
    console.error(err);
  }
}

getExchangeRate();
</code></pre>
     <blockquote>
      <p>Conclusion: These are totally the three syntaxes for asynchronous programming in JavaScript that you should well understand. <strong>So if possible, I recommend that you should use "promise" or "async/await" for refactoring your asynchronous codes (mostly for XHR requests)</strong> !</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Hi, although this answer's contents are accurate, it really doesn't answer OP's question (which is how to return something from an asynchronous call?)</span> <span> - </span> <span class="display-name">Bharath Ram</span> <span> </span> <span class="date">25 Aug 2020 at 12:02</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_33"><span>Answer 33</span> <span class="arrow"> <a href="#answer_32">↑</a> </span> <span class="arrow"> <a href="#answer_34">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>26</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Alex Montoya</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Jul 2018 at 21:48</span>
     </div>
    </div>
    <div>
     <p>Here is an example that works:</p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>const validateName = async userName =&gt; {
  const url = "https://jsonplaceholder.typicode.com/todos/1";
  try {
    const response = await axios.get(url);
    return response.data
  } catch (err) {
    return false;
  }
};

validateName("user")
 .then(data =&gt; console.log(data))
 .catch(reason =&gt; console.log(reason.message))</code></pre>
       <pre class="snippet-code-css lang-css prettyprint-override"><code>.as-console-wrapper { max-height: 100% !important; top: 0; }</code></pre>
       <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;script src=
"https://cdnjs.cloudflare.com/ajax/libs/axios/0.21.1/axios.min.js"&gt;&lt;/script&gt;</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Yet another fine answer demonstrating the use of <code>async</code> - <code>await</code>. ~ * ~ The <code>async</code> - <code>await</code> feature was introduced in the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Language_Resources" rel="nofollow noreferrer">ECMA-262 8th Edition in June 2017</a>.</span> <span> - </span> <span class="display-name">Henke</span> <span> </span> <span class="date">11 May 2021 at 12:38</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_34"><span>Answer 34</span> <span class="arrow"> <a href="#answer_33">↑</a> </span> <span class="arrow"> <a href="#answer_35">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>22</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Kamil Kiełczewski</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Jun 2019 at 07:56</span>
     </div>
    </div>
    <div>
     <h2>Await</h2>
     <p>A request works in an asynchronous way, so you can't read the data synchronously as in typical code. However, using <code>async/await</code> you can create asynchronous code which looks close/similar to the usual synchronous/sequential style. Code which processes response data needs to be wrapped by an <code>async</code> function (<code>load</code> in the below snippet) and inside it you need to add the <code>await</code> keyword before <code>foo()</code> (which also uses <code>async/await</code>).</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>async function foo() {
  var url = 'https://jsonplaceholder.typicode.com/todos/1';
  var result = (await fetch(url)).text(); // Or .json()
  return result;
}

async function load() {
  var result = await foo();
  console.log(result);
}

load();</code></pre>
      </div>
     </div>
     <p></p>
     <p>Remember that an <code>async</code> function always (implicitly) wraps its result into a promise (so it returns a promise).</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>Nice answer! Apparently, the <code>async</code> - <code>await</code> construct was introduced in the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Language_Resources" rel="nofollow noreferrer">ECMAScript 2017 Language Specification in June 2017</a>.</span> <span> - </span> <span class="display-name">Henke</span> <span> </span> <span class="date">10 May 2021 at 08:13</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_35"><span>Answer 35</span> <span class="arrow"> <a href="#answer_34">↑</a> </span> <span class="arrow"> <a href="#answer_36">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>17</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Haim Zamir</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Oct 2017 at 03:22</span>
     </div>
    </div>
    <div>
     <p><strong>Let's see the forest first before looking at the trees.</strong></p>
     <p>There are many informative answers with great details here, I won't repeat any of them. The key to programming in JavaScript is having first the <strong>correct mental model</strong> of overall execution.</p>
     <ol>
      <li>Your entry point(s) is executed as the result of an event. For example, a script tag with code is loaded into the browser. (Accordingly, this is why you may need to be concerned with the readiness of the page to run your code if it requires DOM elements to be constructed first, etc.)</li>
      <li>Your code executes to completion--however many asynchronous calls it makes--without executing <strong>any</strong> of your callbacks, including XHR requests, set timeouts, DOM event handlers, etc. Each of those callbacks waiting to be executed will sit in a queue, waiting their turn to be run after other events that fired have all finished execution.</li>
      <li>Each individual callback to an XHR request, set timeout or DOM the event once invoked will then run to completion.</li>
     </ol>
     <p>The good news is that if you understand this point well, you will never have to worry about race conditions. You should first and foremost thing of how you want to organize your code as essentially the response to different discrete events, and how you want to thread them together into a logical sequence. You can use promises or higher level new async/await as tools to that end, or you can roll your own.</p>
     <p>But you shouldn't use any tactical tools to solve a problem until you are comfortable with the actual problem domain. Draw a map of these dependencies to know what needs to run when. Attempting an ad-hoc approach to all these callbacks is just not going to serve you well.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_36"><span>Answer 36</span> <span class="arrow"> <a href="#answer_35">↑</a> </span> <span class="arrow"> <a href="#answer_37">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>13</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Faiz Mohammed</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Mar 2020 at 06:25</span>
     </div>
    </div>
    <div>
     <p>There is no way you can directly return the result of an Ajax response from a function. The reason is that an Ajax call (<code>$.get()</code> or <code>$.post()</code>) is asynchronous and calling the function that encapsulates the Ajax call would return even before the response is rendered.</p>
     <p>In such scenarios, the only option is to return a promise object, to be resolved when the response arrives.</p>
     <p>There are two ways by which the above issue can be resolved. Both make use of a promise.</p>
     <p>The code snippets below include a JSON URL. Both work and can be directly copied to <a href="https://en.wikipedia.org/wiki/JSFiddle" rel="nofollow noreferrer">JSFiddle</a> and tested.</p>
     <p><strong>Option #1 - return the Ajax call directly from the foo method.</strong><br>
       In the latest version of jQuery, an Ajax call returns a promise object, which can be resolved using a <code>.then</code> function. In code, the <code>.then</code> function is preceded by the call back function to be resolved, <code>foo()</code> in this case.</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>   // Declare function foo
   function foo(url)
   {
     return $.get(url);
   }

   // Invoke the foo function, which returns a promise object
   // the 'then' function accepts the call back to the resolve function
   foo('https://jsonplaceholder.typicode.com/todos/1')
     .then(function(response)
     {
       console.log(response);
     })</code></pre>
       <pre class="snippet-code-css lang-css prettyprint-override"><code>.as-console-wrapper { max-height: 100% !important; top: 0; }</code></pre>
       <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"&gt;&lt;/script&gt;</code></pre>
      </div>
     </div>
     <p></p>
     <p><strong>Option #2 - declare a promise object and return it.</strong><br>
       Declare a promise object inside the function, encapsulate the Ajax call within that promise function and return the promise object.</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>   function foo1() {
     var promise = new Promise(function(resolve, reject)
     {
       $.ajax({
       url: 'https://jsonplaceholder.typicode.com/todos/1',
       success: function(response) {
           console.log(response);
           resolve(response);
           // return response; // &lt;- I tried that one as well
         }
       });
     });
     return promise;
   }

   foo1()
   .then(function(response)
   {
     console.log('Promise resolved:');
     console.log(response);
   })</code></pre>
       <pre class="snippet-code-css lang-css prettyprint-override"><code>.as-console-wrapper { max-height: 100% !important; top: 0; }</code></pre>
       <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"&gt;&lt;/script&gt;</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_37"><span>Answer 37</span> <span class="arrow"> <a href="#answer_36">↑</a> </span> <span class="arrow"> <a href="#answer_38">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>9</span>
     </div>
     <div>
      <span>Answerer: </span> <span>nonopolarity</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Sep 2019 at 07:25</span>
     </div>
    </div>
    <div>
     <p>I think no matter what method or mechanism used, or whatever the framework is (Angular/React) that hides it from you, the following principle holds:</p>
     <ol>
      <li>
       <p>In the flow of the program (think code or even the lowest level: machine code), the data may not arrive back 2 seconds later, 3 seconds later, or may not arrive at all, so there is no usual <code>return</code> to use in order to return the data.</p></li>
      <li>
       <p>It is the classic "observer pattern". (It can be in the form of a "callback".) It is: "hey, I am interested in knowing a successful arrival of data; would you let me know when it does." So you register an observer to be notified (or a function to be called to notify about the successful arrival of the data.) You also usually register an observer for the failure of arrival of such data.</p></li>
      <li>
       <p>When it is successful arrival of data, or a failure of the return of such data, the registered observers (or callbacks) are notified together with the data (or called with the data). If the observer is registered in the form of a callback function <code>foo</code>, then <code>foo(data)</code> will be called. If the observer is registered in the form of an object <code>foo</code>, then depending on the interface, it could be that <code>foo.notify(data)</code> is called.</p></li>
     </ol>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>what do you mean by "It is the classic observer pattern". callback is not the classic observer pattern. maybe promise is a variation of the classic observer pattern, or a variation of PubSub, etc . . but by no means callback itself. at least the way I see it. Do you claim all kinds of async patterns are implementation of the classic observer pattern ? (event RXJS Observable isn't. even though rxjs.subject is)</span> <span> - </span> <span class="display-name">Eva Cohen</span> <span> </span> <span class="date">17 Jan 2021 at 19:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I mean it in the way that "result is not ready, and let me know when it is ready (or has changed)" So for the question "How do I return the response from an asynchronous call?", it is "using a mechanism to get notified when there is result". I guess you can say it is different because observer pattern can be invoked many times but this "callback" or "promise" is only one time? I focus on the "notify me in the future when it is ready", instead of "how many times it can get called".</span> <span> - </span> <span class="display-name">nonopolarity</span> <span> </span> <span class="date">19 Jan 2021 at 04:43</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>well I argue only about your naming, the choice of words. that callback is 'the classic observer pattern' which is a very specific design pattern that you can say Promise is a variation of. but callback (although it's a tool for notifying) is not the classic observer pattern. in promise we can push subscribers that will get notified when the promise settles, but callback is more like an atomic unit and not a pattern, IMHO.</span> <span> - </span> <span class="display-name">Eva Cohen</span> <span> </span> <span class="date">19 Jan 2021 at 07:04</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>ok it is about the naming... what I wanted to put through was, it is the classic "notify me when ready" kind of pattern</span> <span> - </span> <span class="display-name">nonopolarity</span> <span> </span> <span class="date">19 Jan 2021 at 07:08</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_38"><span>Answer 38</span> <span class="arrow"> <a href="#answer_37">↑</a> </span> <span class="arrow"> <a href="#answer_39">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>9</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Philipp Claßen</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 May 2020 at 09:56</span>
     </div>
    </div>
    <div>
     <p>Originally, callbacks were used for asynchronous operations (e.g., in the <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" rel="nofollow noreferrer">XMLHttpRequest API</a>). Now promise-based APIs like the browser's <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="nofollow noreferrer">Fetch API</a> have become the default solution and the nicer <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="nofollow noreferrer"><code>async/await</code></a> syntax is supported by all modern browsers and on Node.js (server side).</p>
     <p>A common scenario - fetching JSON data from the server - can look like this:</p>
     <pre><code>async function fetchResource(url) {
  const res = await fetch(url);
  if (!res.ok) {
    throw new Error(res.statusText);
  }
  return res.json();
}
</code></pre>
     <p>To use it in another function:</p>
     <pre><code>async function doSomething() {
  try {
    const data = await fetchResource("https://example.test/resource/1");
    // ...
  } catch (e) {
    // Handle error
    ...
  }
}
</code></pre>
     <p>If you design a modern API, it is strongly recommended to prefer promise-based style over callbacks. If you inherited an API that relies on callbacks, it is possible to wrap it as a promise:</p>
     <pre><code>function sleep(timeout) {
  return new Promise((resolve) =&gt; {
    setTimeout(() =&gt; {
      resolve();
    }, timeout);
  });
}

async function fetchAfterTwoSeconds(url) {
  await sleep(2000);
  return fetchResource(url);
}
</code></pre>
     <p>In Node.js, which historically relied exclusively on callbacks, that technique is so common that they added a helper function called <a href="https://nodejs.org/api/util.html#util_util_promisify_original" rel="nofollow noreferrer"><code>util.promisify</code></a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_39"><span>Answer 39</span> <span class="arrow"> <a href="#answer_38">↑</a> </span> <span class="arrow"> <a href="#answer_40">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Murtaza Hussain</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Apr 2019 at 16:13</span>
     </div>
    </div>
    <div>
     <p>Use of <code>async/await</code> with a transpilers like <a href="https://en.wikipedia.org/wiki/Babel_(transcompiler)" rel="nofollow noreferrer">Babel</a> to get it working in older browsers. You’ll also have to install this Babel preset and polyfill from npm: <code>npm i -D babel-preset-env babel-polyfill</code>.</p>
     <pre><code>function getData(ajaxurl) { 
  return $.ajax({
    url: ajaxurl,
    type: 'GET',
  });
};

async test() {
  try {
    const res = await getData('https://api.icndb.com/jokes/random')
    console.log(res)
  } catch(err) {
    console.log(err);
  }
}

test();
</code></pre>
     <p>Or the <code>.then</code> callback is just another way to write the same logic.</p>
     <pre><code>getData(ajaxurl).then(function(res) {
    console.log(res)
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_40"><span>Answer 40</span> <span class="arrow"> <a href="#answer_39">↑</a> </span> <span class="arrow"> <a href="#answer_41">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Abd Abughazaleh</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Nov 2020 at 10:17</span>
     </div>
    </div>
    <div>
     <h2>async: false</h2>
     <p>I solved it by setting <code>async</code> to false and restructure my Ajax call:</p>
     <p>I set a global function called <code>sendRequest(type, url, data)</code> with three parameters to be called every time everywhere:</p>
     <pre><code>function sendRequest(type, url, data) {
    let returnValue = null;
    $.ajax({
        url: url,
        type: type,
        async: false,
        data: data,
        dataType: 'json',
        success: function (resp) {
            returnValue = resp;
        }
    });
    return returnValue;
}
</code></pre>
     <p>Now call the function:</p>
     <pre><code>let password = $("#password").val();
        let email = $("#email").val();
        let data = {
            email: email,
            password: password,
        };
        let  resp =  sendRequest('POST', 'http://localhost/signin')}}", data);
        console.log(resp);
</code></pre>
     <blockquote>
      <p>Important <strong>Note</strong> in code is : <code>async: false</code></p>
     </blockquote>
     <p>If this solution is not working with you, please note this may not working in some of browsers or <a href="https://en.wikipedia.org/wiki/JQuery" rel="nofollow noreferrer">jQuery</a> versions.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>This technically solves the issue, but note that this is not recommended because it will freeze the window until the request completes. It's better to learn how to deal with the asynchronous nature of JS than to use synchronous versions of IO-related functions.</span> <span> - </span> <span class="display-name">Matt Welke</span> <span> </span> <span class="date">31 Dec 2020 at 18:44</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>Using <code>async:false</code> is a terrible practice and should <b>never ever</b> be used. It was deprecated by browser vendors years before this answer was written. They even give you warnings in dev tools console not to use it when it is encountered</span> <span> - </span> <span class="display-name">charlietfl</span> <span> </span> <span class="date">27 Mar 2021 at 00:38</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This is not AJAX, this is SJAX.</span> <span> - </span> <span class="display-name">Michael M.</span> <span> </span> <span class="date">15 Jan 2023 at 22:42</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_41"><span>Answer 41</span> <span class="arrow"> <a href="#answer_40">↑</a> </span> <span class="arrow"> <a href="#answer_42">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Zia</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Jun 2023 at 05:46</span>
     </div>
    </div>
    <div>
     <p>I follow these two ways <code>Promises</code> and <code> async/await</code></p>
     <pre><code>Promises

function makeAsyncCall() {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      const response = 'Async response';
      resolve(response);
    }, 2000);
  });
}

makeAsyncCall()
  .then(response =&gt; {
    console.log(response); 
  })
  .catch(error =&gt; {
    console.error(error); 
  });
</code></pre>
     <pre><code>and async/await

async function makeAsyncCall() {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      const response = 'Async response';
      resolve(response);
    }, 2000);
  });
}

async function handleAsyncCall() {
  try {
    const response = await makeAsyncCall();
    console.log(response); 
  } catch (error) {
    console.error(error); 
  }
}

handleAsyncCall();

</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_42"><span>Answer 42</span> <span class="arrow"> <a href="#answer_41">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Lionel Yeo</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Feb 2023 at 02:55</span>
     </div>
    </div>
    <div>
     <p>Many answers do not answer how to obtain the variable inside the callback function and use it later on.</p>
     <pre><code>var myvar = '';
var myvar2 = ajax("GET", "/test", "acrive=1").then(function(result) {
    myvar = result.data.myvar # &lt;-- How to populate myvar?
    return myvar;
})

console.log(myvar) 
# returns undefined

console.log(myvar2)
# returns a promise 

</code></pre>
     <h4>Why</h4>
     <p>The reason is that result.data is a promise. Meaning it is sort of a unstable changing thing and you cannot use it like a variable.</p>
     <h4>How to Use it then?</h4>
     <ol>
      <li>Use js to turn it into HTML</li>
     </ol>
     <pre><code>
.then(function(result) {
    myvar = result.data.myvar 
    $('#result').html(myvar) # &lt;-- use the result in the dom
})

</code></pre>
     <p>This will turn it into a dom "constant" to display</p>
     <ol start="2">
      <li>Use virtual dom like Vue.js variable. The vue.js variables are responsive and automatically connect to the ajax promise so you do not have to do anything.</li>
     </ol>
     <pre><code>myvar = result.data.myvar # &lt;-- How to populate myvar?

var app = new Vue({
   el: '#app',
   data: {
     myvar: ''
   },
   methods: {
     getData() {
         var myvar = '';
         var self = this;
         ajax("GET", "/test", "acrive=1").then(function(result) {
              myvar = result.data.myvar 
              self.myvar = myvar;  #populate this
         })
  }
});
</code></pre>
     <pre><code>HTML
&lt;div id='app'&gt;
   &lt;div&gt; {{ myvar }} &lt;/div&gt;
&lt;/div&gt;
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>This answer makes no sense at all. Getting the value out of an asynchronous method has <b>nothing</b> to do with the DOM. The value passed into an AJAX callback is <b>not</b> a promise. Adding the value to the DOM doesn't magically resolve the promise, if you pass a promise to <code>$("#result").html(x)</code> then all you're going to get is something like <code>[object Object]</code> appended to the DOM. Vue has nothing to do with anything here.</span> <span> - </span> <span class="display-name">user229044</span> <span> </span> <span class="date">26 Feb 2023 at 02:59</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@user229044 agreed that it makes no sense. The explanation is off. However, it does contain a working solution, it it wasn't completely opaque about it. All that's needed is to place the code that <i>uses</i> <code>myvar</code> inside the promise handler that populates <code>myvar</code>. All the talk about promises is actually wrong, since <code>myvar</code> isn't a promise. And the solution with Vue doesn't depend on populating something with a promise - it's just a plain value that's being used again. So the explanation is completely wrong. Moreover, even the working parts of the solution are repeating existing answers.</span> <span> - </span> <span class="display-name">VLAZ -on strike-</span> <span> </span> <span class="date">26 Feb 2023 at 07:45</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>1) Comment 1 put the code outside the call back handler, I have since updated the answer so it's more clear. 2) Comment 2. You are incorrect. Try using myvar outside the callback handler and it will be undefined. This is why we need to discuss promises. <code>myvar</code> isn't a plain value. Also yes I did use some other parts of the solutions but using reactive vue.js allows the value to be worked on.</span> <span> - </span> <span class="display-name">Lionel Yeo</span> <span> </span> <span class="date">27 Feb 2023 at 03:21</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>"<i>Try using myvar outside the callback handler and it will be undefined.</i>" yes. Hence why I said the complete opposite of that. Read again: "<i>All that's needed is to place the code that uses myvar <b>inside the promise handler</b> that populates myvar.</i>" which you'd notise is not "outside". "<i>myvar isn't a plain value</i>" it <i>is</i>. It's just asynchronously populated. It's not a promise, however. You can tell that <i>because*</i> it's <code>undefined</code> exactly as you claim. Were it a promise it would be...a promise, not a plain value. Compare with <code>console.log(Promise.resolve(undefined))</code></span> <span> - </span> <span class="display-name">VLAZ -on strike-</span> <span> </span> <span class="date">27 Feb 2023 at 05:53</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>