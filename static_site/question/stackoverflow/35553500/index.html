<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>XMLHttpRequest cannot load XXX No 'Access-Control-Allow-Origin' header</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>XMLHttpRequest cannot load XXX No 'Access-Control-Allow-Origin' header</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>175</span>
    </div>
    <div>
     <span>Asker: </span> <span>Peter David Carter</span>
    </div>
    <div>
     <span>Asked: </span> <span>22 Feb 2016 at 12:19</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/35553500/xmlhttprequest-cannot-load-xxx-no-access-control-allow-origin-header">source</a>
    </div>
   </div>
   <div>
    <h2>tl;dr; About the Same Origin Policy</h2>
    <p>I have a Grunt process which initiates an instance of express.js server. This was working absolutely fine up until just now when it started serving a blank page with the following appearing in the error log in the developer's console in Chrome (latest version):</p>
    <blockquote>
     <p>XMLHttpRequest cannot load <a href="https://www.example.com/" rel="noreferrer">https://www.example.com/</a> No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin '<a href="http://localhost:4300" rel="noreferrer">http://localhost:4300</a>' is therefore not allowed access.</p>
    </blockquote>
    <p>What is stopping me from accessing the page?</p>
   </div>
   <div class="tags">
    <span class="tag">javascript</span><span class="tag">cors</span><span class="tag">same-origin-policy</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td></td>
       <td><span>I'm working on the website and it was fine five minutes ago.</span> <span> - </span> <span class="display-name">Peter David Carter</span> <span> </span> <span class="date">22 Feb 2016 at 12:25</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>does it issue CORS headers? perhaps if you shared some code it would be easier to see</span> <span> - </span> <span class="display-name">Jaromanda X</span> <span> </span> <span class="date">22 Feb 2016 at 12:25</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Plausibly. Which department should I ask to find out? I just do the backbone.marionette stuff mostly...</span> <span> - </span> <span class="display-name">Peter David Carter</span> <span> </span> <span class="date">22 Feb 2016 at 12:26</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Yeah. I suppose the organisations of departments isn't always uniform anyway, so it is possibly a nebulous question but I would like to know a bit of the backend/routing/sys-admin stuff at my company and this seemed like a good excuse to familiarise myself so if there are problems in future I can help out.</span> <span> - </span> <span class="display-name">Peter David Carter</span> <span> </span> <span class="date">22 Feb 2016 at 12:32</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>I would ask someone on the server side inside your operation. They must have changed it on you if you were able to access it before.</span> <span> - </span> <span class="display-name">Larry Lane</span> <span> </span> <span class="date">22 Feb 2016 at 12:32</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Ok. I'll maybe ask one of the backend people who accesses Narnia (our server room).</span> <span> - </span> <span class="display-name">Peter David Carter</span> <span> </span> <span class="date">22 Feb 2016 at 12:48</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>343</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Quentin</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Feb 2016 at 12:26</span>
     </div>
    </div>
    <div>
     <p>tl;dr —&nbsp;<strong>When you want to read data, (mostly) using client-side JS, from a different server you need the server with the data to grant explicit permission to the code that wants the data.</strong></p>
     <p>There's a summary at the end and headings in the answer to make it easier to find the relevant parts. Reading everything is recommended though as it provides useful background for understanding the <strong>why</strong> that makes seeing how the <strong>how</strong> applies in different circumstances easier.</p>
     <h1>About the Same Origin Policy</h1>
     <p>This is the <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy" rel="nofollow noreferrer">Same Origin Policy</a>. It is a security feature implemented by browsers.</p>
     <p>Your particular case is showing how it is implemented for XMLHttpRequest (and you'll get identical results if you were to use fetch), but it also applies to other things (such as images loaded onto a <code>&lt;canvas&gt;</code> or documents loaded into an <code>&lt;iframe&gt;</code>), just with slightly different implementations.</p>
     <p>The standard scenario that demonstrates the need for the SOP can be demonstrated with <a href="https://en.wikipedia.org/wiki/Alice_and_Bob" rel="nofollow noreferrer">three characters</a>:</p>
     <ul>
      <li>Alice is a person with a web browser</li>
      <li>Bob runs a website (<code>https://www.example.com/</code> in your example)</li>
      <li>Mallory runs a website (<code>http://localhost:4300</code> in your example)</li>
     </ul>
     <p>Alice is logged into Bob's site and has some confidential data there. Perhaps it is a company intranet (accessible only to browsers on the LAN), or her online banking (accessible only with a cookie you get after entering a username and password).</p>
     <p>Alice visits Mallory's website which has some JavaScript that causes Alice's browser to make an HTTP request to Bob's website (from her IP address with her cookies, etc). This could be as simple as using <code>XMLHttpRequest</code> and reading the <code>responseText</code>.</p>
     <p>The browser's Same Origin Policy prevents that JavaScript from reading the data returned by Bob's website (which Bob and Alice don't want Mallory to access). (Note that you can, for example, display an image using an <code>&lt;img&gt;</code> element across origins because the content of the image is not exposed to JavaScript (or Mallory) … unless you throw canvas into the mix in which case you <em>will</em> generate a same-origin violation error).</p>
     <hr>
     <h1>Why the Same Origin Policy applies when you don't think it should</h1>
     <p>For any given URL it is possible that the SOP is not needed. A couple of common scenarios where this is the case are:</p>
     <ul>
      <li>Alice, Bob, and Mallory are the same person.</li>
      <li>Bob is providing entirely public information</li>
     </ul>
     <p>… but the browser has no way of knowing if either of the above is true, so trust is not automatic and the SOP is applied. Permission has to be granted explicitly before the browser will give the data it has received from Bob to some other website.</p>
     <hr>
     <h1>Why the Same Origin Policy applies to JavaScript in a web page but little else</h1>
     <h2>Outside the web page</h2>
     <p>Browser extensions<code>*</code>, the Network tab in browser developer tools, and applications like Postman are installed software. They aren't passing data from one website to the JavaScript belonging to a different website <em>just because you visited that different website</em>. Installing software usually takes a more conscious choice.</p>
     <p>There isn't a third party (Mallory) who is considered a risk.</p>
     <p><code>*</code> Browser extensions do need to be written carefully to avoid cross-origin issues. <a href="https://www.chromium.org/Home/chromium-security/extension-content-script-fetches" rel="nofollow noreferrer">See the Chrome documentation for example</a>.</p>
     <h2>Inside the webpage</h2>
     <p>Most of the time, there isn't a great deal of information leakage when just showing something on a webpage.</p>
     <p>If you use an <code>&lt;img&gt;</code> element to load an image, then it gets shown on the page, but very little information is exposed to Mallory. JavaScript can't read the image (unless you use a <code>crossOrigin</code> attribute to explicitly enable request permission with CORS) and then copy it to her server.</p>
     <p>That said, some information does leak so, to <a href="https://github.com/whatwg/html/issues/1888#issuecomment-252999958" rel="nofollow noreferrer">quote Domenic Denicola (of Google)</a>:</p>
     <blockquote>
      <p>The web's fundamental security model is the same origin policy. We have several legacy exceptions to that rule from before that security model was in place, with script tags being one of the most egregious and most dangerous. (See the various "JSONP" attacks.)</p>
      <p>Many years ago, perhaps with the introduction of XHR or web fonts (I can't recall precisely), we drew a line in the sand, and said no new web platform features would break the same origin policy. The existing features need to be grandfathered in and subject to carefully-honed and oft-exploited exceptions, for the sake of not breaking the web, but we certainly can't add any more holes to our security policy.</p>
     </blockquote>
     <p>This is why you need CORS permission to load fonts across origins.</p>
     <hr>
     <h1>Why you can display data on the page without reading it with JS</h1>
     <p>There are a number of circumstances where Mallory's site can cause a browser to fetch data from a third party and display it (e.g. by adding an <code>&lt;img&gt;</code> element to display an image). It isn't possible for Mallory's JavaScript to read the data in that resource though, only Alice's browser and Bob's server can do that, so it is still secure.</p>
     <hr>
     <h1>CORS</h1>
     <p>The <code>Access-Control-Allow-Origin</code> HTTP <strong>response</strong> header referred to in the error message is part of the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" rel="nofollow noreferrer">CORS</a> standard which allows Bob to explicitly grant permission to Mallory's site to access the data via Alice's browser.</p>
     <p>A basic implementation would just include:</p>
     <pre><code>Access-Control-Allow-Origin: *
</code></pre>
     <p>… in the response headers to permit any website to read the data.</p>
     <pre><code>Access-Control-Allow-Origin: http://example.com
</code></pre>
     <p>… would allow only a specific site to access it, and Bob can dynamically generate that based on the <code>Origin</code> <em>request</em> header to permit multiple, but not all, sites to access it.</p>
     <p>The specifics of how Bob sets that response header depend on Bob's HTTP server and/or server-side programming language. Users of Node.js/Express.js should use the <a href="https://www.npmjs.com/package/cors" rel="nofollow noreferrer">well-documented CORS middleware</a>. Users of other platforms should take a look at this <a href="https://enable-cors.org/server.html" rel="nofollow noreferrer"> collection of guides for various common configurations</a> that might help.</p>
     <p><a href="https://i.stack.imgur.com/VXM0t.png" rel="nofollow noreferrer"><img src="VXM0t.png" alt="Model of where CORS rules are applied"></a></p>
     <p>NB: Some requests are complex and send a <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Preflighted_requests" rel="nofollow noreferrer">preflight</a> OPTIONS request that the server will have to respond to before the browser will send the GET/POST/PUT/Whatever request that the JS wants to make. Implementations of CORS that only add <code>Access-Control-Allow-Origin</code> to specific URLs often get tripped up by this.</p>
     <hr>
     <p>Obviously granting permission via CORS is something Bob would only do only if either:</p>
     <ul>
      <li>The data was not private <em>or</em></li>
      <li>Mallory was trusted</li>
     </ul>
     <hr>
     <h2>How do I add these headers?</h2>
     <p>It depends on your server-side environment.</p>
     <p>If you can, use a library designed to handle CORS as they will present you with simple options instead of having to deal with everything manually.</p>
     <p><a href="https://enable-cors.org/server.html" rel="nofollow noreferrer">Enable-Cors.org</a> has a list of documentation for specific platforms and frameworks that you might find useful.</p>
     <h2>But I'm not Bob!</h2>
     <p>There is no standard mechanism for <em>Mallory</em> to add this header because it has to come from Bob's website, which she does not control.</p>
     <p>If Bob is running a public API then there might be a mechanism to turn on CORS (perhaps by formatting the request in a certain way, or a config option after logging into a Developer Portal site for Bob's site). This will have to be a mechanism implemented by Bob though. Mallory could read the documentation on Bob's site to see if something is available, or she could talk to Bob and ask him to implement CORS.</p>
     <hr>
     <h1>Error messages which mention "Response for preflight"</h1>
     <p>Some cross-origin requests are <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Preflighted_requests" rel="nofollow noreferrer">preflighted</a>.</p>
     <p>This happens when (roughly speaking) you try to make a cross-origin request that:</p>
     <ul>
      <li>Includes credentials like cookies</li>
      <li>Couldn't be generated with a regular HTML form (e.g. sets a Content-Type that you couldn't use in a form's <code>enctype</code> or some other request header(s)).</li>
     </ul>
     <h2>If you are correctly doing something that needs a preflight</h2>
     <p>In these cases then <strong>the rest of this answer still applies</strong> but you also need to make sure that the server can listen for the preflight request (which will be <code>OPTIONS</code> (and not <code>GET</code>, <code>POST</code>, or whatever you were trying to send) and respond to it with the right <code>Access-Control-Allow-Origin</code> header but also <code>Access-Control-Allow-Methods</code> and <code>Access-Control-Allow-Headers</code> to allow your specific HTTP methods or headers.</p>
     <h2>If you are triggering a preflight by mistake</h2>
     <p>Sometimes people make mistakes when trying to construct Ajax requests, and sometimes these trigger the need for a preflight. If the API is designed to allow cross-origin requests but doesn't require anything that would need a preflight, then this can break access.</p>
     <p>Common mistakes that trigger this include:</p>
     <ul>
      <li>trying to put <code>Access-Control-Allow-Origin</code> and other CORS response headers on the request. These don't belong on the request, don't do anything helpful (what would be the point of a permissions system where you could grant yourself permission?), and must appear only on the response.</li>
      <li>trying to put a <code>Content-Type: application/json</code> header on a GET request that has no request body the content of which to describe (typically when the author confuses <code>Content-Type</code> and <code>Accept</code>).</li>
     </ul>
     <p>In either of these cases, removing the extra request header will often be enough to avoid the need for a preflight (which will solve the problem when communicating with APIs that support simple requests but not preflighted requests).</p>
     <hr>
     <h1>Opaque responses (<code>no-cors</code> mode)</h1>
     <p>Sometimes you need to make an HTTP request, but you don't need to read the response. e.g. if you are posting a log message to the server for recording.</p>
     <p>If you are using <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" rel="nofollow noreferrer">the <code>fetch</code> API</a> (rather than <code>XMLHttpRequest</code>), then you can configure it to not try to use CORS.</p>
     <p>Note that <strong>this won't let you do anything that you require CORS to do</strong>. <strong>You will not be able to read the response</strong>. You will not be able to make a request that requires a preflight.</p>
     <p>It will let you make a simple request, not see the response, and not fill the Developer Console with error messages.</p>
     <p>How to do it is explained by the Chrome error message given when you make a request using <code>fetch</code> and don't get permission to view the response with CORS:</p>
     <blockquote>
      <p>Access to fetch at '<code>https://example.com/</code>' from origin '<code>https://example.net</code>' has been blocked by CORS policy: No '<code>Access-Control-Allow-Origin</code>' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.</p>
     </blockquote>
     <p>Thus:</p>
     <pre><code>fetch("http://example.com", { mode: "no-cors" });
</code></pre>
     <hr>
     <h1>Alternatives to CORS</h1>
     <h2>JSONP</h2>
     <p>Bob could also provide the data using a hack like <a href="https://stackoverflow.com/questions/2067472/what-is-jsonp-all-about">JSONP</a> which is how people did cross-origin Ajax before CORS came along.</p>
     <p>It works by presenting the data in the form of a JavaScript program that injects the data into Mallory's page.</p>
     <p>It requires that Mallory trust Bob not to provide malicious code.</p>
     <p>Note the common theme: The site providing the data has to tell the browser that it is OK for a third-party site to access the data it is sending to the browser.</p>
     <p>Since JSONP works by appending a <code>&lt;script&gt;</code> element to load the data in the form of a JavaScript program that calls a function already in the page, attempting to use the JSONP technique on a URL that returns JSON will fail — typically with a CORB error — because JSON is not JavaScript.</p>
     <h2>Move the two resources to a single Origin</h2>
     <p>If the HTML document the JS runs in and the URL being requested are on the same origin (sharing the same scheme, hostname, and port) then the Same Origin Policy grants permission by default. CORS is not needed.</p>
     <h2>A Proxy</h2>
     <p>Mallory <em>could</em> use server-side code to fetch the data (which she could then pass from her server to Alice's browser through HTTP as usual).</p>
     <p>It will either:</p>
     <ul>
      <li>add CORS headers</li>
      <li>convert the response to JSONP</li>
      <li>exist on the same origin as the HTML document</li>
     </ul>
     <p>That server-side code could be written &amp; hosted by a third party (such as CORS Anywhere). Note the privacy implications of this: The third party can monitor who proxies what across their servers.</p>
     <p>Bob wouldn't need to grant any permissions for that to happen.</p>
     <p>There are no security implications here since that is just between Mallory and Bob. There is no way for Bob to think that Mallory is Alice and to provide Mallory with data that should be kept confidential between Alice and Bob.</p>
     <p>Consequently, Mallory can only use this technique to read <em>public</em> data.</p>
     <p>Do note, however, that taking content from someone else's website and displaying it on your own might be a violation of <em>copyright</em> and open you up to legal action.</p>
     <h2>Writing something other than a web app</h2>
     <p>As noted in the section "Why the Same Origin Policy only applies to JavaScript in a web page", you can avoid the SOP by not writing JavaScript in a webpage.</p>
     <p>That doesn't mean you can't continue to use JavaScript and HTML, but you could distribute it using some other mechanism, such as Node-WebKit or PhoneGap.</p>
     <h1>Browser extensions</h1>
     <p>It is possible for a browser extension to inject the CORS headers in the response before the Same Origin Policy is applied.</p>
     <p>These can be useful for development but are not practical for a production site (asking every user of your site to install a browser extension that disables a security feature of their browser is unreasonable).</p>
     <p>They also tend to work only with simple requests (failing when handling preflight OPTIONS requests).</p>
     <p>Having a proper development environment with a local development <em>server</em> is usually a better approach.</p>
     <hr>
     <h1>Other security risks</h1>
     <p>Note that SOP / CORS do not mitigate <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" rel="nofollow noreferrer">XSS</a>, <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" rel="nofollow noreferrer">CSRF</a>, or <a href="https://en.wikipedia.org/wiki/SQL_injection" rel="nofollow noreferrer">SQL Injection</a> attacks which need to be handled independently.</p>
     <hr>
     <h1>Summary</h1>
     <ul>
      <li>There is nothing you can do in <em>your</em> client-side code that will enable CORS access to someone <em>else's</em> server.</li>
      <li>If you control the server the request is being made to: Add CORS permissions to it.</li>
      <li>If you are friendly with the person who controls it: Get them to add CORS permissions to it.</li>
      <li>If it is a public service then (keeping in mind that <strong>most third-party APIs are designed to be interacted with only by your server-side code and do not support CORS</strong> but for those that are): 
       <ul>
        <li>Read their API documentation to see what they say about accessing it with client-side JavaScript: 
         <ul>
          <li>They might tell you to use specific URLs</li>
          <li>They might support JSONP instead of CORS</li>
          <li>They might not support cross-origin access from client-side code at all (this might be a deliberate decision on security grounds, especially if you have to pass a personalized API Key in each request).</li>
         </ul></li>
        <li>Make sure you aren't triggering a preflight request you don't need. The API might grant permission for simple requests but not preflighted requests.</li>
       </ul></li>
      <li>If none of the above apply: Get the browser to talk to <em>your</em> server instead, and then have your server fetch the data from the other server and pass it on. (There are also third-party hosted services that attach CORS headers to publically accessible resources that you could use).</li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>If I run local LAN a web server and try to do ajax load from the IP/URL will that work ? I havent tried that yet. as my web server returing json data would be a MCU</span> <span> - </span> <span class="display-name">Ciasto piekarz</span> <span> </span> <span class="date">23 Dec 2016 at 05:09</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Ciastopiekarz — Normal same origin / different origin rules apply. Normal network routing rules apply.</span> <span> - </span> <span class="display-name">Quentin</span> <span> </span> <span class="date">23 Dec 2016 at 12:25</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Quentin - Wow! +1! So what I'm to understand is if Alice uses the CORS extension, the server thinks that her http calls are <b>not</b> from javascript but from a browser extension and treats it like a normal same origin request?</span> <span> - </span> <span class="display-name">snippetkid</span> <span> </span> <span class="date">11 May 2017 at 11:51</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@snippetkid — No. In the usual case, the server will send CORS headers in ever response and not care where the request came from. It is the responsibility of the browser to allow or deny access to the data to the JS based on the CORS headers on the response. (Things get a /little/ more complex on the server when it comes to preflight requests)</span> <span> - </span> <span class="display-name">Quentin</span> <span> </span> <span class="date">11 May 2017 at 11:54</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>'what language you are using for server-side programming (if any).' Could you clear this up for me? Server Side Programming will require a language.</span> <span> - </span> <span class="display-name">Suraj Jain</span> <span> </span> <span class="date">18 Apr 2018 at 02:43</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@SurajJain — You might choose to add the headers by configuring your HTTP server and no do any programming at all.</span> <span> - </span> <span class="display-name">Quentin</span> <span> </span> <span class="date">18 Apr 2018 at 08:01</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Quentin <a href="https://security.stackexchange.com/a/157065/166709.">This</a> answer on SOP in security stackexchange was wrong according to me, so I edited it, could you please verify the edit, I learned about SOP from your answers and some other domains and am not sure about if I wrote correct or not.</span> <span> - </span> <span class="display-name">Suraj Jain</span> <span> </span> <span class="date">6 May 2018 at 10:08</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>So I cannot edit OPs question and he apparently refuses to add any suggestions to it, but the reason it provides benefits even when proxies are involved is with cookies. Even when the proxy is completely transparent Alices browser (assuming it works properly) wont send (Bobs) cookies to Mallorys proxy and therefore Bobs server has no reason to believe that he is talking to Alice. Subsequently it wont send any info related to Alice to the proxy operated by Mallory. - Just in case anyone was wondering like me and forgot about cookies :)</span> <span> - </span> <span class="display-name">Cromon</span> <span> </span> <span class="date">15 Sep 2018 at 10:43</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>shouldn't be the third person's name Cecil?</span> <span> - </span> <span class="display-name">Sergei Kovalenko</span> <span> </span> <span class="date">10 Oct 2019 at 09:39</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@SergeiKovalenko — <a href="https://en.wikipedia.org/wiki/Alice_and_Bob#Cast_of_characters" rel="nofollow noreferrer">en.wikipedia.org/wiki/Alice_and_Bob#Cast_of_characters</a></span> <span> - </span> <span class="display-name">Quentin</span> <span> </span> <span class="date">10 Oct 2019 at 10:08</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Quentin Wonderful answer. A small query though, <i>There are also third-party hosted services which attach CORS headers to publically accessible resources that you could use</i> with this, isn't the whole purpose of <code>CORS</code> defeated?</span> <span> - </span> <span class="display-name">ABGR</span> <span> </span> <span class="date">28 May 2020 at 17:24</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@RahulDwivedi — No, see the section "A Proxy"</span> <span> - </span> <span class="display-name">Quentin</span> <span> </span> <span class="date">28 May 2020 at 17:34</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Ok but still, the `third party' server could be residing on a different domain. And technically are they allowed just because their code is on a server and it's not the JavaScript that is accessing it?</span> <span> - </span> <span class="display-name">ABGR</span> <span> </span> <span class="date">28 May 2020 at 17:40</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@RahulDwivedi — It's outside a browser so the same origin policy doesn't apply. It's safe because its outside the browser that belongs to the user.</span> <span> - </span> <span class="display-name">Quentin</span> <span> </span> <span class="date">28 May 2020 at 17:41</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I actually meant this. <code>localhost</code> though JavaScipt code is refused access by <code>domain A</code>. So <code>localhost</code> request a 'middle-man' server which on behalf of it, makes a request to <code>domain A</code>. Note that all three of them are on different domains. But, this time the access is granted to the 'middle-man' server (because it made a requested from a server api, not JavaScript) which in turns sends back the resources to <code>localhost</code>. Isn't this exactly happens or am I missing something big?</span> <span> - </span> <span class="display-name">ABGR</span> <span> </span> <span class="date">28 May 2020 at 17:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Case 1: The browser loads a page from SERVER_A which includes JavaScript that makes a request to SERVER_B. SERVER_B does not include CORS headers in the response so the browser denies the JavaScript program access to the data.</span> <span> - </span> <span class="display-name">Quentin</span> <span> </span> <span class="date">28 May 2020 at 18:00</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Case 2: The browser loads a page from SERVER_A which includes JavaScript that makes a request to PROXY. PROXY makes a request to SERVER_B and reads the data. PROXY uses that data in a response to the browser which also includes CORS headers. The browser allows access to the data from PROXY because it has CORS headers. The browser knows and cares nothing about SERVER_B.</span> <span> - </span> <span class="display-name">Quentin</span> <span> </span> <span class="date">28 May 2020 at 18:00</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>hey @Quentin i am getting this when i make a call in axios, but the same api is working totally fine in Postman, it is giving me response, but i get this error when i use axios in my reactjs. so, how can i resolve this? Access to XMLHttpRequest at '<a href="https://s9k.execute-api.ap-south-1.amazonaws.com/UAT/getUserData/" rel="nofollow noreferrer">s9k.execute-api.ap-south-1.amazonaws.com/UAT/getUserData</a>' from origin '<a href="http://localhost:3000" rel="nofollow noreferrer">localhost:3000</a>' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource.</span> <span> - </span> <span class="display-name">Prabhat kumar</span> <span> </span> <span class="date">28 Sep 2020 at 11:51</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Prabhatkumar — Do what it says in the section of this answer with the heading: Error messages which mention "Response for preflight"</span> <span> - </span> <span class="display-name">Quentin</span> <span> </span> <span class="date">28 Sep 2020 at 11:53</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Here is the part I like most: <i>There is nothing you can do in your client-side code that will enable CORS access to someone else's server</i></span> <span> - </span> <span class="display-name">codrelphi</span> <span> </span> <span class="date">5 Jul 2022 at 14:56</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>"Bob is providing entirely public information … but the browser has no way of knowing if the above is true" - why don't browsers provide a way to make an "anonymous" cross-origin <code>fetch</code> which sends no credentials, as if it had been made in a new private browsing window? That way a script could get something completely public, like an RSS feed, and there would be no risk of sending the user's credentials.</span> <span> - </span> <span class="display-name">Jez</span> <span> </span> <span class="date">3 May 2023 at 12:13</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Jez — IP based auth, intranet services. Also I subscribe to a number of RSS feeds that are not completely public.</span> <span> - </span> <span class="display-name">Quentin</span> <span> </span> <span class="date">3 May 2023 at 21:57</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Daphoque</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Sep 2016 at 10:45</span>
     </div>
    </div>
    <div>
     <p>Target server must allowed cross-origin request. In order to allow it through express, simply handle http options request :</p>
     <pre><code>app.options('/url...', function(req, res, next){
   res.header('Access-Control-Allow-Origin', "*");
   res.header('Access-Control-Allow-Methods', 'POST');
   res.header("Access-Control-Allow-Headers", "accept, content-type");
   res.header("Access-Control-Max-Age", "1728000");
   return res.sendStatus(200);
});
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>zwif</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Nov 2017 at 11:37</span>
     </div>
    </div>
    <div>
     <p>As this isn't mentioned in the accepted answer.</p>
     <ul>
      <li>This is not the case for this exact question, but might help others that search for that problem</li>
      <li>This is something you can do in your client-code to prevent CORS errors in <em>some cases</em>.</li>
     </ul>
     <p>You can make use of <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Simple_requests" rel="nofollow noreferrer">Simple Requests</a>.<br>
       In order to perform a 'Simple Requests' the request needs to meet several conditions. E.g. only allowing <code>POST</code>, <code>GET</code> and <code>HEAD</code> method, as well as only allowing some given Headers (you can find all conditions <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Simple_requests" rel="nofollow noreferrer">here</a>).</p>
     <p>If your client code does not explicit set affected Headers (e.g. "Accept") with a fix value in the request it <em>might</em> occur that some clients do set these Headers automatically with some "non-standard" values causing the server to not accept it as Simple Request - which will give you a CORS error.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Vishnu</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Feb 2016 at 12:32</span>
     </div>
    </div>
    <div>
     <p>This is happening because of the CORS error. CORS stands for Cross Origin Resource Sharing. In simple words, this error occurs when we try to access a domain/resource from another domain.</p>
     <p>Read More about it here: <a href="https://stackoverflow.com/questions/25923796/cors-error-with-jquery">CORS error with jquery</a></p>
     <p>To fix this, if you have access to the other domain, you will have to allow Access-Control-Allow-Origin in the server. This can be added in the headers. You can enable this for all the requests/domains or a specific domain.</p>
     <p><a href="https://stackoverflow.com/questions/5750696/how-to-get-a-cross-origin-resource-sharing-cors-post-request-working">How to get a cross-origin resource sharing (CORS) post request working</a></p>
     <p>These links may help</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>morph85</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Dec 2018 at 06:40</span>
     </div>
    </div>
    <div>
     <p>This CORS issue wasn't further elaborated (for other causes).</p>
     <p>I'm having this issue currently under different reason. My front end is returning 'Access-Control-Allow-Origin' header error as well.</p>
     <p>Just that I've pointed the wrong URL so this header wasn't reflected properly (in which i kept presume it did). localhost (front end) -&gt; call to non secured http (supposed to be https), make sure the API end point from front end is pointing to the correct protocol.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Subhashi</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Feb 2020 at 11:02</span>
     </div>
    </div>
    <div>
     <p>I got the same error in Chrome console.</p>
     <p>My problem was, I was trying to go to the site using <code>http://</code> instead of <code>https://</code>. So there was nothing to fix, just had to go to the same site using <code>https</code>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>HungNM2</span>
     </div>
     <div>
      <span> Answered: </span> <span>20 Aug 2020 at 02:13</span>
     </div>
    </div>
    <div>
     <p>This bug cost me 2 days. I checked my Server log, the Preflight Option request/response between browser Chrome/Edge and Server was ok. The main reason is that GET/POST/PUT/DELETE <strong>server response</strong> for XHTMLRequest must also have the following header:</p>
     <pre><code>access-control-allow-origin: origin  
</code></pre>
     <p>"origin" is in the <strong>request header</strong> (Browser will add it to request for you). for example:</p>
     <pre><code>Origin: http://localhost:4221
</code></pre>
     <p>you can add response header like the following to accept for all:</p>
     <pre><code>access-control-allow-origin: *  
</code></pre>
     <p>or response header for a specific request like:</p>
     <pre><code>access-control-allow-origin: http://localhost:4221 
</code></pre>
     <p>The message in browsers is not clear to understand: <strong>"...The requested resource"</strong></p>
     <p><strong>note that:</strong> CORS works well for localhost. different port means different Domain. if you get error message, check the CORS config on the server side.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Geshe</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Nov 2019 at 12:51</span>
     </div>
    </div>
    <div>
     <p>"Get" request with appending headers transform to "Options" request. So Cors policy problems occur. You have to implement "Options" request to your server. <strong>Cors Policy about server side and you need to allow Cors Policy on your server side.</strong> For Nodejs server:<a href="https://expressjs.com/en/resources/middleware/cors.html#:%7E:text=CORS%20is%20a%20node.,enable%20CORS%20with%20various%20options." rel="nofollow noreferrer">details</a></p>
     <pre><code>app.use(cors)
</code></pre>
     <p>For Java to integrate with Angular:<a href="https://spring.io/guides/gs/rest-service-cors/#global-cors-configuration" rel="nofollow noreferrer">details</a></p>
     <pre><code>@CrossOrigin(origins = "http://localhost:4200")
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Massimo Pavanel</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Nov 2020 at 09:08</span>
     </div>
    </div>
    <div>
     <p>In most housing services just add in the .htaccess on the target server folder this:</p>
     <p>Header set Access-Control-Allow-Origin 'https://your.site.folder'</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Inshal Irshad</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 May 2021 at 19:44</span>
     </div>
    </div>
    <div>
     <p>I had the same issue. In my case i fixed it by adding addition parameter of <code>timestamp</code> to my URL. Even this was not required by the server I was accessing.</p>
     <p>Example yoururl.com/yourdocument?timestamp=1234567</p>
     <p>Note: I used epos timestamp</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-13</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Perostek Balveda</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Apr 2017 at 11:13</span>
     </div>
    </div>
    <div>
     <p>You should enable CORS to get it working.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>