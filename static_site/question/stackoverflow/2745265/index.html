<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>Is List&lt;Dog&gt; a subclass of List&lt;Animal&gt;? Why are Java generics not implicitly polymorphic?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>Is List&lt;Dog&gt; a subclass of List&lt;Animal&gt;? Why are Java generics not implicitly polymorphic?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>889</span>
    </div>
    <div>
     <span>Asker: </span> <span>froadie</span>
    </div>
    <div>
     <span>Asked: </span> <span>30 Apr 2010 at 14:39</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/2745265/is-listdog-a-subclass-of-listanimal-why-are-java-generics-not-implicitly-po">source</a>
    </div>
   </div>
   <div>
    <p>I'm a bit confused about how Java generics handle inheritance / polymorphism.</p>
    <p>Assume the following hierarchy -</p>
    <p><strong>Animal</strong> (Parent)</p>
    <p><strong>Dog</strong> - <strong>Cat</strong> (Children)</p>
    <p>So suppose I have a method <code>doSomething(List&lt;Animal&gt; animals)</code>. By all the rules of inheritance and polymorphism, I would assume that a <code>List&lt;Dog&gt;</code> <em>is</em> a <code>List&lt;Animal&gt;</code> and a <code>List&lt;Cat&gt;</code> <em>is</em> a <code>List&lt;Animal&gt;</code> - and so either one could be passed to this method. Not so. If I want to achieve this behavior, I have to explicitly tell the method to accept a list of any subclass of Animal by saying <code>doSomething(List&lt;? extends Animal&gt; animals)</code>.</p>
    <p>I understand that this is Java's behavior. My question is <em>why</em>? Why is polymorphism generally implicit, but when it comes to generics it must be specified?</p>
   </div>
   <div class="tags">
    <span class="tag">java</span><span class="tag">generics</span><span class="tag">inheritance</span><span class="tag">polymorphism</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>22</td>
       <td><span>And a totally unrelated grammar question that's bothering me now - should my title be "why <i>aren't</i> Java's generics" or "why <i>isn't</i> Java's generics"?? Is "generics" plural because of the s or singular because it's one entity?</span> <span> - </span> <span class="display-name">froadie</span> <span> </span> <span class="date">30 Apr 2010 at 14:44</span></td>
      </tr>
      <tr>
       <td>27</td>
       <td><span>generics as done in Java are a very poor form of parametric polymorphism. Don't put too much into faith into them (like I used to), because one day you'll hit hard their pathetic limitations: <i>Surgeon extends Handable&lt;Scalpel&gt;, Handable&lt;Sponge&gt;</i> KABOOM! Does <i>not</i> compute [TM]. There's your Java generics limitation. Any OOA/OOD can be translated fine into Java (and MI can be done very nicely using Java interfaces) but generics just don't cut it. They're fine for "collections" and procedural programming that said (which is what most Java programmers do anyway so...).</span> <span> - </span> <span class="display-name">SyntaxT3rr0r</span> <span> </span> <span class="date">30 Apr 2010 at 15:43</span></td>
      </tr>
      <tr>
       <td>8</td>
       <td><span>Super class of List&lt;Dog&gt; is not List&lt;Animal&gt; but List&lt;?&gt; (i.e list of unknown type) . Generics erases type information in compiled code. This is done so that code which is using generics(java 5 &amp; above) is compatible with earlier versions of java without generics.</span> <span> - </span> <span class="display-name">rai.skumar</span> <span> </span> <span class="date">4 Dec 2012 at 11:15</span></td>
      </tr>
      <tr>
       <td>5</td>
       <td><span>Related SO question - <a href="http://stackoverflow.com/questions/17834145/whats-the-use-of-saying-extends-someobject-instead-of-someobject/17834223">Whats the use of saying &lt;? extends SomeObject&gt; instead of &lt;SomeObject&gt;</a></span> <span> - </span> <span class="display-name">Aniket Thakur</span> <span> </span> <span class="date">2 Oct 2015 at 18:53</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Just like to add that there is actually an Official Java Tutorial concerning this topic: <a href="https://docs.oracle.com/javase/tutorial/extra/generics/subtype.html" rel="nofollow noreferrer">docs.oracle.com/javase/tutorial/extra/generics/subtype.html</a></span> <span> - </span> <span class="display-name">Teng-pao Yu</span> <span> </span> <span class="date">4 Jun 2016 at 08:23</span></td>
      </tr>
      <tr>
       <td>10</td>
       <td><span>@froadie since nobody seemed to respond... it should definitely be "why aren't Java's generics...". The other issue is that "generic" is actually an adjective, and so "generics" is referring to a dropped plural noun modified by "generic". You could say "that function is a generic", but that would be more cumbersome than saying "that function is generic". However, it's a bit cumbersome to say "Java has generic functions and classes", instead of just "Java has generics". As someone who wrote their master's thesis on adjectives, I think you've stumbled upon a very interesting question!</span> <span> - </span> <span class="display-name">dantiston</span> <span> </span> <span class="date">30 May 2017 at 05:18</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span><code>List&lt;A&gt;</code> has no relationship with <code>List&lt;B&gt;</code> regardless of the relationship between class A and B.</span> <span> - </span> <span class="display-name">NoName</span> <span> </span> <span class="date">10 Jul 2017 at 05:27</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@dantiston Generics could be viewed as a collective singular, in which case "isn't" works just fine.</span> <span> - </span> <span class="display-name">Ungeheuer</span> <span> </span> <span class="date">5 Sep 2017 at 16:52</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@SyntaxT3rr0r In your example, my goto solution would be making a super-interface of <code>Scalpel</code> and <code>Sponge</code> (probably named something like <code>SurgeonItem</code>) then declaring <code>Surgeon extends Handable&lt;SurgeonItem&gt;</code>.</span> <span> - </span> <span class="display-name">Kröw</span> <span> </span> <span class="date">10 Jun 2018 at 00:11</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>@rai.skumar <code>List&lt;?&gt;</code> isn't the only effective supertype of <code>List&lt;Dog&gt;</code>. Other examples are <code>List&lt;? extends Dog&gt;</code> and <code>List&lt;? super Dog&gt;</code>. Also, any variant of the four (<code>&lt;Dog&gt;</code>, <code>&lt;? super Dog&gt;</code>, <code>&lt;? extends Dog&gt;</code>, <code>&lt;?&gt;</code>) applied to a supertype of <code>List</code> apply as well: <code>Collection&lt;Dog&gt;</code>, <code>Iterable&lt;? super Dog&gt;</code>, etc.. Anywhere you have a reference to any of those you can also pass in a <code>List&lt;Dog&gt;</code>. Also <code>List&lt;? extends Animal&gt;</code> and <code>List&lt;? super Chihuahua&gt;</code>.</span> <span> - </span> <span class="display-name">M. Justin</span> <span> </span> <span class="date">10 Mar 2021 at 06:07</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>Related: <a href="https://stackoverflow.com/questions/2723397/what-is-pecs-producer-extends-consumer-super">What is PECS (Producer Extends Consumer Super)?</a></span> <span> - </span> <span class="display-name">Lii</span> <span> </span> <span class="date">9 Apr 2021 at 12:33</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1046</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Jon Skeet</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Apr 2010 at 14:44</span>
     </div>
    </div>
    <div>
     <p>No, a <code>List&lt;Dog&gt;</code> is <em>not</em> a <code>List&lt;Animal&gt;</code>. Consider what you can do with a <code>List&lt;Animal&gt;</code> - you can add <em>any</em> animal to it... including a cat. Now, can you logically add a cat to a litter of puppies? Absolutely not.</p>
     <pre><code>// Illegal code - because otherwise life would be Bad
List&lt;Dog&gt; dogs = new ArrayList&lt;Dog&gt;(); // ArrayList implements List
List&lt;Animal&gt; animals = dogs; // Awooga awooga
animals.add(new Cat());
Dog dog = dogs.get(0); // This should be safe, right?
</code></pre>
     <p>Suddenly you have a <em>very</em> confused cat.</p>
     <p>Now, you <em>can't</em> add a <code>Cat</code> to a <code>List&lt;? extends Animal&gt;</code> because you don't know it's a <code>List&lt;Cat&gt;</code>. You can retrieve a value and know that it will be an <code>Animal</code>, but you can't add arbitrary animals. The reverse is true for <code>List&lt;? super Animal&gt;</code> - in that case you can add an <code>Animal</code> to it safely, but you don't know anything about what might be retrieved from it, because it could be a <code>List&lt;Object&gt;</code>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>61</td>
        <td><span>Interestingly, every list of dogs <i>is</i> indeed a list of animals, just like intuition tells us. The point is, that not every list of animals is a list of dogs, hence mutattion of the list by adding a cat is the problem.</span> <span> - </span> <span class="display-name">Ingo</span> <span> </span> <span class="date">28 Jan 2013 at 19:29</span></td>
       </tr>
       <tr>
        <td>80</td>
        <td><span>@Ingo: No, not really: you can add a cat to a list of animals, but you can't add a cat to a list of dogs. A list of dogs is only a list of animals if you consider it in a read-only sense.</span> <span> - </span> <span class="display-name">Jon Skeet</span> <span> </span> <span class="date">28 Jan 2013 at 19:33</span></td>
       </tr>
       <tr>
        <td>15</td>
        <td><span>@JonSkeet - Of course, but who is mandating that making a new list from a cat and a list of dogs actually changes the list of dogs? This is an arbitrary implementation decision in Java. One that goes counter to logic and intuition.</span> <span> - </span> <span class="display-name">Ingo</span> <span> </span> <span class="date">28 Jan 2013 at 19:41</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>@Ingo: The point is that we're speaking <i>in the context of Java</i>, where these things are specified. I don't think that taking it out of that context is really helpful. (And even in real life, in various cases if you start adding "the wrong type of item" to a list, the list no longer makes sense.)</span> <span> - </span> <span class="display-name">Jon Skeet</span> <span> </span> <span class="date">28 Jan 2013 at 19:44</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@JonSkeet I do not want to be nitpicking, but if you included the words "subclass of" after the first occurence of "not a" in your answer, it would get very much better. Or even: "While a list of dogs is certainly a list of animals, this does unfortunately not mean that a List&lt;Dog&gt; is a subtype of List&lt;Animal&gt;"</span> <span> - </span> <span class="display-name">Ingo</span> <span> </span> <span class="date">28 Jan 2013 at 19:54</span></td>
       </tr>
       <tr>
        <td>8</td>
        <td><span>@Ingo: I wouldn't have used that "certainly" to start with. If you have a list which says at the top "Hotels we might want to go to" and then someone added a swimming pool to it, would you think that valid? No - it's a list of hotels, which isn't a list of buildings. And it's not like I even said "A list of dogs is not a list of animals" - I put it <i>in code terms</i>, in a code font. I really don't think there's any ambiguity here. Using subclass would be incorrect anyway - it's about assignment compatibility, not subclassing.</span> <span> - </span> <span class="display-name">Jon Skeet</span> <span> </span> <span class="date">28 Jan 2013 at 19:58</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>I think the problem with this line of argument is that the contract of <code>List&lt;Animal&gt;</code> actually <i>doesn't</i> specify that you can add any <code>Animal</code> to it. List implementations are allowed to be completely immutable, or to be fixed-length, or to have arbitrary restrictions on what elements you can add (e.g. based on their runtime type). Note that a <code>Dog[]</code> <i>is</i> an <code>Animal[]</code>, with forbidden assignments being blocked at runtime. (With <code>List&lt;Dog&gt;</code> that can't be done, in general, due to erasure.) If we want to view this as something other than a failure of language design, I think we need <i>[continued]</i></span> <span> - </span> <span class="display-name">ruakh</span> <span> </span> <span class="date">3 Jul 2013 at 17:03</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span><i>[continued]</i> to use examples like <code>Comparable&lt;Dog&gt;</code>, where it makes sense to say that <code>Comparable&lt;Dog&gt;</code> ("can be compared to any <code>Dog</code>") does not imply <code>Comparable&lt;Animal&gt;</code> ("can be compared to any <code>Animal</code>").</span> <span> - </span> <span class="display-name">ruakh</span> <span> </span> <span class="date">3 Jul 2013 at 17:04</span></td>
       </tr>
       <tr>
        <td>19</td>
        <td><span>@ruakh: The problem is that you're then punting to execution time something which can be blocked at compile-time. And I'd argue that array covariance was a design mistake to start with.</span> <span> - </span> <span class="display-name">Jon Skeet</span> <span> </span> <span class="date">3 Jul 2013 at 17:22</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>Java allows doing that example when using arrays. At compile time you wouldn't have any problems with that. But at runtime a cast exception would be thrown. Please explain me why this is possible with arrays, but not with generic lists. In my opinion this behavior is not consistent. I could imagine that the java developers decided to not keep this behavior anymore as they introduced generics.</span> <span> - </span> <span class="display-name">Dennis Kassel</span> <span> </span> <span class="date">1 May 2014 at 14:00</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@GinoBambino: Firstly, I view the covariance of arrays as a mistake to start with. (And a mistake that .NET copied, to my annoyance.) Secondly, with the way generics are implemented in Java, it <i>couldn't</i> be caught at execution time - a <code>String[]</code> knows it's really a <code>String[]</code> rather than an <code>Object[]</code>, but an <code>ArrayList&lt;String&gt;</code> doesn't know that. As for why the array behaviour wasn't changed when generics were introduced - that would have been a <i>massive</i> breaking change. That was never going to happen.</span> <span> - </span> <span class="display-name">Jon Skeet</span> <span> </span> <span class="date">1 May 2014 at 14:02</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I agree with you that the covariance of arrays can quickly introduce bugs in the code, therefore it should be considered as a mistake. In contrast to Java .NET can differ between List&lt;Object&gt; and List&lt;String), but the above example is also not allowed. I suppose that there are not only technical reasons that argue against this. In Java it may be (because of type erasure)^^</span> <span> - </span> <span class="display-name">Dennis Kassel</span> <span> </span> <span class="date">1 May 2014 at 17:15</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Ingo "Who is mandating that making a new list from a cat and a list of dogs actually changes the list of dogs?" This is inherent in the nature of references. In the code snippet above, the variables named <code>dogs</code> and <code>animals</code> refer to <i>the same object</i>.</span> <span> - </span> <span class="display-name">augurar</span> <span> </span> <span class="date">17 Nov 2014 at 07:49</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Is not it the same as: Cat cat = new Cat(); Object o = cat; Dog dog = (Dog) o; ? This will compile</span> <span> - </span> <span class="display-name">atomAltera</span> <span> </span> <span class="date">19 Feb 2015 at 12:29</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@atomAltera: No, because the aim of generics is to implicitly add casts that are expected to work.</span> <span> - </span> <span class="display-name">Jon Skeet</span> <span> </span> <span class="date">19 Feb 2015 at 12:41</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Just out of curiosity, is there a reference to the Monty Python's sketch "Confuse a cat"? Or is it just a pure coincidence?</span> <span> - </span> <span class="display-name">Luca Cremonesi</span> <span> </span> <span class="date">5 Mar 2015 at 15:45</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@LucaCremonesi: That's just coincidence. Monty Python references elsewhere may well be intentional.</span> <span> - </span> <span class="display-name">Jon Skeet</span> <span> </span> <span class="date">5 Mar 2015 at 16:02</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@Ingo: the reason why the intuition fails here is that it works with immutable lists, rather than shared references to mutable lists. Java offers such a view if you ensure immutability, i.e. you can write <code>List&lt;Animal&gt; animals = Collections.unmodifiableList(dogs);</code>. Since the <code>animals</code> view doesn't allow mutations, it is safe.</span> <span> - </span> <span class="display-name">Holger</span> <span> </span> <span class="date">8 Jan 2016 at 10:29</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The whole argument here can be resolved by stating that <i>supertyping generics parameter is safe when the generic class is immutable</i>. @JonSkeet and @Holger clearly state it and nobody argued against it. I myself do see some interesting implications when we apply this to <code>java.lang.Class&lt;T&gt;</code>.</span> <span> - </span> <span class="display-name">Vlastimil Ovčáčík</span> <span> </span> <span class="date">8 Feb 2016 at 13:31</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Hi Jon, nice argument and vote up, but it seems array works and doesn't array has the same issue of List? Why array works, but not List? See my new post and code here =&gt; <a href="http://stackoverflow.com/questions/42897325/different-behavior-of-array-v-s-listt-in-java-for-sub-class" title="different behavior of array v s listt in java for sub class">stackoverflow.com/questions/42897325/…</a></span> <span> - </span> <span class="display-name">Lin Ma</span> <span> </span> <span class="date">20 Mar 2017 at 06:46</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@LinMa: Arrays are designed fundamentally differently, and show problems at execution time instead of compile time.</span> <span> - </span> <span class="display-name">Jon Skeet</span> <span> </span> <span class="date">20 Mar 2017 at 06:53</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>When you expect a list of animals, you do not care if it is a dog, a cat, or a crocodile.</span> <span> - </span> <span class="display-name">Yar</span> <span> </span> <span class="date">17 Oct 2017 at 16:41</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Yar: You do if you're trying to <i>add</i> to that list of animals. If you're just <i>consuming</i>, that's a different matter. And that's why an <code>IEnumerable&lt;Dog&gt;</code> is an <code>IEnumerable&lt;Animal&gt;</code>, but a <code>List&lt;Dog&gt;</code> isn't a <code>List&lt;Animal&gt;</code>.</span> <span> - </span> <span class="display-name">Jon Skeet</span> <span> </span> <span class="date">17 Oct 2017 at 17:01</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Jon Skeet If I want to add a dog, a cat, a bird to a list of animals - that should be OK, because i always consume an animal, not a dog. If I cast an animal to a dog - that is my problem and responsibility to make sure it is a dog. So - still we have a misunderstanding. Maybe Java is wrong? maybe lists should be more flexible? If a developer wants to LOSE all the benefits of the list of dogs, and treat them as animals - that should be OK. List should "morph" somehow on the fly. Java should adapt to human intuition, not vice versa - in my humble opinion.</span> <span> - </span> <span class="display-name">Yar</span> <span> </span> <span class="date">17 Oct 2017 at 17:42</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Yar: Ignore my <code>IEnumerable&lt;T&gt;</code> part from the previous comment - I'd forgotten this was about Java, not C#. (They have differences, but both are similar.) But no, I don't think Java is wrong - because different pieces of code can be regarding the same object as different types. Suppose you <i>could</i> treat <code>List&lt;Dog&gt;</code> as a <code>List&lt;Animal&gt;</code>. Then you could have: <code>List&lt;Dog&gt; dogs = new ArrayList&lt;Dog&gt;(); List&lt;Animal&gt; animals = dogs; animals.add(new Cat()); Dog dog = dogs.get(0);</code>. What would you want that to do? I want it to fail as early as possible, at compile-time - which is what it does right now.</span> <span> - </span> <span class="display-name">Jon Skeet</span> <span> </span> <span class="date">17 Oct 2017 at 17:45</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@Yar: I don't want the list to "morph" a <code>Cat</code> into a <code>Dog</code>. I want to have - and <i>do</i> have - ways of saying, "Hey, I'm only consuming the list, and everything should be an animal" - so you use <code>List&lt;? extends Animal&gt;</code>, and you don't get to add to the list. That seems fine to me. In general, trying to make programming languages match "human intuition" sounds great, until you realise it becomes ambiguous, and everyone has different intuition.</span> <span> - </span> <span class="display-name">Jon Skeet</span> <span> </span> <span class="date">17 Oct 2017 at 17:47</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Jon Skeet OK, thanks, now you have convinced me. With this: List&lt;Animal&gt; animals = dogs; animals.add(new Cat()); Dog dog = dogs.get(0);</span> <span> - </span> <span class="display-name">Yar</span> <span> </span> <span class="date">19 Oct 2017 at 07:19</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>how about <code>List&lt;? extends Animal&gt;</code> ?</span> <span> - </span> <span class="display-name">Saqib Javed</span> <span> </span> <span class="date">30 Oct 2017 at 08:24</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@SaqibJaved: Yes, at that point you can <i>retrieve</i> <code>Animal</code> values, but not add anything - as per the last paragraph of my answer.</span> <span> - </span> <span class="display-name">Jon Skeet</span> <span> </span> <span class="date">30 Oct 2017 at 08:25</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>As a side note to the previous comment, PECS is involved here if you're writing method signatures. Producer = <code>extends</code>, Consumer = <code>super</code>. That is, if a collection is producing elements for you (i.e. you're reading from it), you use <code>extends</code>. However, if it's consuming elements (i.e. you're adding to it), you use <code>super</code>.</span> <span> - </span> <span class="display-name">Powerlord</span> <span> </span> <span class="date">17 Feb 2018 at 22:13</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>111</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Michael Ekstrand</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Apr 2010 at 14:44</span>
     </div>
    </div>
    <div>
     <p>What you are looking for is called <em><a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)" rel="noreferrer">covariant type</a> parameters</em>. This means that if one type of object can be substituted for another in a method (for instance, <code>Animal</code> can be replaced with <code>Dog</code>), the same applies to expressions using those objects (so <code>List&lt;Animal&gt;</code> could be replaced with <code>List&lt;Dog&gt;</code>). The problem is that covariance is not safe for mutable lists in general. Suppose you have a <code>List&lt;Dog&gt;</code>, and it is being used as a <code>List&lt;Animal&gt;</code>. What happens when you try to add a Cat to this <code>List&lt;Animal&gt;</code> which is really a <code>List&lt;Dog&gt;</code>? Automatically allowing type parameters to be covariant breaks the type system.</p>
     <p>It would be useful to add syntax to allow type parameters to be specified as covariant, which avoids the <code>? extends Foo</code> in method declarations, but that does add additional complexity.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>51</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Michael Aaron Safyan</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Apr 2010 at 14:46</span>
     </div>
    </div>
    <div>
     <p>The reason a <code>List&lt;Dog&gt;</code> is not a <code>List&lt;Animal&gt;</code>, is that, for example, you can insert a <code>Cat</code> into a <code>List&lt;Animal&gt;</code>, but not into a <code>List&lt;Dog&gt;</code>... you can use wildcards to make generics more extensible where possible; for example, reading from a <code>List&lt;Dog&gt;</code> is the similar to reading from a <code>List&lt;Animal&gt;</code> -- but not writing.</p>
     <p>The <a href="http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html" rel="noreferrer">Generics in the Java Language</a> and the <a href="http://java.sun.com/docs/books/tutorial/java/generics/index.html" rel="noreferrer">Section on Generics from the Java Tutorials</a> have a very good, in-depth explanation as to why some things are or are not polymorphic or permitted with generics.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>49</span>
     </div>
     <div>
      <span>Answerer: </span> <span>ein supports Moderator Strike</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Mar 2013 at 07:14</span>
     </div>
    </div>
    <div>
     <p>A point I think should be added to what <a href="https://stackoverflow.com/a/2745301/1593077">other</a> <a href="https://stackoverflow.com/a/2745319/1593077">answers</a> mention is that while</p>
     <blockquote>
      <p><code>List&lt;Dog&gt;</code> isn't-a <code>List&lt;Animal&gt;</code> <strong>in Java</strong></p>
     </blockquote>
     <p>it is also true that</p>
     <blockquote>
      <p>A list of dogs is-a list of animals <strong>in English</strong> (under a reasonable interpretation)</p>
     </blockquote>
     <p>The way the OP's intuition works - which is completely valid of course - is the latter sentence. However, if we apply this intuition we get a language that is not Java-esque in its type system: Suppose our language does allow adding a cat to our list of dogs. What would that mean? It would mean that the list ceases to be a list of dogs, and remains merely a list of animals. And a list of mammals, and a list of quadrapeds.</p>
     <p>To put it another way: A <code>List&lt;Dog&gt;</code> in Java does not mean "a list of dogs" in English, it means "a list of dogs and nothing other than dogs".</p>
     <p>More generally, <strong>OP's intuition lends itself towards a language in which operations on objects can change their type</strong>, or rather, an object's type(s) is a (dynamic) function of its value.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>5</td>
        <td><span>Yes, human language is more fuzzy. But still, once you add a different animal to the list of dogs, it is still a list of animals, but no longer a list of dogs. The difference being, a human, with the fuzzy logic, usually has no problem realizing that.</span> <span> - </span> <span class="display-name">Vlasec</span> <span> </span> <span class="date">13 Nov 2017 at 12:14</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>As someone who finds the constant comparisons to arrays even more confusing, this answer nailed it for me. My problem was the language intuition.</span> <span> - </span> <span class="display-name">FLonLon</span> <span> </span> <span class="date">24 Feb 2019 at 19:49</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>I think the confusion stems from the question of whether the term "list of woozle" refers to a <i>container</i> that may be used to store woozles, a container that holds containers that each hold a woozle, or the contents of a container of woozles, the contents of a container of woozle-containers, or the aggregated contents of the woozle containers held in a collection of them. The English phrase "list of woozles" would most often refer to the last of those, but related constructs in programming languages would often refer to one of the others.</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">21 Oct 2020 at 17:34</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>38</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Yishai</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Apr 2010 at 14:50</span>
     </div>
    </div>
    <div>
     <p>I would say the whole point of Generics is that it doesn't allow that. Consider the situation with arrays, which do allow that type of covariance:</p>
     <pre><code>  Object[] objects = new String[10];
  objects[0] = Boolean.FALSE;
</code></pre>
     <p>That code compiles fine, but throws a runtime error (<code>java.lang.ArrayStoreException: java.lang.Boolean</code> in the second line). It is not typesafe. The point of Generics is to add the compile time type safety, otherwise you could just stick with a plain class without generics.</p>
     <p>Now there are times where you need to be more flexible and that is what the <code>? super Class</code> and <code>? extends Class</code> are for. The former is when you need to insert into a type <code>Collection</code> (for example), and the latter is for when you need to read from it, in a type safe manner. But the only way to do both at the same time is to have a specific type.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>13</td>
        <td><span>Arguably, array covariance is a language design bug. Note that due to type erasure, the same behaviour is technically impossible for generic collection.</span> <span> - </span> <span class="display-name">Michael Borgwardt</span> <span> </span> <span class="date">30 Apr 2010 at 14:55</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>"<i>I would say the whole point of Generics is that it doesn't allow that.</i>". You can never be sure: <a href="https://infoscience.epfl.ch/record/227175" rel="nofollow noreferrer">Java and Scala's Type Systems are Unsound: The Existential Crisis of Null Pointers (presented at OOPSLA 2016)</a> (since corrected it seems)</span> <span> - </span> <span class="display-name">David Tonhofer</span> <span> </span> <span class="date">15 Aug 2017 at 17:52</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Indeed. <i>Reified</i> generics can fundamentally protect against that, but Java's non-type-erased generics cannot. <code>List&lt;Dog&gt;</code> and <code>List&lt;Animal&gt;</code> are both just poor disguises for <code>List</code>, which has zero safety built into it; if you can get around the compile checks (very easy) or create a setup that compile checks cannot be applied to (also easy), you can blow things up.</span> <span> - </span> <span class="display-name">Matthew Read</span> <span> </span> <span class="date">13 May 2022 at 20:21</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>23</span>
     </div>
     <div>
      <span>Answerer: </span> <span>outdev</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Sep 2017 at 19:55</span>
     </div>
    </div>
    <div>
     <p>To understand the problem it's useful to make comparison to arrays.</p>
     <p><code>List&lt;Dog&gt;</code> is <strong>not</strong> subclass of <code>List&lt;Animal&gt;</code>.<br><strong>But</strong> <code>Dog[]</code> <strong>is</strong> subclass of <code>Animal[]</code>.</p>
     <p><strong>Arrays are <a href="http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html" rel="noreferrer">reifiable</a> and covariant</strong>. <br><a href="http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html" rel="noreferrer">Reifiable</a> means their type information is fully available at runtime. <br>
      Therefore arrays provide runtime type safety but not compile-time type safety.</p>
     <pre><code>    // All compiles but throws ArrayStoreException at runtime at last line
    Dog[] dogs = new Dog[10];
    Animal[] animals = dogs; // compiles
    animals[0] = new Cat(); // throws ArrayStoreException at runtime
</code></pre>
     <p>It's vice versa for generics:<br><strong>Generics are <a href="https://docs.oracle.com/javase/tutorial/java/generics/genTypes.html" rel="noreferrer">erased</a> and invariant</strong>. <br>
      Therefore generics can't provide runtime type safety, but they provide compile-time type safety. <br>
      In the code below if generics were covariant it will be possible to make <a href="https://en.wikipedia.org/wiki/Heap_pollution" rel="noreferrer">heap pollution</a> at line 3.</p>
     <pre><code>    List&lt;Dog&gt; dogs = new ArrayList&lt;&gt;();
    List&lt;Animal&gt; animals = dogs; // compile-time error, otherwise heap pollution
    animals.add(new Cat());
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>It might be argued that, precisely because of that, <a href="https://stackoverflow.com/questions/12369957/dealing-with-an-arraystoreexception/12370259#12370259">Arrays in Java are broken</a>,</span> <span> - </span> <span class="display-name">leonbloy</span> <span> </span> <span class="date">15 Dec 2017 at 14:41</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Arrays being covariant is a compiler "feature".</span> <span> - </span> <span class="display-name">Cristik</span> <span> </span> <span class="date">2 Mar 2018 at 07:40</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>glglgl</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Feb 2015 at 21:26</span>
     </div>
    </div>
    <div>
     <p>The answers given here didn't fully convince me. So instead, I make another example.</p>
     <pre><code>public void passOn(Consumer&lt;Animal&gt; consumer, Supplier&lt;Animal&gt; supplier) {
    consumer.accept(supplier.get());
}
</code></pre>
     <p>sounds fine, doesn't it? But you can only pass <code>Consumer</code>s and <code>Supplier</code>s for <code>Animal</code>s. If you have a <code>Mammal</code> consumer, but a <code>Duck</code> supplier, they should not fit although both are animals. In order to disallow this, additional restrictions have been added.</p>
     <p>Instead of the above, we have to define relationships between the types we use.</p>
     <p>E. g.,</p>
     <pre><code>public &lt;A extends Animal&gt; void passOn(Consumer&lt;A&gt; consumer, Supplier&lt;? extends A&gt; supplier) {
    consumer.accept(supplier.get());
}
</code></pre>
     <p>makes sure that we can only use a supplier which provides us the right type of object for the consumer.</p>
     <p>OTOH, we could as well do</p>
     <pre><code>public &lt;A extends Animal&gt; void passOn(Consumer&lt;? super A&gt; consumer, Supplier&lt;A&gt; supplier) {
    consumer.accept(supplier.get());
}
</code></pre>
     <p>where we go the other way: we define the type of the <code>Supplier</code> and restrict that it can be put into the <code>Consumer</code>.</p>
     <p>We even can do</p>
     <pre><code>public &lt;A extends Animal&gt; void passOn(Consumer&lt;? super A&gt; consumer, Supplier&lt;? extends A&gt; supplier) {
    consumer.accept(supplier.get());
}
</code></pre>
     <p>where, having the intuitive relations <code>Life</code> -&gt; <code>Animal</code> -&gt; <code>Mammal</code> -&gt; <code>Dog</code>, <code>Cat</code> etc., we could even put a <code>Mammal</code> into a <code>Life</code> consumer, but not a <code>String</code> into a <code>Life</code> consumer.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>Among the 4 versions, #2 is probably incorrect. e.g. we cannot call it with <code>(Consumer&lt;Runnable&gt;, Supplier&lt;Dog&gt;)</code> while <code>Dog</code> is subtype of <code>Animal &amp; Runnable</code></span> <span> - </span> <span class="display-name">ZhongYu</span> <span> </span> <span class="date">27 Jul 2015 at 20:10</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Hitesh</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Dec 2012 at 10:43</span>
     </div>
    </div>
    <div>
     <p>The basis logic for such behavior is that <code>Generics</code> follow a mechanism of type erasure. So at run time you have no way if identifying the type of <code>collection</code> unlike <code>arrays</code> where there is no such erasure process. So coming back to your question...</p>
     <p>So suppose there is a method as given below:</p>
     <pre><code>add(List&lt;Animal&gt;){
    //You can add List&lt;Dog or List&lt;Cat&gt; and this will compile as per rules of polymorphism
}
</code></pre>
     <p>Now if java allows caller to add List of type Animal to this method then you might add wrong thing into collection and at run time too it will run due to type erasure. While in case of arrays you will get a run time exception for such scenarios...</p>
     <p>Thus in essence this behavior is implemented so that one cannot add wrong thing into collection. Now I believe type erasure exists so as to give compatibility with legacy java without generics....</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mike Nakis</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 May 2022 at 06:10</span>
     </div>
    </div>
    <div>
     <p>Others have done a decent job of explaining why you cannot just cast a list of descendant to list of superclass.</p>
     <p>However, many people visit this question looking for a solution.</p>
     <p>So, the solution to this problem since Java version 10 is as follows:</p>
     <p>(Note: S = superclass)</p>
     <pre><code>List&lt;S&gt; supers = List.copyOf( descendants );
</code></pre>
     <p>This function will do a cast if it is perfectly safe to do so, or a copy if a cast would not be safe.</p>
     <p>For an in-depth explanation (which takes into consideration the potential pitfalls mentioned by other answers here) see related question and my 2022 answer to it: <a href="https://stackoverflow.com/a/72195980/773113">https://stackoverflow.com/a/72195980/773113</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>I like this because its better than superclassThingList = new Array(subclassOfThingList);</span> <span> - </span> <span class="display-name">ggb667</span> <span> </span> <span class="date">3 Nov 2022 at 02:47</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Görkem Mülayim</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 May 2018 at 14:00</span>
     </div>
    </div>
    <div>
     <p>Subtyping is <a href="https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english">invariant</a> for parameterized types. Even tough the class <code>Dog</code> is a subtype of <code>Animal</code>, the parameterized type <code>List&lt;Dog&gt;</code> is not a subtype of <code>List&lt;Animal&gt;</code>. In contrast, <a href="https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english">covariant</a> subtyping is used by arrays, so the array type <code>Dog[]</code> is a subtype of <code>Animal[]</code>.</p>
     <p>Invariant subtyping ensures that the type constraints enforced by Java are not violated. Consider the following code given by @Jon Skeet:</p>
     <pre><code>List&lt;Dog&gt; dogs = new ArrayList&lt;Dog&gt;(1);
List&lt;Animal&gt; animals = dogs;
animals.add(new Cat()); // compile-time error
Dog dog = dogs.get(0);
</code></pre>
     <p>As stated by @Jon Skeet, this code is illegal, because otherwise it would violate the type constraints by returning a cat when a dog expected.</p>
     <p>It is instructive to compare the above to analogous code for arrays.</p>
     <pre><code>Dog[] dogs = new Dog[1];
Object[] animals = dogs;
animals[0] = new Cat(); // run-time error
Dog dog = dogs[0];
</code></pre>
     <p>The code is legal. However, throws an <a href="https://stackoverflow.com/questions/12369957/dealing-with-an-arraystoreexception">array store exception</a>. An array carries its type at run-time this way JVM can enforce type safety of covariant subtyping.</p>
     <p>To understand this further let's look at the bytecode generated by <code>javap</code> of the class below:</p>
     <pre><code>import java.util.ArrayList;
import java.util.List;

public class Demonstration {
    public void normal() {
        List normal = new ArrayList(1);
        normal.add("lorem ipsum");
    }

    public void parameterized() {
        List&lt;String&gt; parameterized = new ArrayList&lt;&gt;(1);
        parameterized.add("lorem ipsum");
    }
}
</code></pre>
     <p>Using the command <code>javap -c Demonstration</code>, this shows the following Java bytecode:</p>
     <pre><code>Compiled from "Demonstration.java"
public class Demonstration {
  public Demonstration();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V
       4: return

  public void normal();
    Code:
       0: new           #2                  // class java/util/ArrayList
       3: dup
       4: iconst_1
       5: invokespecial #3                  // Method java/util/ArrayList."&lt;init&gt;":(I)V
       8: astore_1
       9: aload_1
      10: ldc           #4                  // String lorem ipsum
      12: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z
      17: pop
      18: return

  public void parameterized();
    Code:
       0: new           #2                  // class java/util/ArrayList
       3: dup
       4: iconst_1
       5: invokespecial #3                  // Method java/util/ArrayList."&lt;init&gt;":(I)V
       8: astore_1
       9: aload_1
      10: ldc           #4                  // String lorem ipsum
      12: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z
      17: pop
      18: return
}
</code></pre>
     <p>Observe that the translated code of method bodies are identical. Compiler replaced each parameterized type by its <a href="https://stackoverflow.com/questions/313584/what-is-the-concept-of-erasure-in-generics-in-java">erasure</a>. This property is crucial meaning that it did not break backwards compatibility.</p>
     <p>In conclusion, run-time safety is not possible for parameterized types, since compiler replaces each parameterized type by its erasure. This makes parameterized types are nothing more than syntactic sugar.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Renato Probst</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Jan 2016 at 21:11</span>
     </div>
    </div>
    <div>
     <p>If you are sure that the list items are subclasses of that given super type, you can cast the list using this approach:</p>
     <pre><code>(List&lt;Animal&gt;) (List&lt;?&gt;) dogs
</code></pre>
     <p>This is usefull when you want to pass the list inside of a constructor or iterate over it.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>This will create more problems than it actually solves</span> <span> - </span> <span class="display-name">Ferrybig</span> <span> </span> <span class="date">1 Feb 2016 at 15:33</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>If you try to add a Cat to the list, sure it will create problems, but for looping purposes i think its the only non verbose answer.</span> <span> - </span> <span class="display-name">Renato Probst</span> <span> </span> <span class="date">2 Feb 2016 at 12:28</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>dan b</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Dec 2014 at 11:14</span>
     </div>
    </div>
    <div>
     <p>The <a href="https://stackoverflow.com/a/2745301/4350148">answer</a> as well as other answers are correct. I am going to add to those answers with a solution that I think will be helpful. I think this comes up often in programming. One thing to note is that for Collections (Lists, Sets, etc.) the main issue is adding to the Collection. That is where things break down. Even removing is OK.</p>
     <p>In most cases, we can use <code>Collection&lt;? extends T&gt;</code> rather then <code>Collection&lt;T&gt;</code> and that should be the first choice. However, I am finding cases where it is not easy to do that. It is up for debate as to whether that is always the best thing to do. I am presenting here a class DownCastCollection that can take convert a <code>Collection&lt;? extends T&gt;</code> to a <code>Collection&lt;T&gt;</code> (we can define similar classes for List, Set, NavigableSet,..) to be used when using the standard approach is very inconvenient. Below is an example of how to use it (we could also use <code>Collection&lt;? extends Object&gt;</code> in this case, but I am keeping it simple to illustrate using DownCastCollection.</p>
     <pre><code>/**Could use Collection&lt;? extends Object&gt; and that is the better choice. 
* But I am doing this to illustrate how to use DownCastCollection. **/

public static void print(Collection&lt;Object&gt; col){  
    for(Object obj : col){
    System.out.println(obj);
    }
}
public static void main(String[] args){
  ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
  list.addAll(Arrays.asList("a","b","c"));
  print(new DownCastCollection&lt;Object&gt;(list));
}
</code></pre>
     <p>Now the class:</p>
     <pre><code>import java.util.AbstractCollection;
import java.util.Collection;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class DownCastCollection&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; {
private Collection&lt;? extends E&gt; delegate;

public DownCastCollection(Collection&lt;? extends E&gt; delegate) {
    super();
    this.delegate = delegate;
}

@Override
public int size() {
    return delegate ==null ? 0 : delegate.size();
}

@Override
public boolean isEmpty() {
    return delegate==null || delegate.isEmpty();
}

@Override
public boolean contains(Object o) {
    if(isEmpty()) return false;
    return delegate.contains(o);
}
private class MyIterator implements Iterator&lt;E&gt;{
    Iterator&lt;? extends E&gt; delegateIterator;

    protected MyIterator() {
        super();
        this.delegateIterator = delegate == null ? null :delegate.iterator();
    }

    @Override
    public boolean hasNext() {
        return delegateIterator != null &amp;&amp; delegateIterator.hasNext();
    }

    @Override
    public  E next() {
        if(!hasNext()) throw new NoSuchElementException("The iterator is empty");
        return delegateIterator.next();
    }

    @Override
    public void remove() {
        delegateIterator.remove();

    }

}
@Override
public Iterator&lt;E&gt; iterator() {
    return new MyIterator();
}



@Override
public boolean add(E e) {
    throw new UnsupportedOperationException();
}

@Override
public boolean remove(Object o) {
    if(delegate == null) return false;
    return delegate.remove(o);
}

@Override
public boolean containsAll(Collection&lt;?&gt; c) {
    if(delegate==null) return false;
    return delegate.containsAll(c);
}

@Override
public boolean addAll(Collection&lt;? extends E&gt; c) {
    throw new UnsupportedOperationException();
}

@Override
public boolean removeAll(Collection&lt;?&gt; c) {
    if(delegate == null) return false;
    return delegate.removeAll(c);
}

@Override
public boolean retainAll(Collection&lt;?&gt; c) {
    if(delegate == null) return false;
    return delegate.retainAll(c);
}

@Override
public void clear() {
    if(delegate == null) return;
        delegate.clear();

}
</code></pre>
     <p>}</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>This is a good idea, so much so that it exists in Java SE already. ; ) <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableCollection-java.util.Collection-" rel="nofollow noreferrer"><code>Collections.unmodifiableCollection</code></a></span> <span> - </span> <span class="display-name">Radiodef</span> <span> </span> <span class="date">8 May 2015 at 21:30</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Right but the collection I define can be modified.</span> <span> - </span> <span class="display-name">dan b</span> <span> </span> <span class="date">9 May 2015 at 11:40</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Yes, it can be modified. <code>Collection&lt;? extends E&gt;</code> already handles that behavior correctly though, unless you use it in a way that is not type-safe (e.g. casting it to something else). The only advantage I see there is, when you call the <code>add</code> operation, it throws an exception even if you casted it.</span> <span> - </span> <span class="display-name">Vlasec</span> <span> </span> <span class="date">13 Nov 2017 at 12:47</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Yttrill</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Nov 2020 at 04:02</span>
     </div>
    </div>
    <div>
     <p>The issue has been correctly identified as related to variance but the details are not correct. A purely functional list is a covariant data functor, which means if a type Sub is a subtype of Super, then a list of Sub is definitely a subtype of a list of Super.</p>
     <p>However mutability of a list is not the basic problem here. The problem is mutability in general. The problem is well known, and is called the Covariance Problem, it was first identified I think by Castagna, and it completely and utterly destroys object orientation as a general paradigm. It is based on previously established variance rules established by Cardelli and Reynolds.</p>
     <p>Somewhat oversimplifying, lets consider assignment of an object B of type T to an object A of type T as a mutation. This is without loss of generality: a mutation of A can be written A = f (A) where f: T -&gt; T. The problem, of course, is that whilst functions are covariant in their codomain, they're contravariant in their domain, but with assignments the domain and codomain are the same, so assignment is invariant!</p>
     <p>It follows, generalising, that subtypes cannot be mutated. But with object orientation mutation is fundamental, hence object orientation is intrinsically flawed.</p>
     <p>Here's a simple example: in a purely functional setting a symmetric matrix is clearly a matrix, it is a subtype, no problem. Now lets add to matrix the ability to set a single element at coordinates (x,y) with the rule no other element changes. Now symmetric matrix is no longer a subtype, if you change (x,y) you have also changed (y,x). The functional operation is delta: Sym -&gt; Mat, if you change one element of a symmetric matrix you get a general non-symmetric matrix back. Therefore if you included a "change one element" method in Mat, Sym is not a subtype. In fact .. there are almost certainly NO proper subtypes.</p>
     <p>To put all this in easier terms: if you have a general data type with a wide range of mutators which leverage its generality you can be certain any proper subtype cannot possibly support all those mutations: if it could, it would be just as general as the supertype, contrary to the specification of "proper" subtype.</p>
     <p>The fact Java prevents subtyping mutable lists fails to address the real issue: why are you using object oriented rubbish like Java when it was discredited several decades ago??</p>
     <p>In any case there's a reasonable discussion here:</p>
     <p><a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)" rel="nofollow noreferrer">https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span> <span class="arrow"> <a href="#answer_15">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>aurelius</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Feb 2016 at 13:00</span>
     </div>
    </div>
    <div>
     <p>Lets take the example from JavaSE <a href="https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html" rel="nofollow">tutorial</a></p>
     <pre><code>public abstract class Shape {
    public abstract void draw(Canvas c);
}

public class Circle extends Shape {
    private int x, y, radius;
    public void draw(Canvas c) {
        ...
    }
}

public class Rectangle extends Shape {
    private int x, y, width, height;
    public void draw(Canvas c) {
        ...
    }
}
</code></pre>
     <p>So why a list of dogs (circles) should not be considered implicitly a list of animals (shapes) is because of this situation:</p>
     <pre><code>// drawAll method call
drawAll(circleList);


public void drawAll(List&lt;Shape&gt; shapes) {
   shapes.add(new Rectangle());    
}
</code></pre>
     <p>So Java "architects" had 2 options which address this problem:</p>
     <ol>
      <li>
       <p>do not consider that a subtype is implicitly it's supertype, and give a compile error, like it happens now</p></li>
      <li>
       <p>consider the subtype to be it's supertype and restrict at compile the "add" method (so in the drawAll method, if a list of circles, subtype of shape, would be passed, the compiler should detected that and restrict you with compile error into doing that).</p></li>
     </ol>
     <p>For obvious reasons, that chose the first way.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_15"><span>Answer 15</span> <span class="arrow"> <a href="#answer_14">↑</a> </span> <span class="arrow"> <a href="#answer_16">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Cristik</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Mar 2018 at 07:48</span>
     </div>
    </div>
    <div>
     <p>We should also take in consideration how the compiler threats the generic classes: in "instantiates" a different type whenever we fill the generic arguments.</p>
     <p>Thus we have <code>ListOfAnimal</code>, <code>ListOfDog</code>, <code>ListOfCat</code>, etc, which are distinct classes that end up being "created" by the compiler when we specify the generic arguments. And this is a flat hierarchy (actually regarding to <code>List</code> is not a hierarchy at all).</p>
     <p>Another argument why covariance doesn't make sense in case of generic classes is the fact that at base all classes are the same - are <code>List</code> instances. Specialising a <code>List</code> by filling the generic argument doesn't extend the class, it just makes it work for that particular generic argument.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_16"><span>Answer 16</span> <span class="arrow"> <a href="#answer_15">↑</a> </span> <span class="arrow"> <a href="#answer_17">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>gerardw</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Mar 2018 at 18:56</span>
     </div>
    </div>
    <div>
     <p>The problem has been well-identified. But there's a solution; make <em>doSomething</em> generic:</p>
     <pre><code>&lt;T extends Animal&gt; void doSomething&lt;List&lt;T&gt; animals) {
}
</code></pre>
     <p>now you can call doSomething with either List&lt;Dog&gt; or List&lt;Cat&gt; or List&lt;Animal&gt;.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Yea, except do something might depend on Dog specific behavior.</span> <span> - </span> <span class="display-name">ggb667</span> <span> </span> <span class="date">3 Nov 2022 at 02:44</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_17"><span>Answer 17</span> <span class="arrow"> <a href="#answer_16">↑</a> </span> <span class="arrow"> <a href="#answer_18">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>ejaenv</span>
     </div>
     <div>
      <span> Answered: </span> <span>20 Jul 2018 at 14:12</span>
     </div>
    </div>
    <div>
     <p>another solution is to build a new list</p>
     <pre><code>List&lt;Dog&gt; dogs = new ArrayList&lt;Dog&gt;(); 
List&lt;Animal&gt; animals = new ArrayList&lt;Animal&gt;(dogs);
animals.add(new Cat());
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_18"><span>Answer 18</span> <span class="arrow"> <a href="#answer_17">↑</a> </span> <span class="arrow"> <a href="#answer_19">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Luke Hutchison</span>
     </div>
     <div>
      <span> Answered: </span> <span>20 Nov 2019 at 04:21</span>
     </div>
    </div>
    <div>
     <p>Further to the answer by Jon Skeet, which uses this example code:</p>
     <pre><code>// Illegal code - because otherwise life would be Bad
List&lt;Dog&gt; dogs = new ArrayList&lt;Dog&gt;(); // ArrayList implements List
List&lt;Animal&gt; animals = dogs; // Awooga awooga
animals.add(new Cat());
Dog dog = dogs.get(0); // This should be safe, right?
</code></pre>
     <p>At the deepest level, the problem here is that <code>dogs</code> and <code>animals</code> share a reference. That means that one way to make this work would be to copy the entire list, which would break reference equality:</p>
     <pre><code>// This code is fine
List&lt;Dog&gt; dogs = new ArrayList&lt;Dog&gt;();
dogs.add(new Dog());
List&lt;Animal&gt; animals = new ArrayList&lt;&gt;(dogs); // Copy list
animals.add(new Cat());
Dog dog = dogs.get(0);   // This is fine now, because it does not return the Cat
</code></pre>
     <p>After calling <code>List&lt;Animal&gt; animals = new ArrayList&lt;&gt;(dogs);</code>, you cannot subsequently directly assign <code>animals</code> to either <code>dogs</code> or <code>cats</code>:</p>
     <pre><code>// These are both illegal
dogs = animals;
cats = animals;
</code></pre>
     <p>therefore you can't put the wrong subtype of <code>Animal</code> into the list, because there is no wrong subtype -- any object of subtype <code>? extends Animal</code> can be added to <code>animals</code>.</p>
     <p>Obviously, this changes the semantics, since the lists <code>animals</code> and <code>dogs</code> are no longer shared, so adding to one list does not add to the other (which is exactly what you want, to avoid the problem that a <code>Cat</code> could be added to a list that is only supposed to contain <code>Dog</code> objects). Also, copying the entire list can be inefficient. However, this does solve the type equivalence problem, by breaking reference equality.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_19"><span>Answer 19</span> <span class="arrow"> <a href="#answer_18">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Shubham Arya</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Dec 2020 at 15:33</span>
     </div>
    </div>
    <div>
     <p>I see that the question has already been answered a number of times, just want to put in my inputs on the same question.</p>
     <p>Lets us go ahead and create a simplified Animal class hierarchy.</p>
     <pre><code>abstract class Animal {
    void eat() {
        System.out.println("animal eating");
    }
}

class Dog extends Animal {
    void bark() { }
}

class Cat extends Animal {
    void meow() { }
}
</code></pre>
     <p>Now let us have a look at our old friend Arrays, which we know support polymorphism implicitly-</p>
     <pre><code>class TestAnimals {
    public static void main(String[] args) {
        Animal[] animals = {new Dog(), new Cat(), new Dog()};
        Dog[] dogs = {new Dog(), new Dog(), new Dog()};
        takeAnimals(animals);
        takeAnimals(dogs);
    }

    public void takeAnimals(Animal[] animals) {
        for(Animal a : animals) {
            System.out.println(a.eat());
        }
    }   
}
</code></pre>
     <p>The class compiles fine and when we run the above class we get the output</p>
     <pre><code>animal eating
animal eating
animal eating
animal eating
animal eating
animal eating
</code></pre>
     <p>The point to note here is that the takeAnimals() method is defined to take anything which is of type Animal, it can take an array of type Animal and it can take an array of Dog as well because Dog-is-a-Animal. So this is Polymorphism in action.</p>
     <p>Let us now use this same approach with generics,</p>
     <p>Now say we tweak our code a little bit and use ArrayLists instead of Arrays -</p>
     <pre><code>class TestAnimals {
    public static void main(String[] args) {
        ArrayList&lt;Animal&gt; animals = new ArrayList&lt;Animal&gt;();
        animals.add(new Dog());
        animals.add(new Cat());
        animals.add(new Dog());
        takeAnimals(animals);
    }

    public void takeAnimals(ArrayList&lt;Animal&gt; animals) {
        for(Animal a : animals) {
            System.out.println(a.eat());
        }
    }   
}
</code></pre>
     <p>The class above will compile and will produce the output -</p>
     <pre><code>animal eating
animal eating
animal eating
animal eating
animal eating
animal eating
</code></pre>
     <p>So we know this works, now lets tweak this class a little bit to use Animal type polymorphically -</p>
     <pre><code>class TestAnimals {
    public static void main(String[] args) {
        ArrayList&lt;Animal&gt; animals = new ArrayList&lt;Animal&gt;();
        animals.add(new Dog());
        animals.add(new Cat());
        animals.add(new Dog());

        ArrayList&lt;Dog&gt; dogs = new ArrayList&lt;Dog&gt;();
        takeAnimals(animals);
        takeAnimals(dogs);
    }

    public void takeAnimals(ArrayList&lt;Animal&gt; animals) {
        for(Animal a : animals) {
            System.out.println(a.eat());
        }
    }   
}
</code></pre>
     <p>Looks like there should be no problem in compiling the above class as the takeAnimals() method is designed to take any ArrayList of type Animal and Dog-is-a-Animal so it should not be a deal breaker here.</p>
     <p>But, unfortunately the compiler throws an error and doesn't allow us to pass a Dog ArrayList to a variable expecting Animal ArrayList.</p>
     <p>You ask why?</p>
     <p>Because just imagine, if JAVA were to allow the Dog ArrayList - dogs - to be put into the Animal ArrayList - animals - and then inside the takeAnimals() method somebody does something like -</p>
     <pre><code>animals.add(new Cat());
</code></pre>
     <p>thinking that this should be doable because ideally it is an Animal ArrayList and you should be in a position to add any cat to it as Cat-is-also-a-Animal, but in real you passed a Dog type ArrayList to it.</p>
     <p>So, now you must be thinking the the same should have happened with the Arrays as well. You are right in thinking so.</p>
     <p>If somebody tries to do the same thing with Arrays then Arrays are also going to throw an error but Arrays handle this error at runtime whereas ArrayLists handle this error at compile time.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>