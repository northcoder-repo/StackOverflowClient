<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>What is the difference between a 'closure' and a 'lambda'?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>What is the difference between a 'closure' and a 'lambda'?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>971</span>
    </div>
    <div>
     <span>Asker: </span> <span>sker</span>
    </div>
    <div>
     <span>Asked: </span> <span>21 Oct 2008 at 03:12</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/220658">source</a>
    </div>
   </div>
   <div>
    <p>Could someone explain? I understand the basic concepts behind them but I often see them used interchangeably and I get confused.</p>
    <p>And now that we're here, how do they differ from a regular function?</p>
   </div>
   <div class="tags">
    <span class="tag">function</span><span class="tag">lambda</span><span class="tag">functional-programming</span><span class="tag">closures</span><span class="tag">terminology</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>113</td>
       <td><span>Lambdas are a <i>language construct</i> (anonymous functions), closures are an <i>implementation technique</i> to implement first-class functions (whether anonymous or not). Unfortunately, this is often confused by many people.</span> <span> - </span> <span class="display-name">Andreas Rossberg</span> <span> </span> <span class="date">21 Jul 2012 at 16:54</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Related: <a href="http://stackoverflow.com/questions/208835/function-pointers-closures-and-lambda">Function pointers, Closures, and Lambda</a></span> <span> - </span> <span class="display-name">legends2k</span> <span> </span> <span class="date">14 Jul 2014 at 10:08</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>For PHP closures, see <a href="http://php.net/manual/en/class.closure.php" rel="nofollow noreferrer">php.net/manual/en/class.closure.php</a> . It is not what a JavaScript programmer would expect.</span> <span> - </span> <span class="display-name">PaulH</span> <span> </span> <span class="date">2 Nov 2016 at 12:56</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>SasQ's answer is excellent. IMHO this question would be more useful to SO users if it guided viewers to that answer.</span> <span> - </span> <span class="display-name">AmigoNico</span> <span> </span> <span class="date">15 Jul 2019 at 22:08</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>789</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Claudiu</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Oct 2008 at 03:58</span>
     </div>
    </div>
    <div>
     <p>A <b>lambda</b> is just an anonymous function - a function defined with no name. In some languages, such as Scheme, they are equivalent to named functions. In fact, the function definition is re-written as binding a lambda to a variable internally. In other languages, like Python, there are some (rather needless) distinctions between them, but they behave the same way otherwise.</p>
     <p>A <b>closure</b> is any function which <b>closes over</b> the <b>environment</b> in which it was defined. This means that it can access variables not in its parameter list. Examples:</p>
     <pre><code>def func(): return h
def anotherfunc(h):
   return func()
</code></pre>
     <p>This will cause an error, because <code>func</code> does not <b>close over</b> the environment in <code>anotherfunc</code> - <code>h</code> is undefined. <code>func</code> only closes over the global environment. This will work:</p>
     <pre><code>def anotherfunc(h):
    def func(): return h
    return func()
</code></pre>
     <p>Because here, <code>func</code> is defined in <code>anotherfunc</code>, and in python 2.3 and greater (or some number like this) when they <i>almost</i> got closures correct (mutation still doesn't work), this means that it <b>closes over</b> <code>anotherfunc</code>'s environment and can access variables inside of it. In Python 3.1+, mutation works too when using <a href="http://docs.python.org/release/3.1.3/reference/simple_stmts.html#nonlocal" rel="noreferrer">the <code>nonlocal</code> keyword</a>.</p>
     <p>Another important point - <code>func</code> will continue to close over <code>anotherfunc</code>'s environment even when it's no longer being evaluated in <code>anotherfunc</code>. This code will also work:</p>
     <pre><code>def anotherfunc(h):
    def func(): return h
    return func

print anotherfunc(10)()
</code></pre>
     <p>This will print 10.</p>
     <p>This, as you notice, has nothing to do with <b>lambda</b>s - they are two different (although related) concepts.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>Claudiu, to my uncertain knowledge python has never quite got closures correct. Did they fix the mutability problem while I wasn't looking? Quite possible...</span> <span> - </span> <span class="display-name">simon</span> <span> </span> <span class="date">21 Oct 2008 at 05:20</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>simon - you're right, they're still not fully correct. i think python 3.0 will add a hack to work around this. (something like a 'nonlocal' identifier). i'll change my ansewr to reflect that.</span> <span> - </span> <span class="display-name">Claudiu</span> <span> </span> <span class="date">21 Oct 2008 at 05:26</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>"This means that it can access variables not in its parameter list." I hope you're right about this, because this was my main take away from your answer. It's going to be difficult to forget this comment if you're wrong :)</span> <span> - </span> <span class="display-name">Daniel Kaplan</span> <span> </span> <span class="date">16 Aug 2013 at 17:47</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@tieTYT: Hehe, if that's your take-away then good! That is the main point and specialty of a closure.</span> <span> - </span> <span class="display-name">Claudiu</span> <span> </span> <span class="date">1 May 2014 at 04:49</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>I find this statement useful for a little better understanding: 'Python supports a feature called function closures which means that inner functions defined in non-global scope remember what their enclosing namespaces looked like at definition time.' More info at: <a href="http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/" rel="nofollow noreferrer">simeonfranklin.com/blog/2012/jul/1/…</a></span> <span> - </span> <span class="display-name">user3885927</span> <span> </span> <span class="date">9 Sep 2014 at 21:42</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>In Java 8’ lambdas one can also access final values outside the lambda scope which are also not in its parameters list. Still Java 8 authors keep calling them “lambdas” and not “closures”. Why?</span> <span> - </span> <span class="display-name">Alex</span> <span> </span> <span class="date">16 Feb 2015 at 22:29</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>@AlexanderOrlov: They are both lambdas and closures. Java had closures before via anonymous inner classes. Now that functionality has been made syntactically easier via lambda expressions. So probably the most relevant aspect of the new feature is that there are now lambdas. It's not incorrect to call them lambdas, they are indeed lambdas. Why Java 8 authors may choose not to highlight the fact that they are closures is not something I know.</span> <span> - </span> <span class="display-name">Claudiu</span> <span> </span> <span class="date">16 Feb 2015 at 22:51</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@AlexanderOrlov because Java 8 lambdas are not true closures, they are simulations of closures. They are more similar to Python 2.3 closures (no mutability, hence the requirement for the variables referenced to be 'effectively final'), and internally compile to non-closure functions that take all variables referenced in the enclosing scope as hidden parameters.</span> <span> - </span> <span class="display-name">Logan Pickup</span> <span> </span> <span class="date">30 Jun 2016 at 20:51</span></td>
       </tr>
       <tr>
        <td>11</td>
        <td><span>@Claudiu I think the reference to a a particular language implementation (Python) may over-complicate the answer. The question is completely language-agnostic (as well as has no language-specific tags).</span> <span> - </span> <span class="display-name">Matthew</span> <span> </span> <span class="date">2 Mar 2017 at 03:16</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Even before 3.1, Python supported <i>mutation</i> (e.g. <code>d[a] = b</code> works perfectly well if <code>d</code> is a closed-over dict), it just didn't support <i>name rebinding</i> (<code>d = {a: b}</code> creates a local variable and shadows any closure variable). As far as Python is concerned, those are entirely separate operations. As a result, anything you could reasonably want to do with mutability was still doable in older versions of Python, just more annoying because you had to wrap everything in a mutable dict.</span> <span> - </span> <span class="display-name">Kevin</span> <span> </span> <span class="date">13 Oct 2017 at 01:16</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Kevin but the point is not rebinding and creating new shadowing local variable; the point it indeed mutating the value of a binding in one closure and having the new value be seen in another closure that references the same binding. of course mutating the <i>structure</i> (or "storage") can emulate that too, as you said.</span> <span> - </span> <span class="display-name">Will Ness</span> <span> </span> <span class="date">29 Mar 2021 at 19:43</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@WillNess honestly, I think this is a case where "explicit is better than implicit".</span> <span> - </span> <span class="display-name">Karl Knechtel</span> <span> </span> <span class="date">20 Aug 2022 at 01:28</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>548</span>
     </div>
     <div>
      <span>Answerer: </span> <span>SasQ</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Apr 2016 at 01:18</span>
     </div>
    </div>
    <div>
     <p>There is a lot of confusion around lambdas and closures, even in the answers to this StackOverflow question here. Instead of asking random programmers who learned about closures from practice with certain programming languages or other clueless programmers, take a journey to the <em>source</em> (where it all began). And since lambdas and closures come from <strong>Lambda Calculus</strong> invented by Alonzo Church back in the '30s before first electronic computers even existed, this is the <em>source</em> I'm talking about.</p>
     <p>Lambda Calculus is the simplest programming language in the world. The only things you can do in it:►</p>
     <ul>
      <li>APPLICATION: Applying one expression to another, denoted <code>f x</code>.<br>
       (Think of it as a <em>function call</em>, where <code>f</code> is the function and <code>x</code> is its only parameter)</li>
      <li>ABSTRACTION: Binds a symbol occurring in an expression to mark that this symbol is just a "slot", a blank box waiting to be filled with value, a "variable" as it were. It is done by prepending a Greek letter <code>λ</code> (lambda), then the symbolic name (e.g. <code>x</code>), then a dot <code>.</code> before the expression. This then converts the expression into a <em>function</em> expecting one <em>parameter</em>.<br>
       For example: <code>λx.x+2</code> takes the expression <code>x+2</code> and tells that the symbol <code>x</code> in this expression is a <em>bound variable</em> – it can be substituted with a value you supply as a parameter.<br>
        Note that the function defined this way is <em>anonymous</em> – it doesn't have a name, so you can't refer to it yet, but you can <em>immediately call</em> it (remember application?) by supplying it the parameter it is waiting for, like this: <code>(λx.x+2) 7</code>. Then the expression (in this case a literal value) <code>7</code> is substituted as <code>x</code> in the subexpression <code>x+2</code> of the applied lambda, so you get <code>7+2</code>, which then reduces to <code>9</code> by common arithmetics rules.</li>
     </ul>
     <p>So we've solved one of the mysteries:<br><strong>lambda</strong> is the <em>anonymous function</em> from the example above, <code>λx.x+2</code>.</p>
     <hr> In different programming languages, the syntax for functional abstraction (lambda) may differ. For example, in JavaScript it looks like this:
     <p></p>
     <pre><code>function(x) { return x+2; }
</code></pre>
     <p>and you can immediately apply it to some parameter like this:</p>
     <pre><code>(function(x) { return x+2; })(7)
</code></pre>
     <p>or you can store this anonymous function (lambda) into some variable:</p>
     <pre><code>var f = function(x) { return x+2; }
</code></pre>
     <p>which effectively gives it a name <code>f</code>, allowing you to refer to it and call it multiple times later, e.g.:</p>
     <pre><code>alert(  f(7) + f(10)  );   // should print 21 in the message box
</code></pre>
     <p>But you didn't have to name it. You could call it immediately:</p>
     <pre><code>alert(  function(x) { return x+2; } (7)  );  // should print 9 in the message box
</code></pre>
     <p>In LISP, lambdas are made like this:</p>
     <pre><code>(lambda (x) (+ x 2))
</code></pre>
     <p>and you can call such a lambda by applying it immediately to a parameter:</p>
     <pre><code>(  (lambda (x) (+ x 2))  7  )
</code></pre>
     <p></p>
     <hr> OK, now it's time to solve the other mystery: what is a <em>closure</em>. In order to do that, let's talk about <em>symbols</em> (<em>variables</em>) in lambda expressions.
     <p></p>
     <p>As I said, what the lambda abstraction does is <em>binding</em> a symbol in its subexpression, so that it becomes a substitutible <em>parameter</em>. Such a symbol is called <em>bound</em>. But what if there are other symbols in the expression? For example: <code>λx.x/y+2</code>. In this expression, the symbol <code>x</code> is bound by the lambda abstraction <code>λx.</code> preceding it. But the other symbol, <code>y</code>, is not bound – it is <em>free</em>. We don't know what it is and where it comes from, so we don't know what it <em>means</em> and what <em>value</em> it represents, and therefore we cannot evaluate that expression until we figure out what <code>y</code> means.</p>
     <p>In fact, the same goes with the other two symbols, <code>2</code> and <code>+</code>. It's just that we are so familiar with these two symbols that we usually forget that the computer doesn't know them and we need to tell it what they mean by defining them somewhere, e.g. in a library or the language itself.</p>
     <p>You can think of the <em>free</em> symbols as defined somewhere else, outside the expression, in its "surrounding context", which is called its <strong>environment</strong>. The environment might be a bigger expression that this expression is a part of (as Qui-Gon Jinn said: "There's always a bigger fish" ;) ), or in some library, or in the language itself (as a <em>primitive</em>).</p>
     <p>This lets us divide lambda expressions into two categories:</p>
     <ul>
      <li>CLOSED expressions: every symbol that occurs in these expressions is <em>bound</em> by some lambda abstraction. In other words, they are <em>self-contained</em>; they don't require any surrounding context to be evaluated. They are also called <em>combinators</em>.</li>
      <li>OPEN expressions: some symbols in these expressions are not <em>bound</em> – that is, some of the symbols occurring in them are <em>free</em> and they require some external information, and thus they cannot be evaluated until you supply the definitions of these symbols.</li>
     </ul>
     <p>You can CLOSE an <em>open</em> lambda expression by supplying the <strong>environment</strong>, which defines all these free symbols by binding them to some values (which may be numbers, strings, anonymous functions aka lambdas, whatever…).</p>
     <p>And here comes the <em>closure</em> part:<br>
       The <strong>closure</strong> of a <em>lambda expression</em> is this particular set of symbols defined in the outer context (environment) that give values to the <em>free symbols</em> in this expression, making them non-free anymore. It turns an <em>open</em> lambda expression, which still contains some "undefined" free symbols, into a <em>closed</em> one, which doesn't have any free symbols anymore.</p>
     <p>For example, if you have the following lambda expression: <code>λx.x/y+2</code>, the symbol <code>x</code> is bound, while the symbol <code>y</code> is free, therefore the expression is <code>open</code> and cannot be evaluated unless you say what <code>y</code> means (and the same with <code>+</code> and <code>2</code>, which are also free). But suppose that you also have an <em>environment</em> like this:</p>
     <pre><code>{  y: 3,
+: [built-in addition],
2: [built-in number],
q: 42,
w: 5  }
</code></pre>
     <p>This <em>environment</em> supplies definitions for all the "undefined" (free) symbols from our lambda expression (<code>y</code>, <code>+</code>, <code>2</code>), and several extra symbols (<code>q</code>, <code>w</code>). The symbols that we need to be defined are this subset of the environment:</p>
     <pre><code>{  y: 3,
+: [built-in addition],
2: [built-in number]  }
</code></pre>
     <p>and this is precisely the <em>closure</em> of our lambda expression :&gt;</p>
     <p>In other words, it <em>closes</em> an open lambda expression. This is where the name <em>closure</em> came from in the first place, and this is why so many people's answers in this thread are not quite correct :P</p>
     <hr> So why are they mistaken? Why do so many of them say that closures are some data structures in memory, or some features of the languages they use, or why do they confuse closures with lambdas? :P
     <p></p>
     <p>Well, the corporate marketoids of Sun/Oracle, Microsoft, Google etc. are to blame, because that's what they called these constructs in their languages (Java, C#, Go etc.). They often call "closures" what are supposed to be just lambdas. Or they call "closures" a particular technique they used to implement lexical scoping, that is, the fact that a function can access the variables that were defined in its outer scope at the time of its definition. They often say that the function "encloses" these variables, that is, captures them into some data structure to save them from being destroyed after the outer function finishes executing. But this is just made-up <em>post factum</em> "folklore etymology" and marketing, which only makes things more confusing, because every language vendor uses its own terminology.</p>
     <p>And it's even worse because of the fact that there's always a bit of truth in what they say, which does not allow you to easily dismiss it as false :P Let me explain:</p>
     <p>If you want to implement a language that uses lambdas as first-class citizens, you need to allow them to use symbols defined in their surrounding context (that is, to use free variables in your lambdas). And these symbols must be there even when the surrounding function returns. The problem is that these symbols are bound to some local storage of the function (usually on the call stack), which won't be there anymore when the function returns. Therefore, in order for a lambda to work the way you expect, you need to somehow "capture" all these free variables from its outer context and save them for later, even when the outer context will be gone. That is, you need to find the <em>closure</em> of your lambda (all these external variables it uses) and store it somewhere else (either by making a copy, or by preparing space for them upfront, somewhere else than on the stack). The actual method you use to achieve this goal is an "implementation detail" of your language. What's important here is the <em>closure</em>, which is the set of <em>free variables</em> from the <em>environment</em> of your lambda that need to be saved somewhere.</p>
     <p>It didn't took too long for people to start calling the actual data structure they use in their language's implementations to implement closure as the "closure" itself. The structure usually looks something like this:</p>
     <pre><code>Closure {
   [pointer to the lambda function's machine code],
   [pointer to the lambda function's environment]
}
</code></pre>
     <p>and these data structures are being passed around as parameters to other functions, returned from functions, and stored in variables, to represent lambdas, and allowing them to access their enclosing environment as well as the machine code to run in that context. But it's just a way (one of many) to <em>implement</em> closure, not <em>the</em> closure itself.</p>
     <p>As I explained above, the closure of a lambda expression is the subset of definitions in its environment that give values to the free variables contained in that lambda expression, effectively <em>closing</em> the expression (turning an <em>open</em> lambda expression, which cannot be evaluated yet, into a <em>closed</em> lambda expression, which can then be evaluated, since all the symbols contained in it are now defined).</p>
     <p>Anything else is just a "cargo cult" and "voo-doo magic" of programmers and language vendors unaware of the real roots of these notions.</p>
     <p>I hope that answers your questions. But if you had any follow-up questions, feel free to ask them in the comments, and I'll try to explain it better.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>98</td>
        <td><span>Best answer explaining things generically rather than language specific</span> <span> - </span> <span class="display-name">Shishir Arora</span> <span> </span> <span class="date">9 May 2016 at 11:52</span></td>
       </tr>
       <tr>
        <td>80</td>
        <td><span>i love this kind of approach when explaining things. Starting from the very beginning, explaining how things work and then how the current misconceptions were created. This answer needs to go to the top.</span> <span> - </span> <span class="display-name">Sharky</span> <span> </span> <span class="date">13 Jun 2016 at 14:32</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@SasQ &gt; the closure of a lambda expression is the subset of definitions in its environment that give values to the free variables contained in that lambda expression &lt; So in your example data structure, does that mean it's more appropriate to say the "pointer to the lambda function's environment" is the closure?</span> <span> - </span> <span class="display-name">Jeff M</span> <span> </span> <span class="date">13 Oct 2017 at 16:58</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>Though Lambda calculus feels like machine language to me I must concur that it is a "found" language in contrast with a "made" language. And thus much less subject to arbitrary conventions, and much more suited to capturing the underlying structure of reality. We can find specifics in Linq, JavaScript, F# more approachable/accessible, but Lambda calculus gets to the nub of the matter without distraction.</span> <span> - </span> <span class="display-name">StevePoling</span> <span> </span> <span class="date">9 Nov 2018 at 15:44</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Should <code>/</code> be included in the environment as well? Excellent answer, I might add.</span> <span> - </span> <span class="display-name">Kevin W Matthews</span> <span> </span> <span class="date">22 Jan 2019 at 17:42</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>So, given all of the above, what is the correct name, in your opinion, that the creators of JAVA, C#, etc, should have named the operation of creating an anonymous function that copies off values from the stack into its local memory? In the absence of another term, I'm going to continue to call those "closures". Maybe "partial closure" is more accurate, but it did close over something. I'm curious if you have a better name.</span> <span> - </span> <span class="display-name">srm</span> <span> </span> <span class="date">6 Apr 2019 at 19:33</span></td>
       </tr>
       <tr>
        <td>9</td>
        <td><span>I appreciate that you reiterated your point several times, with slightly different wording each time. It helps reinforce the concept. I wish more people did this.</span> <span> - </span> <span class="display-name">johnklawlor</span> <span> </span> <span class="date">19 Feb 2020 at 04:44</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span><a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)#History_and_etymology" rel="nofollow noreferrer">Wikipedia</a> has a citation for "<i>Peter J. Landin defined the term closure in 1964 as having an environment part and a control part as used by his SECD machine for evaluating expressions</i>". So closure means lambda function implementation. I have not be able to find closure being used in the context of pure mathematical Lambda Calculus. – ap-osd just now</span> <span> - </span> <span class="display-name">ap-osd</span> <span> </span> <span class="date">12 Jun 2020 at 10:48</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This 2007 post <a href="http://gafter.blogspot.com/2007/01/definition-of-closures.html" rel="nofollow noreferrer">gafter.blogspot.com/2007/01/definition-of-closures.html</a> will surely add value to all who are mathematically inclined</span> <span> - </span> <span class="display-name">KGhatak</span> <span> </span> <span class="date">19 Mar 2021 at 07:18</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>you said it. lots of wrong and misleading/confusing statements in this answer, with <i>some</i> truth to them. there are no closures in Lambda Calculus, for starters, because there are no environments in Lambda Calculus (cc @ap-osd). BTW congrats! Google now brings up your wrong definition on <a href="https://www.google.com/search?q=closed+lambda+expression" rel="nofollow noreferrer">this search</a>. in truth a closure is a paring of lambda expression with its definitional environment. no copies, no subsets, it must be the original frame itself (with <i>its</i> pointer up the chain), because it's not about values, but about <b><i>bindings</i></b>.</span> <span> - </span> <span class="display-name">Will Ness</span> <span> </span> <span class="date">29 Mar 2021 at 19:22</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span><i>values</i> can just be substituted, in the absence of mutation (which is what LC is doing, incidentally). but in the presence of mutation in the language, <i>bindings</i> must be maintained instead. without mutation there's no need for a separate concept of a closure (like in LC there isn't) -- just that of a (lexical) scope. the whole story includes possibility of (shared) mutation -- change it "here", see it reflected "there" as well. just remembering the values (by whatever means -- substitution, subset-copying, whatever) is only part of the story.</span> <span> - </span> <span class="display-name">Will Ness</span> <span> </span> <span class="date">29 Mar 2021 at 20:02</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>In addition to the comment of @Kevin W Matthews: I guess the environment should also contain <code>3: [built-in number]</code>, since 3 is unbound otherwise?</span> <span> - </span> <span class="display-name">Kyrion</span> <span> </span> <span class="date">5 Jan 2022 at 17:06</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>"Lambda Calculus is the simplest programming language in the world." False. There are <a href="https://en.wikipedia.org/wiki/Combinatory_logic" rel="nofollow noreferrer">combinatory logics</a> which are strictly simpler than the untyped lambda calculus both in syntactic and semantic rules. (Roughly they are lambda calculus with a few primitives instead of free vairables and the lambda abstraction.) That said, <i>programming</i> using combinatory logics may be likely far less simpler than using lambda calculi; see also <a href="https://en.wikipedia.org/wiki/Unlambda" rel="nofollow noreferrer">Unlambda</a>.</span> <span> - </span> <span class="display-name">FrankHB</span> <span> </span> <span class="date">25 Jan 2022 at 13:53</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@WillNess True and false. It is true that the lambda calculus has nothing to do with closures at the very first place. It is false that bindings are required for mutation; usually, bindings are immediately necessary for the <i>encapsulation</i> of the objects used in the source language (usually they can be encoded as <i>administrative terms</i> in the operational semantic based on term rewrite) whose representation not expressible in the source language. (On the contrary, all the values in the lambda calculus can be encoded as some lambda term.)</span> <span> - </span> <span class="display-name">FrankHB</span> <span> </span> <span class="date">25 Jan 2022 at 14:09</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@WillNess See also the vau-e calculus (the 1st pure <a href="https://web.wpi.edu/Pubs/ETD/Available/etd-090110-124904/unrestricted/jshutt.pdf" rel="nofollow noreferrer">vau calculi by John Shutt</a>) for an example of introducing the environments before introducing the mutation. The dedicated rules for environments here are for the stength of the corresponding equational theory.</span> <span> - </span> <span class="display-name">FrankHB</span> <span> </span> <span class="date">25 Jan 2022 at 14:10</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>"For example: λx.x+2 takes the expression x+2 and tells that the symbol x in this expression is a bound variable – it can be substituted with a value you supply as a parameter." Isn't that a <b>free</b> variable, whereas a bound variable is one that has been set via (possibly partial) application?</span> <span> - </span> <span class="display-name">Karl Knechtel</span> <span> </span> <span class="date">20 Aug 2022 at 01:23</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Superp answer! Cheers!</span> <span> - </span> <span class="display-name">rikisa</span> <span> </span> <span class="date">28 Apr 2023 at 12:07</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>182</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mark Cidade</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Oct 2008 at 03:46</span>
     </div>
    </div>
    <div>
     <p>When most people think of <em>functions</em>, they think of <strong>named functions</strong>:</p>
     <pre><code>function foo() { return "This string is returned from the 'foo' function"; }
</code></pre>
     <p>These are called by name, of course:</p>
     <pre><code>foo(); //returns the string above
</code></pre>
     <p>With <em>lambda expressions</em>, you can have <strong>anonymous functions</strong>:</p>
     <pre><code> @foo = lambda() {return "This is returned from a function without a name";}
</code></pre>
     <p>With the above example, you can call the lambda through the variable it was assigned to:</p>
     <pre><code>foo();
</code></pre>
     <p>More useful than assigning anonymous functions to variables, however, are passing them to or from higher-order functions, i.e., functions that accept/return other functions. In a lot of these cases, naming a function is unecessary:</p>
     <pre><code>function filter(list, predicate) 
 { @filteredList = [];
   for-each (@x in list) if (predicate(x)) filteredList.add(x);
   return filteredList;
 }

//filter for even numbers
filter([0,1,2,3,4,5,6], lambda(x) {return (x mod 2 == 0)}); 
</code></pre>
     <p>A <em>closure</em> may be a named or anonymous function, but is known as such when it "closes over" variables in the scope where the function is defined, i.e., the closure will still refer to the environment with any outer variables that are used in the closure itself. Here's a named closure:</p>
     <pre><code>@x = 0;

function incrementX() { x = x + 1;}

incrementX(); // x now equals 1
</code></pre>
     <p>That doesn't seem like much but what if this was all in another function and you passed <code>incrementX</code> to an external function?</p>
     <pre><code>function foo()
 { @x = 0;

   function incrementX() 
    { x = x + 1;
      return x;
    }

   return incrementX;
 }

@y = foo(); // y = closure of incrementX over foo.x
y(); //returns 1 (y.x == 0 + 1)
y(); //returns 2 (y.x == 1 + 1)
</code></pre>
     <p>This is how you get stateful objects in functional programming. Since naming "incrementX" isn't needed, you can use a lambda in this case:</p>
     <pre><code>function foo()
 { @x = 0;

   return lambda() 
           { x = x + 1;
             return x;
           };
 }
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>17</td>
        <td><span>what language are you ising here?</span> <span> - </span> <span class="display-name">Claudiu</span> <span> </span> <span class="date">21 Oct 2008 at 03:53</span></td>
       </tr>
       <tr>
        <td>8</td>
        <td><span>It's basically pseudocode. There's some lisp and JavaScript in it, as well as a language I'm designing called "@" ("at"), named after the variable declaration operator.</span> <span> - </span> <span class="display-name">Mark Cidade</span> <span> </span> <span class="date">21 Oct 2008 at 03:57</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@MarkCidade, so where is this language @? Is there a documentation and donwload?</span> <span> - </span> <span class="display-name">Pacerier</span> <span> </span> <span class="date">27 Aug 2013 at 08:43</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Pacerier I'm still designing it. No downloads or documentation is available yet.</span> <span> - </span> <span class="display-name">Mark Cidade</span> <span> </span> <span class="date">27 Aug 2013 at 17:41</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>Why not take Javascript and add a constraint of declaring variables with leading @ sign? That would save time a little :)</span> <span> - </span> <span class="display-name">Nemoden</span> <span> </span> <span class="date">18 Nov 2013 at 14:58</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>The language is more than just JavaScript with <code>@</code> instead of <code>var</code>.</span> <span> - </span> <span class="display-name">Mark Cidade</span> <span> </span> <span class="date">19 Nov 2013 at 19:43</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>@Pacerier: I started implementing the language: <a href="http://github.com/marxidad/At2015" rel="nofollow noreferrer">github.com/marxidad/At2015</a></span> <span> - </span> <span class="display-name">Mark Cidade</span> <span> </span> <span class="date">9 Apr 2016 at 06:31</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span><code>This is how you get stateful objects in functional programming</code>, this statement make this answer attracts me.</span> <span> - </span> <span class="display-name">Lebecca</span> <span> </span> <span class="date">1 Mar 2020 at 08:10</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>61</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Michael Brown</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Oct 2008 at 03:29</span>
     </div>
    </div>
    <div>
     <p>Not all closures are lambdas and not all lambdas are closures. Both are functions, but not necessarily in the manner we're used to knowing.</p>
     <p>A lambda is essentially a function that is defined inline rather than the standard method of declaring functions. Lambdas can frequently be passed around as objects.</p>
     <p>A closure is a function that encloses its surrounding state by referencing fields external to its body. The enclosed state remains across invocations of the closure.</p>
     <p>In an object-oriented language, closures are normally provided through objects. However, some OO languages (e.g. C#) implement special functionality that is closer to the definition of closures provided by purely <a href="http://en.wikipedia.org/wiki/Category:Functional_languages" rel="noreferrer">functional languages</a> (such as lisp) that do not have objects to enclose state.</p>
     <p>What's interesting is that the introduction of Lambdas and Closures in C# brings functional programming closer to mainstream usage.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>So, could we say that closures are a subset of lambdas and lambdas are a subset of functions?</span> <span> - </span> <span class="display-name">sker</span> <span> </span> <span class="date">21 Oct 2008 at 03:37</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Closures are a subset of lambdas...but lambdas are more special than normal functions. Like I said, lambdas are defined inline. Essentially there is no way to reference them unless they are passed to another function or returned as a return value.</span> <span> - </span> <span class="display-name">Michael Brown</span> <span> </span> <span class="date">21 Oct 2008 at 03:39</span></td>
       </tr>
       <tr>
        <td>20</td>
        <td><span>Lambdas and closures are each a subset of all functions, but there is only an intersection between lambdas and closures, where the non-intersecting part of closures would be named functions that are closures and non-intersecting lamdas are self-contained functions with fully-bound variables.</span> <span> - </span> <span class="display-name">Mark Cidade</span> <span> </span> <span class="date">21 Oct 2008 at 04:06</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Roarrr... Some facts: (1) Closures are <i>not</i> necessarily functions. (2) Lisp is <i>not</i> <i>purely</i> functional. (3) Lisp <i>does have</i> objects; it just traditionally treats "object" as synonym as "value" before the definition of "object" being overriden to something else (e.g. by CLOS).</span> <span> - </span> <span class="display-name">FrankHB</span> <span> </span> <span class="date">25 Jan 2022 at 14:22</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>You are right...I've learned much since the 14 years I first wrote this. Wonder if I can revise to encompass what I've learned since.</span> <span> - </span> <span class="display-name">Michael Brown</span> <span> </span> <span class="date">23 May 2022 at 21:32</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>20</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Andreas Rossberg</span>
     </div>
     <div>
      <span> Answered: </span> <span>19 Mar 2014 at 08:31</span>
     </div>
    </div>
    <div>
     <p>It's as simple as this: lambda is a language construct, i.e. simply syntax for anonymous functions; a closure is a technique to implement it -- or any first-class functions, for that matter, named or anonymous.</p>
     <p>More precisely, a closure is how a <a href="http://en.wikipedia.org/wiki/First-class_function" rel="noreferrer">first-class function</a> is represented at runtime, as a pair of its "code" and an environment "closing" over all the non-local variables used in that code. This way, those variables are still accessible even when the outer scopes where they originate have already been exited.</p>
     <p>Unfortunately, there are many languages out there that do not support functions as first-class values, or only support them in crippled form. So people often use the term "closure" to distinguish "the real thing".</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>13</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Wei Qiu</span>
     </div>
     <div>
      <span> Answered: </span> <span>19 Mar 2014 at 00:11</span>
     </div>
    </div>
    <div>
     <p>From the view of programming languages, they are completely two different things.</p>
     <p>Basically for a Turing complete language we only needs very limited elements, e.g. abstraction, application and reduction. Abstraction and application provides the way you can build up lamdba expression, and reduction dertermines the meaning of the lambda expression.</p>
     <p>Lambda provides a way you can abstract the computation process out. for example, to compute the sum of two numbers, a process which takes two parameters x, y and returns x+y can be abstracted out. In scheme, you can write it as</p>
     <pre><code>(lambda (x y) (+ x y))
</code></pre>
     <p>You can rename the parameters, but the task that it completes doesn't change. In almost all of programming languages, you can give the lambda expression a name, which are named functions. But there is no much difference, they can be conceptually considered as just syntax sugar.</p>
     <p>OK, now imagine how this can be implemented. Whenever we apply the lambda expression to some expressions, e.g.</p>
     <pre><code>((lambda (x y) (+ x y)) 2 3)
</code></pre>
     <p>We can simply substitute the parameters with the expression to be evaluated. This model is already very powerful. But this model doesn't enable us to change the values of symbols, e.g. We can't mimic the change of status. Thus we need a more complex model. To make it short, whenever we want to calculate the meaning of the lambda expression, we put the pair of symbol and the corresponding value into an environment(or table). Then the rest (+ x y) is evaluated by looking up the corresponding symbols in the table. Now if we provide some primitives to operate on the environment directly, we can model the changes of status!</p>
     <p>With this background, check this function:</p>
     <pre><code>(lambda (x y) (+ x y z))
</code></pre>
     <p>We know that when we evaluate the lambda expression, x y will be bound in a new table. But how and where can we look z up? Actually z is called a free variable. There must be an outer an environment which contains z. Otherwise the meaning of the expression can't be determined by only binding x and y. To make this clear, you can write something as follows in scheme:</p>
     <pre><code>((lambda (z) (lambda (x y) (+ x y z))) 1)
</code></pre>
     <p>So z would be bound to 1 in an outer table. We still get a function which accepts two parameters but the real meaning of it also depends on the outer environment. In other words the outer environment closes on the free variables. With the help of set!, we can make the function stateful, i.e, it's not a function in the sense of maths. What it returns not only depends on the input, but z as well.</p>
     <p>This is something you already know very well, a method of objects almost always relies on the state of objects. That's why some people say "closures are poor man's objects. " But we could also consider objects as poor man's closures since we really like first class functions.</p>
     <p>I use scheme to illustrate the ideas due to that scheme is one of the earliest language which has real closures. All of the materials here are much better presented in SICP chapter 3.</p>
     <p>To sum up, lambda and closure are really different concepts. A lambda is a function. A closure is a pair of lambda and the corresponding environment which closes the lambda.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>So one could substitute all closures by nested lambdas until no free variables are present anymore? In this case I would say that closures could be seen as special kind of lambdas.</span> <span> - </span> <span class="display-name">NoDataDumpNoContribution</span> <span> </span> <span class="date">13 Jun 2014 at 09:22</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Some problems. (1) The "reduction" here seems vague. In term rewrite systems, lambda abstractions are also instances of redex, and they will be rewrite to the value of a procedure as per Scheme's rules. Do you mean the "variable referencing"? (2) Abstractions are not necessary to make a language Turing-complete, e.g. combinatory logics have no abstractions. (3) Named functions in many contemporary languages are built independent of lambda expressions. Some of them have peculiar features which lambda expressions do not share, e.g. overloading.</span> <span> - </span> <span class="display-name">FrankHB</span> <span> </span> <span class="date">25 Jan 2022 at 14:32</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>(4) In Scheme, objects are just values. Better avoid mixing ambiguous terms together. (5) A closure does not need to store the syntactic elements of the abstraction (plus there are other operators can be the abstractions), so a closure is <i>not</i> a pair containing whatever "lambda" stuff. (Still more correct than the answer which assert "closures are functions", though.)</span> <span> - </span> <span class="display-name">FrankHB</span> <span> </span> <span class="date">25 Jan 2022 at 14:34</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>11</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Developer</span>
     </div>
     <div>
      <span> Answered: </span> <span>31 Jul 2014 at 07:41</span>
     </div>
    </div>
    <div>
     <p>Concept is same as described above, but if you are from PHP background, this further explain using PHP code.</p>
     <pre><code>$input = array(1, 2, 3, 4, 5);
$output = array_filter($input, function ($v) { return $v &gt; 2; });
</code></pre>
     <p>function ($v) { return $v &gt; 2; } is the lambda function definition. We can even store it in a variable, so it can be reusable:</p>
     <pre><code>$max = function ($v) { return $v &gt; 2; };

$input = array(1, 2, 3, 4, 5);
$output = array_filter($input, $max);
</code></pre>
     <p>Now, what if you want to change the maximum number allowed in the filtered array? You would have to write another lambda function or create a closure (PHP 5.3):</p>
     <pre><code>$max_comp = function ($max) {
  return function ($v) use ($max) { return $v &gt; $max; };
};

$input = array(1, 2, 3, 4, 5);
$output = array_filter($input, $max_comp(2));
</code></pre>
     <p>A closure is a function that is evaluated in its own environment, which has one or more bound variables that can be accessed when the function is called. They come from the functional programming world, where there are a number of concepts in play. Closures are like lambda functions, but smarter in the sense that they have the ability to interact with variables from the outside environment of where the closure is defined.</p>
     <p>Here is a simpler example of PHP closure:</p>
     <pre><code>$string = "Hello World!";
$closure = function() use ($string) { echo $string; };

$closure();
</code></pre>
     <p><a href="http://www.codeforest.net/anonymous-or-lambda-functions-in-php" rel="noreferrer">Nicely explained in this article.</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>9</span>
     </div>
     <div>
      <span>Answerer: </span> <span>philippe lhardy</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Nov 2014 at 17:46</span>
     </div>
    </div>
    <div>
     <p>This question is old and got many answers.<br>
       Now with Java 8 and Official Lambda that are unofficial closure projects, it revives the question.</p>
     <p>The answer in Java context (via <a href="http://www.lambdafaq.org/lambdas-and-closures-whats-the-difference/" rel="nofollow noreferrer">Lambdas and closures — what’s the difference?</a>):</p>
     <blockquote>
      <p>"A closure is a lambda expression paired with an environment that binds each of its free variables to a value. In Java, lambda expressions will be implemented by means of closures, so the two terms have come to be used interchangeably in the community."</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>How Lamdas are implemented by closure in Java? Does it mean the Lamdas expression gets converted to an old style anonymous class?</span> <span> - </span> <span class="display-name">hackjutsu</span> <span> </span> <span class="date">19 Jul 2016 at 22:38</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>feilengcui008</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 May 2015 at 07:03</span>
     </div>
    </div>
    <div>
     <p>Simply speaking, closure is a trick about scope, lambda is an anonymous function. We can realize closure with lambda more elegantly and lambda is often used as a parameter passed to a higher function</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>yoAlex5</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Mar 2021 at 21:17</span>
     </div>
    </div>
    <div>
     <p><strong>Lambda vs Closure</strong></p>
     <p><code>Lambda</code> is <strong>anonymous</strong> function(method)</p>
     <p><code>Closure</code> is function which <strong>closes over</strong>(capture) variables from its enclosing scope(e.g. non-local variables)</p>
     <p>Java</p>
     <pre><code>interface Runnable {
    void run();
}

class MyClass {
    void foo(Runnable r) {

    }

    //Lambda
    void lambdaExample() {
        foo(() -&gt; {});
    }

    //Closure
    String s = "hello";
    void closureExample() {
        foo(() -&gt; { s = "world";});
    }
}
</code></pre>
     <p>Swift<a href="https://stackoverflow.com/questions/24133879/what-are-the-differences-between-functions-and-methods-in-swift/60988242#60988242"><sup>[Closure]</sup></a></p>
     <pre><code>class MyClass {
    func foo(r:() -&gt; Void) {}
    
    func lambdaExample() {
        foo(r: {})
    }
    
    var s = "hello"
    func closureExample() {
        foo(r: {s = "world"})
    }
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>It might be more clear not to use anonymous function in the closure example. Anonymous class can be used instead</span> <span> - </span> <span class="display-name">darw</span> <span> </span> <span class="date">12 May 2023 at 13:15</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Or named function can be used for the closure example instead of using anonymous function for both examples</span> <span> - </span> <span class="display-name">darw</span> <span> </span> <span class="date">12 May 2023 at 13:30</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>j2emanue</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Apr 2019 at 21:57</span>
     </div>
    </div>
    <div>
     <p>A Lambda expression is just an anonymous function. in plain java, for example, you can write it like this:</p>
     <pre><code>Function&lt;Person, Job&gt; mapPersonToJob = new Function&lt;Person, Job&gt;() {
    public Job apply(Person person) {
        Job job = new Job(person.getPersonId(), person.getJobDescription());
        return job;
    }
};
</code></pre>
     <p>where the class Function is just built in java code. Now you can call <code>mapPersonToJob.apply(person)</code> somewhere to use it. thats just one example. Thats a lambda before there was syntax for it. Lambdas a short cut for this.</p>
     <p>Closure:</p>
     <p>a Lambda becomes a closure when it can access the variables outside of this scope. i guess you can say its magic, it magically can wrap around the environment it was created in and use the variables outside of its scope(outer scope. so to be clear, a closure means a lambda can access its OUTER SCOPE.</p>
     <p>in Kotlin, a lambda can always access its closure (the variables that are in its outer scope)</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>FrankHB</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Jan 2022 at 13:50</span>
     </div>
    </div>
    <div>
     <p>There are many noises of technically vague or "not even wrong" artificial pearls in various existing answers to this question, so I'd finally add a new one...</p>
     <h1>Clarification on the terminology</h1>
     <p>It is better to know, the terms "closure" and "lambda" can both denote different things, contextually dependently.</p>
     <p>This is a formal issue because the specification of the PL (programming language) being discussed may define such terms explicitly.</p>
     <p>For example, by ISO C++ (since C++11):</p>
     <blockquote>
      <p>The type of a lambda-expression (which is also the type of the closure object) is a unique, unnamed non-union class type, called the closure type, whose properties are described below.</p>
     </blockquote>
     <p>As users of C-like languages are daily confusing with "pointers" (types) to "pointer values" or "pointer objects" (inhabitants of types), there are risks to getting confused here, too: most C++ users are actually talking about "closure objects" by using the term "closure". Be cautious to the ambiguity.</p>
     <p><strong>NOTE</strong> To make things generally clearer and more precise, I'd seldom deliberately use some language-neutral terms (usually specific to the <a href="https://en.wikipedia.org/wiki/Programming_language_theory" rel="nofollow noreferrer">PL theory</a> instead of the language-defined terminology. For instance, <a href="https://en.wikipedia.org/wiki/Type_inhabitation" rel="nofollow noreferrer">type inhabitant</a> used above covers the language-specific "(r)values" and "lvalues" in a broader sense. (Since the syntactic essence of C++'s <em>value category</em> definition is irrelevant, avoiding "(l/r)values" may reduce confusion). (Disclaimer: lvalues and rvalues are <a href="https://en.wikipedia.org/wiki/Value_%28computer_science%29#lrvalue" rel="nofollow noreferrer">common</a> enough in many other contexts.) Terms not defined formally among different PLs may be in quotes. Verbatim copy from referenced materials may be also in quotes, with typos unchanged.</p>
     <p>This is even more relevant to "lambda". The (small case) letter lambda (λ) is an element of the Greek alphabet. By compared with "lambda" and "closure", one is certainly not talking about the letter itself, but something behind the syntax using "lambda"-derived concepts.</p>
     <p>The relevant constructs in modern PLs are usually named as "lambda expressions". And it is derived from the "lambda abstractions", discussed below.</p>
     <p>Before the detailed discussions, I recommend reading some comments of the question itself. I feel they safer and more helpful than most answers of the question here, in the sense of less risks of getting confused. (Sadly, this is the most significant reason I decide to provide an answer here...)</p>
     <h1>Lambdas: a brief history</h1>
     <p>The constructs named of "lambda" in PLs, whatever "lambda expression" or something others, are <em>syntactic</em>. In other words, users of the languages can find such <em>source language constructs</em> which are used to build something others. Roughly, the "others" are just "anonymous functions" in practice.</p>
     <p>Such constructs are originated from <em>lambda abstractions</em>, one of the three syntax categories ("kinds of expressions") of the <a href="https://en.wikipedia.org/wiki/Lambda_calculus" rel="nofollow noreferrer">(untyped) lambda calculus</a> developed by A. Church.</p>
     <p>Lambda calculus is a deducing system (more precisely, a <a href="https://en.wikipedia.org/wiki/Rewriting#Term_rewriting_systems" rel="nofollow noreferrer">TRS (term rewrite system)</a>) to model computation universally. To reduce a of lambda term is just like to evaluate an expression in normal PLs. With the built-in reduction rules, it is sufficient to define the various ways to compute. (As you may know, <a href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis" rel="nofollow noreferrer">it is Turing-complete</a>.) Hence, it can be used as a PL.</p>
     <p><strong>NOTE</strong> Evaluating an expression in a PL is not interchangable to reducing a term in a TRS in general. However, lambda calculus is a language with all reduction results expressible within the source language (i.e. as lambda terms), so they have same meaning coincidentally. Almost all PLs in practice do not have this property; the calculus to describe their semantics may contain terms not being the source lanugage expressions, and reductions may have more detailed effects than evaluations.</p>
     <p>Every terms ("expressions") in the lambda calculus (lambda terms) are either variable, abstraction or application. "Variable" here is the syntax (just the variable's name) of symbol, which can refer to an existing "variable" (semantically, an entity which may reduce to some other lambda term) introduced previously. The ability to introduce a variable is provided by the abstraction syntax, which has a leading letter λ, followed by a <em>bound variable</em>, a dot and a lambda term. The bound variable is similar to the formal parameter name both in the syntax and semantic among many languages, and the followed lambda term inside the lambda abstraction is just like the function body. The application syntax combines a lambda term ("actual argument") to some abstraction, like the function call expression in many PLs.</p>
     <p><strong>NOTE</strong> A lambda abstraction can introduce only one parameter. To overcome the limitation inside the calculus, see <a href="https://en.wikipedia.org/wiki/Currying" rel="nofollow noreferrer">Currying</a>.</p>
     <p>The ability of introducing variables makes lambda calculus a typical high-level language (albeit simple). On the other hand, <a href="https://en.wikipedia.org/wiki/Combinatory_logic" rel="nofollow noreferrer">combinatory logics</a> can be treated as PLs by remove away the variable and abstraction features from the lambda calculus. Combinatory logics are low-level exactly in this sense: they are like plain-old assembly languages which do not allow to introduce variables named by the user (despite macros, which requires additional preprocessing). (... If not more low-level... typically assembly languages can at least introduce user-named labels.)</p>
     <p>Noticing the lambda abstraction can be built in-place inside any other lambda terms, without the need to specify a name to denote the abstraction. So, the lambda abstraction in a whole forms the anonymous function (probably nested). This is a quite high-level feature (compared to, e.g. ISO C, which does not allow anonymous or nested functions).</p>
     <p>The successor of the untyped lambda calculus include various typed lambda calculi (like the <a href="https://en.wikipedia.org/wiki/Lambda_cube" rel="nofollow noreferrer">lambda cube</a>). These are more like statically typed languages which requires type annotations on the formal parameters of functions. Nevertheless, the lambda abstractions still have the same roles here.</p>
     <p>Although lambda calculi are not intended to be directly used as PLs implemented in computers, they do have affected PLs in practice. Notably, J. McCarthy introduced the <code>LAMBDA</code> operator in LISP to provide functions exactly following the idea of Church's untyped lambda calculus. Apparently, the name <code>LAMBDA</code> comes from the letter λ. LISP (later) has a different syntax (<a href="https://en.wikipedia.org/wiki/S-expression" rel="nofollow noreferrer">S-expression</a>), but all programmable elements in the <code>LAMBDA</code> expressions can be directly mapped to the lambda abstractions in the untyped lambda calculus by trivial syntactic conversions.</p>
     <p>On the other hand, many other PLs express similar functionalities by other means. A slightly different way to introduce reusable computations are named functions (or more exactly, named subroutines), which are supported by earlier PLs like FORTRAN, and languages derived from ALGOL. They are introduced by syntaxes specifying a named entity being a function at the same time. This is simpler in some sense compared to LISP dialects (esp. in the aspect of implementation), and it seems more popular than LISP dialects for decades. Named functions may also allow extensions not shared by anonymous functions like function overloading.</p>
     <p>Nevertheless, more and more industrial programmers finally find the usefulness of <a href="https://en.wikipedia.org/wiki/First-class_function" rel="nofollow noreferrer">first-class functions</a>, and demands of the ability to introduce function definitions in-place (in the expressions in the arbitrary contexts, say, as an argument of some other function) are increasing. It is natural and legitimate to avoid naming a thing not required to be, and any named functions fail here by definition. (You may know, <a href="https://skeptics.stackexchange.com/questions/19836">naming things correctly is one of the well-known hard problems in the computer science</a>.) To address the problem, anonymous functions are introduced to languages traditionally only providing named functions (or function-like constructs like "methods", whatsoever), like C++ and Java. Many of them name the feature as "lambda expressions" or similar lambda things, because they are basically reflecting the essentially same idea in lambda calculi. <em>Renaissance.</em></p>
     <p>A bit disambiguity: in the lambda calculus, all terms (variables, abstractions and applications) are effectively expressions in a PL; they are all "lambda expressions" in this sense. However, PLs adding lambda abstraction to enrich their features may speficially name the syntax of the abstraction as the "lambda expression", to distinguish with existing other kinds of expressions.</p>
     <h1>Closures: the history</h1>
     <p><a href="https://en.wikipedia.org/wiki/Closure_%28mathematics%29" rel="nofollow noreferrer">Closures in mathematics</a> is not the same to <a href="https://en.wikipedia.org/wiki/Closure_%28computer_programming%29" rel="nofollow noreferrer">it in PLs</a>.</p>
     <p>In the latter context, the term <a href="https://www.cs.kent.ac.uk/people/staff/dat/tfp12/tfp12.pdf" rel="nofollow noreferrer">is coined by P. J. Landin in 1964</a>, to providing the support of the first-class functions in the implementation of evaluating the PLs "modelled in Church's λ-notation".</p>
     <p>Specific to the model proposed by Landin (the <a href="https://en.wikipedia.org/wiki/SECD_machine" rel="nofollow noreferrer">SECD machine</a>), <a href="https://www.cs.cmu.edu/%7Ecrary/819-f09/Landin64.pdf" rel="nofollow noreferrer">a closure is comprising the λ-expression and the environment relative to which it was evaluated</a>, or more precisely:</p>
     <blockquote>
      <p>an environment part which is a list whose two items are (1) an environment (2) an identifier of list of identifiers</p>
     </blockquote>
     <blockquote>
      <p>and a control part which consists of a list whose sole item is an AE</p>
     </blockquote>
     <p><strong>NOTE</strong> <em>AE</em> is abbreviated for <em>applicative expression</em> in the paper. This is the syntax exposing more or less the same functionality of application in the lambda calculus. There are also some additional pieces of details like <a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Strict_evaluation" rel="nofollow noreferrer">"applicative"</a> not that interesting in the lambda calculus (because it is purely functional), though. SECD is not consistent with the original lambda calculus for these minor differences. For example, SECD halts on arbitrary single lambda abstraction whether the subterm ("body") has a normal form, because it will not reduce the subterm ("evaluate the body") without the abstraction has been applied ("called"). However, such behavior may be more like the PLs today than the lambda calculus. SECD is also not the only abstract machine can evaluate lambda terms; although most other abstract machines for the similar purpose may also have environments. Contrast to the lambda calculus (which is pure), these abstract machines can support mutation in some degrees.</p>
     <p>So, in this specific context, a closure is an internal data structure to implement specific evaluations of PLs with AEs.</p>
     <p>The discipline of accessing the variables in closures reflects <a href="https://en.wikipedia.org/wiki/Scope_%28computer_science%29#Lexical_scope" rel="nofollow noreferrer">lexical scoping</a>, first used in early 1960s by the imperative language ALGOL 60. ALGOL 60 does support nested procedures and passing procedures to parameters, but not returning procedures as results. For languages has full support of first-class functions which can be returned by functions, the static chain in ALGOL 60-style implementations does not work because free variables used by the function being returned may be no longer present on the call stack. This is the <a href="https://en.wikipedia.org/wiki/Funarg_problem#Upwards_funarg_problem" rel="nofollow noreferrer">upwards funarg problem</a>. Closures resolve the problem by capturing the free variable in the environment parts and avoiding allocating them on the stack.</p>
     <p>On the other hand, early LISP implementations all use dynamic scope. This makes the variable bindings referenced all reachable in the global store, and name hiding (if any) is implemented as per-variable basis: once a variable is created with an existing name, the old one is backed by a LIFO structure; in other words, each variable's name can access a corresponding global stack. This effectively cancels the need of the per-function environments because no free variables are ever captured in the function (they are already "captured" by the stacks).</p>
     <p>Despite imitating the lambda notation at the first, LISP is very different to the lambda calculus here. The lambda calculus is <em>statically scoped</em>. That is, each variable denotes to the instance bounded by the nearest same named-formal parameter of a lambda abstraction which contains the variable before its reduction. In the semantics of lambda calculus, reducing an application substitute the term ("argument") to the bound variable ("formal parameter") in the abstraction. Since all values can be represented as lambda terms in the lambda calculus, this can be done by direct rewriting by replacing specific subterms in each step of the reducing.</p>
     <p><strong>NOTE</strong> So, environments are not essential to reduce the lambda terms. However, a calculus extending the lambda calculus can introduce the environments explicitly in the grammar, even when it only models pure computations (without mutation). By adding environments explicitly, there can be dedicated rules of constraints on the environments to enforce environment normalizations which strengthens the equational theory of the calculus. (See <a href="https://web.wpi.edu/Pubs/ETD/Available/etd-090110-124904/unrestricted/jshutt.pdf" rel="nofollow noreferrer">[Shu10]</a> §9.1.)</p>
     <p>LISP is quite different, because its underlying semantic rules are based on neither lambda calculus nor term rewriting. Therefore, LISP needs some different mechanism to maintaining the scoping discipline. It adopted the mechanism based on the environment data structures saving the variable to value mappings (i.e. variable bindings). There may be more sophisticated structure in an environment in new variants of LISP (e.g. lexically scoped Lisp allows mutations), but the simplest structure conceptually equivalent to the environment defined by the Landin's paper, discussed below.</p>
     <p>LISP implementations do support first-class functions at the very early era, but with pure dynamic scoping, there is no real funargs problem: they can just avoid the allocations on the stack and letting a global owner (the GC, garbage collector) to manage the resources in the environments (and activation records) referencing the variables. Closures are not needed then. And this is the early implementations prior to the invention of closures do.</p>
     <p><em>Deep binding</em> which approximates static (lexical) binding was introduced around 1962 in LISP 1.5, via the <code>FUNARG</code> device. This finally made the problem well-known under the name "funarg problem".</p>
     <p><strong>NOTE</strong> <a href="https://dspace.mit.edu/bitstream/handle/1721.1/5854/AIM-199.pdf" rel="nofollow noreferrer">AIM-199</a> points out that this is essentially about the environments.</p>
     <p>Scheme is <a href="https://en.wikipedia.org/wiki/History_of_the_Scheme_programming_language#Influence" rel="nofollow noreferrer">the first</a> Lisp dialect <a href="https://en.wikipedia.org/wiki/Scheme_%28programming_language%29#Lexical_scope" rel="nofollow noreferrer">supporting lexical scoping</a> by default (dynamic scope can be simulated by <code>make-parameter</code>/<code>parameterize</code> forms in modern versions of Scheme). There were some debates in a later decade, but finally most Lisp dialects adopt the idea to default to lexical scoping, as many other languages do. Since then, closure, as an implementation technique, are more widely spread and more popular among PLs of different flavors.</p>
     <h2>Closures: the evolution</h2>
     <p>The original paper of Landin first defines an environment being a mathematical function mapping the name ("constant") to the named object ("primitive"). Then, it specifies the environment as "a list-structure made up of name/value pairs". The latter is also implemented in early Lisp implementation as <em>alist</em>s (associative lists), but modern language implementations do not necessarily follow such detail. In particular, environments can be <em>linked</em> to support nested closures, which is unlikely directly supported by abstract machines like SECD.</p>
     <p>Besides the environment, the other component of the "environment part" in Landin's paper is used to keep the names of bound variable(s) of the lambda abstractions (the formal parameter(s) of the functions). This is also optional (and likely missing) for modern implementations where the names of the parameters can be statically optimized away (spiritually granted by the alpha-renaming rules of lambda calculi), when there is no need to reflect the source information.</p>
     <p>Similarly, modern implementations may not save the syntactic constructs (AEs or lambda terms) directly as the control part. Instead, they may use some internal IR (intermediate representation) or the "compiled" form (e.g. FASL used by some implementations of Lisp dialects). Such IR is even not guaranteed to be generated from <code>lambda</code> forms (e.g. it can come from the body of some named functions).</p>
     <p>Moreover, the the environment part can save other information not for the evaluation for the lambda calculi. For example, <a href="https://web.wpi.edu/Pubs/ETD/Available/etd-090110-124904/unrestricted/jshutt.pdf" rel="nofollow noreferrer">it can keep an extra identifier to provide additional binding naming the environment at the call site</a>. This can implement languages based on extensions of lambda calculi.</p>
     <h2>Revisit of PL-specific terminology</h2>
     <p>Further, some languages may define "closure"-related terms in their specification to name entities may be implemented by closures. This is unfortunate because it leads to many misconceptions like "a closure is a function". But fortunately enough, most languages seem to avoid to name it directly as a syntactic construct in the language.</p>
     <p>Nevertheless, this is still better than the overloading more well-established common concepts arbitrary by language specifications. To name a few:</p>
     <ul>
      <li>
       <p>"objects" are redirected to "instance of classes" (in <a href="https://docs.oracle.com/javase/specs/jls/se17/html/index.html" rel="nofollow noreferrer">Java</a>/CLR/"OOP" languages) instead of <a href="https://www.ics.uci.edu/%7Ejajones/INF102-S18/readings/05_stratchey_1967.pdf" rel="nofollow noreferrer">traditional</a> "typed storage" (in C and <a href="http://www.eel.is/c++draft/" rel="nofollow noreferrer">C++</a>) or just "values" (in many Lisps);</p></li>
      <li>
       <p>"variables" are redirected to something traditional called "objects" (in <a href="https://go.dev/ref/spec" rel="nofollow noreferrer">Golang</a>) as well as mutable states (in many new languages), so it is no longer compatible to mathematics and pure functional languages;</p></li>
      <li>
       <p>"polymorphism" is restricted to <a href="https://en.wikipedia.org/wiki/Inclusion_polymorphism" rel="nofollow noreferrer">inclusion polymorphism</a> (in C++/"OOP" languages) even these languages do have other kinds of polymorphism (parametric polymorphism and ad-hoc polymorphism).</p></li>
     </ul>
     <h2>About the resource mangagement</h2>
     <p>Despite the components being ommited in modern implementations, the definitions in Landin's paper are fairly flexible. It does not limits how to store the components like the environments out of the contexts of SECD machine.</p>
     <p>In practice, various strategies are used. The most common and traditional way is making all resources owned by a global owner which can collect the resources not any longer in use, i.e. the (global) GC, first used in the LISP.</p>
     <p>Other ways may not need a global owner and have better locality to the closures, for example:</p>
     <ul>
      <li>
       <p>In C++, resources of entities captured in closures are allowed being managed explicitly by users, by specifying how to capture each variable in the lambda-expression's capture list (by value copy, by reference, or even by an explicit initializer) and the exact type of each variable (smart pointers or other types). This can be unsafe, but it gains more flexibility when used correctly.</p></li>
      <li>
       <p>In Rust, resources are captured with different capture modes (by immutable borrow, by borrow, by move) tried in turn (by the implementation), and users can specify explicit <code>move</code>. This is more conservative than C++, but safer in some sense (since borrows are statically checked, compared to unchecked by-reference captures in C++).</p></li>
     </ul>
     <p>All the strategies above can support closures (C++ and Rust do have the language-specific definitions of the concept "closure type"). The disciplines to manage the resources used by the closures have nothing to do of the qualification of the closures.</p>
     <p>So, (although not seen here,) <a href="http://lambda-the-ultimate.org/node/5007#comment-81721" rel="nofollow noreferrer">the claim of the necessity of graph tracing for closures by Thomas Lord at LtU</a> is also technically incorrect. Closures can solve the funarg problem because it allows preventing invalid accesses to the activation record (the stack), but the fact does not magically assert every operations on the resources comprising the closure <em>will</em> be valid. Such mechanism depend on the external execution environment. It should be clear, even in traditional implementations, the implicit owner (GC) is not a component <em>in</em> the closures, and the existence of the owner is the implementation detail of SECD machine (so it is one of the "high-order" details to the users). Whether such detail supports graph tracing or not has no effects on the qualification of closures. Besides, AFAIK, <a href="https://www.cs.kent.ac.uk/people/staff/dat/tfp12/tfp12.pdf" rel="nofollow noreferrer">the language constructs <code>let</code> combined with <code>rec</code> is first introduced (again by P. Landin) in ISWIM in 1966</a>, which could not have effects to enforce the original meaning of the closures invented earlier than itself.</p>
     <h1>The relationships</h1>
     <p>So, to sum them up, a closure can be (informally) defined as:</p>
     <p>(1) a PL implementation-specific data structure comprising as an environment part and a control part for a function-like entity, where:</p>
     <p>(1.1) the control part is derived from some source language constructs specifying the evaluation construct of the function-like entity;</p>
     <p>(1.2) the environment part is comprised by an environment and optionally other implementation-defined data;</p>
     <p>(1.3) the environment in (1.2) is determined by the potentially context-dependent source language constructs of the function-like entity, used to hold the captured free variables occurs in the evaluation construct of the source language constructs creating the function-like entity.</p>
     <p>(2) alternatively, the umbrella term of an implementation technique to utilize the entities named "closures" in (1).</p>
     <p>Lambda expressions (abstractions) are just <em>one of</em> the syntactic constructs in the source language to introduce (to create) unnamed function-like entities. A PL may provide it as the only way introduce the function-like entity.</p>
     <p>In general, there are no definite correspondence between lambda expressions in the source program and the existence of the closures in the execution of the program. As implementation details having no effects on the observable behavior of the program, a PL implementation is usually allowed to merge resources allocated for closures when possible, or totally omitting creating them when it does not matter on the program semantics:</p>
     <ul>
      <li>
       <p>The implementation can check the set of the free variables to be captured in the lambda expression, and when the set is empty, it can avoid introducing the environment part, so the function-like entity will not require a closure to be maintained. Such strategy is usually mandated in the rules of static languages.</p></li>
      <li>
       <p>Otherwise, the implementation may or may not always create a closure for a function-like entity resulted by evaluating the lambda expression whether there are variables to be captured.</p></li>
     </ul>
     <p>Lambda expressions may be evaluates to the function-like entity. Users of some PLs may call such a function-like entity a "closure". "Anonymous function" should be a more neutral name of such "closure" in this context.</p>
     <h1>Appendix: functions: the messy history</h1>
     <p>This is not directly tied to the problem, but it may also worth noting "functions" can name different entities in different contexts.</p>
     <p>It is already <a href="https://en.wikipedia.org/wiki/History_of_the_function_concept" rel="nofollow noreferrer">a mess in mathematics</a>.</p>
     <p>Currently I am too lazy to sum them up in the contexts of PLs, but as a caveat: keep an eye on the context to make sure the various definitions of "function" in different PLs not making your reasoning biased from the topic.</p>
     <p>As of the use "anonymous functions" in general (shared by PLs in practice), I believe it will not introduce significant confusions and misconceptions on this topic, though.</p>
     <p>Named functions may have a slightly more problems. Functions may denote the entity of the name themselves (the "symbols"), as well as the evaluated values of these names. Given that the fact that most PLs don't have unevaluated context to differentiate a function with some other entities carrying interesting meaning (e.g. <code>sizeof(a_plain_cxx_function)</code> in C++ just ill-formed), users may not observe the differences of the misinterpretation between unevaluated operand and evaluated values. That will be problematic with some Lisp dialects having <code>QUOTE</code>. <a href="https://eighty-twenty.org/2011/09/29/fexprs-remain-inscrutable#comment-418744898" rel="nofollow noreferrer">Even experienced PL specialists can easily miss something important</a>; this is also why I emphasize to distinguish syntactic constructs with other entities.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>DIPANSHU GOYAL</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Sep 2018 at 09:34</span>
     </div>
    </div>
    <div>
     <p>It depends on whether a function uses external variable or not to perform operation.</p>
     <p><strong>External variables</strong> - variables defined outside the scope of a function.</p>
     <ul>
      <li>
       <p>Lambda expressions are <strong>stateless</strong> because It depends on parameters, internal variables or constants to perform operations.</p>
       <pre><code>Function&lt;Integer,Integer&gt; lambda = t -&gt; {
    int n = 2
    return t * n 
}
</code></pre></li>
      <li>
       <p>Closures <strong>hold state</strong> because it uses external variables (i.e. variable defined outside the scope of the function body) along with parameters and constants to perform operations.</p>
       <pre><code>int n = 2

Function&lt;Integer,Integer&gt; closure = t -&gt; {
    return t * n 
}
</code></pre></li>
     </ul>
     <p>When Java creates closure, it keeps the variable n with the function so it can be referenced when passed to other functions or used anywhere.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>(1) The "external variable" has a better canonical name: "free variable". (2) Closures <i>can</i> hold states, but not always. They even do not need to hold references to variables if there are nothing to capture besides the bound variables (when the local environment meets the safe-for-space property, usually true for typical static languages).</span> <span> - </span> <span class="display-name">FrankHB</span> <span> </span> <span class="date">25 Jan 2022 at 14:44</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span> <span class="arrow"> <a href="#answer_15">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>mtmrv</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Aug 2021 at 09:59</span>
     </div>
    </div>
    <div>
     <p>The question is 12 years old and we still get it as the first link in Google for “closures vs lambda”. So I have to say it as no one did explicitly.</p>
     <p>Lambda expression is an anonymous function (declaration).</p>
     <p>And a closure, quoting <strong>Scott's Programming Language Pragmatics</strong> is explained as:</p>
     <blockquote>
      <p>… creating an explicit representation of a referencing environment (generally the one in which the subroutine would execute if called at the present time) and bundling it together with a reference to the subroutine … is referred to as a <strong>closure</strong>.</p>
     </blockquote>
     <p>That is, it is just as we call <em>the bundle</em> of “function + surrendering context”.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>The definition of closure here is more technically precise than some other answers of this question by emphasizing the "explicit representation", though still subtly problematic in many aspects (e.g. there actually can be more than one referencing environments being bundled, and the subroutine is not necessarily bundled via a reference).</span> <span> - </span> <span class="display-name">FrankHB</span> <span> </span> <span class="date">25 Jan 2022 at 14:58</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_15"><span>Answer 15</span> <span class="arrow"> <a href="#answer_14">↑</a> </span> <span class="arrow"> <a href="#answer_16">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>ap-osd</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Mar 2021 at 16:45</span>
     </div>
    </div>
    <div>
     <p>Lambda is an anonymous function <em>definition</em> that is not (necessarily) bound to an identifier.</p>
     <blockquote>
      <p>"Anonymous functions originate in the work of Alonzo Church in his invention of the lambda calculus, in which all functions are anonymous" - <a href="https://en.wikipedia.org/wiki/Anonymous_function" rel="nofollow noreferrer">Wikipedia</a></p>
     </blockquote>
     <p>Closure is the lambda function implementation.</p>
     <blockquote>
      <p>"Peter J. Landin defined the term closure in 1964 as having an environment part and a control part as used by his SECD machine for evaluating expressions" - <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)#History_and_etymology" rel="nofollow noreferrer">Wikipedia</a></p>
     </blockquote>
     <p>The generic explanation of Lambda and Closure is covered in the other responses.</p>
     <p>For those from a C++ background, Lambda expressions were introduced in C++11. Think of Lambdas as a convenient way to create anonymous functions and function objects.</p>
     <blockquote>
      <p>"The distinction between a lambda and the corresponding closure is precisely equivalent to the distinction between a class and an instance of the class. A class exists only in source code; it doesn’t exist at runtime. What exists at runtime are objects of the class type. Closures are to lambdas as objects are to classes. This should not be a surprise, because each lambda expression causes a unique class to be generated (during compilation) and also causes an object of that class type, a closure to be created (at runtime)." - <a href="http://scottmeyers.blogspot.com/2013/05/lambdas-vs-closures.html" rel="nofollow noreferrer">Scott Myers</a></p>
     </blockquote>
     <p>C++ allows us to examine the nuances of Lambda and Closure as you have to explicitly specify the free variables to be captured.</p>
     <p>In the sample below, the Lambda expression has no free variables, an empty capture list (<code>[]</code>). It’s essentially an ordinary function and no closure is required in the strictest sense. So it can even be passed as a function pointer argument.</p>
     <pre><code>void register_func(void(*f)(int val))   // Works only with an EMPTY capture list
{
    int val = 3;
    f(val);
}
 
int main() 
{
    int env = 5;
    register_func( [](int val){ /* lambda body can access only val variable*/ } );
}
</code></pre>
     <p>As soon as a free variable from the surrounding environment is introduced in the capture list (<code>[env]</code>), a Closure has to be generated.</p>
     <pre><code>    register_func( [env](int val){ /* lambda body can access val and env variables*/ } );
</code></pre>
     <p>Since this is no longer an ordinary function, but a closure instead, it produces a compilation error.<br><code>no suitable conversion function from "lambda []void (int val)-&gt;void" to "void (*)(int val)" exists</code></p>
     <p>The error can be fixed with a function wrapper <code>std::function</code> which accepts any callable target including a generated closure.</p>
     <pre><code>void register_func(std::function&lt;void(int val)&gt; f)
</code></pre>
     <p>See <a href="https://cognitivewaves.wordpress.com/lambda-and-closure/" rel="nofollow noreferrer">Lambda and Closure</a> for a detailed explanation with a C++ example.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>a closure is a pairing of a lambda function (i.e. function definition) and its definitional environment. end of story.</span> <span> - </span> <span class="display-name">Will Ness</span> <span> </span> <span class="date">29 Mar 2021 at 19:53</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@WillNess This is technically incorrect, as explained in a comment in Wei Qiu's answer. One more direct reason concerned here is that C++'s "closure" names some <i>C++ object</i> by definition.</span> <span> - </span> <span class="display-name">FrankHB</span> <span> </span> <span class="date">25 Jan 2022 at 14:51</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@FrankHB your comment makes no sense. the very answer to which you refer repeats that same point I made you object to. that answer ends with: "A closure is a pair of lambda and the corresponding environment". you might come to this from the modern C++ POV, but these are concepts well established in Lisp and its derived languages for half a century.</span> <span> - </span> <span class="display-name">Will Ness</span> <span> </span> <span class="date">25 Jan 2022 at 15:37</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@WillNess Your "makes no sense" comments exactly makes no sense by fading the <a href="https://en.wikipedia.org/wiki/Funarg_problem" rel="nofollow noreferrer">funargs problem</a> background out. That problem is first found and made popular by ancient LISP implementations, and (lexical) closures are exactly the solution to that problem. Ironically, <i>lexical</i> closures are <i>not</i> invented by Lisps, but ALGOL. The first Lisp dialect to adopt the solution is Scheme. The original LISP uses dynamic scoping, and in the next decade, most Lisp communities accept the change. That's the history you'd learnt, which has nothing to do with C++.</span> <span> - </span> <span class="display-name">FrankHB</span> <span> </span> <span class="date">27 Jan 2022 at 07:12</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@WillNess If you insists the more broadened extents, the term "closure" is coined by P. Landing in his SECD machine. True, this time it does not necessarily has something to do with "lexical", but it is also useless in the contexts here, because such closures are nothing necessary besides mandating of the lexical closures. In other words, without the significance of the lexical scoping, "closures" are just an historical implementation detail not qualified to be compared with "lambdas", which is always a source language device where it is available.</span> <span> - </span> <span class="display-name">FrankHB</span> <span> </span> <span class="date">27 Jan 2022 at 07:20</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@WillNess For historical interests, there are some additional points you did not caputured. (1) As an implementation detail, abstract machines like SECD are <i>not</i> specific implementations for Lisp-like languages. Roughly all dynamic languages based on some operational semantics with <code>eval</code> can share such implementation strategy. (2) More importantly, your advertised definition of "closure" <i>is</i> overly simplified compared to these abstract machines (SECD and all kinds of modern variants like CEK).</span> <span> - </span> <span class="display-name">FrankHB</span> <span> </span> <span class="date">27 Jan 2022 at 07:30</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>... Even in the pure PL sense with strongly Lisp-flavor's interpretation of the source language (instead of any machine-oriented semantics), the "pair" definition totally fails to distinguish the source forms ("quoted" ones) and the evaluated expressions. Lambdas, whether "abstractions" or "expressions", are the former; and closures are closed to the latter. The "pair" definition even does not reflect this very basic fact of the sense, which has been covered by several other answers here (in some rather unclear non-Lispy ways, though).</span> <span> - </span> <span class="display-name">FrankHB</span> <span> </span> <span class="date">27 Jan 2022 at 07:32</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@FrankHB I've no interest in being accused of something I did not do, and in fact the exact opposite of what I did. in the interests of clarity, I did not fade the funarg problem with my remarks, quite the opposite. I also did not claim that lambdas are syntax forms (which is an immaterial implementational detail anyway).</span> <span> - </span> <span class="display-name">Will Ness</span> <span> </span> <span class="date">27 Jan 2022 at 08:17</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@WillNess There are many details, but for the brevity: (1) you can't make overly simplified claims to get it just right; (2) lambda (despite the inaccuracy of the terminology itself) <i>is</i> the syntactic construct in either programming languages and their formal semantics (the λ symbol itself may occur in semantics), unless in some very specific contexts (usually related to rules of specific calculi). OK, I think I'd better to write an answer to clarify the problems here.</span> <span> - </span> <span class="display-name">FrankHB</span> <span> </span> <span class="date">27 Jan 2022 at 12:35</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_16"><span>Answer 16</span> <span class="arrow"> <a href="#answer_15">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Bahtiyar Özdere</span>
     </div>
     <div>
      <span> Answered: </span> <span>31 Jan 2023 at 14:35</span>
     </div>
    </div>
    <div>
     <p>Closure means a function returning another function. Not the result, but the callable function like delegates do. Lambda is an anonymous function description. A lambda can also be a closure if it returns a function.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>