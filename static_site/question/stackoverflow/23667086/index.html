<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>Why is my variable unaltered after I modify it inside of a function? - Asynchronous code reference</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>Why is my variable unaltered after I modify it inside of a function? - Asynchronous code reference</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>904</span>
    </div>
    <div>
     <span>Asker: </span> <span>Fabrício Matté</span>
    </div>
    <div>
     <span>Asked: </span> <span>14 May 2014 at 23:55</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/23667086">source</a>
    </div>
   </div>
   <div>
    <p>Given the following examples, why is <code>outerScopeVar</code> undefined in all cases?</p>
    <pre><code>var outerScopeVar;

var img = document.createElement('img');
img.onload = function() {
    outerScopeVar = this.width;
};
img.src = 'lolcat.png';
alert(outerScopeVar);
</code></pre>
    <pre><code>var outerScopeVar;
setTimeout(function() {
    outerScopeVar = 'Hello Asynchronous World!';
}, 0);
alert(outerScopeVar);
</code></pre>
    <pre><code>// Example using some jQuery
var outerScopeVar;
$.post('loldog', function(response) {
    outerScopeVar = response;
});
alert(outerScopeVar);
</code></pre>
    <pre><code>// Node.js example
var outerScopeVar;
fs.readFile('./catdog.html', function(err, data) {
    outerScopeVar = data;
});
console.log(outerScopeVar);
</code></pre>
    <pre><code>// with promises
var outerScopeVar;
myPromise.then(function (response) {
    outerScopeVar = response;
});
console.log(outerScopeVar);
</code></pre>
    <pre><code>// with observables
var outerScopeVar;
myObservable.subscribe(function (value) {
    outerScopeVar = value;
});
console.log(outerScopeVar);
</code></pre>
    <pre><code>// geolocation API
var outerScopeVar;
navigator.geolocation.getCurrentPosition(function (pos) {
    outerScopeVar = pos;
});
console.log(outerScopeVar);
</code></pre>
    <p>Why does it output <code>undefined</code> in all of these examples? I don't want workarounds, I want to know <strong>why</strong> this is happening.</p>
    <hr>
    <blockquote>
     <p><strong>Note:</strong> This is a canonical question for <em>JavaScript asynchronicity</em>. Feel free to improve this question and add more simplified examples which the community can identify with.</p>
    </blockquote>
   </div>
   <div class="tags">
    <span class="tag">javascript</span><span class="tag">asynchronous</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>11</td>
       <td><span>Related Meta discussion - <a href="http://meta.stackoverflow.com/q/254895">General JavaScript asynchronicity reference for close voting?</a></span> <span> - </span> <span class="display-name">Bernhard Barker</span> <span> </span> <span class="date">16 May 2014 at 00:02</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@Dukeling thanks, I'm pretty sure that I had commented with that link but there are apparently some missing comments. Also, regarding your edit: I believe having "canonical" and "asynchronicity" in the title helps when searching for this question to mark another question as a dupe. And of course, it also helps in finding this question from Google when looking for asynchronicity explanations.</span> <span> - </span> <span class="display-name">Fabrício Matté</span> <span> </span> <span class="date">16 May 2014 at 00:18</span></td>
      </tr>
      <tr>
       <td>8</td>
       <td><span>Putting a bit more of thought, "canonical asynchronicity topic" is a bit heavy on the title, "asynchronous code reference" is simpler and more objective. I also believe most people search for "asynchronous" instead of "asynchronicity".</span> <span> - </span> <span class="display-name">Fabrício Matté</span> <span> </span> <span class="date">20 May 2014 at 12:16</span></td>
      </tr>
      <tr>
       <td>4</td>
       <td><span>Some people initialize their variable before the function call. How about changing the title that somehow represents that as well? Like "Why is my variable <b>unaltered</b> after I modify it inside of a function?" ?</span> <span> - </span> <span class="display-name">Felix Kling</span> <span> </span> <span class="date">7 Jul 2014 at 08:32</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>In all the code examples that you have mentioned above, "alert(outerScopeVar);" executes NOW , whereas assigning of value to "outerScopeVar" happens LATER(asynchronously).</span> <span> - </span> <span class="display-name">refactor</span> <span> </span> <span class="date">3 May 2016 at 08:52</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>If possible, I'd like to include <a href="https://stackoverflow.com/q/4057440/1541563">this issue</a> in your question and community answer. <a href="https://stackoverflow.com/q/48573057/1541563">This self-answered question</a> suggests that some people believe that due to the Chrome lazy console evaluation bug, that the above pattern actually does work. Can we somehow include that in here or should that be a new question entirely?</span> <span> - </span> <span class="display-name">Patrick Roberts</span> <span> </span> <span class="date">1 Feb 2018 at 23:15</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>I added/modified the alerts in the first couple of samples so that I think the alerts show the answer. If that helps then I or someone can make corresponding edits to the other samples.</span> <span> - </span> <span class="display-name">Sam Hobbs</span> <span> </span> <span class="date">6 Dec 2018 at 20:35</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Does this answer your question? <a href="https://stackoverflow.com/questions/14220321/how-to-return-the-response-from-an-asynchronous-call">How to return the response from an asynchronous call</a></span> <span> - </span> <span class="display-name">user3840170</span> <span> </span> <span class="date">24 Jan 2022 at 15:30</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>715</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Fabrício Matté</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 May 2014 at 23:55</span>
     </div>
    </div>
    <div>
     <p>One word answer: <strong>asynchronicity</strong>.</p>
     <h2>Forewords</h2>
     <p>This topic has been iterated at least a couple of thousands of times here in Stack Overflow. Hence, first off I'd like to point out some extremely useful resources:</p>
     <ul>
      <li>
       <p><a href="https://stackoverflow.com/a/14220323/1331430">@Felix Kling's answer to "How do I return the response from an asynchronous call?"</a>. See his excellent answer explaining synchronous and asynchronous flows, as well as the "Restructure code" section.<br>
         @Benjamin Gruenbaum has also put a lot of effort into explaining asynchronicity in the same thread.</p></li>
      <li>
       <p><a href="https://stackoverflow.com/a/10058879/1331430">@Matt Esch's answer to "Get data from fs.readFile"</a> also explains asynchronicity extremely well in a simple manner.</p></li>
     </ul>
     <hr>
     <h2>The answer to the question at hand</h2>
     <p>Let's trace the common behavior first. In all examples, the <code>outerScopeVar</code> is modified inside of a <em>function</em>. That function is clearly not executed immediately; it is being assigned or passed as an argument. That is what we call a <em><strong>callback</strong></em>.</p>
     <p>Now the question is, when is that callback called?</p>
     <p>It depends on the case. Let's try to trace some common behavior again:</p>
     <ul>
      <li><code>img.onload</code> may be called <em>sometime in the future</em> when (and if) the image has successfully loaded.</li>
      <li><code>setTimeout</code> may be called <em>sometime in the future</em> after the delay has expired and the timeout hasn't been canceled by <code>clearTimeout</code>. Note: even when using <code>0</code> as delay, all browsers have a minimum timeout delay cap (specified to be 4ms in the HTML5 spec).</li>
      <li>jQuery <code>$.post</code>'s callback may be called <em>sometime in the future</em> when (and if) the Ajax request has been completed successfully.</li>
      <li>Node.js's <code>fs.readFile</code> may be called <em>sometime in the future</em> when the file has been read successfully or thrown an error.</li>
     </ul>
     <p>In all cases, we have a callback that may run <em>sometime in the future</em>. This "sometime in the future" is what we refer to as <strong>asynchronous flow</strong>.</p>
     <p>Asynchronous execution is pushed out of the synchronous flow. That is, the asynchronous code will <strong>never</strong> execute while the synchronous code stack is executing. This is the meaning of JavaScript being single-threaded.</p>
     <p>More specifically, when the JS engine is idle -- not executing a stack of (a)synchronous code -- it will poll for events that may have triggered asynchronous callbacks (e.g. expired timeout, received network response) and execute them one after another. This is regarded as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/EventLoop" rel="noreferrer">Event Loop</a>.</p>
     <p>That is, the asynchronous code highlighted in the hand-drawn red shapes may execute only after all the remaining synchronous code in their respective code blocks have executed:</p>
     <p><img src="40IwM.png" alt="async code highlighted"></p>
     <p>In short, the callback functions are created synchronously but executed asynchronously. You can't rely on the execution of an asynchronous function until you know it has been executed, and how to do that?</p>
     <p>It is simple, really. The logic that depends on the asynchronous function execution should be started/called from inside this asynchronous function. For example, moving the <code>alert</code>s and <code>console.log</code>s inside the callback function would output the expected result because the result is available at that point.</p>
     <h3>Implementing your own callback logic</h3>
     <p>Often you need to do more things with the result from an asynchronous function or do different things with the result depending on where the asynchronous function has been called. Let's tackle a bit more complex example:</p>
     <pre><code>var outerScopeVar;
helloCatAsync();
alert(outerScopeVar);

function helloCatAsync() {
    setTimeout(function() {
        outerScopeVar = 'Nya';
    }, Math.random() * 2000);
}
</code></pre>
     <p><strong>Note:</strong> I'm using <code>setTimeout</code> with a random delay as a generic asynchronous function; the same example applies to Ajax, <code>readFile</code>, <code>onload</code>, and any other asynchronous flow.</p>
     <p>This example clearly suffers from the same issue as the other examples; it is not waiting until the asynchronous function executes.</p>
     <p>Let's tackle it by implementing a callback system of our own. First off, we get rid of that ugly <code>outerScopeVar</code> which is completely useless in this case. Then we add a parameter that accepts a function argument, our callback. When the asynchronous operation finishes, we call this callback, passing the result. The implementation (please read the comments in order):</p>
     <pre><code>// 1. Call helloCatAsync passing a callback function,
//    which will be called receiving the result from the async operation
helloCatAsync(function(result) {
    // 5. Received the result from the async function,
    //    now do whatever you want with it:
    alert(result);
});

// 2. The "callback" parameter is a reference to the function which
//    was passed as an argument from the helloCatAsync call
function helloCatAsync(callback) {
    // 3. Start async operation:
    setTimeout(function() {
        // 4. Finished async operation,
        //    call the callback, passing the result as an argument
        callback('Nya');
    }, Math.random() * 2000);
}
</code></pre>
     <p>Code snippet of the above example:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>// 1. Call helloCatAsync passing a callback function,
//    which will be called receiving the result from the async operation
console.log("1. function called...")
helloCatAsync(function(result) {
    // 5. Received the result from the async function,
    //    now do whatever you want with it:
    console.log("5. result is: ", result);
});

// 2. The "callback" parameter is a reference to the function which
//    was passed as an argument from the helloCatAsync call
function helloCatAsync(callback) {
    console.log("2. callback here is the function passed as argument above...")
    // 3. Start async operation:
    setTimeout(function() {
    console.log("3. start async operation...")
    console.log("4. finished async operation, calling the callback, passing the result...")
        // 4. Finished async operation,
        //    call the callback passing the result as argument
        callback('Nya');
    }, Math.random() * 2000);
}</code></pre>
      </div>
     </div>
     <p></p>
     <p>Most often in real use cases, the DOM API and most libraries already provide the callback functionality (the <code>helloCatAsync</code> implementation in this demonstrative example). You only need to pass the callback function and understand that it will execute out of the synchronous flow and restructure your code to accommodate for that.</p>
     <p>You will also notice that due to the asynchronous nature, it is impossible to <code>return</code> a value from an asynchronous flow back to the synchronous flow where the callback was defined, as the asynchronous callbacks are executed long after the synchronous code has already finished executing.</p>
     <p>Instead of <code>return</code>ing a value from an asynchronous callback, you will have to make use of the callback pattern, or... Promises.</p>
     <h3>Promises</h3>
     <p>Although there are ways to keep the <a href="http://callbackhell.com/" rel="noreferrer">callback hell</a> at bay with vanilla JS, promises are growing in popularity and are currently being standardized in ES6 (see <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noreferrer">Promise - MDN</a>).</p>
     <p>Promises (a.k.a. Futures) provide a more linear, and thus pleasant, reading of the asynchronous code, but explaining their entire functionality is out of the scope of this question. Instead, I'll leave these excellent resources for the interested:</p>
     <ul>
      <li><a href="http://www.html5rocks.com/en/tutorials/es6/promises/" rel="noreferrer">JavaScript Promises - HTML5 Rocks</a></li>
      <li><a href="http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/" rel="noreferrer">You're Missing the Point of Promises - domenic.me</a></li>
     </ul>
     <hr>
     <h3>More reading material about JavaScript asynchronicity</h3>
     <ul>
      <li><a href="https://github.com/maxogden/art-of-node#callbacks" rel="noreferrer">The Art of Node - Callbacks</a> explains asynchronous code and callbacks very well with vanilla JS examples and Node.js code as well.</li>
     </ul>
     <hr>
     <blockquote>
      <p><strong>Note:</strong> I've marked this answer as Community Wiki. Hence anyone with at least 100 reputations can edit and improve it! Please feel free to improve this answer or submit a completely new answer if you'd like as well.</p>
      <p>I want to turn this question into a canonical topic to answer asynchronicity issues that are unrelated to Ajax (there is <a href="https://stackoverflow.com/q/14220321/1331430">How to return the response from an AJAX call?</a> for that), hence this topic needs your help to be as good and helpful as possible!</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>In your last example, is there a specific reason why you use anonymous functions or would it work the same by using named functions?</span> <span> - </span> <span class="display-name">JDelage</span> <span> </span> <span class="date">3 May 2016 at 21:34</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>The code examples are a bit weird as you're declaring the function after calling it. Works because of hoisting of course, but was it intentional?</span> <span> - </span> <span class="display-name">Bergi</span> <span> </span> <span class="date">5 May 2016 at 22:12</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>is it deadlock . felix kling is pointing to your answer and you are pointing to felix answer</span> <span> - </span> <span class="display-name">Mahi</span> <span> </span> <span class="date">2 Jan 2017 at 10:23</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>You need to understand that the red circle code is only async because it is being executed by NATIVE async javascript functions. This is a feature of your javascript engine--whether it be Node.js or a browser. It is async because it is being passed in as a "callback" to a function that is essentially a black box (implemented in C etc..). To the hapless developer they are async...just because. If you want to write your own async function you have to hack it by sending it in to SetTimeout(myfunc,0). Should you do that? Another debate....probably not.</span> <span> - </span> <span class="display-name">Sean Anderson</span> <span> </span> <span class="date">5 Jan 2017 at 19:08</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>How would this work if the functions being called were in a separate file?</span> <span> - </span> <span class="display-name">The_Redhawk</span> <span> </span> <span class="date">19 Mar 2022 at 17:52</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>191</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Matt</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 May 2014 at 09:09</span>
     </div>
    </div>
    <div>
     <p><em>Fabrício's answer is spot on; but I wanted to complement his answer with something less technical, which focusses on an analogy to help explain the concept of asynchronicity</em>.</p>
     <hr>
     <h3>An Analogy...</h3>
     <p>Yesterday, the work I was doing required some information from a colleague. I rang him up; here's how the conversation went:</p>
     <blockquote>
      <p><strong>Me</strong>: Hi Bob, I need to know how we <em>foo</em>'d the <em>bar</em>'d last week. Jim wants a report on it, and you're the only one who knows the details about it.</p>
     </blockquote>
     <blockquote>
      <p><strong>Bob</strong>: Sure thing, but it'll take me around 30 minutes?</p>
     </blockquote>
     <blockquote>
      <p><strong>Me</strong>: That's great Bob. Give me a ring back when you've got the information!</p>
     </blockquote>
     <p>At this point, I hung up the phone. Since I needed information from Bob to complete my report, I left the report and went for a coffee instead, then I caught up on some email. 40 minutes later (Bob is slow), Bob called back and gave me the information I needed. At this point, I resumed my work with my report, as I had all the information I needed.</p>
     <hr>
     <p>Imagine if the conversation had gone like this instead;</p>
     <blockquote>
      <p><strong>Me</strong>: Hi Bob, I need to know how we <em>foo</em>'d the <em>bar</em>'d last week. Jim want's a report on it, and you're the only one who knows the details about it.</p>
     </blockquote>
     <blockquote>
      <p><strong>Bob</strong>: Sure thing, but it'll take me around 30 minutes?</p>
     </blockquote>
     <blockquote>
      <p><strong>Me</strong>: That's great Bob. I'll wait.</p>
     </blockquote>
     <p>And I sat there and waited. And waited. And waited. For 40 minutes. Doing nothing but waiting. Eventually, Bob gave me the information, we hung up, and I completed my report. But I'd lost 40 minutes of productivity.</p>
     <hr>
     <h3>This is asynchronous vs. synchronous behavior</h3>
     <p>This is exactly what is happening in all the examples in our question. Loading an image, loading a file off disk, and requesting a page via AJAX are all slow operations (in the context of modern computing).</p>
     <p>Rather than <em>waiting</em> for these slow operations to complete, JavaScript lets you register a callback function which will be executed when the slow operation has completed. In the meantime, however, JavaScript will continue to execute other code. The fact that JavaScript executes <em>other code</em> whilst waiting for the slow operation to complete makes the behavior<strong>asynchronous</strong>. Had JavaScript waited around for the operation to complete before executing any other code, this would have been <strong>synchronous</strong> behavior.</p>
     <pre><code>var outerScopeVar;    
var img = document.createElement('img');

// Here we register the callback function.
img.onload = function() {
    // Code within this function will be executed once the image has loaded.
    outerScopeVar = this.width;
};

// But, while the image is loading, JavaScript continues executing, and
// processes the following lines of JavaScript.
img.src = 'lolcat.png';
alert(outerScopeVar);
</code></pre>
     <p>In the code above, we're asking JavaScript to load <code>lolcat.png</code>, which is a <em>sloooow</em> operation. The callback function will be executed once this slow operation has done, but in the meantime, JavaScript will keep processing the next lines of code; i.e. <code>alert(outerScopeVar)</code>.</p>
     <p>This is why we see the alert showing <code>undefined</code>; since the <code>alert()</code> is processed immediately, rather than after the image has been loaded.</p>
     <p>In order to fix our code, all we have to do is move the <code>alert(outerScopeVar)</code> code <em>into</em> the callback function. As a consequence of this, we no longer need the <code>outerScopeVar</code> variable declared as a global variable.</p>
     <pre><code>var img = document.createElement('img');

img.onload = function() {
    var localScopeVar = this.width;
    alert(localScopeVar);
};

img.src = 'lolcat.png';
</code></pre>
     <p>You'll <strong><em>always</em></strong> see a callback is specified as a function, because that's the only* way in JavaScript to define some code, but not execute it until later.</p>
     <p>Therefore, in all of our examples, the <code>function() { /* Do something */ }</code> is the callback; to fix <strong>all</strong> the examples, all we have to do is move the code which needs the response of the operation into there!</p>
     <p><sup>* Technically you can use <code>eval()</code> as well, but <a href="https://stackoverflow.com/questions/86513/why-is-using-the-javascript-eval-function-a-bad-idea"><code>eval()</code> is evil</a> for this purpose</sup></p>
     <hr>
     <h3>How do I keep my caller waiting?</h3>
     <p>You might currently have some code similar to this;</p>
     <pre><code>function getWidthOfImage(src) {
    var outerScopeVar;

    var img = document.createElement('img');
    img.onload = function() {
        outerScopeVar = this.width;
    };
    img.src = src;
    return outerScopeVar;
}

var width = getWidthOfImage('lolcat.png');
alert(width);
</code></pre>
     <p>However, we now know that the <code>return outerScopeVar</code> happens immediately; before the <code>onload</code> callback function has updated the variable. This leads to <code>getWidthOfImage()</code> returning <code>undefined</code>, and <code>undefined</code> being alerted.</p>
     <p>To fix this, we need to allow the function calling <code>getWidthOfImage()</code> to register a callback, then move the alert'ing of the width to be within that callback;</p>
     <pre><code>function getWidthOfImage(src, cb) {     
    var img = document.createElement('img');
    img.onload = function() {
        cb(this.width);
    };
    img.src = src;
}

getWidthOfImage('lolcat.png', function (width) {
    alert(width);
});
</code></pre>
     <p>... as before, note that we've been able to remove the global variables (in this case <code>width</code>).</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>12</td>
        <td><span>But how is alerting or sending to console useful if you want to use the results in a different calculation, or store it in an object variable?</span> <span> - </span> <span class="display-name">Ken Ingram</span> <span> </span> <span class="date">22 Mar 2019 at 21:51</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>This is the most useful, quick and concise answer on the entire stackoverflow. Thanks.</span> <span> - </span> <span class="display-name">MasterMind</span> <span> </span> <span class="date">31 May 2021 at 13:22</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The final code example shows the usage of another parameter - here src - that is not related with with the callback function and that is even inserted in code after the callback. Short and concise as Mastermind writes!</span> <span> - </span> <span class="display-name">Timo</span> <span> </span> <span class="date">6 Mar 2022 at 07:48</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>How do I know that <code>img.onload=function(){..</code> is asynchronous when I maybe could rewrite it to <code>function img.onload(){..</code> which is not possible but which seems synchronous. LIes it in the JS feeling that one should get after reading a lot of this shit?</span> <span> - </span> <span class="display-name">Timo</span> <span> </span> <span class="date">6 Mar 2022 at 08:15</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>95</span>
     </div>
     <div>
      <span>Answerer: </span> <span>JohnnyHK</span>
     </div>
     <div>
      <span> Answered: </span> <span>20 Jan 2015 at 23:42</span>
     </div>
    </div>
    <div>
     <p>Here's a more concise answer for people that are looking for a quick reference as well as some examples using promises and async/await.</p>
     <p>Start with the naive approach (that doesn't work) for a function that calls an asynchronous method (in this case <code>setTimeout</code>) and returns a message:</p>
     <pre><code>function getMessage() {
  var outerScopeVar;
  setTimeout(function() {
    outerScopeVar = 'Hello asynchronous world!';
  }, 0);
  return outerScopeVar;
}
console.log(getMessage());
</code></pre>
     <p><code>undefined</code> gets logged in this case because <code>getMessage</code> returns before the <code>setTimeout</code> callback is called and updates <code>outerScopeVar</code>.</p>
     <p>The two main ways to solve it are using <strong>callbacks</strong> and <strong>promises</strong>:</p>
     <p><strong>Callbacks</strong></p>
     <p>The change here is that <code>getMessage</code> accepts a <code>callback</code> parameter that will be called to deliver the results back to the calling code once available.</p>
     <pre><code>function getMessage(callback) {
  setTimeout(function() {
    callback('Hello asynchronous world!');
  }, 0);
}
getMessage(function(message) {
  console.log(message);
});
</code></pre>
     <p><strong><a href="https://developers.google.com/web/fundamentals/primers/promises" rel="noreferrer">Promises</a></strong></p>
     <p>Promises provide an alternative which is more flexible than callbacks because they can be naturally combined to coordinate multiple async operations. A <a href="https://promisesaplus.com/" rel="noreferrer">Promises/A+</a> standard implementation is natively provided in node.js (0.12+) and many current browsers, but is also implemented in libraries like <a href="https://github.com/petkaantonov/bluebird" rel="noreferrer">Bluebird</a> and <a href="https://github.com/kriskowal/q" rel="noreferrer">Q</a>.</p>
     <pre><code>function getMessage() {
  return new Promise(function(resolve, reject) {
    setTimeout(function() {
      resolve('Hello asynchronous world!');
    }, 0);
  });
}

getMessage().then(function(message) {
  console.log(message);  
});
</code></pre>
     <p><strong>jQuery <a href="http://api.jquery.com/category/deferred-object/" rel="noreferrer">Deferreds</a></strong></p>
     <p>jQuery provides functionality that's similar to promises with its Deferreds.</p>
     <pre><code>function getMessage() {
  var deferred = $.Deferred();
  setTimeout(function() {
    deferred.resolve('Hello asynchronous world!');
  }, 0);
  return deferred.promise();
}

getMessage().done(function(message) {
  console.log(message);  
});
</code></pre>
     <p><strong>async/await</strong></p>
     <p>If your JavaScript environment includes support for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noreferrer"><code>async</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" rel="noreferrer"><code>await</code></a> (like Node.js 7.6+), then you can use promises synchronously within <code>async</code> functions:</p>
     <pre><code>function getMessage () {
    return new Promise(function(resolve, reject) {
        setTimeout(function() {
            resolve('Hello asynchronous world!');
        }, 0);
    });
}

async function main() {
    let message = await getMessage();
    console.log(message);
}

main();
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>Your sample on Promises is basically what I've been searching for, for the past few hours. Your example is beautiful and explains Promises at the same time. Why this is not anywhere else is boggling.</span> <span> - </span> <span class="display-name">Vincent P</span> <span> </span> <span class="date">8 Jan 2016 at 08:40</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This is all fine, but what if you need to call getMessage() with parameters? How would you write the above in that scenario?</span> <span> - </span> <span class="display-name">Chiwda</span> <span> </span> <span class="date">1 Aug 2017 at 17:51</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@Chiwda You just put the callback parameter last: <code>function getMessage(param1, param2, callback) {...}</code>.</span> <span> - </span> <span class="display-name">JohnnyHK</span> <span> </span> <span class="date">1 Aug 2017 at 19:09</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The $.Deferred() implementation you provided is just what I was looking for with jQuery, since I'm running old packages, thank you.</span> <span> - </span> <span class="display-name">Daggerpov</span> <span> </span> <span class="date">30 May 2023 at 20:53</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>61</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Johannes Fahrenkrug</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Dec 2015 at 16:48</span>
     </div>
    </div>
    <div>
     <p>To state the obvious, the cup represents <code>outerScopeVar</code>.</p>
     <p>Asynchronous functions be like...</p>
     <p><a href="https://i.stack.imgur.com/yCASc.jpg"><img src="yCASc.jpg" alt="asynchronous call for coffee"></a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>17</td>
        <td><span>Whereas trying to make an asynchronous function act synchronously would be trying to drink the coffee at 1 second, and having it poured into your lap at 1 minute.</span> <span> - </span> <span class="display-name">Teepeemm</span> <span> </span> <span class="date">10 Dec 2015 at 15:22</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>If it were stating the obvious, I don't think the question would have been asked, No?</span> <span> - </span> <span class="display-name">broccoli2000</span> <span> </span> <span class="date">3 Jul 2016 at 13:10</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@broccoli2000 By that I didn't mean that the question was obvious, but that it's obvious what the cup represents in the drawing :)</span> <span> - </span> <span class="display-name">Johannes Fahrenkrug</span> <span> </span> <span class="date">29 Sep 2016 at 19:24</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>If the cup is the variable, then where is the function?</span> <span> - </span> <span class="display-name">JoePythonKing</span> <span> </span> <span class="date">9 Jan 2022 at 20:58</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>16</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Teja</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Feb 2016 at 03:59</span>
     </div>
    </div>
    <div>
     <p>The other answers are excellent and I just want to provide a straight forward answer to this. Just limiting to jQuery asynchronous calls</p>
     <p>All ajax calls (including the <code>$.get</code> or <code>$.post</code> or <code>$.ajax</code>) are asynchronous.</p>
     <p>Considering your example</p>
     <pre><code>var outerScopeVar;  //line 1
$.post('loldog', function(response) {  //line 2
    outerScopeVar = response;
});
alert(outerScopeVar);  //line 3
</code></pre>
     <p>The code execution starts from line 1, declares the variable and triggers and asynchronous call on line 2, (i.e., the post request) and it continues its execution from line 3, without waiting for the post request to complete its execution.</p>
     <p>Lets say that the post request takes 10 seconds to complete, the value of <code>outerScopeVar</code> will only be set after those 10 seconds.</p>
     <p>To try out,</p>
     <pre><code>var outerScopeVar; //line 1
$.post('loldog', function(response) {  //line 2, takes 10 seconds to complete
    outerScopeVar = response;
});
alert("Lets wait for some time here! Waiting is fun");  //line 3
alert(outerScopeVar);  //line 4
</code></pre>
     <p>Now when you execute this, you would get an alert on line 3. Now wait for some time until you are sure the post request has returned some value. Then when you click OK, on the alert box, next alert would print the expected value, because you waited for it.</p>
     <p>In real life scenario, the code becomes,</p>
     <pre><code>var outerScopeVar;
$.post('loldog', function(response) {
    outerScopeVar = response;
    alert(outerScopeVar);
});
</code></pre>
     <p>All the code that depends on the asynchronous calls, is moved inside the asynchronous block, or by waiting on the asynchronous calls.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>12</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Tom Sebastian</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Oct 2015 at 06:35</span>
     </div>
    </div>
    <div>
     <p>In all these scenarios <code>outerScopeVar</code> is modified or assigned a value <strong>asynchronously</strong> or <strong>happening in a later time(waiting or listening for some event to occur),for which the current execution will not wait</strong>.So all these cases current execution flow results in <code>outerScopeVar = undefined</code></p>
     <p>Let's discuss each examples(I marked the portion which is called asynchronously or delayed for some events to occur):</p>
     <p><strong>1.</strong></p>
     <p><a href="https://i.stack.imgur.com/Ck9q6.png" rel="noreferrer"><img src="Ck9q6.png" alt="enter image description here"></a></p>
     <p>Here we register an eventlistner which will be executed upon that particular event.Here loading of image.Then the current execution continuous with next lines <code>img.src = 'lolcat.png';</code> and <code>alert(outerScopeVar);</code> meanwhile the event may not occur. i.e, funtion <code>img.onload</code> wait for the referred image to load, asynchrously. This will happen all the folowing example- the event may differ.</p>
     <p><strong>2.</strong></p>
     <p><a href="https://i.stack.imgur.com/rOzdX.png" rel="noreferrer"><img src="rOzdX.png" alt="2"></a></p>
     <p>Here the timeout event plays the role, which will invoke the handler after the specified time. Here it is <code>0</code>, but still it registers an asynchronous event it will be added to the last position of the <code>Event Queue</code> for execution, which makes the guaranteed delay.</p>
     <p><strong>3.</strong></p>
     <p><a href="https://i.stack.imgur.com/2VpYE.png" rel="noreferrer"><img src="2VpYE.png" alt="enter image description here"></a> This time ajax callback.</p>
     <p><strong>4.</strong></p>
     <p><a href="https://i.stack.imgur.com/p8ZrL.png" rel="noreferrer"><img src="p8ZrL.png" alt="enter image description here"></a></p>
     <p>Node can be consider as a king of asynchronous coding.Here the marked function is registered as a callback handler which will be executed after reading the specified file.</p>
     <p><strong>5.</strong></p>
     <p><a href="https://i.stack.imgur.com/vpmGy.png" rel="noreferrer"><img src="vpmGy.png" alt="enter image description here"></a></p>
     <p>Obvious promise (something will be done in future) is asynchronous. see <a href="https://stackoverflow.com/questions/6801283/what-are-the-differences-between-deferred-promise-and-future-in-javascript">What are the differences between Deferred, Promise and Future in JavaScript?</a></p>
     <p><a href="https://www.quora.com/Whats-the-difference-between-a-promise-and-a-callback-in-Javascript" rel="noreferrer">https://www.quora.com/Whats-the-difference-between-a-promise-and-a-callback-in-Javascript</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>samnoon</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Jul 2022 at 05:46</span>
     </div>
    </div>
    <div>
     <p>The short answer is : <strong>asynchronicity.</strong></p>
     <p><strong>Why asynchronous is needed?</strong></p>
     <p>JavaScript is single-threaded, meaning that two bits of the script cannot run at the same time; they have to run one after another. In browsers, JavaScript shares a thread with a load of other stuff that differs from browser to browser. But typically JavaScript is in the same queue as painting, updating styles, and handling user actions (such as highlighting text and interacting with form controls). Activity in one of these things delays the others.</p>
     <p>You've probably used events and callbacks to get around this. Here are events:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>var img1 = document.querySelector('.img-1');

img1.addEventListener('load', function() {
  // image loaded
  console.log("Loaded");
});

img1.addEventListener('error', function() {
  // error caught
  console.log("Error printed");
});</code></pre>
       <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;img class="img-1" src="#" alt="img"&gt;</code></pre>
      </div>
     </div>
     <p></p>
     <p>This isn't sneezy at all. We get the image, add a couple of listeners, then JavaScript can stop executing until one of those listeners is called.</p>
     <p>Unfortunately, in the example above, it's possible that the events happened before we started listening for them, so we need to work around that using the "complete" property of images:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>var img1 = document.querySelector('.img-1');

function loaded() {
  // image loaded
  console.log("Loaded");
}

if (img1.complete) {
  loaded();
} else {
  img1.addEventListener('load', loaded);
}

img1.addEventListener('error', function() {
  // error caught
  console.log("Error printed");
});</code></pre>
       <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;img class="img-1" src="#" alt="img"&gt;</code></pre>
      </div>
     </div>
     <p></p>
     <p>This doesn't catch images that errored before we got a chance to listen for them; unfortunately, the DOM doesn't give us a way to do that. Also, this is loading one image. Things get even more complex if we want to know when a set of images have loaded.</p>
     <p><strong>Events aren't always the best way</strong></p>
     <p>Events are great for things that can happen multiple times on the same object— <code>keyup</code>, <code>touchstart</code> etc. With those events, you don't really care about what happened before you attached the listener.</p>
     <p>The two main ways to do it correctly: are callbacks and promises.</p>
     <p><strong>Callbacks</strong></p>
     <p>Callbacks are functions that are passed inside the arguments of other functions, this procedure is valid in JavaScript because functions are objects and objects can be passed as arguments to functions. The basic structure of the callback function looks something like this:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function getMessage(callback) {
  callback();
}

function showMessage() {
  console.log("Hello world! I am a callback");
}
getMessage(showMessage);</code></pre>
      </div>
     </div>
     <p></p>
     <p><strong>Promise</strong></p>
     <p>Although there are ways to keep the callback hell at bay with vanilla JS, promises are growing in popularity and are currently being standardized in ES6 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="nofollow noreferrer">(see Promise)</a>.</p>
     <p>A <strong>promise</strong> is a placeholder representing the eventual result (value) of an asynchronous operation</p>
     <ul>
      <li>the promise placeholder will be replaced by the result value (if successful) or reason for failure (if unsuccessful)</li>
     </ul>
     <p><em><strong>If you don't need to know when something happened, but just whether it happened or not, then a promise is what you are looking for.</strong></em></p>
     <p>A promise is a bit like an event listener, except that:</p>
     <ul>
      <li>a promise can only succeed or fail once</li>
      <li>a promise can't switch from fail to success, or vice versa</li>
      <li>once you have a result, the promise is immutable</li>
      <li>if a promise has succeeded or failed, and you later add a success/failure callback, the correct callback will be called</li>
      <li>it doesn't matter that the event occurred before you added the callback</li>
     </ul>
     <p><strong>Note: Always return a result from a function inside a Promise, otherwise there's nothing for the subsequent function to act on.</strong></p>
     <p><strong>Promise Terminology</strong></p>
     <p>A promise can be:</p>
     <ul>
      <li>fulfilled: The action relating to the promise succeeded 
       <ul>
        <li>the asynchronous operation has completed</li>
        <li>the promise has a value</li>
        <li>the promise will not change again</li>
       </ul></li>
      <li>rejected: The action relating to the promise failed 
       <ul>
        <li>the asynchronous operation failed</li>
        <li>the promise will never be fulfilled</li>
        <li>the promise has a reason indicating why the operation failed</li>
        <li>the promise will not change again</li>
       </ul></li>
      <li>pending: Hasn't fulfilled or rejected yet 
       <ul>
        <li>the asynchronous operation hasn't been completed yet</li>
        <li>can transition to fulfilled or rejected</li>
       </ul></li>
      <li>settled: Has been fulfilled or rejected and is thus immutable</li>
     </ul>
     <p><strong>How to Create a Promise</strong></p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function getMessage() {
  return new Promise(function(resolve, reject) {
    setTimeout(function() {
      resolve('Hello world! I am a promise');
    }, 0);
  });
}

getMessage().then(function(message) {
  console.log(message);
});</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>