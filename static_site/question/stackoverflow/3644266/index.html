<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>How can we match a^n b^n?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>How can we match a^n b^n?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>108</span>
    </div>
    <div>
     <span>Asker: </span> <span>polygenelubricants</span>
    </div>
    <div>
     <span>Asked: </span> <span>4 Sep 2010 at 22:49</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/3644266/how-can-we-match-an-bn">source</a>
    </div>
   </div>
   <div>
    <blockquote>
     <p><sub><em>This is the second part of a series of educational regex articles. It shows how lookaheads and nested references can be used to match the non-regular languge a<sup>n</sup>b<sup>n</sup>. Nested references are first introduced in: <a href="https://stackoverflow.com/questions/3627681/how-does-this-regex-find-triangular-numbers/">How does this regex find triangular numbers?</a></em></sub></p>
    </blockquote>
    <p>One of the archetypal non-<a href="http://en.wikipedia.org/wiki/Regular_language" rel="noreferrer">regular languages</a> is:</p>
    <blockquote>
     <p><code>L = { a</code><sup>n</sup><code>b</code><sup>n</sup><code>: n &gt; 0 }</code></p>
    </blockquote>
    <p>This is the language of all non-empty strings consisting of some number of <code>a</code>'s followed by an equal number of <code>b</code>'s. Examples of strings in this language are <code>ab</code>, <code>aabb</code>, <code>aaabbb</code>.</p>
    <p>This language can be show to be non-regular by the <a href="http://en.wikipedia.org/wiki/Pumping_lemma_for_regular_languages" rel="noreferrer">pumping lemma</a>. It is in fact an archetypal <a href="http://en.wikipedia.org/wiki/Context-free_language" rel="noreferrer">context-free language</a>, which can be generated by the <a href="http://en.wikipedia.org/wiki/Context-free_language" rel="noreferrer">context-free grammar</a> <code>S → aSb | ab</code>.</p>
    <p>Nonetheless, modern day regex implementations clearly recognize more than just regular languages. That is, they are not "regular" by formal language theory definition. PCRE and Perl supports recursive regex, and .NET supports balancing groups definition. Even less "fancy" features, e.g. backreference matching, means that regex is not regular.</p>
    <p>But just how powerful is this "basic" features? Can we recognize <code>L</code> with Java regex, for example? Can we perhaps combine lookarounds and nested references and have a pattern that works with e.g. <a href="http://download.oracle.com/javase/6/docs/api/java/lang/String.html#matches%28java.lang.String%29" rel="noreferrer"><code>String.matches</code></a> to match strings like <code>ab</code>, <code>aabb</code>, <code>aaabbb</code>, etc?</p>
    <h3>References</h3>
    <ul>
     <li><a href="http://perldoc.perl.org/perlfaq6.html#Can-I-use-Perl-regular-expressions-to-match-balanced-text?" rel="noreferrer">perlfaq6: Can I use Perl regular expressions to match balanced text?</a></li>
     <li><a href="http://msdn.microsoft.com/en-us/library/bs2twtah.aspx#balancing_group_definition" rel="noreferrer">MSDN - Regular Expression Language Elements - Balancing Group Definitions</a></li>
     <li><a href="http://www.pcre.org/pcre.txt" rel="noreferrer">pcre.org - PCRE man page</a></li>
     <li><a href="http://www.regular-expressions.info/" rel="noreferrer">regular-expressions.info</a> - <a href="http://www.regular-expressions.info/lookaround.html" rel="noreferrer">Lookarounds</a> and <a href="http://www.regular-expressions.info/brackets.html" rel="noreferrer">Grouping and Backreferences</a></li>
     <li><a href="http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html" rel="noreferrer"><code>java.util.regex.Pattern</code></a></li>
    </ul>
    <h3>Linked questions</h3>
    <ul>
     <li><a href="https://stackoverflow.com/questions/2974210/does-lookaround-affect-which-languages-can-be-matched-by-regular-expressions">Does lookaround affect which languages can be matched by regular expressions?</a></li>
     <li><a href="https://stackoverflow.com/questions/3349999/net-regex-recursive-patterns">.NET Regex Balancing Groups vs PCRE Recursive Patterns</a></li>
    </ul>
   </div>
   <div class="tags">
    <span class="tag">regex</span><span class="tag">regex-lookarounds</span><span class="tag">capturing-group</span><span class="tag">nested-reference</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>5</td>
       <td><span>This series was started by permission of some in the community (<a href="http://meta.stackexchange.com/questions/62695/permission-to-start-a-series-of-advanced-regex-articles" title="permission to start a series of advanced regex articles">meta.stackexchange.com/questions/62695/…</a>). If the reception is good, I plan to continue to cover other more advanced as well as more basic features of regex.</span> <span> - </span> <span class="display-name">polygenelubricants</span> <span> </span> <span class="date">4 Sep 2010 at 22:52</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Part 3: <a href="http://stackoverflow.com/questions/3664881/how-does-this-java-regex-detect-palindromes" title="how does this java regex detect palindromes">stackoverflow.com/questions/3664881/…</a></span> <span> - </span> <span class="display-name">polygenelubricants</span> <span> </span> <span class="date">8 Sep 2010 at 05:43</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>Wow, I never knew Java's regexs won't restricted to regular expressions. I guess that explains why I've always thought they won't fully implemented. What I mean is that there are no complement, difference, or product operators built into Java Regexs, but that makes sense since they aren't restricted to Regular Languages.</span> <span> - </span> <span class="display-name">Lan</span> <span> </span> <span class="date">5 Nov 2013 at 13:53</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>This question has been added to the <a href="http://stackoverflow.com/a/22944075/2736496">Stack Overflow Regular Expression FAQ</a>, under "Advanced Regex-Fu".</span> <span> - </span> <span class="display-name">aliteralmind</span> <span> </span> <span class="date">10 Apr 2014 at 01:38</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>154</span>
     </div>
     <div>
      <span>Answerer: </span> <span>polygenelubricants</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Sep 2010 at 22:50</span>
     </div>
    </div>
    <div>
     <p>The answer is, needless to say, <em>YES!</em> You can most certainly write a Java regex pattern to match <em>a<sup>n</sup>b<sup>n</sup></em>. It uses a positive lookahead for assertion, and one nested reference for "counting".</p>
     <p>Rather than immediately giving out the pattern, this answer will guide readers through <em>the process</em> of deriving it. Various hints are given as the solution is slowly constructed. In this aspect, hopefully this answer will contain much more than just another neat regex pattern. Hopefully readers will also learn how to "think in regex", and how to put various constructs harmoniously together, so they can derive more patterns on their own in the future.</p>
     <p>The language used to develop the solution will be PHP for its conciseness. The final test once the pattern is finalized will be done in Java.</p>
     <hr>
     <h3>Step 1: Lookahead for assertion</h3>
     <p>Let's start with a simpler problem: we want to match <code>a+</code> at the beginning of a string, but only if it's followed immediately by <code>b+</code>. We can use <code>^</code> to <a href="http://www.regular-expressions.info/anchors.html" rel="noreferrer">anchor</a> our match, and since we only want to match the <code>a+</code> without the <code>b+</code>, we can use <a href="http://www.regular-expressions.info/lookaround.html" rel="noreferrer">lookahead</a> assertion <code>(?=…)</code>.</p>
     <p>Here is our pattern with a simple test harness:</p>
     <pre><code>function testAll($r, $tests) {
   foreach ($tests as $test) {
      $isMatch = preg_match($r, $test, $groups);
      $groupsJoined = join('|', $groups);
      print("$test $isMatch $groupsJoined\n");
   }
}
 
$tests = array('aaa', 'aaab', 'aaaxb', 'xaaab', 'b', 'abbb');
 
$r1 = '/^a+(?=b+)/';
#          └────┘
#         lookahead

testAll($r1, $tests);
</code></pre>
     <p>The output is (<a href="http://ideone.com/wo233" rel="noreferrer">as seen on ideone.com</a>):</p>
     <pre><code>aaa 0
aaab 1 aaa
aaaxb 0
xaaab 0
b 0
abbb 1 a
</code></pre>
     <p>This is exactly the output we want: we match <code>a+</code>, only if it's at the beginning of the string, and only if it's immediately followed by <code>b+</code>.</p>
     <p><em><strong>Lesson</strong></em>: You can use patterns in lookarounds to make assertions.</p>
     <hr>
     <h3>Step 2: Capturing in a lookahead (and f r e e - s p a c i n g mode)</h3>
     <p>Now let's say that even though we don't want the <code>b+</code> to be part of the match, we do want to <a href="http://www.regular-expressions.info/brackets.html" rel="noreferrer">capture</a> it anyway into group 1. Also, as we anticipate having a more complicated pattern, let's use <code>x</code> modifier for <a href="http://www.regular-expressions.info/freespacing.html" rel="noreferrer">free-spacing</a> so we can make our regex more readable.</p>
     <p>Building on our previous PHP snippet, we now have the following pattern:</p>
     <pre><code>$r2 = '/ ^ a+ (?= (b+) ) /x';
#             │   └──┘ │
#             │     1  │
#             └────────┘
#              lookahead
 
testAll($r2, $tests);
</code></pre>
     <p>The output is now (<a href="http://ideone.com/7GYCR" rel="noreferrer">as seen on ideone.com</a>):</p>
     <pre><code>aaa 0
aaab 1 aaa|b
aaaxb 0
xaaab 0
b 0
abbb 1 a|bbb
</code></pre>
     <p>Note that e.g. <code>aaa|b</code> is the result of <code>join</code>-ing what each group captured with <code>'|'</code>. In this case, group 0 (i.e. what the pattern matched) captured <code>aaa</code>, and group 1 captured <code>b</code>.</p>
     <p><em><strong>Lesson</strong></em>: You can capture inside a lookaround. You can use free-spacing to enhance readability.</p>
     <hr>
     <h3>Step 3: Refactoring the lookahead into the "loop"</h3>
     <p>Before we can introduce our counting mechanism, we need to do one modification to our pattern. Currently, the lookahead is outside of the <code>+</code> repetition "loop". This is fine so far because we just wanted to assert that there's a <code>b+</code> following our <code>a+</code>, but what we <em>really</em> want to do eventually is assert that for each <code>a</code> that we match inside the "loop", there's a corresponding <code>b</code> to go with it.</p>
     <p>Let's not worry about the counting mechanism for now and just do the refactoring as follows:</p>
     <ul>
      <li>First refactor <code>a+</code> to <code>(?: a )+</code> (note that <code>(?:…)</code> is a non-capturing group)</li>
      <li>Then move the lookahead inside this non-capturing group 
       <ul>
        <li>Note that we must now "skip" <code>a*</code> before we can "see" the <code>b+</code>, so modify the pattern accordingly</li>
       </ul></li>
     </ul>
     <p>So we now have the following:</p>
     <pre><code>$r3 = '/ ^ (?: a (?= a* (b+) ) )+ /x';
#          │     │      └──┘ │ │
#          │     │        1  │ │
#          │     └───────────┘ │
#          │       lookahead   │
#          └───────────────────┘
#           non-capturing group
</code></pre>
     <p>The output is the same as before (<a href="http://ideone.com/Aw431" rel="noreferrer">as seen on ideone.com</a>), so there's no change in that regard. The important thing is that now we are making the assertion at <em>every iteration</em> of the <code>+</code> "loop". With our current pattern, this is not necessary, but next we'll make group 1 "count" for us using self-reference.</p>
     <p><em><strong>Lesson</strong></em>: You can capture inside a non-capturing group. Lookarounds can be repeated.</p>
     <hr>
     <h3>Step 4: This is the step where we start counting</h3>
     <p>Here's what we're going to do: we'll rewrite group 1 such that:</p>
     <ul>
      <li>At the end of the first iteration of the <code>+</code>, when the first <code>a</code> is matched, it should capture <code>b</code></li>
      <li>At the end of the second iteration, when another <code>a</code> is matched, it should capture <code>bb</code></li>
      <li>At the end of the third iteration, it should capture <code>bbb</code></li>
      <li>...</li>
      <li>At the end of the <em>n</em>-th iteration, group 1 should capture <em>b<sup>n</sup></em></li>
      <li>If there aren't enough <code>b</code> to capture into group 1 then the assertion simply fails</li>
     </ul>
     <p>So group 1, which is now <code>(b+)</code>, will have to be rewritten to something like <code>(\1 b)</code>. That is, we try to "add" a <code>b</code> to what group 1 captured in the previous iteration.</p>
     <p>There's a slight problem here in that this pattern is missing the "base case", i.e. the case where it can match without the self-reference. A base case is required because group 1 starts "uninitialized"; it hasn't captured anything yet (not even an empty string), so a self-reference attempt will always fail.</p>
     <p>There are many ways around this, but for now let's just make the self-reference matching <a href="http://www.regular-expressions.info/optional.html" rel="noreferrer">optional</a>, i.e. <code>\1?</code>. This may or may not work perfectly, but let's just see what that does, and if there's any problem then we'll cross that bridge when we come to it. Also, we'll add some more test cases while we're at it.</p>
     <pre><code>$tests = array(
  'aaa', 'aaab', 'aaaxb', 'xaaab', 'b', 'abbb', 'aabb', 'aaabbbbb', 'aaaaabbb'
);
 
$r4 = '/ ^ (?: a (?= a* (\1? b) ) )+ /x';
#          │     │      └─────┘ | │
#          │     │         1    | │
#          │     └──────────────┘ │
#          │         lookahead    │
#          └──────────────────────┘
#             non-capturing group
</code></pre>
     <p>The output is now (<a href="http://ideone.com/sQHcD" rel="noreferrer">as seen on ideone.com</a>):</p>
     <pre><code>aaa 0
aaab 1 aaa|b        # (*gasp!*)
aaaxb 0
xaaab 0
b 0
abbb 1 a|b          # yes!
aabb 1 aa|bb        # YES!!
aaabbbbb 1 aaa|bbb  # YESS!!!
aaaaabbb 1 aaaaa|bb # NOOOOOoooooo....
</code></pre>
     <p>A-ha! It looks like we're really close to the solution now! We managed to get group 1 to "count" using self-reference! But wait... something is wrong with the second and the last test cases!! There aren't enough <code>b</code>s, and somehow it counted wrong! We'll examine why this happened in the next step.</p>
     <p><em><strong>Lesson</strong></em>: One way to "initialize" a self-referencing group is to make the self-reference matching optional.</p>
     <hr>
     <h3>Step 4½: Understanding what went wrong</h3>
     <p>The problem is that since we made the self-reference matching optional, the "counter" can "reset" back to 0 when there aren't enough <code>b</code>'s. Let's closely examine what happens at every iteration of our pattern with <code>aaaaabbb</code> as input.</p>
     <pre><code> a a a a a b b b
↑
# Initial state: Group 1 is "uninitialized".
           _
 a a a a a b b b
  ↑
  # 1st iteration: Group 1 couldn't match \1 since it was "uninitialized",
  #                  so it matched and captured just b
           ___
 a a a a a b b b
    ↑
    # 2nd iteration: Group 1 matched \1b and captured bb
           _____
 a a a a a b b b
      ↑
      # 3rd iteration: Group 1 matched \1b and captured bbb
           _
 a a a a a b b b
        ↑
        # 4th iteration: Group 1 could still match \1, but not \1b,
        #  (!!!)           so it matched and captured just b
           ___
 a a a a a b b b
          ↑
          # 5th iteration: Group 1 matched \1b and captured bb
          #
          # No more a, + "loop" terminates
</code></pre>
     <p>A-ha! On our 4th iteration, we could still match <code>\1</code>, but we couldn't match <code>\1b</code>! Since we allow the self-reference matching to be optional with <code>\1?</code>, the engine backtracks and took the "no thanks" option, which then allows us to match and capture just <code>b</code>!</p>
     <p>Do note, however, that except on the very first iteration, you could always match just the self-reference <code>\1</code>. This is obvious, of course, since it's what we just captured on our previous iteration, and in our setup we can always match it again (e.g. if we captured <code>bbb</code> last time, we're guaranteed that there will still be <code>bbb</code>, but there may or may not be <code>bbbb</code> this time).</p>
     <p><em><strong>Lesson</strong></em>: Beware of backtracking. The regex engine will do as much backtracking as you allow until the given pattern matches. This may impact performance (i.e. <a href="http://www.regular-expressions.info/catastrophic.html" rel="noreferrer">catastrophic backtracking</a>) and/or correctness.</p>
     <hr>
     <h3>Step 5: Self-possession to the rescue!</h3>
     <p>The "fix" should now be obvious: combine optional repetition with <a href="http://www.regular-expressions.info/possessive.html" rel="noreferrer">possessive</a> quantifier. That is, instead of simply <code>?</code>, use <code>?+</code> instead (remember that a repetition that is quantified as possessive does not backtrack, even if such "cooperation" may result in a match of the overall pattern).</p>
     <p>In very informal terms, this is what <code>?+</code>, <code>?</code> and <code>??</code> says:</p>
     <blockquote>
      <h2><code>?+</code></h2>
      <ul>
       <li>(optional) "It doesn't have to be there," 
        <ul>
         <li>(possessive) "but if it is there, you must take it and not let go!"</li>
        </ul></li>
      </ul>
      <h2><code>?</code></h2>
      <ul>
       <li>(optional) "It doesn't have to be there," 
        <ul>
         <li>(greedy) "but if it is you can take it for now," 
          <ul>
           <li>(backtracking) "but you may be asked to let it go later!"</li>
          </ul></li>
        </ul></li>
      </ul>
      <h2><code>??</code></h2>
      <ul>
       <li>(optional) "It doesn't have to be there," 
        <ul>
         <li>(reluctant) "and even if it is you don't have to take it just yet," 
          <ul>
           <li>(backtracking) "but you may be asked to take it later!"</li>
          </ul></li>
        </ul></li>
      </ul>
     </blockquote>
     <p>In our setup, <code>\1</code> will not be there the very first time, but it will <em>always</em> be there any time after that, and we <em>always</em> want to match it then. Thus, <code>\1?+</code> would accomplish exactly what we want.</p>
     <pre><code>$r5 = '/ ^ (?: a (?= a* (\1?+ b) ) )+ /x';
#          │     │      └──────┘ │ │
#          │     │          1    │ │
#          │     └───────────────┘ │
#          │         lookahead     │
#          └───────────────────────┘
#             non-capturing group
</code></pre>
     <p>Now the output is (<a href="http://ideone.com/v2MbA" rel="noreferrer">as seen on ideone.com</a>):</p>
     <pre><code>aaa 0
aaab 1 a|b          # Yay! Fixed!
aaaxb 0
xaaab 0
b 0
abbb 1 a|b
aabb 1 aa|bb
aaabbbbb 1 aaa|bbb
aaaaabbb 1 aaa|bbb  # Hurrahh!!!
</code></pre>
     <p>Voilà!!! Problem solved!!! We are now counting properly, exactly the way we want it to!</p>
     <p><em><strong>Lesson</strong></em>: Learn the difference between greedy, reluctant, and possessive repetition. Optional-possessive can be a powerful combination.</p>
     <hr>
     <h3>Step 6: Finishing touches</h3>
     <p>So what we have right now is a pattern that matches <code>a</code> repeatedly, and for every <code>a</code> that was matched, there is a corresponding <code>b</code> captured in group 1. The <code>+</code> terminates when there are no more <code>a</code>, or if the assertion failed because there isn't a corresponding <code>b</code> for an <code>a</code>.</p>
     <p>To finish the job, we simply need to append to our pattern <code>\1 $</code>. This is now a back reference to what group 1 matched, followed by the end of the line anchor. The anchor ensures that there aren't any extra <code>b</code>'s in the string; in other words, that in fact we have <em>a<sup>n</sup>b<sup>n</sup></em>.</p>
     <p>Here's the finalized pattern, with additional test cases, including one that's 10,000 characters long:</p>
     <pre><code>$tests = array(
  'aaa', 'aaab', 'aaaxb', 'xaaab', 'b', 'abbb', 'aabb', 'aaabbbbb', 'aaaaabbb',
  '', 'ab', 'abb', 'aab', 'aaaabb', 'aaabbb', 'bbbaaa', 'ababab', 'abc',
  str_repeat('a', 5000).str_repeat('b', 5000)
);
 
$r6 = '/ ^ (?: a (?= a* (\1?+ b) ) )+ \1 $ /x';
#          │     │      └──────┘ │ │
#          │     │          1    │ │
#          │     └───────────────┘ │
#          │         lookahead     │
#          └───────────────────────┘
#             non-capturing group
</code></pre>
     <p>It finds 4 matches: <code>ab</code>, <code>aabb</code>, <code>aaabbb</code>, and the <em>a<sup>5000</sup>b<sup>5000</sup></em>. It takes <a href="http://ideone.com/Sr8Jd" rel="noreferrer">only 0.06s to run on ideone.com</a>.</p>
     <hr>
     <h3>Step 7: The Java test</h3>
     <p>So the pattern works in PHP, but the ultimate goal is to write a pattern that works in Java.</p>
     <pre><code>public static void main(String[] args) {
 
        String aNbN = "(?x) (?:  a  (?= a* (\\1?+ b))  )+ \\1";
        String[] tests = {
                "",      // false
                "ab",    // true
                "abb",   // false
                "aab",   // false
                "aabb",  // true
                "abab",  // false
                "abc",   // false
                repeat('a', 5000) + repeat('b', 4999), // false
                repeat('a', 5000) + repeat('b', 5000), // true
                repeat('a', 5000) + repeat('b', 5001), // false
        };
        for (String test : tests) {
                System.out.printf("[%s]%n  %s%n%n", test, test.matches(aNbN));
        }
 
}
 
static String repeat(char ch, int n) {
        return new String(new char[n]).replace('\0', ch);
}
</code></pre>
     <p>The pattern works as expected (<a href="http://ideone.com/ga6fn" rel="noreferrer">as seen on ideone.com</a>).</p>
     <hr>
     <h3>And now we come to the conclusion...</h3>
     <p>It needs to be said that the <code>a*</code> in the lookahead, and indeed the "main <code>+</code> loop", both permit backtracking. Readers are encouraged to confirm why this is not a problem in terms of correctness, and why at the same time making both possessive would also work (though perhaps mixing mandatory and non-mandatory possessive quantifier in the same pattern may lead to misperceptions).</p>
     <p>It should also be said that while it's neat that there's a regex pattern that will match <em>a<sup>n</sup>b<sup>n</sup></em>, this is in not always the "best" solution in practice. A much better solution is to simply match <code>^(a+)(b+)$</code>, and then compare the length of the strings captured by groups 1 and 2 in the hosting programming language.</p>
     <p>In PHP, it may look something like this (<a href="http://ideone.com/Weiz3" rel="noreferrer">as seen in ideone.com</a>):</p>
     <pre><code>function is_anbn($s) {
   return (preg_match('/^(a+)(b+)$/', $s, $groups)) &amp;&amp;
      (strlen($groups[1]) == strlen($groups[2]));
}
</code></pre>
     <p>The purpose of this article is <em>NOT</em> to convince readers that regex can do almost anything; it clearly can't, and even for the things it can do, at least partial delegation to the hosting language should be considered if it leads to a simpler solution.</p>
     <p>As mentioned at the top, while this article is necessarily tagged <code>[regex]</code> for stackoverflow, it is perhaps about more than that. While certainly there's value in learning about assertions, nested references, possessive quantifier, etc, perhaps the bigger lesson here is the creative process by which one can try to solve problems, the determination and hard work that it often requires when you're subjected to various constraints, the systematic composition from various parts to build a working solution, etc.</p>
     <hr>
     <h3>Bonus material! PCRE recursive pattern!</h3>
     <p>Since we did bring up PHP, it needs to be said that PCRE supports recursive pattern and subroutines. Thus, following pattern works for <code>preg_match</code> (<a href="http://ideone.com/xZpsJ" rel="noreferrer">as seen on ideone.com</a>):</p>
     <pre><code>$rRecursive = '/ ^ (a (?1)? b) $ /x';
</code></pre>
     <p>Currently Java's regex does not support recursive pattern.</p>
     <hr>
     <h3>Even more bonus material! Matching <em>a<sup>n</sup>b<sup>n</sup>c<sup>n</sup></em> !!</h3>
     <p>So we've seen how to match <em>a<sup>n</sup>b<sup>n</sup></em> which is non-regular, but still context-free, but can we also match <em>a<sup>n</sup>b<sup>n</sup>c<sup>n</sup></em>, which isn't even context-free?</p>
     <p>The answer is, of course, <em>YES!</em> Readers are encouraged to try to solve this on their own, but the solution is provided below (with <a href="http://ideone.com/5i0ww" rel="noreferrer">implementation in Java on ideone.com</a>).</p>
     <blockquote class="spoiler">
      <p><code>^ (?: a (?= a* (\1?+ b) b* (\2?+ c) ) )+ \1 \2 $</code></p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>No doubt there may be mistakes/typos in this long answer, so please leave feedbacks as comments so I can revise them on my own.</span> <span> - </span> <span class="display-name">polygenelubricants</span> <span> </span> <span class="date">4 Sep 2010 at 22:55</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Great job. It'll take me a while to read over, but the very last line is basically impossible to read; it is such small font. ------ Oh wait. Is that a <code>feature</code>?.... Not sure if it's a good idea. I know what the last symbol is, but it can't be read (aside from copy pasting it).</span> <span> - </span> <span class="display-name">Peter Ajtai</span> <span> </span> <span class="date">4 Sep 2010 at 23:54</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>@Peter: Highlight the small text and copy and paste into something else. It's made difficult to read on purpose: it's a spoiler, the solution to the bonus puzzle.</span> <span> - </span> <span class="display-name">polygenelubricants</span> <span> </span> <span class="date">4 Sep 2010 at 23:56</span></td>
       </tr>
       <tr>
        <td>8</td>
        <td><span>+1: Fantastic explanation, these "Advanced articles" are brilliant ideas.</span> <span> - </span> <span class="display-name">Callum Rogers</span> <span> </span> <span class="date">6 Sep 2010 at 16:24</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>great article. You asked for feedback... you mention java regexes in the title, but then use PHP. I'm confused by that. Does PHP's preg_match() use java regexes?</span> <span> - </span> <span class="display-name">LarsH</span> <span> </span> <span class="date">28 Sep 2010 at 21:26</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@LarsH PHP's <code>preg_match()</code> is an example of <a href="http://www.pcre.org/" title="Perl Compatible Regular Expressions" rel="nofollow noreferrer">PCRE</a>. Java regexes <a href="http://stackoverflow.com/a/1448213/1337">seem to be based on an older version of Perl regexps</a>. Which means that PHP regexes are more powerful than the version in Java. As of <a href="https://en.wikipedia.org/wiki/ISO_8601" rel="nofollow noreferrer">2013-02-21</a>, <a href="http://www.pcre.org/pcre.txt" rel="nofollow noreferrer">pcre.txt</a> states that it <i>corresponds approximately with Perl 5.12</i>. While Perl is currently at 5.16, with 5.18 a few months off. (There actually hasn't been much added to regexes in that time)</span> <span> - </span> <span class="display-name">Brad Gilbert</span> <span> </span> <span class="date">21 Feb 2013 at 17:46</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Fantastic explanation, have 100 rep for me :) Thanks again for your wonderful posts about regular expressions!</span> <span> - </span> <span class="display-name">ComFreek</span> <span> </span> <span class="date">5 Nov 2013 at 15:14</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Since lookaround doesn't affect which languages can be matched by regular expressions, could this be written as a regex without lookarounds?</span> <span> - </span> <span class="display-name">gatinueta</span> <span> </span> <span class="date">27 Nov 2013 at 20:54</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This is a great answer. Thank you.</span> <span> - </span> <span class="display-name">Witiko</span> <span> </span> <span class="date">15 Dec 2015 at 23:10</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>daaaamn... . :o</span> <span> - </span> <span class="display-name">Christoffer Bubach</span> <span> </span> <span class="date">22 Dec 2019 at 16:35</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>22</span>
     </div>
     <div>
      <span>Answerer: </span> <span>jaytea</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Sep 2010 at 10:01</span>
     </div>
    </div>
    <div>
     <p>Given that no mention has been made of PCRE supporting recursive patterns, I'd just like to point out the simplest and most efficient example of PCRE that describes the language in question:</p>
     <pre><code>/^(a(?1)?b)$/
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>+1 wow, I didn't know PCRE supports recursive pattern (I'm still learning! Every day!). I've revised the article to accommodate this information. I don't think recursive pattern can match <code>a^n b^n c^n</code>, though.</span> <span> - </span> <span class="display-name">polygenelubricants</span> <span> </span> <span class="date">6 Sep 2010 at 14:36</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>It should be noted this option is simpler, but not as good as the posted answer - the recursion overflows on long strings.</span> <span> - </span> <span class="display-name">Kobi</span> <span> </span> <span class="date">6 Sep 2010 at 18:49</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Kobi This depends on your definition of "good". For example the recursive solution is around one order of magnitude faster than the other one (<a href="http://codepad.viper-7.com/CWgy7c" rel="nofollow noreferrer">codepad.viper-7.com/CWgy7c</a>). And it is far easier to understand. The recursive solution is pretty much the direct transformation of the grammar into a regex (actually you could just write it in the grammarized form, it would work).</span> <span> - </span> <span class="display-name">NikiC</span> <span> </span> <span class="date">19 Sep 2011 at 16:04</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@polygeniclubricants, you can match that pattern with two recursive patterns, one to consume <code>a</code>s and <code>b</code>s without capturing (and verifies there are the same amount w/recursion), followed by a capturing regex that greedily consumes all a's, and then applies the recursive pattern to consume and verify that there are the same number of <code>b</code>s and <code>c</code>s. The regex is: <code>/^(?=(a(?-1)?b)c)a+(b(?-1)?c)$/x</code>. Credit to: <a href="http://nikic.github.io/2012/06/15/The-true-power-of-regular-expressions.html" rel="nofollow noreferrer">nikic.github.io/2012/06/15/…</a></span> <span> - </span> <span class="display-name">Josh Reback</span> <span> </span> <span class="date">13 Aug 2017 at 23:39</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>15</span>
     </div>
     <div>
      <span>Answerer: </span> <span>kennytm</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Sep 2010 at 15:36</span>
     </div>
    </div>
    <div>
     <p>As mentioned in the question — with .NET balancing group, the patterns of the type <em>a<sup>n</sup>b<sup>n</sup>c<sup>n</sup>d<sup>n</sup>…z<sup>n</sup></em> can be matched easily as</p>
     <pre><code>^
  (?&lt;A&gt;a)+
  (?&lt;B-A&gt;b)+  (?(A)(?!))
  (?&lt;C-B&gt;c)+  (?(B)(?!))
  ...
  (?&lt;Z-Y&gt;z)+  (?(Y)(?!))
$
</code></pre>
     <p>For example: <a href="http://www.ideone.com/usuOE" rel="noreferrer">http://www.ideone.com/usuOE</a></p>
     <hr>
     <p><strong>Edit:</strong></p>
     <p>There is also a PCRE pattern for the generalized language with recursive pattern, but a lookahead is needed. I don't think this is a direct translation of the above.</p>
     <pre><code>^
  (?=(a(?-1)?b))  a+
  (?=(b(?-1)?c))  b+
  ...
  (?=(x(?-1)?y))  x+
     (y(?-1)?z)
$
</code></pre>
     <p>For example: <a href="http://www.ideone.com/9gUwF" rel="noreferrer">http://www.ideone.com/9gUwF</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>@poly: Thanks :). Actually I am not familiar with .NET patterns, but for this kind of patterns it turns out to be very easy with balancing groups, so I supplement this answer.</span> <span> - </span> <span class="display-name">kennytm</span> <span> </span> <span class="date">6 Sep 2010 at 16:23</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>can you do this with recursive pattern? Because if you can't, that's an interesting twist that balancing group can do things that recursive pattern can't. (And yes, I very much appreciate the supplement).</span> <span> - </span> <span class="display-name">polygenelubricants</span> <span> </span> <span class="date">6 Sep 2010 at 16:23</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>by the way, the reason why I omitted .NET solution was because I do have plans for "How can we match <code>a^n b^n</code> with .NET regex?" article in the future, but you're more than welcome to write it if you want. I'm not doing these articles just for myself; I do want to encourage others to do it as well to have good content on the site.</span> <span> - </span> <span class="display-name">polygenelubricants</span> <span> </span> <span class="date">6 Sep 2010 at 16:28</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Please update if you figure out a way to do it with recursive patterns. I played around with balancing groups to capture words whose lengths make a Fibonacci series, and couldn't get it to work. It may be possible using look-around, similar to what I've done.</span> <span> - </span> <span class="display-name">Kobi</span> <span> </span> <span class="date">6 Sep 2010 at 18:17</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Somebody needs to write a tongue-in-cheek RE language with expressions like <code>a(?!#@&amp;*b)</code>... which translates to, 'What in tarnation is an <code>a</code> doing there? It's supposed to be a <code>b</code>!'</span> <span> - </span> <span class="display-name">LarsH</span> <span> </span> <span class="date">28 Sep 2010 at 21:29</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>I'd just like to point out that the PCRE version of this pattern is slightly flawed as it matches if the next chunk of characters is longer than the previous. See here: <a href="https://regex101.com/r/sdlRTm/1" rel="nofollow noreferrer">regex101.com/r/sdlRTm/1</a> You need to add <code>(?!b)</code>, <code>(?!c)</code>, etc. after the capture groups like so: <a href="https://regex101.com/r/sdlRTm/2" rel="nofollow noreferrer">regex101.com/r/sdlRTm/2</a></span> <span> - </span> <span class="display-name">jaytea</span> <span> </span> <span class="date">19 Nov 2017 at 12:53</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>