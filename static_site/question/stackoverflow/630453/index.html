<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>What is the difference between POST and PUT in HTTP?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>What is the difference between POST and PUT in HTTP?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>6247</span>
    </div>
    <div>
     <span>Asker: </span> <span>alex</span>
    </div>
    <div>
     <span>Asked: </span> <span>10 Mar 2009 at 14:25</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/630453">source</a>
    </div>
   </div>
   <div>
    <p><strong>Background Information Analysis:</strong></p>
    <p>According to <a href="https://www.rfc-editor.org/rfc/rfc2616#section-9.5" rel="noreferrer">RFC 2616, § 9.5</a>, <code>POST</code> is used to <em>create</em> a resource:</p>
    <blockquote>
     <p>The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line.</p>
    </blockquote>
    <p>According to <a href="https://www.rfc-editor.org/rfc/rfc2616#section-9.6" rel="noreferrer">RFC 2616, § 9.6</a>, <code>PUT</code> is used to <em>create or replace</em> a resource:</p>
    <blockquote>
     <p>The PUT method requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI.</p>
    </blockquote>
    <p><strong>My Question:</strong></p>
    <p>So, which HTTP method should be used to create a resource? Or should both be supported?</p>
   </div>
   <div class="tags">
    <span class="tag">http</span><span class="tag">rest</span><span class="tag">post</span><span class="tag">put</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>66</td>
       <td><span>It may be helpful to use the definitions in HTTPbis - Roy put a fair amount of work into clarifying them. See: <a href="http://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-16#section-7.5" rel="nofollow noreferrer">tools.ietf.org/html/…</a></span> <span> - </span> <span class="display-name">Mark Nottingham</span> <span> </span> <span class="date">23 Oct 2011 at 21:03</span></td>
      </tr>
      <tr>
       <td>19</td>
       <td><span>Just to bring @MarkNottingham's comment to the latest revision, here's <b><a href="http://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-21#section-5.3.3" rel="nofollow noreferrer">POST</a></b> and <b><a href="http://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-21#section-5.3.4" rel="nofollow noreferrer">PUT</a></b>, as defined on HTTPbis.</span> <span> - </span> <span class="display-name">Marius Butuc</span> <span> </span> <span class="date">18 Nov 2012 at 01:58</span></td>
      </tr>
      <tr>
       <td>46</td>
       <td><span>It seems to me that this debate has arisen from the common practice of oversimplifying REST by describing the HTTP Methods in terms of CRUD operations.</span> <span> - </span> <span class="display-name">Stuporman</span> <span> </span> <span class="date">14 Feb 2013 at 17:05</span></td>
      </tr>
      <tr>
       <td>7</td>
       <td><span>Unfortunally the first answers are wrong about POST. Check my answer for a better explanation of the differences: <a href="http://stackoverflow.com/a/18243587/2458234">stackoverflow.com/a/18243587/2458234</a></span> <span> - </span> <span class="display-name">7hi4g0</span> <span> </span> <span class="date">25 Nov 2013 at 05:21</span></td>
      </tr>
      <tr>
       <td>34</td>
       <td><span>PUT and POST are both unsafe methods. However, PUT is idempotent, while POST is not. - See more at: <a href="http://restcookbook.com/HTTP%20Methods/put-vs-post/#sthash.u3S9tnPo.dpuf" rel="nofollow noreferrer">restcookbook.com/HTTP%20Methods/put-vs-post/…</a></span> <span> - </span> <span class="display-name">Dinesh Saini</span> <span> </span> <span class="date">10 Jan 2014 at 20:26</span></td>
      </tr>
      <tr>
       <td>4</td>
       <td><span>you know... I realise the spec refers to PUT as 'update', but I think everyone would be a lot less confused if we said it 'replaced', that is what it does after all.</span> <span> - </span> <span class="display-name">thecoshman</span> <span> </span> <span class="date">15 Jun 2014 at 20:28</span></td>
      </tr>
      <tr>
       <td>3</td>
       <td><span>In pratice, POST works well for creating resources. The URL of the newly created resource should be returned in the Location response header. PUT should be used for updating a resource completely. Please understand that these are the best practices when designing a RESTful API. HTTP specification as such does not restrict using PUT/POST with a few restrictions for creating/updating resources. Take a look at <a href="http://techoctave.com/c7/posts/71-twitter-rest-api-dissected" rel="nofollow noreferrer">techoctave.com/c7/posts/71-twitter-rest-api-dissected</a> that summarizes the best practices.</span> <span> - </span> <span class="display-name">java_geek</span> <span> </span> <span class="date">6 Oct 2014 at 06:42</span></td>
      </tr>
      <tr>
       <td>3</td>
       <td><span><code>idempotency</code> is the key. Read <a href="https://jcalcote.wordpress.com/2008/10/16/put-or-post-the-rest-of-the-story/" rel="nofollow noreferrer">PUT or POST: The REST of the Story by John Calcote</a>. If your method is idempotent, go with PUT. If not go with POST.</span> <span> - </span> <span class="display-name">LCJ</span> <span> </span> <span class="date">11 Aug 2016 at 18:12</span></td>
      </tr>
      <tr>
       <td>2</td>
       <td><span>I don't understand the prevailing wisdom on this. OP's citation for PUT begins with "The PUT method requests that the enclosed entity be stored...." That screams "creation" to me. When we talk about "putting" something somewhere, we're talking about a place it hadn't been previously. You don't "put" something to change it. When you amend a document, you don't "put" a new one. The use of the HTTP verb PUT to mean "update" is an ill semantic fit.</span> <span> - </span> <span class="display-name">Keith Tyler</span> <span> </span> <span class="date">28 Mar 2017 at 16:31</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>PUT began as a way for early Microsoft HTML design tools to publish content directly to a server. The fact that it was also used to update (wholesale) was due to the lack of another updating method. Even still since it was a wholesale update, it really was creation, just one that was idempotent. An "update" implies that some aspect of the previous state was maintained.</span> <span> - </span> <span class="display-name">Keith Tyler</span> <span> </span> <span class="date">28 Mar 2017 at 16:33</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>Real world scenario in elastic documentation: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/_modifying_your_data.html" rel="nofollow noreferrer">elastic.co/guide/en/elasticsearch/reference/current/…</a>. Have a look at difference between all PUT requests and last POST request example.</span> <span> - </span> <span class="display-name">DevDio</span> <span> </span> <span class="date">10 Apr 2018 at 09:02</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Difference between <a href="https://restfulapi.net/rest-put-vs-post/" rel="nofollow noreferrer">POST vs PUT</a> methods should be described in defined context. Such as here, question is about REST, and it is actually about consistency and uniform interface. Till the time, you are honoring the API design consistency, you are good.</span> <span> - </span> <span class="display-name">Lokesh Gupta</span> <span> </span> <span class="date">17 Aug 2018 at 18:22</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>OP's enclosed quote about POST is no longer valid. "The actual function performed by the POST method is determined by the server and is usually dependent on the effective request URI. The action performed by the POST method might not result in a resource that can be identified by a URI. " via <a href="https://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-21#section-5.3.3" rel="nofollow noreferrer">tools.ietf.org/html/…</a></span> <span> - </span> <span class="display-name">sindhu_sp</span> <span> </span> <span class="date">13 Nov 2019 at 10:09</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4819</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Brian R. Bondy</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Mar 2009 at 14:29</span>
     </div>
    </div>
    <div>
     <p><strong>Overall:</strong></p>
     <p>Both PUT and POST can be used for creating.</p>
     <p>You have to ask, "what are you performing the action upon?", to distinguish what you should be using. Let's assume you're designing an API for asking questions. If you want to use POST, then you would do that to a list of questions. If you want to use PUT, then you would do that to a particular question.</p>
     <p><strong>Great, both can be used, so which one should I use in my RESTful design:</strong></p>
     <p>You do not need to support both PUT and POST.</p>
     <p>Which you use is up to you. But just remember to use the right one depending on what object you are referencing in the request.</p>
     <p>Some considerations:</p>
     <ul>
      <li>Do you name the URL objects you create explicitly, or let the server decide? If you name them then use PUT. If you let the server decide then use POST.</li>
      <li>PUT is defined to assume idempotency, so if you PUT an object twice, it should have no additional effect. This is a nice property, so I would use PUT when possible. Just make sure that the PUT-idempotency actually is implemented correctly in the server.</li>
      <li>You can update or create a resource with PUT with the same object URL</li>
      <li>With POST you can have 2 requests coming in at the same time making modifications to a URL, and they may update different parts of the object.</li>
     </ul>
     <p><strong>An example:</strong></p>
     <p>I wrote the following as part of <a href="https://stackoverflow.com/questions/256349/what-are-the-best-common-restful-url-verbs-and-actions/256359#256359">another answer on SO regarding this</a>:</p>
     <blockquote>
      <p><strong>POST:</strong></p>
      <p>Used to modify and update a resource</p>
      <pre><code>POST /questions/&lt;existing_question&gt; HTTP/1.1
Host: www.example.com/
</code></pre>
      <p>Note that the following is an error:</p>
      <pre><code>POST /questions/&lt;new_question&gt; HTTP/1.1
Host: www.example.com/
</code></pre>
      <p>If the URL is not yet created, you should not be using POST to create it while specifying the name. This should result in a 'resource not found' error because <code>&lt;new_question&gt;</code> does not exist yet. You should PUT the <code>&lt;new_question&gt;</code> resource on the server first.</p>
      <p>You could though do something like this to create a resources using POST:</p>
      <pre><code>POST /questions HTTP/1.1
Host: www.example.com/
</code></pre>
      <p>Note that in this case the resource name is not specified, the new objects URL path would be returned to you.</p>
      <p><strong>PUT:</strong></p>
      <p>Used to create a resource, or overwrite it. While you specify the resources new URL.</p>
      <p>For a new resource:</p>
      <pre><code>PUT /questions/&lt;new_question&gt; HTTP/1.1
Host: www.example.com/
</code></pre>
      <p>To overwrite an existing resource:</p>
      <pre><code>PUT /questions/&lt;existing_question&gt; HTTP/1.1
Host: www.example.com/
</code></pre>
     </blockquote>
     <p>Additionally, and a bit more concisely, <a href="https://www.rfc-editor.org/rfc/rfc7231#section-4.3.4" rel="noreferrer">RFC 7231 Section 4.3.4 PUT</a> states (emphasis added),</p>
     <blockquote>
      <p><strong>4.3.4. PUT</strong></p>
      <p>The PUT method requests that the state of the target resource be <code>created</code> or <code>replaced</code> with the state defined by the representation enclosed in the request message payload.</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1202</td>
        <td><span>I think one cannot stress enough the fact that PUT is idempotent: if the network is botched and the client is not sure whether his request made it through, it can just send it a second (or 100th) time, and it is guaranteed by the HTTP spec that this has exactly the same effect as sending once.</span> <span> - </span> <span class="display-name">Jörg W Mittag</span> <span> </span> <span class="date">10 Mar 2009 at 15:17</span></td>
       </tr>
       <tr>
        <td>90</td>
        <td><span>@Jörg W Mittag: Not necessary. The second time could return 409 Conflict or something if the request has been modified in meantime (by some other user or the first request itself, which got through).</span> <span> - </span> <span class="display-name">Mitar</span> <span> </span> <span class="date">27 Nov 2011 at 23:28</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>I think there is no difference in definition. 409 Conflict could be a result even for the first request the client made. In any case it should investigate the problem.</span> <span> - </span> <span class="display-name">Mitar</span> <span> </span> <span class="date">28 Nov 2011 at 02:21</span></td>
       </tr>
       <tr>
        <td>717</td>
        <td><span>If I'm not mistaken, what we should be stressing is that PUT is <i>defined</i> to be idempotent. You still have to write your server in such a way that PUT behaves correctly, yes? Perhaps it's better to say "PUT causes the transport to assume idempotence, which may affect behavior of the transport, e.g. caching."</span> <span> - </span> <span class="display-name">Ian Ni-Lewis</span> <span> </span> <span class="date">28 Dec 2011 at 02:05</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>There are some <a href="http://www.prescod.net/reliable_http.html" rel="nofollow noreferrer">ideas about how to make POST more reliable</a> on Paul Prescod's website, though the site overall doesn't seem to be kept up to date.</span> <span> - </span> <span class="display-name">hotshot309</span> <span> </span> <span class="date">4 Apr 2012 at 18:48</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>To make things even clearer it might be an idea to add that this example should return an error: PUT /questions HTTP/1.1 Host: wahteverblahblah.com</span> <span> - </span> <span class="display-name">Martin Brown</span> <span> </span> <span class="date">4 Oct 2013 at 08:46</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>I second that, @MartinBrown... your point is quite illuminating for me, actually. The answer as it stands is already fantastic, though, don't get me wrong!</span> <span> - </span> <span class="display-name">Eric Fuller</span> <span> </span> <span class="date">23 Oct 2013 at 03:57</span></td>
       </tr>
       <tr>
        <td>175</td>
        <td><span>@JörgWMittag Idempotence catchphrase? How about "Send and send and send my friend, it makes no difference in the end."</span> <span> - </span> <span class="display-name">James Beninger</span> <span> </span> <span class="date">3 Mar 2014 at 17:13</span></td>
       </tr>
       <tr>
        <td>10</td>
        <td><span>PUT should only be used to create a resource if the client cares about the resource's name. A client caring about a resource's name indicates coupling. Coupling is the result of poor practices. Therefore, use POST. If there is concern about a resource being created twice with POST (since it's not idempotent) read <a href="http://stackoverflow.com/questions/630453/put-vs-post-in-rest/19670755#19670755">this answer</a>.</span> <span> - </span> <span class="display-name">Joshcodes</span> <span> </span> <span class="date">17 Mar 2014 at 19:00</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@JörgWMittag If a PUT is idempotent, what happens if the PUT is creating a new resource and the server is the one generating the object id? That would imply every PUT call would create a different object id. Does that mean that a PUT should not/cannot be used in that case, and a POST is required instead?</span> <span> - </span> <span class="display-name">Eric B.</span> <span> </span> <span class="date">9 Jul 2014 at 04:37</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@EricB. The "object ID" is what he is referring to as the name. Thus, it should be supplied as part of the URL when using POST and not be generated by the server.</span> <span> - </span> <span class="display-name">Legogris</span> <span> </span> <span class="date">22 Sep 2014 at 07:28</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>In pratice, POST works well for creating resources. The URL of the newly created resource should be returned in the Location response header. PUT should be used for updating a resource completely. Please understand that these are the best practices when designing a RESTful API. HTTP specification as such does not restrict using PUT/POST with a few restrictions for creating/updating resources</span> <span> - </span> <span class="display-name">java_geek</span> <span> </span> <span class="date">6 Oct 2014 at 06:28</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>One note on using POST for CRUD style updates: I know that <a href="http://roy.gbiv.com/untangled/2009/it-is-okay-to-use-post" rel="nofollow noreferrer">Roy Fielding pointed out</a> that it should be more important for a RESTful design to make use of Hypermedia and discoverable self-explaining APIs than (e.g.) disallowing POST requests to perform item updates. But the quoted http spec gives a rule of thumb: In general it is quite intuitive and consistent to <i>allow POST only for creating new subordinates for the given resource</i>. For replacing or updating existing resources, I always prefer PUT or PATCH.</span> <span> - </span> <span class="display-name">matthias</span> <span> </span> <span class="date">12 Mar 2015 at 18:01</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Whatever the semantic value of POST vs PUT: If you have to support IE9 and IE8, beware that CORS requests in these versions do not support PUT - only GET/POST. See <a href="http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx" rel="nofollow noreferrer">blogs.msdn.com/b/ieinternals/archive/2010/05/13/…</a></span> <span> - </span> <span class="display-name">flexponsive</span> <span> </span> <span class="date">10 Apr 2015 at 19:21</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>Can someone elaborate on this sentence. "With POST you can have 2 requests coming in at the same time making modifications to a URL, and they may update different parts of the object." Please explain why this applies to POST and not to PUT?</span> <span> - </span> <span class="display-name">Kevin Wheeler</span> <span> </span> <span class="date">8 Sep 2015 at 22:28</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@KevinWheeler: Bill de Hora has a good blog post about using POST to update only some fields of a resource, while PUT must supply all fields (whether creating or updating): <a href="http://www.dehora.net/journal/2009/02/03/just-use-post/" rel="nofollow noreferrer">dehora.net/journal/2009/02/03/just-use-post</a> He makes the point that PUT can be very heavy weight if you have to send through all the fields when you only want to update one. So, following his scheme, you could have POST sending through an update to a couple of fields and another POST request updating another couple of fields in the same resource. Not sure but I think PATCH now does the same sort of thing.</span> <span> - </span> <span class="display-name">Simon Elms</span> <span> </span> <span class="date">13 Jan 2016 at 21:31</span></td>
       </tr>
       <tr>
        <td>72</td>
        <td><span>Thinks of them as: PUT = insert or update; POST = insert. So when you make two PUT - you get the one new record, when you do two POSTs - you get two new records.</span> <span> - </span> <span class="display-name">Eugen Konkov</span> <span> </span> <span class="date">22 Aug 2016 at 09:34</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>"With POST you can have 2 requests coming in at the same time making modifications to a URL, and they may update different parts of the object." .......... you mean POST can update?</span> <span> - </span> <span class="display-name">Raúl</span> <span> </span> <span class="date">11 Nov 2016 at 07:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>"Used to modify and update a resource" ....... you must meant 'or' here - right ?</span> <span> - </span> <span class="display-name">Raúl</span> <span> </span> <span class="date">11 Nov 2016 at 07:04</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Learner I second your sentiment. This answer and the examples are confusing. Words are used inconsistently.</span> <span> - </span> <span class="display-name">lucid_dreamer</span> <span> </span> <span class="date">18 Jun 2017 at 01:52</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Think like a server: Expect an item to be uniquely identifiable. If I receive a PUT <i>without</i> an identifier I'm going to reject it because it's not telling me what to update. If I receive a POST <i>with</i> an identifier I'm going to reject it because I can't <i>create</i> what already exists.</span> <span> - </span> <span class="display-name">Brian Lowe</span> <span> </span> <span class="date">20 Jul 2017 at 13:16</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Assuming I having the following URL: test.awesome.com/questions, is the above saying that I would PUT to that URL to create a new resource? I thought it's POST to a collection and PUT to a URL with a specified ID. Isn't it PUT here: test.awesome.com/questions/1 and POST here: test.awesome.com/questions? Or, is it saying if test.awesome.com/questions/1 doesn't exist, PUT will create it or replace it if it already exists on the server?</span> <span> - </span> <span class="display-name">cr1pto</span> <span> </span> <span class="date">22 Sep 2017 at 16:11</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Does idempotency of PUT mean we cannot have the same resource name or that objects that have the same hashes cannot exist at the same time ?</span> <span> - </span> <span class="display-name">monolith</span> <span> </span> <span class="date">21 Nov 2017 at 19:56</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@wedran idempotency means, that if someone calls PUT once or multiple times, the outcome is still the same. So an operation, where every call causes a change (e.g. a counter to increment) wouldn't be idempotent ( <a href="http://www.restapitutorial.com/lessons/idempotency.html" rel="nofollow noreferrer">restapitutorial.com/lessons/idempotency.html</a> ). I would recommend reading through all answers answers here to get a better understanding. It doesn't have anything to do with the resource name or a hash.</span> <span> - </span> <span class="display-name">skofgar</span> <span> </span> <span class="date">21 Nov 2017 at 23:02</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Am I mistaken, or does this answer contradict the info in the question? There it says Post=Create. Put=Update if possible. If not, create. However here, it says 'Post=Update'. I'm confused.</span> <span> - </span> <span class="display-name">Mark A. Donohoe</span> <span> </span> <span class="date">15 Dec 2017 at 21:43</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>You should really be using PATCH to update a entity, PUT to insert a entity , DELETE to delete/remove a entity and a POST to do other things, like submitting form data type requests.</span> <span> - </span> <span class="display-name">SynackSA</span> <span> </span> <span class="date">19 Jan 2018 at 19:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Would be nice if we could add the difference with PATCH. Right now I'm in a situation where I define the resource's ID beforehand (not the server), I'm therefore using PUT to create it, and then POST to update it, but I could also use PATCH instead of POST and that would make more sense, semantically speaking.</span> <span> - </span> <span class="display-name">Vadorequest</span> <span> </span> <span class="date">20 Feb 2018 at 00:49</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@BrianR.Bondy you Wrote: <i>POST: Used to modify and update a resource POST /questions/&lt;existing_question&gt; HTTP/1.1</i>. But in this case you make POST method idempotent. This is in contrast with HTTP specification! <a href="https://tools.ietf.org/html/rfc7231#section-4.3.3" rel="nofollow noreferrer">RFC 7231</a></span> <span> - </span> <span class="display-name">Glauco Cucchiar</span> <span> </span> <span class="date">2 Mar 2018 at 10:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@BrianR.Bondy in the below link definitions are contradictory <a href="https://restfulapi.net/rest-put-vs-post/" rel="nofollow noreferrer">restfulapi.net/rest-put-vs-post</a></span> <span> - </span> <span class="display-name">user7030548</span> <span> </span> <span class="date">10 Apr 2018 at 12:00</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Sirius - I thought the same thing, but technically POST can be used to append to an existing resource as stated in <a href="https://tools.ietf.org/html/rfc7231#section-4.3.3" rel="nofollow noreferrer">Section 4.3.3 of RFC 7231</a> - 4th bullet point. I would consider appending as an update but it could be interpreted differently</span> <span> - </span> <span class="display-name">commandt</span> <span> </span> <span class="date">3 May 2018 at 18:36</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2518</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Cheeso</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Apr 2010 at 14:55</span>
     </div>
    </div>
    <div>
     <p>You can find assertions on the web that say</p>
     <ul>
      <li><a href="https://web.archive.org/web/20100819115115/http://www.oracle.com/technetwork/articles/javase/index-137171.html" rel="noreferrer"><strong>POST</strong> should be used to create a resource, and <strong>PUT</strong> should be used to modify one</a></li>
      <li><a href="https://awsmedia.s3.amazonaws.com/pdf/RESTandS3.pdf" rel="noreferrer"><strong>PUT</strong> should be used to create a resource, and <strong>POST</strong> should be used to modify one</a></li>
     </ul>
     <p>Neither is quite right.</p>
     <hr>
     <p>Better is to choose between PUT and POST based on <a href="https://en.wikipedia.org/wiki/Idempotence" rel="noreferrer">idempotence</a> of the action.</p>
     <p><strong>PUT</strong> implies putting a resource - completely replacing whatever is available at the given URL with a different thing. By definition, a PUT is idempotent. Do it as many times as you like, and the result is the same. <code>x=5</code> is idempotent. You can PUT a resource whether it previously exists, or not (eg, to Create, or to Update)!</p>
     <p><strong>POST</strong> updates a resource, adds a subsidiary resource, or causes a change. A POST is not idempotent, in the way that <code>x++</code> is not idempotent.</p>
     <hr>
     <p>By this argument, PUT is for creating when you know the URL of the thing you will create. POST can be used to create when you know the URL of the "factory" or manager for the category of things you want to create.</p>
     <p>So:</p>
     <pre><code>POST /expense-report
</code></pre>
     <p>or:</p>
     <pre><code>PUT  /expense-report/10929
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>84</td>
        <td><span>I agree, wherever idempotence is concerned it should trump any other concerns since getting that wrong can cause many many unexpected bugs.</span> <span> - </span> <span class="display-name">Josh</span> <span> </span> <span class="date">26 Oct 2010 at 05:56</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Yes. In fact, AtomPub protocol defies this (or more accurately, restricts its semantic meaning of PUT): "PUT is used to edit a known Resource. It is not used for Resource creation." Just because AtomPub protocol says so (which is valid by the way) doesn't mean all RESTful protocols must follow it. (because REST is generic)</span> <span> - </span> <span class="display-name">Hendy Irawan</span> <span> </span> <span class="date">14 Apr 2011 at 16:04</span></td>
       </tr>
       <tr>
        <td>20</td>
        <td><span>If POST can update a resource, how is that not idempotent? If I change a students age using PUT and do that 10x times the students age is the same if I did it once.</span> <span> - </span> <span class="display-name">Jack Ukleja</span> <span> </span> <span class="date">6 May 2011 at 10:54</span></td>
       </tr>
       <tr>
        <td>32</td>
        <td><span>@Schneider, in this case your server is making an extra effort to guarantee idempotence, but it is not advertising it. Browsers will still warn the user if they try to reload such a POST request.</span> <span> - </span> <span class="display-name">Tobu</span> <span> </span> <span class="date">6 Jan 2012 at 10:53</span></td>
       </tr>
       <tr>
        <td>52</td>
        <td><span>@Schneider POST may create a subsidiary resource; hence you can POST to collection, like <b>POST /expense-reports</b> and it would create as many entities (expense reports) on your server as the quantity of requests you've sent, even if they are completely similar. Think of it as inserting the same row in the DB table (/expense-reports) with auto-incremented primary key. Data remains the same, key (URI in this case) is generated by server and is different for every other insert (request). So, POST effect <b>can</b> be idempotent, but also <b>may</b> not. Hence, POST is <b>not</b> idempotent.</span> <span> - </span> <span class="display-name">Snifff</span> <span> </span> <span class="date">26 Jan 2012 at 17:32</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>This is dead on, and the "accepted" answers look to me (@brian) to miss this critical subtlety.</span> <span> - </span> <span class="display-name">Andrew Roberts</span> <span> </span> <span class="date">21 Mar 2012 at 18:48</span></td>
       </tr>
       <tr>
        <td>14</td>
        <td><span>Let's say we have entities which may have two properties - <code>name</code> and <code>date</code>. If we have an entity with an existing <code>name</code> and <code>date</code>, but then make requests to it specifying only a <code>name</code>, the proper behavior of <b>PUT</b> would be to obliterate the <code>date</code> of the entity, whereas <b>POST</b> may update only the properties specified, leaving the unspecified properties as they were before the request was made. Does that sound correct/reasonable, or is it an improper use of <b>PUT</b> (I saw references to <b>PATCH</b>, which it seems would be more appropriate, but doesn't exist yet)?</span> <span> - </span> <span class="display-name">Jon z</span> <span> </span> <span class="date">8 May 2013 at 18:28</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This is dead wrong. Idempotence should <b>not</b> decide if PUT or POST is used. Who owns the responsibility for the URL structure decides if PUT or POST is used. To understand how to handle duplicate POST requests see <a href="http://stackoverflow.com/questions/630453/put-vs-post-in-rest/17114749#19670755">this answer</a>.</span> <span> - </span> <span class="display-name">Joshcodes</span> <span> </span> <span class="date">24 Apr 2014 at 12:22</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>I wonder if what he means by "<b>POST</b> can update a resource" is that by POSTing to a collection you are adding an item to it and therefore "updating the collection". That distinction seems a <i>bit</i> misleading. I like the answer, though.</span> <span> - </span> <span class="display-name">Thomas</span> <span> </span> <span class="date">28 May 2015 at 13:43</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Thank you, this is very helpful. To further your analogy, <code>POST</code> may be used to "assign" (as opposed to <code>x++</code>), but it's more like <code>obj.setX(5)</code> -- the <code>setX</code> method <i>should</i> result in x being 5, but may have side effects.</span> <span> - </span> <span class="display-name">Nicole</span> <span> </span> <span class="date">1 Oct 2015 at 22:21</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>If using POST to partially update an existing resource, such as updating only a couple of fields, can you specify the resource name? The reason I ask is that many people say POST can't be used with an individual resource, only with its parent collection. eg POST applied to expense reports. Is it possible to update say a single field of expense report 10929 using <code>POST /expense-report/10929</code> ?</span> <span> - </span> <span class="display-name">Simon Elms</span> <span> </span> <span class="date">13 Jan 2016 at 21:39</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I agree with this answer. Key difference is idempotency of PUT. I found a very good explanation of idempotency at <a href="https://stormpath.com/blog/put-or-post" rel="nofollow noreferrer">stormpath.com/blog/put-or-post</a></span> <span> - </span> <span class="display-name">Naymesh Mistry</span> <span> </span> <span class="date">5 Sep 2016 at 02:01</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>Comparing <b>PUT</b> and <b>POST</b> to mysql: <b>POST</b> is like an <code>INSERT INTO</code> without providing the ID of an auto-increment column, if you do it multiple times, you will create multiple rows. <b>PUT</b> is like an <code>UPDATE</code> using the primary key in the <code>WHERE</code> statement, if you do it multiple times, the row should be the same after each one. Some vendors may also allow you to <b>PUT</b> to create, which would be like an <code>INSERT INTO</code> providing a value for the auto-increment column.</span> <span> - </span> <span class="display-name">Jo.</span> <span> </span> <span class="date">16 Mar 2017 at 19:01</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>There is nothing that says you cannot implement POST to be idempotent, all the standard says is that it is treated as unsafe. Implenting an idempotent post for resource creation where the client can generate the id and pass along a request token to identify retries works well.. eg /api/foobars/{GUID}?request={AnotherGUID}</span> <span> - </span> <span class="display-name">nrjohnstone</span> <span> </span> <span class="date">20 Aug 2017 at 18:16</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Helpful mnemonic: Idem<b>PUT</b>ent</span> <span> - </span> <span class="display-name">Mercury</span> <span> </span> <span class="date">4 Sep 2019 at 07:38</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>834</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Nigel Thorne</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Apr 2010 at 05:52</span>
     </div>
    </div>
    <div>
     <ul>
      <li><strong>POST</strong> to a URL <strong>creates a child resource</strong> at a <em>server defined</em> URL.</li>
      <li><strong>PUT</strong> to a URL <strong>creates/replaces the resource</strong> in its entirety at the <em>client defined</em> URL.</li>
      <li><strong>PATCH</strong> to a URL <strong>updates <em>part</em> of the resource</strong> at that client defined URL.</li>
     </ul>
     <p>The relevant specification for PUT and POST is <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.5" rel="noreferrer">RFC 2616 §9.5ff.</a></p>
     <p><strong>POST creates a child resource</strong>, so POST to <code>/items</code> creates a resources that lives under the <code>/items</code> resource. Eg. <code>/items/1</code>. Sending the same post packet twice will create two resources.</p>
     <p><strong>PUT</strong> is for creating or replacing a resource at a <strong>URL known by the client</strong>.</p>
     <p>Therefore: <strong>PUT</strong> is only a candidate for CREATE where the client already knows the url before the resource is created. Eg. <code>/blogs/nigel/entry/when_to_use_post_vs_put</code> as the title is used as the resource key</p>
     <p><strong>PUT</strong> replaces the resource at the known url if it already exists, so sending the same request twice has no effect. In other words, <strong>calls to PUT are idempotent</strong>.</p>
     <p>The RFC reads like this:</p>
     <blockquote>
      <p>The fundamental difference between the POST and PUT requests is reflected in the different meaning of the Request-URI. The URI in a POST request identifies the resource that will handle the enclosed entity. That resource might be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. In contrast, the URI in a PUT request identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server MUST NOT attempt to apply the request to some other resource. If the server desires that the request be applied to a different URI,</p>
     </blockquote>
     <p><strong>Note:</strong> PUT has mostly been used to update resources (by replacing them in their entireties), but recently there is movement towards using PATCH for updating existing resources, as PUT specifies that it replaces the whole resource. <a href="https://www.rfc-editor.org/rfc/rfc5789" rel="noreferrer">RFC 5789.</a></p>
     <p><strong>Update 2018</strong>: There is a case that can be made to avoid PUT. See <a href="https://www.thoughtworks.com/radar/techniques/rest-without-put" rel="noreferrer">"REST without PUT"</a></p>
     <blockquote>
      <p>With “REST without PUT” technique, the idea is that consumers are forced to post new 'nounified' request resources. As discussed earlier, changing a customer’s mailing address is a POST to a new “ChangeOfAddress” resource, not a PUT of a “Customer” resource with a different mailing address field value.</p>
     </blockquote>
     <p>taken from <a href="https://www.thoughtworks.com/insights/blog/rest-api-design-resource-modeling" rel="noreferrer">REST API Design - Resource Modeling by Prakash Subramaniam of Thoughtworks</a></p>
     <p>This forces the API to avoid state transition problems with multiple clients updating a single resource, and matches more nicely with event sourcing and CQRS. When the work is done asynchronously, POSTing the transformation and waiting for it to be applied seems appropriate.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>69</td>
        <td><span>Or from the other side of the fence: PUT if the client determines the resulting resource's address, POST if the server does it.</span> <span> - </span> <span class="display-name">DanMan</span> <span> </span> <span class="date">28 Nov 2012 at 19:47</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>I think that this answer should be edited to make it more clear what @DanMan pointed in a very simple way. What I find the most valuable here is the note at the end, stating that a PUT should be used only for replacing the whole resource.</span> <span> - </span> <span class="display-name">Hermes</span> <span> </span> <span class="date">26 Nov 2013 at 22:37</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>PATCH isn't a realistic option for at least a few years, but I agree with the ideology.</span> <span> - </span> <span class="display-name">crush</span> <span> </span> <span class="date">3 Oct 2014 at 17:33</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>I'm trying to understand, but using PUT to create something would only make sense if the client knows for sure that the resource doesn't exist yet, right? Following the blog example, say you have created hundreds of blog posts in a couple of years, then accidentally pick the same title as you did for a post two years ago. Now you have gone and replaced that post, which wasn't intended. So using PUT to create would require the client to track what is taken and what is not, and could lead to accidents and unintended side effects, as well as having routes that do two entirely different things?</span> <span> - </span> <span class="display-name">galaxyAbstractor</span> <span> </span> <span class="date">30 Jan 2015 at 09:01</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>You are correct. PUTting a blog post at the same url as an existing one would cause an update to that existing post (although you could obviously check first with a GET). This indicates why it would be a bad idea to use just the title as the URL. It would however work anywhere there was a natural key in the data... which in my experience is rare. Or if you used GUIDs</span> <span> - </span> <span class="display-name">Nigel Thorne</span> <span> </span> <span class="date">3 Feb 2015 at 05:20</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@crush: Why isn't PATCH a realistic option for at least a few years?</span> <span> - </span> <span class="display-name">arthropod</span> <span> </span> <span class="date">21 Jun 2016 at 03:58</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@NigelThorne The only answer that talks about server defined and client defined URLs. Who does validation on client defined URLs?</span> <span> - </span> <span class="display-name">realPK</span> <span> </span> <span class="date">26 Jul 2016 at 22:17</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@PK_ the server validates the URL. The client would have to adhere to the url schema the server supports. Invalid urls would be rejected by the server.</span> <span> - </span> <span class="display-name">Nigel Thorne</span> <span> </span> <span class="date">30 Aug 2016 at 06:44</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I'm working on a project where the id's are known to the client. So I'd like to use PUT for creation. However, a colleague disagrees with the argument that it would be confusing if the resource would get deleted while someone else does a PUT (to update as a whole), now the resource would be recreated, even though it was deleted. His point is, that in a POST, PUT, DELETE scenario PUT should return a 404 if someone wants to update a resource and it doesn't exist. Any thoughts that might help?</span> <span> - </span> <span class="display-name">skofgar</span> <span> </span> <span class="date">21 Nov 2017 at 23:15</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>HTTP says ... when a client 'puts' to a url, it is requesting that url to hold that data. It's up to the server to decide if it's happy to do that. If you want 'DELETE' to stop PUTs working... then that's fine, but can you ever have anything at that url ever again? If so, then you should probably let the subsequent PUT through... after all one of your users is trying to put content at that location for a reason. Who's to say who was more correct? :) the answer is.. "your domain". Do what models your domain. but PUT means "I am trying to store this here".</span> <span> - </span> <span class="display-name">Nigel Thorne</span> <span> </span> <span class="date">22 Nov 2017 at 06:47</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@skofgar PUT is supposed to be idempotent (multiple identical requests have the same result.) That's a powerful concept and makes developers' lives infinitely easier because it's a reliable operation. I agree w/ the user confusion in that scenario, but I think you want to address that in the front end as much as possible. It's also not uncommon behavior and is sometimes very helpful (e.g. if editing in one browser tab, and you delete it in another by mistake, then saving restores the resource in its entirety)</span> <span> - </span> <span class="display-name">John Neuhaus</span> <span> </span> <span class="date">14 May 2018 at 15:41</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@skofgar In your scenario (clients know the ids and drive the creation). What about PUT to create and PATCH to partially update? You save some bandwidth and PATCH could fail if the resource is deleted.</span> <span> - </span> <span class="display-name">Marcel Toth</span> <span> </span> <span class="date">6 Feb 2020 at 00:56</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Good idea, I haven't seen PATCH being used very widely, furthermore I want to keep the API's as simple as possible. But I think using PATCH would have made sense in this case.</span> <span> - </span> <span class="display-name">skofgar</span> <span> </span> <span class="date">8 Feb 2020 at 16:23</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I was going to use PUT to edit profile but after reading the article and talking with the client, he told he only wanted users to edit specific parts of profile and I consider that to be a perfect application for /changeAddress of something as mentioned in the blog post as it puts the server back in control. And removes the state from the client. Not to mention that I can now record stuff like how often do users edit their profile and what do they change</span> <span> - </span> <span class="display-name">Hemil</span> <span> </span> <span class="date">24 Jul 2020 at 10:27</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>325</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Alexander Torstling</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Oct 2011 at 14:27</span>
     </div>
    </div>
    <div>
     <p><code>POST</code> means "create new" as in "Here is the input for creating a user, create it for me".</p>
     <p><code>PUT</code> means "insert, replace if already exists" as in "Here is the data for user 5".</p>
     <p>You <code>POST</code> to example.com/users since you don't know the <code>URL</code> of the user yet, you want the server to create it.</p>
     <p>You <code>PUT</code> to example.com/users/id since you want to replace/create a <em>specific</em> user.</p>
     <p>POSTing twice with the same data means create two identical users with different ids. PUTing twice with the same data creates the user the first and updates him to the same state the second time (no changes). Since you end up with the same state after a <code>PUT</code> no matter how many times you perform it, it is said to be "equally potent" every time - idempotent. This is useful for automatically retrying requests. No more 'are you sure you want to resend' when you push the back button on the browser.</p>
     <p>A general advice is to use <code>POST</code> when you need the server to be in control of <code>URL</code> generation of your resources. Use <code>PUT</code> otherwise. Prefer <code>PUT</code> over <code>POST</code>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>28</td>
        <td><span>Sloppiness may have cause it to be commonly taught that there are only two verbs you need: GET and POST. GET to obtain, POST to change. Even PUT and DELETE were performed using POST. Asking what PUT really means 25 years later maybe a sign we learned it wrong at first. REST popularity drove people back to the basics where we must now unlearn past bad mistakes. POST was overused and now commonly taught incorrectly. Best part: "POSTing twice with the same data means create two identical [resources]". Great point!</span> <span> - </span> <span class="display-name">maxpolk</span> <span> </span> <span class="date">1 Sep 2014 at 19:36</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>How can you use PUT to create a record by the ID, like in your example <code>user 5</code> if it doesn't exist yet? Don't you mean <code>update, replace if already exists</code>? or something</span> <span> - </span> <span class="display-name">Luke</span> <span> </span> <span class="date">28 Nov 2014 at 12:44</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Coulton: I meant what I wrote. You insert user 5 if you PUT to /users/5 and #5 does not exist yet.</span> <span> - </span> <span class="display-name">Alexander Torstling</span> <span> </span> <span class="date">28 Nov 2014 at 15:46</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Coulton: And <code>PUT</code> can also be used to <i>replace</i> the value of an <i>existing</i> resource in its entirety.</span> <span> - </span> <span class="display-name">DavidRR</span> <span> </span> <span class="date">16 Dec 2014 at 14:02</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>"Prefer PUT over POST"... care to justify that?</span> <span> - </span> <span class="display-name">thecoshman</span> <span> </span> <span class="date">8 Jun 2015 at 08:04</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@thecoshman: Sure. I wrote that as a general advise. My reasoning is that PUT is idempotent, hence better from a network perspective. POST is also more general, so by recommending PUT you avoid POST being used for situations where PUT would have sufficed. POST is also heavily overused due to browser restrictions, and so a recommendation against it will have positive effects for REST as a concept. There are also some positive effects in the URL scheme when the clients are in control of the URL construction IMO, but I cannot fit that into a comment here.</span> <span> - </span> <span class="display-name">Alexander Torstling</span> <span> </span> <span class="date">8 Jun 2015 at 09:08</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@AlexanderTorstling excuse whilst I try to tease out solid reasoning others might benefit from. Better from a network perspective how? Sure if your network goes down and you failed to confirmation you can just re-create, but what if it did work, and then someone else modified? Your re-PUT will overwrite what they did. You make it sound like POST has some extra overhead compared to PUT (where PUT would have sufficed). I think the fact POST is overused should not mean we advise against it when it is the correct choice, just learn to advise the right choices. That Last point is rather subjective.</span> <span> - </span> <span class="display-name">thecoshman</span> <span> </span> <span class="date">8 Jun 2015 at 13:09</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@thecoshman: I was thinking of retries, yes. PUT concurrency can be controlled by conditional headers like If-Modified et al. Doing the same for POST would result in much coarser locking. You have a point in advocating the right choices, I however had no intention of banning POST. Perhaps "Use PUT when possible" would have been a better wording?</span> <span> - </span> <span class="display-name">Alexander Torstling</span> <span> </span> <span class="date">8 Jun 2015 at 14:28</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@AlexanderTorstling well, my main point was that your answer states you should have a preference, with no justification for it. Your responses here however seem fairly justifiable. That said, I don't think it's the correct reasoning to use for PUT vs POST</span> <span> - </span> <span class="display-name">thecoshman</span> <span> </span> <span class="date">9 Jun 2015 at 16:12</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Here is one benefit that using POST to create a resource has over PUT. In this case, if you try to modify a resource that doesn't exist yet (using PUT), you will get an error. To generalize this advice beyond PUT vs POST, try to not to use an interface where the result/action depends on the current state, because the user may have an incorrect assumption about what the current state is (in the put example, he thinks the resource already exists). Use two separate interfaces and throw an error if the current state does not match the preconditions.</span> <span> - </span> <span class="display-name">Kevin Wheeler</span> <span> </span> <span class="date">8 Sep 2015 at 23:07</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>PS I still don't understand what is meant by "Better from a network perspective." I can, however, think of at least one reason on my own as to why PUT would be better from a network perspective: the results can be cached (perhaps by a proxy cache server).</span> <span> - </span> <span class="display-name">Kevin Wheeler</span> <span> </span> <span class="date">8 Sep 2015 at 23:10</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>I would say that POSTing twice with the same data MAY result in two identical users. Were I creating my API, if someone tried to POST a new user with the same email address, but different data, I might issue a 409. If someone tried to POST a new user with identical data, I might issue a 303. I probably wouldn't want my system to be able to have two identical users.</span> <span> - </span> <span class="display-name">Dan Jones</span> <span> </span> <span class="date">27 Dec 2015 at 16:24</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I don't think this is true at least for App with database ... so if I have a POST */createUser/diego and PUT */createUser/jose , and I clicked twice and both with the method persisted() , it will insert 4 records.</span> <span> - </span> <span class="display-name">diego matos - keke</span> <span> </span> <span class="date">16 Mar 2016 at 22:58</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@diegomatos-keke: You are not supposed to PUT or POST to a verb URI like "createUser". You are supposed to POST to '*/users' to create Diego and PUT to '*/users/diego' to update Diego. If you click twice for the POST, you will create 2 Diegos. But if you click twice for the PUT, you will update Diego twice, but not create 2 Diegos.</span> <span> - </span> <span class="display-name">Alexander Torstling</span> <span> </span> <span class="date">17 Mar 2016 at 08:42</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@AlexanderTorstling commenting to point your attention to <a href="http://stackoverflow.com/questions/39057416/how-to-ignore-multiple-clicks-from-an-impatient-user" title="how to ignore multiple clicks from an impatient user">stackoverflow.com/questions/39057416/…</a>. maybe you can help.</span> <span> - </span> <span class="display-name">Roam</span> <span> </span> <span class="date">20 Aug 2016 at 19:23</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>it is ok according to RFC <a href="https://tools.ietf.org/html/rfc2616#page-54" rel="nofollow noreferrer">tools.ietf.org/html/rfc2616#page-54</a></span> <span> - </span> <span class="display-name">F.Tamy</span> <span> </span> <span class="date">7 Sep 2020 at 07:17</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>282</span>
     </div>
     <div>
      <span>Answerer: </span> <span>7hi4g0</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Aug 2013 at 22:47</span>
     </div>
    </div>
    <div>
     <h1>Summary:</h1>
     <h2>Create:</h2>
     <p>Can be performed with both PUT or POST in the following way:</p>
     <blockquote>
      <h3>PUT</h3>
      <p>Creates <strong>THE</strong> new resource with <strong>newResourceId</strong> as the identifier, under the /resources URI, or <strong>collection</strong>.</p>
      <pre><code>PUT /resources/&lt;newResourceId&gt; HTTP/1.1
</code></pre>
      <h3>POST</h3>
      <p>Creates <strong>A</strong> new resource under the /resources URI, or <strong>collection</strong>. Usually the identifier is returned by the server.</p>
      <pre><code>POST /resources HTTP/1.1
</code></pre>
     </blockquote>
     <h2>Update:</h2>
     <p>Can <strong>only</strong> be performed with PUT in the following way:</p>
     <blockquote>
      <h3>PUT</h3>
      <p>Updates the resource with <strong>existingResourceId</strong> as the identifier, under the /resources URI, or <strong>collection</strong>.</p>
      <pre><code>PUT /resources/&lt;existingResourceId&gt; HTTP/1.1
</code></pre>
     </blockquote>
     <h1>Explanation:</h1>
     <p>When dealing with REST and URI as general, you have <strong>generic</strong> on the <em>left</em> and <strong>specific</strong> on the <em>right</em>. The <strong>generics</strong> are usually called <strong>collections</strong> and the more <strong>specific</strong> items can be called <strong>resource</strong>. Note that a <strong>resource</strong> can contain a <strong>collection</strong>.</p>
     <blockquote>
      <h2>Examples:</h2>
      <p><strong>&lt;-- generic -- specific --&gt;</strong></p>
      <pre><code>URI: website.example/users/john
website.example  - whole site
users        - collection of users
john         - item of the collection, or a resource

URI:website.example/users/john/posts/23
website.example  - whole site
users        - collection of users
john         - item of the collection, or a resource
posts        - collection of posts from john
23           - post from john with identifier 23, also a resource
</code></pre>
     </blockquote>
     <p>When you use POST you are <strong>always</strong> refering to a <strong>collection</strong>, so whenever you say:</p>
     <pre><code>POST /users HTTP/1.1
</code></pre>
     <p>you are posting a new user to the <em>users</em> <strong>collection</strong>.</p>
     <p>If you go on and try something like this:</p>
     <pre><code>POST /users/john HTTP/1.1
</code></pre>
     <p>it will work, but semantically you are saying that you want to add a resource to the <em>john</em> <strong>collection</strong> under the <em>users</em> <strong>collection</strong>.</p>
     <p>Once you are using PUT you are refering to a <strong>resource</strong> or single item, possibly inside a <strong>collection</strong>. So when you say:</p>
     <pre><code>PUT /users/john HTTP/1.1
</code></pre>
     <p>you are telling to the server update, or create if it doesn't exist, the <em>john</em> <strong>resource</strong> under the <em>users</em> <strong>collection</strong>.</p>
     <h2>Spec:</h2>
     <p>Let me highlight some important parts of the spec:</p>
     <h3>POST</h3>
     <blockquote>
      <p>The <strong>POST</strong> method is used to request that the origin server <strong>accept</strong> the entity enclosed in the request as a <strong><em>new</em> subordinate</strong> of the resource identified by the Request-URI in the Request-Line</p>
     </blockquote>
     <p>Hence, creates a new <strong>resource</strong> on a <strong>collection</strong>.</p>
     <h3>PUT</h3>
     <blockquote>
      <p>The <strong>PUT</strong> method requests that the enclosed entity be <strong>stored</strong> under the supplied Request-URI. If the Request-URI refers to an <strong>already existing</strong> resource, the enclosed entity SHOULD be considered as a <strong>modified version</strong> of the one residing on the origin server. If the Request-URI does <strong>not point to an existing</strong> resource, and that URI is <strong>capable</strong> of being defined as a <strong><em>new</em> resource</strong> by the requesting user agent, the origin server can <strong>create</strong> the resource with that URI."</p>
     </blockquote>
     <p>Hence, create or update based on existence of the <strong>resource</strong>.</p>
     <h1>Reference:</h1>
     <ul>
      <li><a href="https://www.rfc-editor.org/rfc/rfc7231#section-4.3.3" rel="noreferrer">HTTP/1.1 Spec</a></li>
      <li><a href="http://en.wikipedia.org/wiki/Representational_state_transfer" rel="noreferrer">Wikipedia - REST</a></li>
      <li><a href="http://www.ietf.org/rfc/rfc2396.txt" rel="noreferrer">Uniform Resource Identifiers (URI): Generic Syntax and Semantics</a></li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>19</td>
        <td><span>This post was helpful to me in understanding that POST adds "something" as a child to the given collection (URI), whereas PUT explicitly defines the "something" at the given URI location.</span> <span> - </span> <span class="display-name">kwah</span> <span> </span> <span class="date">23 Nov 2013 at 16:33</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>It is a very reasonable way to implement a CRUD API that is REST/http complient. A good reading: the RFC about HTTP, and in particular what is idempotent and the expected behavior of web cache. The use of POST/PUT are constrained by the expected behavior of cache (web or user agent)</span> <span> - </span> <span class="display-name">mcoolive</span> <span> </span> <span class="date">21 Oct 2014 at 09:34</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>No, PUT is not for update or create. It is for replacing. Note that you can replace nothing with something for the effect of creating.</span> <span> - </span> <span class="display-name">thecoshman</span> <span> </span> <span class="date">8 Jun 2015 at 08:07</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@thecoshman I have posted in my answer the relevant parts of the HTTP/1.1 spec. Read the last part of my answer entitled <code>Spec</code>. The spec clearly states that <code>PUT</code> is used to <i>create</i> or <i>update</i> an entity.</span> <span> - </span> <span class="display-name">7hi4g0</span> <span> </span> <span class="date">8 Jun 2015 at 12:50</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@7hi4g0 PUT is for for updating with a complete replacement, in other words, it replaces. You replace nothing with something, or something with a completely new something. PUT is not for making a minor change (unless you have the client make that minor change and provide the entire new version, even what is remaining the same). For partial modification, PATCH is the method of choice.</span> <span> - </span> <span class="display-name">thecoshman</span> <span> </span> <span class="date">8 Jun 2015 at 12:57</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@thecoshman I never said that <code>PUT</code> should be used for partial modification. If you don't like the terminology, I can restate. The spec clearly states that <code>PUT</code> is used to <i>create</i> or <i>modify</i> an entity.</span> <span> - </span> <span class="display-name">7hi4g0</span> <span> </span> <span class="date">8 Jun 2015 at 13:07</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@thecoshman I guess you can say, <i>create</i> or <i>replace</i>, but the two are different actions according to the Spec. Either way, <i>update</i>, <i>modify</i>, <i>replace</i> are only terms.</span> <span> - </span> <span class="display-name">7hi4g0</span> <span> </span> <span class="date">8 Jun 2015 at 13:15</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@7hi4g0 my point is, if you read the rest of that sentence from the spec, you are updating that URI to have a completely new resource at that location. As such, it is replace 100% with what data is included in this <code>PUT</code> request. Likewise, I'd argue that create is effectively just replacing 'nothing with something'. And so, you can "Keep It Simple Stupid" by just saying "PUT is for replacing".</span> <span> - </span> <span class="display-name">thecoshman</span> <span> </span> <span class="date">9 Jun 2015 at 16:15</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@thecoshman You could, but it wouldn't be too clear that create is also covered in there. In this case, it is better to be explicit.</span> <span> - </span> <span class="display-name">7hi4g0</span> <span> </span> <span class="date">9 Jun 2015 at 20:21</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@7hi4g0 I would generally say that POST is (usually) more appropriate for create, but still. I think we can leave it at that, we've at least given people sensible discussion to think about, which IMO is the most important thing to have when you have fluffy 'guideline' :P</span> <span> - </span> <span class="display-name">thecoshman</span> <span> </span> <span class="date">9 Jun 2015 at 21:37</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>PUT <b><i>can</i></b> be used to create a resource and is appropriate for creating resources <b><i>if</i></b> the client is responsible for providing the URL structure. However, it is <b><i>highly unlikely</i></b> that in your solution it is appropriate for the client to provide the URL structure.</span> <span> - </span> <span class="display-name">Joshcodes</span> <span> </span> <span class="date">11 Sep 2015 at 14:49</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Of course you can POST an 'update'. If you keep prior versions around (and there are many reasons why you may want to do so) then your update is not idempotent and so cannot be expressed by PUT. (Or in other words everything turns into a collection when you stare at it hard enough)</span> <span> - </span> <span class="display-name">CurtainDog</span> <span> </span> <span class="date">5 Sep 2018 at 06:20</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>upvoted! curious question when you do insert on conflict do nothing, i am guessing post is what should be used since put would actually replace it</span> <span> - </span> <span class="display-name">PirateApp</span> <span> </span> <span class="date">4 Feb 2020 at 04:02</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>192</span>
     </div>
     <div>
      <span>Answerer: </span> <span>ThaDon</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Jan 2011 at 19:59</span>
     </div>
    </div>
    <div>
     <p>I'd like to add my "pragmatic" advice. Use PUT when you know the "id" by which the object you are saving can be retrieved. Using PUT won't work too well if you need, say, a database generated id to be returned for you to do future lookups or updates.</p>
     <p>So: To save an existing user, or one where the client generates the id and it's been verified that the id is unique:</p>
     <pre><code>PUT /user/12345 HTTP/1.1  &lt;-- create the user providing the id 12345
Host: mydomain.example

GET /user/12345 HTTP/1.1  &lt;-- return that user
Host: mydomain.example
</code></pre>
     <p>Otherwise, use POST to initially create the object, and PUT to update the object:</p>
     <pre><code>POST /user HTTP/1.1   &lt;--- create the user, server returns 12345
Host: mydomain.example

PUT /user/12345 HTTP/1.1  &lt;--- update the user
Host: mydomain.example
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>20</td>
        <td><span>Actually, it should be <code>POST /users</code>. (Note that <code>/users</code> is plural.) This has the affect of creating a new user and making it a child resource of the <code>/users</code> collection.</span> <span> - </span> <span class="display-name">DavidRR</span> <span> </span> <span class="date">16 Dec 2014 at 13:54</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>@DavidRR to be fair, how to handle groups is another debate altogether. <code>GET /users</code> makes sense, it reads as you want, but I'd be ok with <code>GET /user/&lt;id&gt;</code> or <code>POST /user</code> (with payload for said new user) because it reads correctly 'get me users 5' is odd, but 'get me user 5' is more natural. I'd probably still fall down on the side of pluralisation though :)</span> <span> - </span> <span class="display-name">thecoshman</span> <span> </span> <span class="date">8 Jun 2015 at 07:57</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>@thecoshman You can read it like 'from users get me id 5' ;)</span> <span> - </span> <span class="display-name">xuiqzy</span> <span> </span> <span class="date">8 Nov 2020 at 11:56</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>@xuiqzy hmm, I quite like this way of thinking about it really, and expands nicely <code>GET /users/5/documents/4/title</code> would be like 'get the users, from there get me user 5, from there get me the documents, from there get me document 4, from there get me the title'</span> <span> - </span> <span class="display-name">thecoshman</span> <span> </span> <span class="date">17 Nov 2020 at 22:54</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>171</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Premraj</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Sep 2015 at 13:12</span>
     </div>
    </div>
    <div>
     <p>Both are used for data transmission between client to server, but there are subtle differences between them, which are:</p>
     <div class="s-table-container">
      <table class="s-table">
       <thead>
        <tr>
         <th>PUT</th>
         <th>POST</th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td>Replacing existing resource or creating if resource is not exist. <code>www.example.com/com/customer/{customerId} www.example.com/com/customer/123/order/{orderId}</code> Identifier is chosen by the client.</td>
         <td>Creating new resources and subordinate resources, e.g. a file is subordinate to a directory containing it or a row is subordinate to a database table. <code>www.example.com/com/customer/ www.example.com/com/customer/123/order/</code> identifier is returned by server</td>
        </tr>
        <tr>
         <td>Idempotent i.e. if you <code>PUT</code> a resource twice, it has no effect. Example: Do it as many times as you want, the result will be same. <code>x=1;</code></td>
         <td><code>POST</code> is neither safe nor idempotent. Example: <code>x++;</code></td>
        </tr>
        <tr>
         <td>Works as specific</td>
         <td>Works as abstractive</td>
        </tr>
        <tr>
         <td>If you create or update a resource using <code>PUT</code> and then make that same call again, the resource is still there and still has the same state as it did with the first call.</td>
         <td>Making two identical <code>POST</code> requests will most likely result in two resources containing the same information.</td>
        </tr>
       </tbody>
      </table>
     </div>
     <p>Analogy:</p>
     <ul>
      <li>PUT i.e. take and <strong>put</strong> where it was.</li>
      <li>POST as send mail in <strong>post</strong> office.</li>
     </ul>
     <p><a href="https://i.stack.imgur.com/AQKrz.jpg" rel="noreferrer"><img src="/question/stackoverflow/630453/AQKrz.jpg" alt="enter image description here"></a></p>
     <p>Social Media/Network Analogy:</p>
     <ul>
      <li><strong>Post</strong> on social media: when we post message, it creates new post.</li>
      <li><strong>Put</strong>(i.e. edit) for the message we already Posted.</li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>24</td>
        <td><span>@MobileMon No, REST methods are not CRUD.</span> <span> - </span> <span class="display-name">jlr</span> <span> </span> <span class="date">8 Jan 2016 at 19:06</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>I'd say PUT for UPSERTS</span> <span> - </span> <span class="display-name">Hola Soy Edu Feliz Navidad</span> <span> </span> <span class="date">26 Nov 2018 at 11:45</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@MobileMon no : POST when you create a new resource and you don't know the final endpoint to get it. PUT for other cases.</span> <span> - </span> <span class="display-name">Portekoi</span> <span> </span> <span class="date">19 Jul 2019 at 13:33</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>152</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Tim Sullivan</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Mar 2009 at 14:28</span>
     </div>
    </div>
    <div>
     <p>Use POST to create, and PUT to update. That's how Ruby on Rails is doing it, anyway.</p>
     <pre><code>PUT    /items/1      #=&gt; update
POST   /items        #=&gt; create
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span><code>POST /items</code> adds a new item to an already defined resource ('item'). It does not, as the answer says, "create a group." I don't understand why this has 12 votes.</span> <span> - </span> <span class="display-name">David J.</span> <span> </span> <span class="date">21 Jun 2012 at 05:26</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Out of the box, Rails does not support 'creating a group' via REST. To 'create a group' by which I mean 'create a resource' you have to do it via the source code.</span> <span> - </span> <span class="display-name">David J.</span> <span> </span> <span class="date">21 Jun 2012 at 05:28</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>It has 12 votes because it predates the change that was made that added the group thing. I've reverted the change.</span> <span> - </span> <span class="display-name">Tim Sullivan</span> <span> </span> <span class="date">21 Jun 2012 at 15:20</span></td>
       </tr>
       <tr>
        <td>9</td>
        <td><span>This is a fair guideline, but an oversimplification. As the other answers mention, either method could be used for both create and update.</span> <span> - </span> <span class="display-name">Brad Koch</span> <span> </span> <span class="date">7 Mar 2013 at 15:55</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>I agree with the answer with a slight modification. Use POST to create and PUT to update the resource completely. For partial updates, we can use PUT or PATCH. Lets say we want to update the status of a group. We can use PUT /groups/1/status with the status is the request payload or PATCH /groups/1 with the details about the action in the payload</span> <span> - </span> <span class="display-name">java_geek</span> <span> </span> <span class="date">6 Oct 2014 at 06:26</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@BradKoch You are right with the statement; but when you are designing a RESTful API, you need to ensure that its consistent so that it makes life easy for clients consuming your API's. If you are using POST/PUT interchangeably to create/update resources it makes life hard for your consumer. You would want to keep it easy for your clients because thats how you grow your consumer base.</span> <span> - </span> <span class="display-name">java_geek</span> <span> </span> <span class="date">6 Oct 2014 at 06:38</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>It should also be made clear that <code>PUT /items/42</code> is also valid for <i>creating</i> a resource, <i>but only if the client has the privilege of naming the resource</i>. (Does Rails allow a client this naming privilege?)</span> <span> - </span> <span class="display-name">DavidRR</span> <span> </span> <span class="date">16 Dec 2014 at 14:10</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Nice and short +1. For extra details one can read further :)</span> <span> - </span> <span class="display-name">Akif</span> <span> </span> <span class="date">23 Feb 2021 at 13:06</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>75</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Jörg W Mittag</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Mar 2009 at 15:27</span>
     </div>
    </div>
    <div>
     <p>REST is a <em>very</em> high-level concept. In fact, it doesn't even mention HTTP at all!</p>
     <p>If you have any doubts about how to implement REST in HTTP, you can always take a look at the <a href="https://www.ietf.org/rfc/rfc5023.txt" rel="noreferrer">Atom Publication Protocol (AtomPub)</a> specification. AtomPub is a standard for writing RESTful webservices with HTTP that was developed by many HTTP and REST luminaries, with some input from Roy Fielding, the inventor of REST and (co-)inventor of HTTP himself.</p>
     <p>In fact, you might even be able to use AtomPub directly. While it came out of the blogging community, it is in no way restricted to blogging: it is a generic protocol for RESTfully interacting with arbitrary (nested) collections of arbitrary resources via HTTP. If you can represent your application as a nested collection of resources, then you can just use AtomPub and not worry about whether to use PUT or POST, what HTTP Status Codes to return and all those details.</p>
     <p>This is what AtomPub has to say about resource creation (section 9.2):</p>
     <blockquote>
      <p>To add members to a Collection, clients send POST requests to the URI of the Collection.</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>9</td>
        <td><span>There's nothing wrong with allowing PUT to create resources. Just be aware that it means that the client provides the URL.</span> <span> - </span> <span class="display-name">Julian Reschke</span> <span> </span> <span class="date">7 Apr 2010 at 07:47</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>There's something very wrong with allowing PUT to create resources: the client provides the URL. That's the server's job!</span> <span> - </span> <span class="display-name">Joshcodes</span> <span> </span> <span class="date">29 Oct 2013 at 17:33</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Joshcodes It is not always the case that it is the server's job to create client ids. I have increasingly seen designs that let clients generate some sort of UUID as the resource id. This design lends itself in particular to increase scale.</span> <span> - </span> <span class="display-name">Justin Ohms</span> <span> </span> <span class="date">5 Feb 2017 at 18:26</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@JustinOhms I agree with your point about client generated IDs (side note: all systems designed by me since circa 2008 require the client to create the ID as a UUID/Guid). That does not mean the client should specify the URL.</span> <span> - </span> <span class="display-name">Joshcodes</span> <span> </span> <span class="date">6 Feb 2017 at 18:24</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Joshcodes It's matter of separating concerns. Where the URL is generated is actually of little consequence. Yes the server is responsible for delivering content from the correct URL but that does not limit a server from responding to a request on an incorrect URL. The correct response from the server in this case is a 308. A proper client will then retry the PUT on the correct URL. Another example is a distributed system where not all nodes know of all resource provided by clients. Here a PUT to create would be perfectly valid because for that server node the resource does not exist.</span> <span> - </span> <span class="display-name">Justin Ohms</span> <span> </span> <span class="date">6 Feb 2017 at 19:48</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@JustinOhms I agree completely it's about separating concerns. I also agree there are edge cases for using PUT (one encountered recently by me involved a data import than needed the ability to re-run). The approach you have outlined above works because the server "instruct(s) clients on how to construct appropriate URIs", (Roy Fielding's words). However, it is not obvious to me why that is better than just using POST as intended.</span> <span> - </span> <span class="display-name">Joshcodes</span> <span> </span> <span class="date">6 Feb 2017 at 20:48</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Joshcodes The reason to use a PUT like this in a multi node setup is that that for the client to switch from PUT to POST the client would require knowledge about the state of the data on that node. It seems odd because we are often think of the server as being a single authority however in a distributed system with eventual consistency the client may actually have more information than any given server node at any point in time. In this case the client knows the resource exists, the node does not. (maybe a sync is needed) Plus POST would not be appropriate because the resource does exist.</span> <span> - </span> <span class="display-name">Justin Ohms</span> <span> </span> <span class="date">6 Feb 2017 at 21:28</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Yes, if the resource already exists, use PUT. However, in nearly all cases, the resources should be created with POST and the client should not provide the URL. Roy Fielding agrees with this statement FWIW: <a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" rel="nofollow noreferrer">roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driv‌​en</a></span> <span> - </span> <span class="display-name">Joshcodes</span> <span> </span> <span class="date">7 Feb 2017 at 01:26</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Any reference for "with some input from Roy Fielding"?</span> <span> - </span> <span class="display-name">wlnirvana</span> <span> </span> <span class="date">27 Apr 2020 at 07:28</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>72</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Joshcodes</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Oct 2013 at 23:00</span>
     </div>
    </div>
    <div>
     <p><strong>The decision of whether to use PUT or POST to create a resource on a server with an HTTP + REST API is based on who owns the URL structure.</strong> Having the client know, or participate in defining, the URL struct is an unnecessary coupling akin to the undesirable couplings that arose from SOA. Escaping types of couplings is the reason REST is so popular. Therefore, <strong>the proper method to use is POST.</strong> There are exceptions to this rule and they occur when the client wishes to retain control over the location structure of the resources it deploys. This is rare and likely means something else is wrong.</p>
     <p>At this point some people will argue that if <em>RESTful-URL's</em> are used, the client does knows the URL of the resource and therefore a PUT is acceptable. After all, this is why canonical, normalized, Ruby on Rails, Django URLs are important, look at the Twitter API … blah blah blah. Those people need to understand <strong>there is no such thing as a Restful-URL</strong> and that <strong>Roy Fielding himself states that</strong>:</p>
     <blockquote>
      <p>A REST API must not define fixed resource names or hierarchies (an obvious coupling of client and server). Servers must have the freedom to control their own namespace. Instead, allow servers to instruct clients on how to construct appropriate URIs, such as is done in HTML forms and URI templates, by defining those instructions within media types and link relations. [Failure here implies that clients are assuming a resource structure due to out-of band information, such as a domain-specific standard, which is the data-oriented equivalent to RPC's functional coupling].</p>
      <p><a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" rel="noreferrer">http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven</a></p>
     </blockquote>
     <p>The idea of a <em>RESTful-URL</em> is actually a violation of REST as the server is in charge of the URL structure and should be free to decide how to use it to avoid coupling. If this confuses you read about the significance of self discovery on API design.</p>
     <p><strong>Using POST to create resources comes with a design consideration because POST is not idempotent.</strong> This means that repeating a POST several times does not guarantee the same behavior each time. <strong>This scares people into using PUT to create resources when they should not.</strong> They know it's wrong (POST is for CREATE) but they do it anyway because they don't know how to solve this problem. This concern is demonstrated in the following situation:</p>
     <ol>
      <li>The client POST a new resource to the server.</li>
      <li>The server processes the request and sends a response.</li>
      <li>The client never receives the response.</li>
      <li>The server is unaware the client has not received the response.</li>
      <li>The client does not have a URL for the resource (therefore PUT is not an option) and repeats the POST.</li>
      <li>POST is not idempotent and the server …</li>
     </ol>
     <p>Step 6 is where people commonly get confused about what to do. However, there is no reason to create a kludge to solve this issue. Instead, HTTP can be used as specified in <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.10" rel="noreferrer" title="RFC 2616 409 Conflict">RFC 2616</a> and the server replies:</p>
     <blockquote>
      <p>10.4.10 409 Conflict</p>
      <p>The request could not be completed due to a conflict with the current state of the resource. This code is only allowed in situations where it is expected that the user might be able to resolve the conflict and resubmit the request. The response body SHOULD include enough</p>
      <p>information for the user to recognize the source of the conflict. Ideally, the response entity would include enough information for the user or user agent to fix the problem; however, that might not be possible and is not required.</p>
      <p>Conflicts are most likely to occur in response to a PUT request. For example, if versioning were being used and the entity being PUT included changes to a resource which conflict with those made by an earlier (third-party) request, the server might use the 409 response to indicate that it can’t complete the request. In this case, the response entity would likely contain a list of the differences between the two versions in a format defined by the response Content-Type.</p>
     </blockquote>
     <p><strong>Replying with a status code of 409 Conflict is the correct recourse because</strong>:</p>
     <ul>
      <li>Performing a POST of data which has an ID which matches a resource already in the system is “a conflict with the current state of the resource.”</li>
      <li>Since the important part is for the client to understand the server has the resource and to take appropriate action. This is a “situation(s) where it is expected that the user might be able to resolve the conflict and resubmit the request.”</li>
      <li>A response which contains the URL of the resource with the conflicting ID and the appropriate preconditions for the resource would provide “enough information for the user or user agent to fix the problem” which is the ideal case per RFC 2616.</li>
     </ul>
     <p><strong>Update based on release of RFC 7231 to Replace 2616</strong></p>
     <p><a href="https://www.rfc-editor.org/rfc/rfc7231" rel="noreferrer">RFC 7231</a> is designed to replace 2616 and in <a href="https://www.rfc-editor.org/rfc/rfc7231#section-4.3.3" rel="noreferrer" title="RFC 7231 - Section 4.3.3">Section 4.3.3</a> describes the follow possible response for a POST</p>
     <blockquote>
      <p>If the result of processing a POST would be equivalent to a representation of an existing resource, an origin server MAY redirect the user agent to that resource by sending a 303 (See Other) response with the existing resource's identifier in the Location field. This has the benefits of providing the user agent a resource identifier and transferring the representation via a method more amenable to shared caching, though at the cost of an extra request if the user agent does not already have the representation cached.</p>
     </blockquote>
     <p>It now may be tempting to simply return a 303 in the event that a POST is repeated. However, the opposite is true. Returning a 303 would only make sense if multiple create requests (creating different resources) return the same content. An example would be a "thank you for submitting your request message" that the client need not re-download each time. RFC 7231 still maintains in section 4.2.2 that POST is not to be idempotent and continues to maintain that POST should be used for create.</p>
     <p>For more information about this, read this <a href="http://articles.joshcodes.com/?p=5" rel="noreferrer" title="POST to PUT to REST how to properly create resources on a server">article</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Would a 409 Conflict response be the appropriate code for something like trying to create a new account with a username that already exists? I've been using 409 for versioning conflicts specifically, but after reading your answer, I wonder if it shouldn't be used for any "duplicate" requests.</span> <span> - </span> <span class="display-name">Eric B.</span> <span> </span> <span class="date">9 Jul 2014 at 04:43</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@EricB. Yes, in the situation you describe "due to a conflict with the current state of the resource" the operation fails. Additionally, it is reasonable to expect that the user can resolve the conflict and the message body only needs to inform the user that the username already exists.</span> <span> - </span> <span class="display-name">Joshcodes</span> <span> </span> <span class="date">10 Jul 2014 at 13:25</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Joshcodes can you say more about the conflict resolution process? In this case, if the username already exists is the client expected to prompt the end user for a different username? What if the client is actually trying to use POST to change the username? Should PUT requests still be used for updating parameters, while POST is used for creating objects whether it be one at a time or several? Thanks.</span> <span> - </span> <span class="display-name">BFar</span> <span> </span> <span class="date">22 Jan 2015 at 22:41</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@BFar2 if the username already exists then the client should prompt the user. To change the username, assuming the username is part of an already created resource which needs modified, PUT would be used because you are correct, POST is used for create, always and PUT for updates.</span> <span> - </span> <span class="display-name">Joshcodes</span> <span> </span> <span class="date">23 Jan 2015 at 01:09</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Joshcodes i'm seeking an answer to <a href="http://stackoverflow.com/questions/39057416/how-to-ignore-multiple-clicks-from-an-impatient-user" title="how to ignore multiple clicks from an impatient user">stackoverflow.com/questions/39057416/…</a>. commenting now to point your attention to it.</span> <span> - </span> <span class="display-name">Roam</span> <span> </span> <span class="date">20 Aug 2016 at 19:20</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Joshcodes i'm aware the work on <a href="http://stackoverflow.com/questions/39057416/how-to-ignore-multiple-clicks-from-an-impatient-user" title="how to ignore multiple clicks from an impatient user">stackoverflow.com/questions/39057416/…</a> doesn't comply w/Restful architecture. yet works for our case as an exception.</span> <span> - </span> <span class="display-name">Roam</span> <span> </span> <span class="date">20 Aug 2016 at 19:21</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Joshcodes Interesting. to clarify: <i>Performing a POST of data which has an ID which matches a resource already in the system is a conflict"</i> Isn't your prescription that a POST never includes an ID since the server decides the ID?</span> <span> - </span> <span class="display-name">Iain</span> <span> </span> <span class="date">23 Sep 2017 at 23:46</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Iain, the client determines the ID. The server determines the URL.</span> <span> - </span> <span class="display-name">Joshcodes</span> <span> </span> <span class="date">24 Sep 2017 at 14:01</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Joshcodes How is the client to determine the ID? Generating a UUID? What about apps that just use the auto-incrementing table ID; something I see a lot. Is this just bad practice?</span> <span> - </span> <span class="display-name">Kenmore</span> <span> </span> <span class="date">25 Feb 2018 at 01:41</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Zuko, In my opinion, auto-incrementing table IDs have no place in a distributed environment. UUID's are superior in every way except storage space. Ints for IDs are a holdover from when DB storage was a larger concern that it is today.</span> <span> - </span> <span class="display-name">Joshcodes</span> <span> </span> <span class="date">5 Mar 2018 at 18:14</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>57</span>
     </div>
     <div>
      <span>Answerer: </span> <span>metamatt</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Jan 2012 at 17:18</span>
     </div>
    </div>
    <div>
     <p>I like this advice, from <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">RFC 2616's definition of PUT</a>:</p>
     <blockquote>
      <p>The fundamental difference between the POST and PUT requests is reflected in the different meaning of the Request-URI. The URI in a POST request identifies the resource that will handle the enclosed entity. That resource might be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. In contrast, the URI in a PUT request identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server MUST NOT attempt to apply the request to some other resource.</p>
     </blockquote>
     <p>This jibes with the other advice here, that PUT is best applied to resources that already have a name, and POST is good for creating a new object under an existing resource (and letting the server name it).</p>
     <p>I interpret this, and the idempotency requirements on PUT, to mean that:</p>
     <ul>
      <li>POST is good for creating new objects under a collection (and create does not need to be idempotent)</li>
      <li>PUT is good for updating existing objects (and update needs to be idempotent)</li>
      <li>POST can also be used for non-idempotent updates to existing objects (especially, changing part of an object without specifying the whole thing -- if you think about it, creating a new member of a collection is actually a special case of this kind of update, from the collection's perspective)</li>
      <li>PUT can also be used for create if and only if you allow the client to name the resource. But since REST clients aren't supposed to make assumptions about URL structure, this is less in the intended spirit of things.</li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span>"POST can also be used for non-idempotent updates to existing objects (especially, changing part of an object without specifying the whole thing" That's what PATCH is for</span> <span> - </span> <span class="display-name">Snuggs</span> <span> </span> <span class="date">4 May 2012 at 22:11</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>56</span>
     </div>
     <div>
      <span>Answerer: </span> <span>bharatj</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Jul 2016 at 11:11</span>
     </div>
    </div>
    <div>
     <p>In short:</p>
     <p><strong>PUT</strong> is idempotent, where the resource state will be the same if the same operation is executed one time or multiple times.</p>
     <p><strong>POST</strong> is non-idempotent, where the resource state may become different if the operation is executed multiple times as compared to executing a single time.</p>
     <h3>Analogy with database query</h3>
     <p><strong>PUT</strong> You can think of similar to "UPDATE STUDENT SET address = "abc" where id="123";</p>
     <p><strong>POST</strong> You can think of something like "INSERT INTO STUDENT(name, address) VALUES ("abc", "xyzzz");</p>
     <p>Student Id is auto generated.</p>
     <p>With PUT, if the same query is executed multiple times or one time, the STUDENT table state remains the same.</p>
     <p>In case of POST, if the same query is executed multiple times then multiple Student records get created in the database and the database state changes on each execution of an "INSERT" query.</p>
     <p><strong>NOTE:</strong> PUT needs a resource location (already-resource) on which update needs to happen, whereas POST doesn't require that. Therefore intuitively POST is meant for creation of a new resource, whereas PUT is needed for updating the already existing resource.</p>
     <p><em>Some may come up with that updates can be performed with POST. There is no hard rule which one to use for updates or which one to use for create. Again these are conventions, and intuitively I'm inclined with the above mentioned reasoning and follow it.</em></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>7</td>
        <td><span>for <i>PUT</i> is similar to <b>INSERT or UPDATE</b> query</span> <span> - </span> <span class="display-name">Eugen Konkov</span> <span> </span> <span class="date">22 Aug 2016 at 09:25</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>actually PUT You can think of similar to "UPDATE STUDENT SET address = "abc" where id="123"; would be a statement for PATCH. "UPDATE STUDENT SET address = "abc", name="newname" where id="123" would be a correct analogy for PUT</span> <span> - </span> <span class="display-name">mko</span> <span> </span> <span class="date">12 Apr 2017 at 13:24</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Put could also be used for INSERT. For example if you server detected you were trying to upload the same file multiple times, it would make your request idempotent. (No new file uploads are done).</span> <span> - </span> <span class="display-name">kiwicomb123</span> <span> </span> <span class="date">20 Aug 2018 at 22:46</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>53</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Homer6</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Jun 2013 at 18:10</span>
     </div>
    </div>
    <div>
     <p>POST is like posting a letter to a mailbox or posting an email to an email queue. PUT is like when you put an object in a cubby hole or a place on a shelf (it has a known address).</p>
     <p>With POST, you're posting to the address of the QUEUE or COLLECTION. With PUT, you're putting to the address of the ITEM.</p>
     <p>PUT is idempotent. You can send the request 100 times and it will not matter. POST is not idempotent. If you send the request 100 times, you'll get 100 emails or 100 letters in your postal box.</p>
     <p>A general rule: if you know the id or name of the item, use PUT. If you want the id or name of the item to be assigned by the receiving party, use POST.</p>
     <p><img src="/question/stackoverflow/630453/ugbjx.png" alt="POST versus PUT"></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>No, PUT implies that you know the URL. If you only know the ID then POST with that ID to get the URL.</span> <span> - </span> <span class="display-name">Joshcodes</span> <span> </span> <span class="date">29 Oct 2013 at 17:35</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>The id is part of the URL, so yes, use PUT if you know the URL (which includes the id).</span> <span> - </span> <span class="display-name">Homer6</span> <span> </span> <span class="date">29 Oct 2013 at 22:02</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>No, the URL is determined by the server and the ID is not necessarily part of the URL. Roy Fielding would tell you the <a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" rel="nofollow noreferrer">same</a> or you could just read his <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" rel="nofollow noreferrer">thesis</a>.</span> <span> - </span> <span class="display-name">Joshcodes</span> <span> </span> <span class="date">29 Oct 2013 at 23:06</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Joshcodes, is that assuming REST? In a RESTful architecture, the item id is most definitely part of the URL, as in: /people/123. I like this site for REST: <a href="http://microformats.org/wiki/rest/urls" rel="nofollow noreferrer">microformats.org/wiki/rest/urls</a></span> <span> - </span> <span class="display-name">Beez</span> <span> </span> <span class="date">26 Dec 2013 at 19:10</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Beez the mircoformats link suggests a good way for <i>servers</i> to structure their URLs but the <i>server</i> determines the URL. The client next-to-never does. See <a href="http://stackoverflow.com/questions/630453/put-vs-post-in-rest/17114749#19670755">my answer</a> or associated <a href="http://articles.joshcodes.com/?p=5" rel="nofollow noreferrer">article</a> if you don't understand this.</span> <span> - </span> <span class="display-name">Joshcodes</span> <span> </span> <span class="date">7 Jan 2014 at 17:11</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Joshcodes, I'm not denying where a URL is determined. I'm saying that in a RESTful architecture (defined from the server on up), the ID is part of a URL.</span> <span> - </span> <span class="display-name">Beez</span> <span> </span> <span class="date">7 Jan 2014 at 20:21</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Beez if the server determines the URL, the URL should not be dictated by the client. Therefore, even if you know the ID, use POST not PUT. Whether the ID should be part of the URL is a different conversation.</span> <span> - </span> <span class="display-name">Joshcodes</span> <span> </span> <span class="date">7 Jan 2014 at 21:16</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I think "General Rule" covers it generally having the ID or name in the URL. Great answer!</span> <span> - </span> <span class="display-name">TamusJRoyce</span> <span> </span> <span class="date">11 May 2015 at 04:48</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@TamusJRoyce, Roy Fielding (the guy who created REST) would disagree with you: <a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" rel="nofollow noreferrer">roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driv‌​en</a> Also, while true that the ID will likely be provide by the client via the URL the client still does not know where in the URL to put the ID.</span> <span> - </span> <span class="display-name">Joshcodes</span> <span> </span> <span class="date">11 Sep 2015 at 14:44</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@beez and Homer6: Joshcodes is correct. Nothing about REST requires the ID to be in the URL, and a URL with a structure like /collection/:id does not imply that the website is RESTful. In fact, sites with non-HTML representations almost always aren't.</span> <span> - </span> <span class="display-name">Nicholas Shanks</span> <span> </span> <span class="date">26 Dec 2016 at 13:22</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span> <span class="arrow"> <a href="#answer_15">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>49</span>
     </div>
     <div>
      <span>Answerer: </span> <span>ishandutta2007</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Oct 2017 at 02:33</span>
     </div>
    </div>
    <div>
     <p><strong>Short Answer:</strong></p>
     <p>Simple rule of thumb: Use POST to create, use PUT to update.</p>
     <p><strong>Long Answer:</strong></p>
     <p>POST:</p>
     <ul>
      <li>POST is used to send data to server.</li>
      <li>Useful when the resource's URL is unknown</li>
     </ul>
     <p>PUT:</p>
     <ul>
      <li>PUT is used to transfer state to the server</li>
      <li>Useful when a resource's URL is known</li>
     </ul>
     <p><strong>Longer Answer:</strong></p>
     <p>To understand it we need to question why PUT was required, what were the problems PUT was trying to solve that POST couldn't.</p>
     <p>From a REST architecture's point of view there is none that matters. We could have lived without PUT as well. But from a client developer's point of view it made his/her life a lot simpler.</p>
     <p>Prior to PUT, clients couldn't directly know the URL that the server generated or if all it had generated any or whether the data to be sent to the server is already updated or not. PUT relieved the developer of all these headaches. PUT is idempotent, PUT handles race conditions, and PUT lets the client choose the URL.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span>Your short answer might be VERY wrong. HTTP PUT is free to be repeated by HTTP proxies. And so, if PUT is actually doing SQL INSERT it might fail second time, which means it would return different result and so it would not be IDEMPOTENT (which is the difference between PUT and POST)</span> <span> - </span> <span class="display-name">Kamil Tomšík</span> <span> </span> <span class="date">30 Apr 2018 at 17:27</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_15"><span>Answer 15</span> <span class="arrow"> <a href="#answer_14">↑</a> </span> <span class="arrow"> <a href="#answer_16">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>48</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Jordan</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Aug 2012 at 20:10</span>
     </div>
    </div>
    <div>
     <p><strong>New answer (now that I understand REST better):</strong></p>
     <p>PUT is merely a statement of what content the service should, from now on, use to render representations of the resource identified by the client; POST is a statement of what content the service should, from now on, contain (possibly duplicated) but it's up to the server how to identify that content.</p>
     <p><code>PUT x</code> (if <code>x</code> identifies a <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2_1_1" rel="noreferrer">resource</a>): "Replace the content of the resource identified by <code>x</code> with my content."</p>
     <p><code>PUT x</code> (if <code>x</code> does not identify a resource): "Create a new resource containing my content and use <code>x</code> to identify it."</p>
     <p><code>POST x</code>: "Store my content and give me an identifier that I can use to identify a resource (old or new) containing said content (possibly mixed with other content). Said resource should be identical or subordinate to that which <code>x</code> identifies." "<em>y</em>'s resource is subordinate to <em>x</em>'s resource" is typically but not necessarily implemented by making <em>y</em> a subpath of <em>x</em> (e.g. <em>x</em> = <code>/foo</code> and <em>y</em> = <code>/foo/bar</code>) and modifying the representation(s) of <em>x</em>'s resource to reflect the existence of a new resource, e.g. with a hyperlink to <em>y</em>'s resource and some metadata. Only the latter is really essential to good design, as URLs are opaque in REST -- you're supposed to <a href="https://stackoverflow.com/a/9194942/972499">use hypermedia</a> instead of client-side URL construction to traverse the service anyways.</p>
     <p>In REST, there's no such thing as a resource containing "content". I refer as "content" to data that the service uses to render representations consistently. It typically consists of some related rows in a database or a file (e.g. an image file). It's up to the service to convert the user's content into something the service can use, e.g. converting a JSON payload into SQL statements.</p>
     <p><strong>Original answer (might be easier to read)</strong>:</p>
     <p><code>PUT /something</code> (if <code>/something</code> already exists): "Take whatever you have at <code>/something</code> and replace it with what I give you."</p>
     <p><code>PUT /something</code> (if <code>/something</code> does not already exist): "Take what I give you and put it at <code>/something</code>."</p>
     <p><code>POST /something</code>: "Take what I give you and put it anywhere you want under <code>/something</code> as long as you give me its URL when you're done."</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>But how can you use PUT to create a new resource if it doesn't exist, while your ID generation method is on Auto Increment ? Usually ORM's does auto generate the ID for you, like the way you want it to be in a POST for example. Does it mean that if you want to implement PUT the right way you have to change your id auto generation ? This is awkward if the answer is yes.</span> <span> - </span> <span class="display-name">Roni Axelrad</span> <span> </span> <span class="date">16 Sep 2018 at 15:28</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@RoniAxelrad : PUT is like a database "INSERT OR UPDATE" statement where you are including the key in the statement, so only applicable where you can guarente no collisions. eg. your domain has a 'natural key' or you use a guid. POST is like inserting into a table with an auto incrementing key. You have to be told by the database what ID it got after it has been inserted. Note your "INSERT OR UPDATE" will replace any previous data if it existed.</span> <span> - </span> <span class="display-name">Nigel Thorne</span> <span> </span> <span class="date">26 Nov 2018 at 01:33</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@NigelThorne Thanks for your answer. So if for example I'm trying to PUT a book id 10 with a URI: PUT books/10. If book id 10 does not exists, I should create a book with id 10 right? but I cannot control the creation ID numerator, because it's auto increment. what should I do in that situation ?</span> <span> - </span> <span class="display-name">Roni Axelrad</span> <span> </span> <span class="date">27 Nov 2018 at 20:50</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@RoniAxelrad REST PUT to an ID that doesn't exist is a request to the server to create a resource. It's still up to the server to decide if it wants to allow that. The server is in charge. It can respond with "No. I'm not going to do that". You already do that if the user doesn't have enough permissions...etc. It's okay for the server to say "No". REST is a convention that lets us define the meaning of various types of request ... your server decides what to do with those requests based on your business logic :) Even if it says "no" it's still following REST :)</span> <span> - </span> <span class="display-name">Nigel Thorne</span> <span> </span> <span class="date">3 Dec 2018 at 07:03</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_16"><span>Answer 16</span> <span class="arrow"> <a href="#answer_15">↑</a> </span> <span class="arrow"> <a href="#answer_17">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>42</span>
     </div>
     <div>
      <span>Answerer: </span> <span>germanlinux</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Feb 2012 at 09:21</span>
     </div>
    </div>
    <div>
     <p>Ruby on Rails 4.0 will use the 'PATCH' method instead of PUT to do partial updates.</p>
     <p>RFC 5789 says about PATCH (since 1995):</p>
     <blockquote>
      <p>A new method is necessary to improve interoperability and prevent errors. The PUT method is already defined to overwrite a resource with a complete new body, and cannot be reused to do partial changes. Otherwise, proxies and caches, and even clients and servers, may get confused as to the result of the operation. POST is already used but without broad interoperability (for one, there is no standard way to discover patch format support). PATCH was mentioned in earlier HTTP specifications, but not completely defined.</p>
     </blockquote>
     <p>"<a href="http://weblog.rubyonrails.org/2012/2/26/edge-rails-patch-is-the-new-primary-http-method-for-updates/" rel="noreferrer">Edge Rails: PATCH is the new primary HTTP method for updates</a>" explains it.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_17"><span>Answer 17</span> <span class="arrow"> <a href="#answer_16">↑</a> </span> <span class="arrow"> <a href="#answer_18">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>34</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Rohit Dhiman</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Sep 2018 at 08:28</span>
     </div>
    </div>
    <div>
     <p>In addition to differences suggested by others, I want to add one more.</p>
     <p>In <strong>POST</strong> method you can send body params in <code>form-data</code></p>
     <p>In <strong>PUT</strong> method you have to send body params in <code>x-www-form-urlencoded</code></p>
     <p>Header <code>Content-Type:application/x-www-form-urlencoded</code></p>
     <p>According to this, you cannot send files or multipart data in the <strong>PUT</strong> method</p>
     <p><strong>EDIT</strong></p>
     <blockquote>
      <p>The content type "application/x-www-form-urlencoded" is inefficient for sending large quantities of binary data or text containing non-ASCII characters. The content type "multipart/form-data" should be used for submitting forms that contain files, non-ASCII data, and binary data.</p>
     </blockquote>
     <p>Which means if you have to submit</p>
     <blockquote>
      <p>files, non-ASCII data, and binary data</p>
     </blockquote>
     <p>you should use <strong>POST</strong> method</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>Why was this not upvoted? If true, this is a critical distinction is it not?</span> <span> - </span> <span class="display-name">Iofacture</span> <span> </span> <span class="date">29 Sep 2018 at 03:02</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>I faced it when implementing API for the profile update, which includes user profile pic upload. Then I tested it with the postman, Ajax, PHP curl and laravel 5.6 as backend.</span> <span> - </span> <span class="display-name">Rohit Dhiman</span> <span> </span> <span class="date">29 Sep 2018 at 06:54</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_18"><span>Answer 18</span> <span class="arrow"> <a href="#answer_17">↑</a> </span> <span class="arrow"> <a href="#answer_19">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>32</span>
     </div>
     <div>
      <span>Answerer: </span> <span>skillet-thief</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Mar 2011 at 10:17</span>
     </div>
    </div>
    <div>
     <p>At the risk of restating what has already been said, it seems important to remember that <strong>PUT</strong> implies that the client controls what the <em>URL</em> is going to end up being, when creating a resource. So part of the choice between <strong>PUT</strong> and <strong>POST</strong> is going to be about how much you can trust the client to provide correct, normalized <em>URL</em> that are coherent with whatever your URL scheme is.</p>
     <p>When you can't fully trust the client to do the right thing, it would be more appropriate to use <strong>POST</strong> to create a new item and then send the URL back to the client in the response.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>I'm a bit late to this - but someone saying something similar on another website got it to click for me. If you're creating a resource and using an auto-incremented ID as it's "identifier" instead of a user assigned name, it should be a POST.</span> <span> - </span> <span class="display-name">Ixmatus</span> <span> </span> <span class="date">3 Feb 2012 at 18:51</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>This isn't quite right - PUT can still create a resource by referring to it with a non-canonical name, as long as in the response, the server returns a <code>Location</code> header that <i>does</i> contain the canonical resource name.</span> <span> - </span> <span class="display-name">Ether</span> <span> </span> <span class="date">19 Oct 2012 at 16:08</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Joshcodes don't forget that you can have many URIs referencing the same underlying resource. So what Ether said is sound advice, the client can PUT to a URL (that might be more semantic, like <code>PUT /X-files/series/4/episodes/max</code>) and the server respond with a URI that provides a short canonical unique link to that new resource (ie <code>/X-Ffiles/episodes/91</code>)</span> <span> - </span> <span class="display-name">thecoshman</span> <span> </span> <span class="date">8 Jun 2015 at 08:02</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@thecoshman the issue is the concern for the URL structure does not belong to the client. Reading about self-discovery (also part of REST) may help make this clear.</span> <span> - </span> <span class="display-name">Joshcodes</span> <span> </span> <span class="date">8 Jun 2015 at 17:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Joshcodes then by that logic, a client should never use PUT to create as they shouldn't be concerned with with providing the URL. Well... unless the server provided a URL to PUT to if the client wants to put to it... something like "PUT /comments/new" and the server might respond "204 /comments/234532" but that seems a bit RPC to me, the client should just POST to /comments...</span> <span> - </span> <span class="display-name">thecoshman</span> <span> </span> <span class="date">9 Jun 2015 at 16:18</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@thecoshman yes, the client really should never use PUT. What's RPC about that?</span> <span> - </span> <span class="display-name">Joshcodes</span> <span> </span> <span class="date">10 Jun 2015 at 17:11</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@thecoshman: no, you can't have multiple URLs pointing to one resource. Every unique URI is a unique resource, and every resource has one and only one URI.</span> <span> - </span> <span class="display-name">Nicholas Shanks</span> <span> </span> <span class="date">26 Dec 2016 at 13:38</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@NicholasShanks not really. Consider a resource that represents a school student, you could access <code>/student/123</code> but you might also get to that same student via <code>/class/abc/student/123</code>, That is perfectly valid. There is the concept of the canonical URI though, which in this case we could say the former is. The U is for Uniform, not Unique.</span> <span> - </span> <span class="display-name">thecoshman</span> <span> </span> <span class="date">9 Jan 2017 at 13:41</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@thecoshman What you would then have is two identical resources that just happen to change every time the other one does. A link from one to the other with a <code>canonical</code> relation would definitely help though. Even if you supplied a Content-Location header with one, pointing to the path of the other, that would not unify the underlying resources represented by each URL. Consider that a representation is not a resource, and two identical representations do not make the same resource (e.g. downloads/v1.0.0/ and downloads/latest-version/)</span> <span> - </span> <span class="display-name">Nicholas Shanks</span> <span> </span> <span class="date">9 Jan 2017 at 15:34</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@NicholasShanks I think <a href="http://stackoverflow.com/a/1929934/300797">this</a> answer provides a good explanation that I agree with but also considers your point of view. I'd also say that it is probably a more relevant place for this discussion.</span> <span> - </span> <span class="display-name">thecoshman</span> <span> </span> <span class="date">9 Jan 2017 at 16:48</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_19"><span>Answer 19</span> <span class="arrow"> <a href="#answer_18">↑</a> </span> <span class="arrow"> <a href="#answer_20">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>30</span>
     </div>
     <div>
      <span>Answerer: </span> <span>UniCoder</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Feb 2017 at 06:55</span>
     </div>
    </div>
    <div>
     <p>In a very simple way I'm taking the example of the Facebook timeline.</p>
     <p>Case 1: When you post something on your timeline, it's a fresh new entry. So in this case they use the POST method because the POST method is non-idempotent.</p>
     <p>Case 2: If your friend comment on your post the first time, that also will create a new entry in the database so the POST method used.</p>
     <p>Case 3: If your friend edits his comment, in this case, they had a comment id, so they will update an existing comment instead of creating a new entry in the database. Therefore for this type of operation use the PUT method because it is idempotent.*</p>
     <p>In a single line, use <strong>POST</strong> to add <strong>a new entry</strong> in the database and <strong>PUT</strong> to <strong>update</strong> something in the database.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>If the comment is an object with property like user id, created date, comment-message, etc. and at the time of edit only comment-message is getting updated, PATCH should be done here?</span> <span> - </span> <span class="display-name">Mohammed H</span> <span> </span> <span class="date">12 Aug 2017 at 10:47</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>PUT is used by FB to update the comment because an existing resource is being updated, and that is what PUT does (updates a resource). PUT happens to be idempotent, in contrast to POST. An HTTP verb being idempotent affects the error handling but does not dictate usage. See my answer for a more detail explanation: <a href="https://stackoverflow.com/questions/630453/put-vs-post-in-rest/9197466#19670755" title="put vs post in rest">stackoverflow.com/questions/630453/put-vs-post-in-rest/…</a></span> <span> - </span> <span class="display-name">Joshcodes</span> <span> </span> <span class="date">19 Jun 2018 at 12:57</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_20"><span>Answer 20</span> <span class="arrow"> <a href="#answer_19">↑</a> </span> <span class="arrow"> <a href="#answer_21">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>28</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Hans Malherbe</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Feb 2012 at 16:31</span>
     </div>
    </div>
    <div>
     <p>The most important consideration is <em>reliability</em>. If a POST message gets lost the state of the system is undefined. Automatic recovery is impossible. For PUT messages, the state is undefined only until the first successful retry.</p>
     <p>For instance, it may not be a good idea to create credit card transactions with POST.</p>
     <p>If you happen to have auto generated URI's on your resource you can still use PUT by passing a generated URI (pointing to an empty resource) to the client.</p>
     <p>Some other considerations:</p>
     <ul>
      <li>POST invalidates cached copies of the entire containing resource (better consistency)</li>
      <li>PUT responses are not cacheable while POST ones are (Require Content-Location and expiration)</li>
      <li>PUT is less supported by e.g. Java ME, older browsers, firewalls</li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>This is incorrect. For POST, the state is also undefined <b>only</b> until the first successful retry. Then, either the server accepts the POST (message never arrived), throws a 409 conflict for a duplicate ID (message arrived, response was lost), or any other valid response.</span> <span> - </span> <span class="display-name">Joshcodes</span> <span> </span> <span class="date">24 Apr 2014 at 12:13</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>In general a useragent would not able to safely retry the POST operation since the POST operation gives no that guarantee that two operations would have the same effect as one. The term "ID" has nothing to do with HTTP. The URI identifies the resource.</span> <span> - </span> <span class="display-name">Hans Malherbe</span> <span> </span> <span class="date">25 Jul 2014 at 05:48</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>A useragent can "safely" retry a POST operation as many times as it wants. It will just receive a duplicate ID error (assuming the <b>resource</b> has an ID) or a duplicate data error (assuming that's an issue and the <b>resource</b> does not have IDs).</span> <span> - </span> <span class="display-name">Joshcodes</span> <span> </span> <span class="date">27 Jul 2014 at 02:10</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Bangs head against wall. HTTP has no solution to the problem of reliability, and this is not well understood, not much discussed, and simply not catered for in the vast majority of web applications. @Joshcodes I have an answer to this question. I essentially agree with Hans. There's a problem.</span> <span> - </span> <span class="display-name">bbsimonbb</span> <span> </span> <span class="date">13 Jun 2018 at 08:21</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@bbsimonbb, HTTP has a robust and well documented set of error responses. My answer to this question (<a href="https://stackoverflow.com/questions/630453/put-vs-post-in-rest/9197466#19670755" title="put vs post in rest">stackoverflow.com/questions/630453/put-vs-post-in-rest/…</a>) covers how to use http according to specification to achieve consistency.</span> <span> - </span> <span class="display-name">Joshcodes</span> <span> </span> <span class="date">19 Jun 2018 at 12:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span><i>invalidates cached copies of the entire containing resource</i> any reference for that? Also it's never mandatory for a browser to follow the cache rules set.</span> <span> - </span> <span class="display-name">mfaani</span> <span> </span> <span class="date">26 Nov 2018 at 16:50</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_21"><span>Answer 21</span> <span class="arrow"> <a href="#answer_20">↑</a> </span> <span class="arrow"> <a href="#answer_22">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>22</span>
     </div>
     <div>
      <span>Answerer: </span> <span>bbsimonbb</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Feb 2016 at 11:45</span>
     </div>
    </div>
    <div>
     <p>Readers new to this topic will be struck by the endless discussion about what you <em>should</em> do, and the relative absence of lessons from experience. The fact that REST is "preferred" over SOAP is, I suppose, a high-level learning from experience, but goodness we must have progressed from there? It's 2016. Roy's dissertation was in 2000. What have we developed? Was it fun? Was it easy to integrate with? To support? Will it handle the rise of smartphones and flaky mobile connections?</p>
     <p>According to ME, real-life networks are unreliable. Requests timeout. Connections are reset. Networks go down for hours or days at a time. Trains go into tunnels with mobile users aboard. For any given request (as occasionally acknowledged in all this discussion) the request can fall in the water on its way, or the response can fall in the water on its way back. <strong>In these conditions, issuing PUT, POST and DELETE requests directly against substantive resources has always struck me as a little brutal and naive.</strong></p>
     <p>HTTP does nothing to ensure reliable completion of the request-response, and that's just fine because this is properly the job of network-aware applications. Developing such an application, you can jump through hoops to use PUT instead of POST, then more hoops to give a certain kind of error on the server if you detect duplicate requests. Back at the client, you then have to jump through hoops to interpret these errors, refetch, revalidate and repost.</p>
     <p><strong>Or you can do this</strong>: consider your unsafe requests as ephemeral single-user resources (let's call them actions). Clients request a new "action" on a substantive resource with an empty POST to the resource. POST will be used only for this. Once safely in possession of the URI of the freshly minted action, the client PUTs the unsafe request to the action URI, <em>not the target resource</em>. Resolving the action and updating the "real" resource is properly the job of your API, and is here decoupled from the unreliable network.</p>
     <p>The server does the business, returns the response <em>and stores it against the agreed action URI</em>. If anything goes wrong, the client repeats the request (natural behaviour!), and if the server has already seen it, it repeats the stored response <em>and does nothing else</em>.</p>
     <p>You will quickly spot the similarity with promises: we create and return the placeholder for the result before doing anything. Also like a promise, an action can succeed or fail one time, but its result can be fetched repeatedly.</p>
     <p>Best of all, we give sending and receiving applications a chance to link the uniquely identified action to uniqueness in their respective environments. And we can start to demand, and enforce!, responsible behaviour from clients: repeat your requests as much as you like, but don't go generating a new action until you're in possession of a definitive result from the existing one.</p>
     <p>As such, numerous thorny problems go away. Repeated insert requests won't create duplicates, and we don't create the real resource until we're in possession of the data. (database columns can stay not-nullable). Repeated update requests won't hit incompatible states and won't overwrite subsequent changes. Clients can (re)fetch and seamlessy process the original confirmation for whatever reason (client crashed, response went missing, etc.).</p>
     <p>Successive delete requests can see and process the original confirmation, without hitting a 404 error. If things take longer than expected, we can respond provisionally, and we have a place where the client can check back for the definitive result. The nicest part of this pattern is its Kung-Fu (Panda) property. We take a weakness, the propensity for clients to repeat a request any time they don't understand the response, and turn it into <em>a strength</em> :-)</p>
     <p>Before telling me this is not RESTful, please consider the numerous ways in which REST principles are respected. Clients don't construct URLs. The API stays discoverable, albeit with a little change in semantics. HTTP verbs are used appropriately. If you think this is a huge change to implement, I can tell you from experience that it's not.</p>
     <p>If you think you'll have huge amounts of data to store, let's talk volumes: a typical update confirmation is a fraction of a kilobyte. HTTP currently gives you a minute or two to respond definitively. Even if you only store actions for a week, clients have ample chance to catch up. If you have very high volumes, you may want a dedicated acid-compliant key value store, or an in-memory solution.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>Wont storing response be like maintaining a session? Which would cause (horizontal) scaling issues.</span> <span> - </span> <span class="display-name">Saurabh Harwande</span> <span> </span> <span class="date">21 Aug 2018 at 17:57</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_22"><span>Answer 22</span> <span class="arrow"> <a href="#answer_21">↑</a> </span> <span class="arrow"> <a href="#answer_23">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>20</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Burhan</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Oct 2013 at 04:18</span>
     </div>
    </div>
    <div>
     <p>There seems to always be some confusion as to when to use the HTTP POST versus the HTTP PUT method for REST services. Most developers will try to associate CRUD operations directly to HTTP methods. I will argue that this is not correct and one can not simply associate the CRUD concepts to the HTTP methods. That is:</p>
     <pre><code>Create =&gt; HTTP PUT
Retrieve =&gt; HTTP GET
Update =&gt; HTTP POST
Delete =&gt; HTTP DELETE
</code></pre>
     <p>It is true that the R(etrieve) and D(elete) of the CRUD operations can be mapped directly to the HTTP methods GET and DELETE respectively. However, the confusion lies in the C(reate) and U(update) operations. In some cases, one can use the PUT for a create while in other cases a POST will be required. The ambiguity lies in the definition of an HTTP PUT method versus an HTTP POST method.</p>
     <p>According to the HTTP 1.1 specifications the GET, HEAD, DELETE, and PUT methods must be idempotent, and the POST method is not idempotent. That is to say that an operation is idempotent if it can be performed on a resource once or many times and always return the same state of that resource. Whereas a non idempotent operation can return a modified state of the resource from one request to another. Hence, in a non idempotent operation, there is no guarantee that one will receive the same state of a resource.</p>
     <p>Based on the above idempotent definition, my take on using the HTTP PUT method versus using the HTTP POST method for REST services is: Use the HTTP PUT method when:</p>
     <pre><code>The client includes all aspect of the resource including the unique identifier to uniquely identify the resource. Example: creating a new employee.
The client provides all the information for a resource to be able to modify that resource.This implies that the server side does not update any aspect of the resource (such as an update date).
</code></pre>
     <p>In both cases, these operations can be performed multiple times with the same results. That is the resource will not be changed by requesting the operation more than once. Hence, a true idempotent operation. Use the HTTP POST method when:</p>
     <pre><code>The server will provide some information concerning the newly created resource. For example, take a logging system. A new entry in the log will most likely have a numbering scheme which is determined on the server side. Upon creating a new log entry, the new sequence number will be determined by the server and not by the client.
On a modification of a resource, the server will provide such information as a resource state or an update date. Again in this case not all information was provided by the client and the resource will be changing from one modification request to the next. Hence a non idempotent operation.
</code></pre>
     <p>Conclusion</p>
     <p>Do not directly correlate and map CRUD operations to HTTP methods for REST services. The use of an HTTP PUT method versus an HTTP POST method should be based on the idempotent aspect of that operation. That is, if the operation is idempotent, then use the HTTP PUT method. If the operation is non idempotent, then use the HTTP POST method.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>Update =&gt; HTTP POST : POST is not for updating</span> <span> - </span> <span class="display-name">Premraj</span> <span> </span> <span class="date">30 Jan 2016 at 00:57</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@premraj You made the assumption that Burhan is telling you not to make; namely, you are conflating CRUD, REST, and HTTP. If you read RFC 7231, where these things are defined, you will find that in HTTP protocol, the definition of POST certainly allows updating. It is only the constraints of REST that say otherwise.</span> <span> - </span> <span class="display-name">IAM_AL_X</span> <span> </span> <span class="date">16 Apr 2020 at 03:32</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_23"><span>Answer 23</span> <span class="arrow"> <a href="#answer_22">↑</a> </span> <span class="arrow"> <a href="#answer_24">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>18</span>
     </div>
     <div>
      <span>Answerer: </span> <span>inf3rno</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Jan 2014 at 07:58</span>
     </div>
    </div>
    <div>
     <blockquote>
      <p>the origin server can create the resource with that URI</p>
     </blockquote>
     <p>So you use POST and probably, but not necessary PUT for resource creation. You don't have to support both. For me POST is perfectly enough. So it is a design decision.</p>
     <p>As your quote mentioned, you use PUT for creation of there is no resource assigned to an IRI, and you want to create a resource anyway. For example, <code>PUT /users/123/password</code> usually replaces the old password with a new one, but you can use it to create a password if it does not exist already (for example, by freshly registered users or by restoring banned users).</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>I think you've managed to provide one of the few good examples of how to use PUT, well done.</span> <span> - </span> <span class="display-name">thecoshman</span> <span> </span> <span class="date">8 Jun 2015 at 08:13</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_24"><span>Answer 24</span> <span class="arrow"> <a href="#answer_23">↑</a> </span> <span class="arrow"> <a href="#answer_25">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>17</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Gerard ONeill</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Oct 2013 at 21:16</span>
     </div>
    </div>
    <div>
     <p>I'm going to land with the following:</p>
     <p>PUT refers to a resource, identified by the URI. In this case, you are updating it. It is the part of the three verbs referring to resources -- delete and get being the other two.</p>
     <p>POST is basically a free form message, with its meaning being defined 'out of band'. If the message can be interpreted as adding a resource to a directory, that would be OK, but basically you need to understand the message you are sending (posting) to know what will happen with the resource.</p>
     <hr>
     <p>Because PUT and GET and DELETE refer to a resource, they are also by definition idempotent.</p>
     <p>POST can perform the other three functions, but then the semantics of the request will be lost on the intermediaries such as caches and proxies. This also applies to providing security on the resource, since a post's URI doesn't necessarily indicate the resource it is applying to (it can though).</p>
     <p>A PUT doesn't need to be a create; the service could error if the resource isn't already created, but otherwise update it. Or vice versa -- it may create the resource, but not allow updates. The only thing required about PUT is that it points to a specific resource, and its payload is the representation of that resource. A successful PUT means (barring interference) that a GET would retrieve the same resource.</p>
     <hr>
     <p>Edit: One more thing -- a PUT can create, but if it does then the ID has to be a natural ID -- AKA an email address. That way when you PUT twice, the second put is an update of the first. This makes it <em>idempotent</em>.</p>
     <p>If the ID is generated (a new employee ID, for example), then the second PUT with the same URL would create a new record, which violates the idempotent rule. In this case the verb would be POST, and the message (not resource) would be to create a resource using the values defined in this message.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_25"><span>Answer 25</span> <span class="arrow"> <a href="#answer_24">↑</a> </span> <span class="arrow"> <a href="#answer_26">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>14</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Adam Griffiths</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Dec 2013 at 22:15</span>
     </div>
    </div>
    <div>
     <p>Here's a simple rule:</p>
     <p><strong>PUT</strong> to a URL should be used to update or create the resource that can be located at that URL.</p>
     <p><strong>POST</strong> to a URL should be used to update or create a resource which is located at some other ("subordinate") URL, or is not locatable via HTTP.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>PUT is not for update, it is for replace, note that to create you are replacing nothing with something. POST is absolutely not for update in any shape of form.</span> <span> - </span> <span class="display-name">thecoshman</span> <span> </span> <span class="date">8 Jun 2015 at 08:10</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>Does the http spec say that? Or are you basing your comment on something else?</span> <span> - </span> <span class="display-name">Adam Griffiths</span> <span> </span> <span class="date">10 Jul 2016 at 20:41</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>thecoshman -- you are abusing semantics here -- a replace can be an update if it is the same resource with a few differences. A replace is only valid for put if replace is used to change the same resource. Replacing with a new and different resource is invalid (remove old and add new?), especially if the 'new' resource doesn't have a natural ID. POST, OTOH, is something that can create, update, replace, and delete -- using post depends on whether or not there is a message to interpret, such as 'apply the discount', which may or may not change the resource depending on logic.</span> <span> - </span> <span class="display-name">Gerard ONeill</span> <span> </span> <span class="date">28 Dec 2016 at 16:54</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>As for your second comment -- how about you 'get' the resource, modify the fields you need to, and then put it back? Or how about if the resource comes from a different source but uses a natural ID (the external ID) -- put would naturally update the resource at the URL when the original data changed.</span> <span> - </span> <span class="display-name">Gerard ONeill</span> <span> </span> <span class="date">28 Dec 2016 at 16:56</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_26"><span>Answer 26</span> <span class="arrow"> <a href="#answer_25">↑</a> </span> <span class="arrow"> <a href="#answer_27">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>13</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Gregory Magarshak</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Oct 2011 at 20:07</span>
     </div>
    </div>
    <div>
     <p>The semantics are supposed be different, in that "PUT", like "GET" is supposed to be idempotent -- meaning, you can the same exact PUT request multiple times and the result will be as if you executed it only once.</p>
     <p>I will describe the conventions which I think are most widely used and are most useful:</p>
     <p>When you PUT a resource at a particular URL what happens is that it should get saved at that URL, or something along those lines.</p>
     <p>When you POST to a resource at a particular URL, often you are posting a related piece of information to that URL. This implies that the resource at the URL already exists.</p>
     <p>For example, when you want to create a new stream, you can PUT it to some URL. But when you want to POST a message to an existing stream, you POST to its URL.</p>
     <p>As for modifying the properties of the stream, you can do that with either PUT or POST. Basically, only use "PUT" when the operation is idempotent - otherwise use POST.</p>
     <p>Note, however, that not all modern browsers support HTTP verbs other than GET or POST.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>What you describe POST as is actually how PATCH should behave. POST is supposed to mean something more akin to "append" as in "post to mailing list".</span> <span> - </span> <span class="display-name">Alexander Torstling</span> <span> </span> <span class="date">28 Nov 2014 at 15:57</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_27"><span>Answer 27</span> <span class="arrow"> <a href="#answer_26">↑</a> </span> <span class="arrow"> <a href="#answer_28">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>13</span>
     </div>
     <div>
      <span>Answerer: </span> <span>tothemario</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Jun 2017 at 17:38</span>
     </div>
    </div>
    <div>
     <p>Most of the time, you will use them like this:</p>
     <ul>
      <li><strong>POST</strong> a resource into a collection</li>
      <li><strong>PUT</strong> a resource identified by collection/:id</li>
     </ul>
     <p>For example:</p>
     <ul>
      <li><strong>POST</strong> /items</li>
      <li><strong>PUT</strong> /items/1234</li>
     </ul>
     <p>In both cases, the request body contains the data for the resource to be created or updated. It should be obvious from the route names that POST is not idempotent (if you call it 3 times it will create 3 objects), but PUT is idempotent (if you call it 3 times the result is the same). PUT is often used for "upsert" operation (create or update), but you can always return a 404 error if you only want to use it to modify.</p>
     <p>Note that POST "creates" a new element in the collection, and PUT "replaces" an element at a given URL, but it is a very common practice to use PUT for partial modifications, that is, use it only to update existing resources and only modify the included fields in the body (ignoring the other fields). This is technically incorrect, if you want to be REST-purist, PUT should replace the whole resource and you should use PATCH for the partial update. I personally don't care much as far as the behavior is clear and consistent across all your API endpoints.</p>
     <p>Remember, REST is a set of conventions and guidelines to keep your API simple. If you end up with a complicated work-around just to check the "RESTfull" box then you are defeating the purpose ;)</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_28"><span>Answer 28</span> <span class="arrow"> <a href="#answer_27">↑</a> </span> <span class="arrow"> <a href="#answer_29">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>13</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Moritz</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Sep 2021 at 09:51</span>
     </div>
    </div>
    <div>
     <p>To me, the key of understanding the difference was to understand <strong>who defines the ID</strong> of the resource:</p>
     <p>Example (with some address service)</p>
     <pre><code>POST (sever creates new resource)

client               server/addresses      // NOTE: no ID in the request
  |                                 |
  | --{POST address data}--&gt;        |
  |                                 |
  | &lt;--{201, created addresses/321} |      // NOTE: resource ID in the reply
  |                                 |
</code></pre>
     <pre><code>PUT (sever sets data of resource, creating it if necessary)

client               server/addresses/321      // NOTE: *you* put the ID here!
  |                                 |
  | --{PUT address data (to 321)}--&gt;|
  |                                 |
  | &lt;--{201, created }              |          // NOTE: resource ID not required here
  |                                 |
</code></pre>
     <p>There are many great answers with great details below, but that helped me to get to the point.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Nice and simple. A little too terse.., but hopefully this distinction is placed amongst the other lessons around REST :).</span> <span> - </span> <span class="display-name">Gerard ONeill</span> <span> </span> <span class="date">3 Oct 2022 at 18:06</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_29"><span>Answer 29</span> <span class="arrow"> <a href="#answer_28">↑</a> </span> <span class="arrow"> <a href="#answer_30">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>11</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Rajan</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Jun 2016 at 21:13</span>
     </div>
    </div>
    <div>
     <p>If you are familiar with database operations, there are</p>
     <ol>
      <li>Select</li>
      <li>Insert</li>
      <li>Update</li>
      <li>Delete</li>
      <li>Merge (Update if already existing, else insert)</li>
     </ol>
     <p>I use <code>PUT</code> for Merge and update like operations and use <code>POST</code> for Insertions.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_30"><span>Answer 30</span> <span class="arrow"> <a href="#answer_29">↑</a> </span> <span class="arrow"> <a href="#answer_31">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>11</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Géry Ogam</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Dec 2020 at 20:56</span>
     </div>
    </div>
    <div>
     <h2>Summary</h2>
     <ul>
      <li>Use <code>PUT</code> to create or replace the state of the <em>target</em> resource with the state defined by the representation enclosed in the request. That intended effect is <em>standardized</em> and <em>idempotent</em> so it informs intermediaries that they can repeat a request in case of communication failure.</li>
      <li>Use <code>POST</code> otherwise (including to create or replace the state of a resource other than the target resource). The intended effect is <em>not standardized</em> so intermediaries cannot assume any property.</li>
     </ul>
     <h2>References</h2>
     <p>The latest authoritative description of the semantic difference between the <code>POST</code> and <code>PUT</code> request methods is given in <a href="https://www.rfc-editor.org/rfc/rfc9110#section-9.3.4-9" rel="nofollow noreferrer">RFC 9110</a> (Roy Fielding, Mark Nottingham, Julian Reschke, 2022):</p>
     <blockquote>
      <p>The fundamental difference between the <code>POST</code> and <code>PUT</code> methods is highlighted by the different intent for the enclosed representation. The target resource in a <code>POST</code> request is intended to handle the enclosed representation according to the resource's own semantics, whereas the enclosed representation in a <code>PUT</code> request is defined as replacing the state of the target resource. Hence, the intent of <code>PUT</code> is idempotent and visible to intermediaries, even though the exact effect is only known by the origin server.</p>
     </blockquote>
     <p>In other words, the intended effect of <code>PUT</code> is <em>standardized</em> (create or replace the state of the <em>target</em> resource with the state defined by the representation enclosed in the request) and so is generic to all target resources, while the intended effect of <code>POST</code> is <em>not standardized</em> and so is specific to each target resource. Thus <code>POST</code> can be used for anything, including for achieving the intended effects of <code>PUT</code> and other request methods (<code>GET</code>, <code>HEAD</code>, <code>DELETE</code>, <code>CONNECT</code>, <code>OPTIONS</code>, and <code>TRACE</code>).</p>
     <p>But it is recommended to always use the more specialized request method rather than <code>POST</code> when applicable because it provides more information to intermediaries for automating information retrieval (since <code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code>, and <code>TRACE</code> are defined as <em>safe</em>), handling communication failure (since <code>GET</code>, <code>HEAD</code>, <code>PUT</code>, <code>DELETE</code>, <code>OPTIONS</code>, and <code>TRACE</code> are defined as <em>idempotent</em>), and optimizing cache performance (since <code>GET</code> and <code>HEAD</code> are defined as <em>cacheable</em>), as explained in <a href="https://roy.gbiv.com/untangled/2009/it-is-okay-to-use-post" rel="nofollow noreferrer"><em>It Is Okay to Use POST</em></a> (Roy Fielding, 2009):</p>
     <blockquote>
      <p><code>POST</code> only becomes an issue when it is used in a situation for which some other method is ideally suited: e.g., retrieval of information that should be a representation of some resource (<code>GET</code>), complete replacement of a representation (<code>PUT</code>), or any of the other standardized methods that tell intermediaries something more valuable than “this may change something.” The other methods are more valuable to intermediaries because they say something about how failures can be automatically handled and how intermediate caches can optimize their behavior. <code>POST</code> does not have those characteristics, but that doesn’t mean we can live without it. <code>POST</code> serves many useful purposes in HTTP, including the general purpose of “this action isn’t worth standardizing.”</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_31"><span>Answer 31</span> <span class="arrow"> <a href="#answer_30">↑</a> </span> <span class="arrow"> <a href="#answer_32">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>10</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Tom Stickel</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Jul 2014 at 20:02</span>
     </div>
    </div>
    <div>
     <p>While there is probably an agnostic way to describe these, it does seem to be conflicting with various statements from answers to websites.</p>
     <p>Let's be very clear and direct here. If you are a .NET developer working with Web API, the facts are (from the Microsoft API documentation), <a href="http://www.asp.net/web-api/overview/creating-web-apis/creating-a-web-api-that-supports-crud-operations" rel="nofollow noreferrer">http://www.asp.net/web-api/overview/creating-web-apis/creating-a-web-api-that-supports-crud-operations</a>:</p>
     <pre><code>1. PUT = UPDATE (/api/products/id)
2. MCSD Exams 2014 -  UPDATE = PUT, there are **NO** multiple answers for that question period.
</code></pre>
     <p>Sure you "can" use "POST" to update, but just follow the conventions laid out for you with your given framework. In my case it is .NET / Web API, so <strong>PUT is for UPDATE</strong> there is no debate.</p>
     <p>I hope this helps any Microsoft developers that read all comments with Amazon and Sun/Java website links.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_32"><span>Answer 32</span> <span class="arrow"> <a href="#answer_31">↑</a> </span> <span class="arrow"> <a href="#answer_33">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mahozad</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Nov 2021 at 14:11</span>
     </div>
    </div>
    <div>
     <p><code>POST</code> is used to send data to a server.<br><code>PUT</code> is used to deposit data into a resource on the server (e.g., a file).</p>
     <p>I saw this in a footnote (page 55) from the book <em><a href="https://www.oreilly.com/library/view/http-the-definitive/1565925092/" rel="noreferrer">HTTP: The Definitive Guide</a></em>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_33"><span>Answer 33</span> <span class="arrow"> <a href="#answer_32">↑</a> </span> <span class="arrow"> <a href="#answer_34">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>java_geek</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Oct 2014 at 06:51</span>
     </div>
    </div>
    <div>
     <p>In practice, POST works well for creating resources. The URL of the newly created resource should be returned in the Location response header. PUT should be used for updating a resource completely. Please understand that these are the best practices when designing a RESTful API. HTTP specification as such does not restrict using PUT/POST with a few restrictions for creating/updating resources. Take a look at <a href="http://techoctave.com/c7/posts/71-twitter-rest-api-dissected" rel="noreferrer">http://techoctave.com/c7/posts/71-twitter-rest-api-dissected</a> that summarizes the best practices.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>For the most part, from reading through all this noise, you seem on the ball. I would say though, we should refer to PUT as the replace method, rather than the create/update. I think it better describes in one what it does.</span> <span> - </span> <span class="display-name">thecoshman</span> <span> </span> <span class="date">8 Jun 2015 at 08:15</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_34"><span>Answer 34</span> <span class="arrow"> <a href="#answer_33">↑</a> </span> <span class="arrow"> <a href="#answer_35">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>sushil pandey</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Dec 2013 at 11:06</span>
     </div>
    </div>
    <div>
     <p><strong>POST:</strong> Use it for creating new resources. It's like INSERT (SQL statement) with an auto-incremented ID. In the response part it contains a new generated Id.</p>
     <blockquote>
      <p>POST is also used for updating a record.</p>
     </blockquote>
     <p><strong>PUT:</strong> Use it for creating a new resource, but here I know the identity key. It's like INSERT (SQL statement) where I know in advance the identity key. In the response part it sends nothing.</p>
     <blockquote>
      <p>PUT is also used for updating a resource</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>6</td>
        <td><span>PUT is not for update, it is for replace, note that to create you are replacing nothing with something. POST is absolutely not for update in any shape of form.</span> <span> - </span> <span class="display-name">thecoshman</span> <span> </span> <span class="date">8 Jun 2015 at 08:11</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_35"><span>Answer 35</span> <span class="arrow"> <a href="#answer_34">↑</a> </span> <span class="arrow"> <a href="#answer_36">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>baptx</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Jun 2019 at 09:01</span>
     </div>
    </div>
    <div>
     <p>I think there is also an interesting point that was not shared on this PUT vs POST question:</p>
     <p>If you want to have a web application that works without JavaScript (for example if someone is using a command-line browser like Lynx or a browser addon like NoScript or uMatrix), you will have to use POST to send data since HTML forms only support GET and POST HTTP requests.</p>
     <p>Basically if you want to use progressive enhancement (<a href="https://en.wikipedia.org/wiki/Progressive_enhancement" rel="nofollow noreferrer">https://en.wikipedia.org/wiki/Progressive_enhancement</a>) to make your web application work everywhere, with and without JavaScript, you cannot use other HTTP methods like PUT or DELETE, which were only added in HTTP version 1.1.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_36"><span>Answer 36</span> <span class="arrow"> <a href="#answer_35">↑</a> </span> <span class="arrow"> <a href="#answer_37">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Michael Chourdakis</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Oct 2021 at 05:54</span>
     </div>
    </div>
    <div>
     <p>All the answers above and below are correct, just a small (important) note. All these "verbs" are recommendations and their effect is not enforced. The server is free to do whatever they want and this means writing with GET or whatever the server wants. It all depends on the implementation backend.</p>
     <p>PHP for example, reads <code>$_POST</code> and <code>$_GET</code>. It's entirely up to the programmer what exactly it will be done by reading variables from these arrays.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_37"><span>Answer 37</span> <span class="arrow"> <a href="#answer_36">↑</a> </span> <span class="arrow"> <a href="#answer_38">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>maaartinus</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 May 2018 at 02:39</span>
     </div>
    </div>
    <div>
     <blockquote>
      <p>So, which one should be used to create a resource? Or one needs to support both?</p>
     </blockquote>
     <p>You should use <code>PATCH</code>. You PATCH the list of questions like</p>
     <pre><code>PATCH /questions HTTP/1.1
</code></pre>
     <p>with a list containing your to be created object like</p>
     <pre><code>[
    {
        "title": "I said semantics!",
        "content": "Is this serious?",
        "answer": "Not really"
    }
]
</code></pre>
     <p>It's a PATCH request as</p>
     <ul>
      <li>you modify the <em>existing</em> list of resources <em>without providing the whole new</em> content</li>
      <li>you change the state of your new question from non-existing to existing <em>without providing all the data</em> (the server will most probably add an <code>id</code>).</li>
     </ul>
     <p>A great advantage of this method is that you can create multiple entities using a single request, simply by providing them all in the list.</p>
     <p>This is something <code>PUT</code> obviously can't. You could use <code>POST</code> for creating multiple entities as it's the kitchen sink of HTTP and can do basically everything.</p>
     <p>A disadvantage is that probably nobody uses <code>PATCH</code> this way. I'm afraid, I just invented it, but I hope, I provided a good argumentation.</p>
     <p>You could use <code>CREATE</code> instead, as custom HTTP verbs are allowed, it's just that they mayn't work with some tools.</p>
     <p>Concerning semantics, <code>CREATE</code> is IMHO the only right choice, everything else is a square peg in a round hole. Unfortunately, all we have are round holes.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>I think you should be careful in stating that PATCH should be used without providing some clarifying statements. PATCH is great for updating resources, but it's not meant for creating resources. The HTTP specs specifically call out that it is only for updating resources. You can make anything work as you've stated, but the verbs lose their meaning when you arbitrarily give them non-standard functionality.</span> <span> - </span> <span class="display-name">Jitsusama</span> <span> </span> <span class="date">2 Jul 2019 at 14:01</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Jitsusama Read my last but one sentence.... and maybe google for this "It’s like trying to hack a programming paradigm out of the TCP packet header control bits! If URG is high then my calendar appointment is very important. If ACK is low, then I’m denying your friend request.".</span> <span> - </span> <span class="display-name">maaartinus</span> <span> </span> <span class="date">3 Jul 2019 at 00:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I think this is not a good idea. Basically, if you say inserting into a list is a patch, everything becomes a patch: inserting, updating, even deleting. This does not solve the problem but actually adds another ambiguity.</span> <span> - </span> <span class="display-name">dariok</span> <span> </span> <span class="date">25 Oct 2019 at 18:18</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@dariok Agreed, it'd make it even a bit worse than it already is.</span> <span> - </span> <span class="display-name">maaartinus</span> <span> </span> <span class="date">25 Oct 2019 at 22:51</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_38"><span>Answer 38</span> <span class="arrow"> <a href="#answer_37">↑</a> </span> <span class="arrow"> <a href="#answer_39">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Md. Tazbir Ur Rahman Bhuiyan</span>
     </div>
     <div>
      <span> Answered: </span> <span>20 Sep 2019 at 13:31</span>
     </div>
    </div>
    <div>
     <p>Addition to all answers above:</p>
     <hr>
     <p>Most commonly used in professional practice,</p>
     <hr>
     <ul>
      <li>we use PUT over POST in <strong>CREATE</strong> operation. Why? because many here said also, responses are not cacheable while POST ones are (Require Content-Location and expiration).</li>
      <li>We use POST over PUT in <strong>UPDATE</strong> operation. Why? because it invalidates cached copies of the entire containing resource. which is helpful when updating resources.</li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_39"><span>Answer 39</span> <span class="arrow"> <a href="#answer_38">↑</a> </span> <span class="arrow"> <a href="#answer_40">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Charles Derek</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 May 2022 at 16:56</span>
     </div>
    </div>
    <div>
     <p>In the simpliest explained way:</p>
     <p><strong>POST</strong> does what it says, POST means it's presenting <strong>a request for a new object creation</strong>. MDN referse to this as 'other side-effects', an example being incrementing indexes (What the word 'POST' implies).</p>
     <p><strong>PUT</strong> can be thought of as <strong>updating existing data objects</strong>, When people are saying it can be used for adding items. This is because it can update child <code>null</code> values from an existing parent object.</p>
     <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT" rel="nofollow noreferrer">MDN Method PUT Documentation</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>The reason this is all a tad confusing is because the word POST doesn't say or even suggest any clear meaning - certainly nothing about being "NEW". So I'm mystified by your first sentence telling us the word POST does what it says</span> <span> - </span> <span class="display-name">PandaWood</span> <span> </span> <span class="date">28 Jun 2022 at 06:47</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>What trips people up is Putting something can imply Posting (but not the converse). As a noun it doesn't make sense, but only in the verb tense it does. Thinking of when putting the method into an html form, you have to add an Action and Method (both do things and are verbs). The action of placing a post-it on a board, to Post It means you're placing something new there and not editing an existing one. I can relate, even b.i.t.d JavaScript was confusing Juniors with Java because poor word choice when it came out. It's rare when a word in programming is not implicit lol.</span> <span> - </span> <span class="display-name">Charles Derek</span> <span> </span> <span class="date">15 Jul 2022 at 19:46</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_40"><span>Answer 40</span> <span class="arrow"> <a href="#answer_39">↑</a> </span> <span class="arrow"> <a href="#answer_41">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ahmad Ismail</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Jul 2022 at 16:05</span>
     </div>
    </div>
    <div>
     <p>From the looks of it, both POST and PUT are same. However, they have some differences.</p>
     <p>In HTTP Essentials: Protocols for Secure, Scaleable Web Sites, the author says:</p>
     <blockquote>
      <p>The difference between POST and PUT is in how the server interprets the Uniform Resource Identifier. With a POST , the uri identifies an object on the server that can process the included data. With a PUT , on the other hand, the uri identifies an object in which the server should place the data. While a POST uri generally indicates a program or script, the PUT uri is usually the path and name for a file.</p>
     </blockquote>
     <p>The author suggests that we use PUT to upload files, not POST. POST is for submitting forms.</p>
     <p>Implemented correctly, the GET, HEAD, PUT, and DELETE method are idempotent, but not the POST method. So, when you make two PUT - you get the one new record, when you do two POSTs - you get two new records.</p>
     <p>However, please note that, <a href="https://stackoverflow.com/a/166501/1772898">HTML forms only support GET and POST as HTTP request methods</a>.</p>
     <p><a href="https://stackoverflow.com/a/8054241/1772898"><code>&lt;form method="put"&gt;</code> is invalid HTML and will be treated like , i.e. send a GET request.</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_41"><span>Answer 41</span> <span class="arrow"> <a href="#answer_40">↑</a> </span> <span class="arrow"> <a href="#answer_42">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Stokely</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Jan 2023 at 19:07</span>
     </div>
    </div>
    <div>
     <h2>POST vs PUT</h2>
     <p>Let's get the facts on <code>POST</code> and <code>PUT</code> according to the <strong>Internet Engineering Task Force (IETF)</strong>:</p>
     <blockquote>
      <p>The target resource in a POST request is intended to handle the enclosed representation according to the resource's own semantics, whereas the enclosed representation in a PUT request is defined as replacing the state of the target resource.</p>
     </blockquote>
     <blockquote>
      <p>Proper interpretation of a PUT request presumes that the user agent knows which target resource is desired. A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT.</p>
     </blockquote>
     <p><a href="https://www.rfc-editor.org/rfc/rfc7231#section-4.3.4" rel="nofollow noreferrer">https://www.rfc-editor.org/rfc/rfc7231#section-4.3.4</a></p>
     <p>Based on the above, <strong><code>POST</code> should be used to do MOST (if not all) of your CREATE or ALTER data routines</strong> on the server. Only POST is supported in HTML form field methods for this very reason, while <strong>PUT and DELETE are not supported in HTML forms</strong> (see below).</p>
     <p><code>PUT</code> acts as a sub-type of the POST method as it can do only one narrow range of actions that POST does. Both POST and PUT can create and change data. The different is "intent". POST has no intention other than to work with the server's various ways of creating or altering the state of data. PUT has one intent...to REPLACE the state of ONE RESOURCE on the server with its own (which POST can also do, btw, and does often online).</p>
     <p>Because of <em>heavy use of JavaScript</em> the past decade and XMLHttpRequest calls, this has opened the door up to websites using PUT and DELETE more often. WebAPI's are now configured to apply Http Method PUT and the rules to use it more consistently in 2023, than in the past. So the question has been raised, why use it, when we have been using POST to do the same thing successfully the past 20+ years?</p>
     <p>I would ONLY use PUT in one case...where you are using JavaScript to create or alter the identity of a "resource" (state of an item), know the resource identity in your PUT (most often a URI/URL), and the WebAPI endpoint on the server strictly honors change the resource state with the one sent in the PUT. This must be total and complete, unlike with a post.</p>
     <p>In the case of PUT, a good way to enforce this, rather than rely on sketchy JavaScript rules, is to rely on a UNIQUE IDENTIFIER in the URL on the server. This prevents PUT coming in without any rules or identifier. An example might be: <a href="https://example.com/123" rel="nofollow noreferrer">https://example.com/123</a>, with "123" being the ID of some resource or data point at the WebAPI endpoint.</p>
     <p>The URI in a POST request does not need to identify the resource that will handle the enclosed entity or its state or what is changed. In contrast, the URI in a PUT request identifies the entity enclosed with the request and what will be replaced with the data or state in a PUT request.</p>
     <h2>BROWSERS DO NOT SUPPORT "PUT" or "DELETE"!</h2>
     <p><strong>Did you know that HTML Form <code>method</code> attributes in browsers the past 20+ years have only supported <code>POST</code> and <code>GET</code>, and do not support <code>PUT</code>?</strong></p>
     <pre><code>POST and GET work ok...
&lt;form id="form1" name="form1" method="get" action="/form"&gt;...&lt;/form&gt;
&lt;form id="form2" name="form2" method="post" action="/form"&gt;...&lt;/form&gt;

PUT NOT SUPPORTED!
&lt;form id="form3" name="form3" method="put" action="/form"&gt;...&lt;/form&gt;

DELETE NOT SUPPORTED!
&lt;form id="form4" name="form4" method="delete" action="/form"&gt;...&lt;/form&gt;
</code></pre>
     <p>Crazy, huh?</p>
     <p>When a browser user submits data to a server, nobody knows if they are creating, deleting, or modifying data. A POST can add or change an entity just like a PUT can, right? <strong>So, other than the identifying URL, the right action or HTTP Verb to use is most often POST.</strong> Therefore, PUT has always been optional in the traditional web world for decades.</p>
     <p>When a form pushes data to the server, they are not honoring the HTTP VERBS as they were meant to be used. If you set up your server and HTML to follow conventions they would fail. AJAX or other JavaScript REST calls could override conventions and send a PUT meant for a POST for a given URL that is not an identifier type. But it would not matter today online.</p>
     <p>To me, using <code>PUT</code> comes down to JavaScript use and the URI or Unique Identifier; the structure of the URL "posted" to the browser. The server then must look at the Http VERY bit also the URL to decide what the method is honored, then route the POST or PUT or DELETE etc. to the right place or process the resource changes as required. Only this then honors the Post vs Put design.</p>
     <p>It's the flawed nature of today's client-side model with its broken <em>HTML5</em> design, plus the corrupting nature of today's thick-client <em>JavaScript API</em> calls and other circus-tricks, that have polluted what should have been a very simple HTTP Standard created long ago by very forward looking people. But adding PUT to today's mix, and honoring its narrow use with scripting and unique identifiers will help to clean up the messy web we have today.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_42"><span>Answer 42</span> <span class="arrow"> <a href="#answer_41">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Muhammad Ali</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Mar 2023 at 04:52</span>
     </div>
    </div>
    <div>
     <h2>Where PUT is Used?</h2>
     <p>The PUT technique is mostly <strong>used to update server-side resources</strong>. Usually, it replaces anything that is present at the destination URL with something new. It can be used to create brand-new resources or replace old ones. PUT demands that the enclosing entity be saved under the given requested URI. (Uniform Resource Identifier).</p>
     <h2>Where POST is used?</h2>
     <p>A web server mostly <strong>receives the data in the message body that is requested using the POST method, which is provided by HTTP</strong>. The World Wide Web frequently uses POST when sending user-generated content to a web server or when you upload a file.</p>
     <h2>There is a lot of difference</h2>
     <div class="s-table-container">
      <table class="s-table">
       <thead>
        <tr>
         <th>Put Method</th>
         <th>Post Method</th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td><strong>Caching:</strong> PUT method responses can be cached</td>
         <td><strong>Caching:</strong> you cannot cache POST method responses.</td>
        </tr>
        <tr>
         <td><strong>Query:</strong> You can use UPDATE query in PUT</td>
         <td><strong>Query:</strong> you can use create query in POST.</td>
        </tr>
        <tr>
         <td><strong>Decision made by client:</strong> The client decides which URI resource should have</td>
         <td><strong>Decision made by server:</strong> the server decides which URI resource should have.</td>
        </tr>
        <tr>
         <td><strong>Specific in Work:</strong> PUT works as specific</td>
         <td><strong>Abstract in work:</strong> while POST work as abstract</td>
        </tr>
        <tr>
         <td><strong>Type of result:</strong> If you send the same PUT request multiple times, the result will remain the same.</td>
         <td><strong>Type of result:</strong> if you send the same POST request multiple times, you will receive different results.</td>
        </tr>
        <tr>
         <td><strong>Syntax:</strong> <em>PUT /questions/{question-id}</em></td>
         <td><strong>Syntax:</strong> <em>POST /questions</em></td>
        </tr>
       </tbody>
      </table>
     </div>
     <h2>Both have their own advantages</h2>
     <div class="s-table-container">
      <table class="s-table">
       <thead>
        <tr>
         <th>Put Method Advantages</th>
         <th>Post Method Advantages</th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td>You can keep the given entity at the given URL with its assistance.</td>
         <td>If the supplied entity already exists, you can either create using that URL or conduct the update action.</td>
        </tr>
        <tr>
         <td>You can create a resource as many times as you like.</td>
         <td>This technique aids in determining the website URL.</td>
        </tr>
        <tr>
         <td>Creating a resource with PUT method is very easy.</td>
         <td>Using location heading makes it very simple to specify a new resource location header.</td>
        </tr>
        <tr>
         <td>You don't need to make sure the user hasn't repeatedly pressed the submit option.</td>
         <td>User-generated content can be sent to the computer server.</td>
        </tr>
        <tr>
         <td>The entity that is contained with the request can be identified</td>
         <td>You can keep the data private.</td>
        </tr>
       </tbody>
      </table>
     </div>
     <p>Use POST or PUT according to your project needs.</p>
     <p>Hope it helps.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>