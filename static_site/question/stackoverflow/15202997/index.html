<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>What is the difference between canonical name, simple name and class name in Java Class?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>What is the difference between canonical name, simple name and class name in Java Class?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>1137</span>
    </div>
    <div>
     <span>Asker: </span> <span>Mohamed Taher Alrefaie</span>
    </div>
    <div>
     <span>Asked: </span> <span>4 Mar 2013 at 13:45</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/15202997/what-is-the-difference-between-canonical-name-simple-name-and-class-name-in-jav">source</a>
    </div>
   </div>
   <div>
    <p>In Java, what is the difference between these:</p>
    <pre><code>Object o1 = ....
o1.getClass().getSimpleName();
o1.getClass().getName();
o1.getClass().getCanonicalName();
</code></pre>
    <p>I have checked the Javadoc multiple times and yet this never explains it well. I also ran a test and that didn't reflect any real meaning behind the way these methods are called.</p>
   </div>
   <div class="tags">
    <span class="tag">java</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>3</td>
       <td><span><a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.7" rel="nofollow noreferrer">docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.7</a></span> <span> - </span> <span class="display-name">NPE</span> <span> </span> <span class="date">4 Mar 2013 at 13:48</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>See - <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Class.html" rel="nofollow noreferrer">docs.oracle.com/javase/6/docs/api/java/lang/Class.html</a> or maybe just write a test.</span> <span> - </span> <span class="display-name">Nick Holt</span> <span> </span> <span class="date">4 Mar 2013 at 13:50</span></td>
      </tr>
      <tr>
       <td>7</td>
       <td><span>@GrahamBorland The javadoc says <b>"as defined by the Java Language Specification"</b> - so you can look it up in that document. Just because it is not a clickable link people can still do a minimal effort and click on the first search engine result.</span> <span> - </span> <span class="display-name">vbence</span> <span> </span> <span class="date">5 Jun 2014 at 16:14</span></td>
      </tr>
      <tr>
       <td>78</td>
       <td><span>@vbence: Most people would rather get things done than look up the JLS for trivial things like this. Hence, this is the first Google result :)</span> <span> - </span> <span class="display-name">pathikrit</span> <span> </span> <span class="date">19 Nov 2014 at 11:00</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>See also: <a href="https://coderwall.com/p/lap9ww/don-t-rely-on-class-getsimplename-or-class-getcanonicalname" rel="nofollow noreferrer">coderwall.com/p/lap9ww/…</a></span> <span> - </span> <span class="display-name">Stephan</span> <span> </span> <span class="date">2 Oct 2017 at 15:59</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1304</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Nick Holt</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Mar 2013 at 14:07</span>
     </div>
    </div>
    <div>
     <p>If you're unsure about something, try writing a test first.</p>
     <p>I did this:</p>
     <pre class="lang-java prettyprint-override"><code>class ClassNameTest {
    public static void main(final String... arguments) {
        printNamesForClass(
            int.class,
            "int.class (primitive)");
        printNamesForClass(
            String.class,
            "String.class (ordinary class)");
        printNamesForClass(
            java.util.HashMap.SimpleEntry.class,
            "java.util.HashMap.SimpleEntry.class (nested class)");
        printNamesForClass(
            new java.io.Serializable(){}.getClass(),
            "new java.io.Serializable(){}.getClass() (anonymous inner class)");
    }

    private static void printNamesForClass(final Class&lt;?&gt; clazz, final String label) {
        System.out.println(label + ":");
        System.out.println("    getName():          " + clazz.getName());
        System.out.println("    getCanonicalName(): " + clazz.getCanonicalName());
        System.out.println("    getSimpleName():    " + clazz.getSimpleName());
        System.out.println("    getTypeName():      " + clazz.getTypeName()); // added in Java 8
        System.out.println();
    }
}
</code></pre>
     <p>Prints:</p>
     <pre class="lang-none prettyprint-override"><code>int.class (primitive):
    getName():          int
    getCanonicalName(): int
    getSimpleName():    int
    getTypeName():      int

String.class (ordinary class):
    getName():          java.lang.String
    getCanonicalName(): java.lang.String
    getSimpleName():    String
    getTypeName():      java.lang.String

java.util.HashMap.SimpleEntry.class (nested class):
    getName():          java.util.AbstractMap$SimpleEntry
    getCanonicalName(): java.util.AbstractMap.SimpleEntry
    getSimpleName():    SimpleEntry
    getTypeName():      java.util.AbstractMap$SimpleEntry

new java.io.Serializable(){}.getClass() (anonymous inner class):
    getName():          ClassNameTest$1
    getCanonicalName(): null
    getSimpleName():    
    getTypeName():      ClassNameTest$1
</code></pre>
     <p>There's an empty entry in the last block where <code>getSimpleName</code> returns an empty string.</p>
     <p>The upshot looking at this is:</p>
     <blockquote>
      <ul>
       <li>the <strong>name</strong> is the name that you'd use to dynamically load the class with, for example, a call to <code>Class.forName</code> with the default <code>ClassLoader</code>. Within the scope of a certain <code>ClassLoader</code>, all classes have unique names.</li>
       <li>the <strong>canonical name</strong> is the name that would be used in an import statement. It might be useful during <code>toString</code> or logging operations. When the <code>javac</code> compiler has complete view of a classpath, it enforces uniqueness of canonical names within it by clashing fully qualified class and package names at compile time. However JVMs must accept such name clashes, and thus canonical names do not uniquely identify classes within a <code>ClassLoader</code>. (In hindsight, a better name for this getter would have been <code>getJavaName</code>; but this method dates from a time when the JVM was used solely to run Java programs.)</li>
       <li>the <strong>simple name</strong> loosely identifies the class, again might be useful during <code>toString</code> or logging operations but is not guaranteed to be unique.</li>
       <li>the <strong>type name</strong> returns "an informative string for the name of this type", "It's like <code>toString</code>: it's purely informative and has no contract value". (as written by sir4ur0n)</li>
      </ul>
     </blockquote>
     <p>Also you can commonly reference the Java Language Specification documentation for these types technical Java API details:</p>
     <blockquote>
      <ul>
       <li>Here's the Java 11 <strong>Specification</strong> on this subject matter: <a href="https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.7" rel="noreferrer">https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-6.7</a></li>
      </ul>
      <p><code>Example 6.7-2.</code> and <code>Example 6.7-2.</code> goes over <code>Fully Qualified Names</code> and <code>Fully Qualified Names v. Canonical Name</code> respectively</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>5</td>
        <td><span>What extra do you think is needed?</span> <span> - </span> <span class="display-name">Nick Holt</span> <span> </span> <span class="date">4 Mar 2013 at 17:55</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>so canoncial names are ambiguous? e.g. you could have a package <code>java.util.AbstractMap</code> with a non-inner class <code>SimpleEntry</code> and that would have the same canonical name as above?</span> <span> - </span> <span class="display-name">Jayen</span> <span> </span> <span class="date">7 Jul 2014 at 07:13</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Jayen In practice I have never seen a package named like java.util.AbstractMap. Each value after "." starts with lower case letter. The above package would always be defined as java.util.abstractMap. Meanwhile class name would always be AbstractMap</span> <span> - </span> <span class="display-name">Anupam Saini</span> <span> </span> <span class="date">23 Jul 2014 at 10:37</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@AnupamSaini yes. Having such a package name in a real application would be crazy.</span> <span> - </span> <span class="display-name">Jayen</span> <span> </span> <span class="date">23 Jul 2014 at 10:58</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>IT would be crazy, however, that's the kind of assumption that would allow a malicious actor to work. Someone saying "oh, well we know classes will never start with lowercases/packages will never start with capitals". Granted, a malicious actor who has access to your class loader can already do terrible things, so it's probably not an absolutely terrible assumption.</span> <span> - </span> <span class="display-name">corsiKa</span> <span> </span> <span class="date">10 Aug 2014 at 03:56</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>getCanonicalName() is useful, if you want to create a class from string, because the Class.toString() prepends a "class " string before the classname.</span> <span> - </span> <span class="display-name">Lajos Mészáros</span> <span> </span> <span class="date">11 Feb 2015 at 10:15</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Before you can write a test like this, you already need to know the difference between getName() and getCanonicalName() though.</span> <span> - </span> <span class="display-name">Pieter De Bie</span> <span> </span> <span class="date">19 May 2015 at 13:11</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@PieterDeBie How so? All you need to know is the method name you want to test.</span> <span> - </span> <span class="display-name">fool4jesus</span> <span> </span> <span class="date">10 Sep 2015 at 13:29</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@fool4jesus, I'm sorry, I don't really remember my motivation behind my comment, but it seems you're correct.</span> <span> - </span> <span class="display-name">Pieter De Bie</span> <span> </span> <span class="date">11 Sep 2015 at 08:26</span></td>
       </tr>
       <tr>
        <td>25</td>
        <td><span>Java 8 added getTypeName() as well...care to update for that?</span> <span> - </span> <span class="display-name">Theodore Murdock</span> <span> </span> <span class="date">16 May 2016 at 15:59</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Agree with @TheodoreMurdock, would be nice if you would update this, because your answer has to many votes and people would notice the change very easily.</span> <span> - </span> <span class="display-name">X-HuMan</span> <span> </span> <span class="date">7 Jul 2016 at 15:21</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>While this may be cool, I think <code>getTypeName()</code>'s javadoc is pretty clear: <code>Return an informative string for the name of this type.</code>. It's like toString(): it's purely informative and has no contract value.</span> <span> - </span> <span class="display-name">Sir4ur0n</span> <span> </span> <span class="date">11 Aug 2016 at 08:24</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>Looking at the implementation in jdk8_102 (standard Oracle JDK), it seems to just be <code>getName()</code> with the added difference that arrays are not represented like <code>[[[Ljava.lang.Object;</code>, but as <code>java.lang.Object[][][]</code>.</span> <span> - </span> <span class="display-name">Adowrath</span> <span> </span> <span class="date">8 Apr 2017 at 11:55</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@TheodoreMurdock Added <code>getTypeName()</code> output as suggested.</span> <span> - </span> <span class="display-name">Per Lundberg</span> <span> </span> <span class="date">5 Mar 2019 at 10:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>As @Adowrath says, arrays are a very special and especially screwy case. Another answer touches on that.</span> <span> - </span> <span class="display-name">BPS</span> <span> </span> <span class="date">7 Nov 2019 at 14:26</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>120</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Victor Stafusa - BozoNaCadeia</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Apr 2015 at 23:33</span>
     </div>
    </div>
    <div>
     <p>Adding local classes, lambdas and the <code>toString()</code> method to complete the previous two answers. Further, I add arrays of lambdas and arrays of anonymous classes (which do not make any sense in practice though):</p>
     <pre class="lang-java prettyprint-override"><code>package com.example;

public final class TestClassNames {
    private static void showClass(Class&lt;?&gt; c) {
        System.out.println("getName():          " + c.getName());
        System.out.println("getCanonicalName(): " + c.getCanonicalName());
        System.out.println("getSimpleName():    " + c.getSimpleName());
        System.out.println("toString():         " + c.toString());
        System.out.println();
    }

    private static void x(Runnable r) {
        showClass(r.getClass());
        showClass(java.lang.reflect.Array.newInstance(r.getClass(), 1).getClass()); // Obtains an array class of a lambda base type.
    }

    public static class NestedClass {}

    public class InnerClass {}

    public static void main(String[] args) {
        class LocalClass {}
        showClass(void.class);
        showClass(int.class);
        showClass(String.class);
        showClass(Runnable.class);
        showClass(SomeEnum.class);
        showClass(SomeAnnotation.class);
        showClass(int[].class);
        showClass(String[].class);
        showClass(NestedClass.class);
        showClass(InnerClass.class);
        showClass(LocalClass.class);
        showClass(LocalClass[].class);
        Object anonymous = new java.io.Serializable() {};
        showClass(anonymous.getClass());
        showClass(java.lang.reflect.Array.newInstance(anonymous.getClass(), 1).getClass()); // Obtains an array class of an anonymous base type.
        x(() -&gt; {});
    }
}

enum SomeEnum {
   BLUE, YELLOW, RED;
}

@interface SomeAnnotation {}
</code></pre>
     <p>This is the full output:</p>
     <pre class="lang-none prettyprint-override"><code>getName():          void
getCanonicalName(): void
getSimpleName():    void
toString():         void

getName():          int
getCanonicalName(): int
getSimpleName():    int
toString():         int

getName():          java.lang.String
getCanonicalName(): java.lang.String
getSimpleName():    String
toString():         class java.lang.String

getName():          java.lang.Runnable
getCanonicalName(): java.lang.Runnable
getSimpleName():    Runnable
toString():         interface java.lang.Runnable

getName():          com.example.SomeEnum
getCanonicalName(): com.example.SomeEnum
getSimpleName():    SomeEnum
toString():         class com.example.SomeEnum

getName():          com.example.SomeAnnotation
getCanonicalName(): com.example.SomeAnnotation
getSimpleName():    SomeAnnotation
toString():         interface com.example.SomeAnnotation

getName():          [I
getCanonicalName(): int[]
getSimpleName():    int[]
toString():         class [I

getName():          [Ljava.lang.String;
getCanonicalName(): java.lang.String[]
getSimpleName():    String[]
toString():         class [Ljava.lang.String;

getName():          com.example.TestClassNames$NestedClass
getCanonicalName(): com.example.TestClassNames.NestedClass
getSimpleName():    NestedClass
toString():         class com.example.TestClassNames$NestedClass

getName():          com.example.TestClassNames$InnerClass
getCanonicalName(): com.example.TestClassNames.InnerClass
getSimpleName():    InnerClass
toString():         class com.example.TestClassNames$InnerClass

getName():          com.example.TestClassNames$1LocalClass
getCanonicalName(): null
getSimpleName():    LocalClass
toString():         class com.example.TestClassNames$1LocalClass

getName():          [Lcom.example.TestClassNames$1LocalClass;
getCanonicalName(): null
getSimpleName():    LocalClass[]
toString():         class [Lcom.example.TestClassNames$1LocalClass;

getName():          com.example.TestClassNames$1
getCanonicalName(): null
getSimpleName():    
toString():         class com.example.TestClassNames$1

getName():          [Lcom.example.TestClassNames$1;
getCanonicalName(): null
getSimpleName():    []
toString():         class [Lcom.example.TestClassNames$1;

getName():          com.example.TestClassNames$$Lambda$1/1175962212
getCanonicalName(): com.example.TestClassNames$$Lambda$1/1175962212
getSimpleName():    TestClassNames$$Lambda$1/1175962212
toString():         class com.example.TestClassNames$$Lambda$1/1175962212

getName():          [Lcom.example.TestClassNames$$Lambda$1;
getCanonicalName(): com.example.TestClassNames$$Lambda$1/1175962212[]
getSimpleName():    TestClassNames$$Lambda$1/1175962212[]
toString():         class [Lcom.example.TestClassNames$$Lambda$1;
</code></pre>
     <p>So, here are the rules. First, lets start with primitive types and <code>void</code>:</p>
     <ol>
      <li>If the class object represents a primitive type or <code>void</code>, all the four methods simply returns its name.</li>
     </ol>
     <p>Now the rules for the <code>getName()</code> method:</p>
     <ol start="2">
      <li>Every non-lambda and non-array class or interface (i.e, top-level, nested, inner, local and anonymous) has a name (which is returned by <code>getName()</code>) that is the package name followed by a dot (if there is a package), followed by the name of its class-file as generated by the compiler (whithout the suffix <code>.class</code>). If there is no package, it is simply the name of the class-file. If the class is an inner, nested, local or anonymous class, the compiler should generate at least one <code>$</code> in its class-file name. Note that for anonymous classes, the class name would end with a dollar-sign followed by a number.</li>
      <li>Lambda class names are generally unpredictable, and you shouldn't care about they anyway. Exactly, their name is the name of the enclosing class, followed by <code>$$Lambda$</code>, followed by a number, followed by a slash, followed by another number.</li>
      <li>The class descriptor of the primitives are <code>Z</code> for <code>boolean</code>, <code>B</code> for <code>byte</code>, <code>S</code> for <code>short</code>, <code>C</code> for <code>char</code>, <code>I</code> for <code>int</code>, <code>J</code> for <code>long</code>, <code>F</code> for <code>float</code> and <code>D</code> for <code>double</code>. For non-array classes and interfaces the class descriptor is <code>L</code> followed by what is given by <code>getName()</code> followed by <code>;</code>. For array classes, the class descriptor is <code>[</code> followed by the class descriptor of the component type (which may be itself another array class).</li>
      <li>For array classes, the <code>getName()</code> method returns its class descriptor. This rule seems to fail only for array classes whose the component type is a lambda (which possibly is a bug), but hopefully this should not matter anyway because there is no point even on the existence of array classes whose component type is a lambda.</li>
     </ol>
     <p>Now, the <code>toString()</code> method:</p>
     <ol start="6">
      <li>If the class instance represents an interface (or an annotation, which is a special type of interface), the <code>toString()</code> returns <code>"interface " + getName()</code>. If it is a primitive, it returns simply <code>getName()</code>. If it is something else (a class type, even if it is a pretty weird one), it returns <code>"class " + getName()</code>.</li>
     </ol>
     <p>The <code>getCanonicalName()</code> method:</p>
     <ol start="7">
      <li>For top-level classes and interfaces, the <code>getCanonicalName()</code> method returns just what the <code>getName()</code> method returns.</li>
      <li>The <code>getCanonicalName()</code> method returns <code>null</code> for anonymous or local classes and for array classes of those.</li>
      <li>For inner and nested classes and interfaces, the <code>getCanonicalName()</code> method returns what the <code>getName()</code> method would replacing the compiler-introduced dollar-signs by dots.</li>
      <li>For array classes, the <code>getCanonicalName()</code> method returns <code>null</code> if the canonical name of the component type is <code>null</code>. Otherwise, it returns the canonical name of the component type followed by <code>[]</code>.</li>
     </ol>
     <p>The <code>getSimpleName()</code> method:</p>
     <ol start="11">
      <li>For top-level, nested, inner and local classes, the <code>getSimpleName()</code> returns the name of the class as written in the source file.</li>
      <li>For anonymous classes the <code>getSimpleName()</code> returns an empty <code>String</code>.</li>
      <li>For lambda classes the <code>getSimpleName()</code> just returns what the <code>getName()</code> would return without the package name. This do not makes much sense and looks like a bug for me, but there is no point in calling <code>getSimpleName()</code> on a lambda class to start with.</li>
      <li>For array classes the <code>getSimpleName()</code> method returns the simple name of the component class followed by <code>[]</code>. This have the funny/weird side-effect that array classes whose component type is an anonymous class have just <code>[]</code> as their simple names.</li>
     </ol>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span><code>… replacing the dollar-signs by dots</code>: Only the dollar signs which were introduced as delimiters are being replaced. You can well have dollars as part of a simple name, and those will remain in place.</span> <span> - </span> <span class="display-name">MvG</span> <span> </span> <span class="date">2 May 2016 at 09:34</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Oh no! As part of the class name! I'm developing a class transformer and I thought that '/' would be a safe delimiter between the class and the package name :/</span> <span> - </span> <span class="display-name">Polyana Fontes</span> <span> </span> <span class="date">9 Jun 2017 at 17:55</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>83</span>
     </div>
     <div>
      <span>Answerer: </span> <span>gerardw</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 May 2014 at 15:06</span>
     </div>
    </div>
    <div>
     <p>In addition to Nick Holt's observations, I ran a few cases for <code>Array</code> data type:</p>
     <pre class="lang-java prettyprint-override"><code>//primitive Array
int demo[] = new int[5];
Class&lt;? extends int[]&gt; clzz = demo.getClass();
System.out.println(clzz.getName());
System.out.println(clzz.getCanonicalName());
System.out.println(clzz.getSimpleName());       

System.out.println();


//Object Array
Integer demo[] = new Integer[5]; 
Class&lt;? extends Integer[]&gt; clzz = demo.getClass();
System.out.println(clzz.getName());
System.out.println(clzz.getCanonicalName());
System.out.println(clzz.getSimpleName());
</code></pre>
     <p>Above code snippet prints:</p>
     <pre class="lang-none prettyprint-override"><code>[I
int[]
int[]

[Ljava.lang.Integer;
java.lang.Integer[]
Integer[]
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>29</td>
        <td><span>I't would be much better to propose an edit to the above answer.</span> <span> - </span> <span class="display-name">LoKi</span> <span> </span> <span class="date">27 Nov 2015 at 13:07</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>22</span>
     </div>
     <div>
      <span>Answerer: </span> <span>MvG</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 May 2016 at 09:15</span>
     </div>
    </div>
    <div>
     <p>I've been confused by the wide range of different naming schemes as well, and was just about to ask and answer my own question on this when I found this question here. I think my findings fit it well enough, and complement what's already here. My focus is looking for <em>documentation</em> on the various terms, and adding some more related terms that might crop up in other places.</p>
     <p>Consider the following example:</p>
     <pre><code>package a.b;
class C {
  static class D extends C {
  }
  D d;
  D[] ds;
}
</code></pre>
     <ul>
      <li>
       <p>The <strong>simple name</strong> of <code>D</code> is <code>D</code>. That's just the part you wrote when declaring the class. <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.9" rel="noreferrer">Anonymous classes</a> have no simple name. <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getSimpleName--" rel="noreferrer"><code>Class.getSimpleName()</code></a> returns this name or the empty string. It is possible for the simple name to contain a <code>$</code> if you write it like this, since <code>$</code> is a valid part of an identifier as per <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.8" rel="noreferrer">JLS section 3.8</a> (even if it is somewhat discouraged).</p></li>
      <li>
       <p>According to <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html#jls-6.7" rel="noreferrer">the JLS section 6.7</a>, both <code>a.b.C.D</code> and <code>a.b.C.D.D.D</code> would be <strong>fully qualified names</strong>, but only <code>a.b.C.D</code> would be the <strong>canonical name</strong> of <code>D</code>. So every canonical name is a fully qualified name, but the converse is not always true. <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getCanonicalName--" rel="noreferrer"><code>Class.getCanonicalName()</code></a> will return the canonical name or <code>null</code>.</p></li>
      <li>
       <p><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getName--" rel="noreferrer"><code>Class.getName()</code></a> is documented to return the <strong>binary name</strong>, as specified in <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html#jls-13.1" rel="noreferrer">JLS section 13.1</a>. In this case it returns <code>a.b.C$D</code> for <code>D</code> and <code>[La.b.C$D;</code> for <code>D[]</code>.</p></li>
      <li>
       <p><a href="https://stackoverflow.com/a/13343540/1468366">This answer</a> demonstrates that it is possible for two classes loaded by the same class loader to have the same <strong>canonical name</strong> but distinct <strong>binary names</strong>. Neither name is sufficient to reliably deduce the other: if you have the canonical name, you don't know which parts of the name are packages and which are containing classes. If you have the binary name, you don't know which <code>$</code> were introduced as separators and which were part of some simple name. (The class file <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.1" rel="noreferrer">stores the binary name</a> of the <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1" rel="noreferrer">class itself</a> and its <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.6" rel="noreferrer">enclosing class</a>, which allows the runtime to <a href="https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/5be9c5bfcfe9/src/share/classes/java/lang/Class.java#l1280" rel="noreferrer">make this distinction</a>.)</p></li>
      <li>
       <p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.9" rel="noreferrer">Anonymous classes</a> and <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.3" rel="noreferrer">local classes</a> have no <strong>fully qualified names</strong> but still have a <strong>binary name</strong>. The same holds for classes nested inside such classes. <em>Every</em> class has a binary name.</p></li>
      <li>
       <p>Running <code>javap -v -private</code> on <code>a/b/C.class</code> shows that the bytecode refers to the type of <code>d</code> as <code>La/b/C$D;</code> and that of the array <code>ds</code> as <code>[La/b/C$D;</code>. These are called <strong>descriptors</strong>, and they are specified in <a href="http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3" rel="noreferrer">JVMS section 4.3</a>.</p></li>
      <li>
       <p>The class name <code>a/b/C$D</code> used in both of these descriptors is what you get by replacing <code>.</code> by <code>/</code> in the binary name. The JVM spec apparently calls this the <strong>internal form of the binary name</strong>. <a href="http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.2.1" rel="noreferrer">JVMS section 4.2.1</a> describes it, and states that the difference from the binary name were for historical reasons.</p></li>
      <li>
       <p>The <strong>file name</strong> of a class in one of the typical filename-based class loaders is what you get if you interpret the <code>/</code> in the internal form of the binary name as a directory separator, and append the file name extension <code>.class</code> to it. It's resolved relative to the class path used by the class loader in question.</p></li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>This should be the accepted answer since it's the only answer that references the JLS and uses proper terminologies.</span> <span> - </span> <span class="display-name">MEE</span> <span> </span> <span class="date">9 Jul 2018 at 14:37</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>10</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Kiran</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Jun 2016 at 23:12</span>
     </div>
    </div>
    <div>
     <p>this is best document I found describing getName(), getSimpleName(), getCanonicalName()</p>
     <p><a href="https://javahowtodoit.wordpress.com/2014/09/09/java-lang-class-what-is-the-difference-between-class-getname-class-getcanonicalname-and-class-getsimplename/" rel="noreferrer">https://javahowtodoit.wordpress.com/2014/09/09/java-lang-class-what-is-the-difference-between-class-getname-class-getcanonicalname-and-class-getsimplename/</a></p>
     <pre><code>// Primitive type
int.class.getName();          // -&gt; int
int.class.getCanonicalName(); // -&gt; int
int.class.getSimpleName();    // -&gt; int

// Standard class
Integer.class.getName();          // -&gt; java.lang.Integer
Integer.class.getCanonicalName(); // -&gt; java.lang.Integer
Integer.class.getSimpleName();    // -&gt; Integer

// Inner class
Map.Entry.class.getName();          // -&gt; java.util.Map$Entry
Map.Entry.class.getCanonicalName(); // -&gt; java.util.Map.Entry
Map.Entry.class.getSimpleName();    // -&gt; Entry     

// Anonymous inner class
Class&lt;?&gt; anonymousInnerClass = new Cloneable() {}.getClass();
anonymousInnerClass.getName();          // -&gt; somepackage.SomeClass$1
anonymousInnerClass.getCanonicalName(); // -&gt; null
anonymousInnerClass.getSimpleName();    // -&gt; // An empty string

// Array of primitives
Class&lt;?&gt; primitiveArrayClass = new int[0].getClass();
primitiveArrayClass.getName();          // -&gt; [I
primitiveArrayClass.getCanonicalName(); // -&gt; int[]
primitiveArrayClass.getSimpleName();    // -&gt; int[]

// Array of objects
Class&lt;?&gt; objectArrayClass = new Integer[0].getClass();
objectArrayClass.getName();          // -&gt; [Ljava.lang.Integer;
objectArrayClass.getCanonicalName(); // -&gt; java.lang.Integer[]
objectArrayClass.getSimpleName();    // -&gt; Integer[]
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Sim</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Aug 2017 at 01:27</span>
     </div>
    </div>
    <div>
     <p>It is interesting to note that <code>getCanonicalName()</code> and <code>getSimpleName()</code> can raise <code>InternalError</code> when the class name is malformed. This happens for some non-Java JVM languages, e.g., Scala.</p>
     <p>Consider the following (Scala 2.11 on Java 8):</p>
     <pre><code>scala&gt; case class C()
defined class C

scala&gt; val c = C()
c: C = C()

scala&gt; c.getClass.getSimpleName
java.lang.InternalError: Malformed class name
  at java.lang.Class.getSimpleName(Class.java:1330)
  ... 32 elided

scala&gt; c.getClass.getCanonicalName
java.lang.InternalError: Malformed class name
  at java.lang.Class.getSimpleName(Class.java:1330)
  at java.lang.Class.getCanonicalName(Class.java:1399)
  ... 32 elided

scala&gt; c.getClass.getName
res2: String = C
</code></pre>
     <p>This can be a problem for mixed language environments or environments that dynamically load bytecode, e.g., app servers and other platform software.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Abdul Alim Shakir</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Oct 2019 at 03:54</span>
     </div>
    </div>
    <div>
     <p><strong>getName()</strong> – returns the name of the entity (class, interface, array class, primitive type, or void) represented by this Class object, as a String.</p>
     <p><strong>getCanonicalName()</strong> – returns the canonical name of the underlying class as defined by the Java Language Specification.</p>
     <p><strong>getSimpleName()</strong> – returns the simple name of the underlying class, that is the name it has been given in the source code.</p>
     <pre><code>package com.practice;

public class ClassName {
public static void main(String[] args) {

  ClassName c = new ClassName();
  Class cls = c.getClass();

  // returns the canonical name of the underlying class if it exists
  System.out.println("Class = " + cls.getCanonicalName());    //Class = com.practice.ClassName
  System.out.println("Class = " + cls.getName());             //Class = com.practice.ClassName
  System.out.println("Class = " + cls.getSimpleName());       //Class = ClassName
  System.out.println("Class = " + Map.Entry.class.getName());             // -&gt; Class = java.util.Map$Entry
  System.out.println("Class = " + Map.Entry.class.getCanonicalName());    // -&gt; Class = java.util.Map.Entry
  System.out.println("Class = " + Map.Entry.class.getSimpleName());       // -&gt; Class = Entry 
  }
}
</code></pre>
     <p>One difference is that if you use an <em>anonymous class</em> you can get a null value when trying to get the name of the class using the <code>getCanonicalName()</code></p>
     <p>Another fact is that <code>getName()</code> method behaves differently than the <code>getCanonicalName()</code> method for <em>inner classes</em>. <code>getName()</code> uses a dollar as the separator between the enclosing class canonical name and the inner class simple name.</p>
     <p>To know more about <a href="https://www.baeldung.com/java-class-name" rel="nofollow noreferrer">retrieving a class name in Java</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Shirish Singh</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Oct 2016 at 14:15</span>
     </div>
    </div>
    <div>
     <pre><code>    public void printReflectionClassNames(){
    StringBuffer buffer = new StringBuffer();
    Class clazz= buffer.getClass();
    System.out.println("Reflection on String Buffer Class");
    System.out.println("Name: "+clazz.getName());
    System.out.println("Simple Name: "+clazz.getSimpleName());
    System.out.println("Canonical Name: "+clazz.getCanonicalName());
    System.out.println("Type Name: "+clazz.getTypeName());
}

outputs:
Reflection on String Buffer Class
Name: java.lang.StringBuffer
Simple Name: StringBuffer
Canonical Name: java.lang.StringBuffer
Type Name: java.lang.StringBuffer
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>The first two lines inside the method can be reduced to <code>Class&lt;StringBuffer&gt; clazz = StringBuffer.class</code></span> <span> - </span> <span class="display-name">ThePyroEagle</span> <span> </span> <span class="date">29 Dec 2016 at 16:08</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Zufar Sunagatov</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Apr 2023 at 20:50</span>
     </div>
    </div>
    <div>
     <blockquote>
      <p>What is the difference between canonical name, simple name and class name in Java Class?</p>
     </blockquote>
     <p>The method <code>getClass()</code> in <code>Java</code> is used to get the <strong>Class object</strong> associated with a specific object instance. The <strong>Class object</strong> represents information about the <strong>class</strong> to which the <strong>object</strong> belongs.</p>
     <p>The <code>getSimpleName()</code>, <code>getName()</code>, and <code>getCanonicalName()</code> methods differ in the following ways:</p>
     <ul>
      <li><code>getSimpleName()</code> is the method which returns the simple name of the class represented by the Class object. It has no information about a package.</li>
     </ul>
     <p><strong>For example:</strong> if <code>objectOne</code> is an instance of the <code>java.util.ArrayList class</code>, <code>objectOne.getClass().getSimpleName()</code> will return <code>ArrayList</code>.</p>
     <ul>
      <li><code>getName()</code> is the method which returns the fully-qualified name of the class represented by the Class object, including the package name.</li>
     </ul>
     <p><strong>For example:</strong> if <code>objectOne</code> is an instance of the <code>java.util.ArrayList class</code>, <code>objectOne.getClass().getName()</code> will return <code>java.util.ArrayList</code>.</p>
     <ul>
      <li><code>getCanonicalName()</code> is the method which returns the canonical name of the class represented by the Class object. The canonical name is the fully-qualified name of the class, but with any generic type information removed.</li>
     </ul>
     <p><strong>For example:</strong> if <code>objectOne</code> is an instance of the <code>java.util.ArrayList</code> class with a <code>generic type parameter of String</code>, <code>o1.getClass().getCanonicalName()</code> will return <code>java.util.ArrayList</code>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>