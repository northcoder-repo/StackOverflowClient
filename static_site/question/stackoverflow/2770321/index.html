<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>What is a raw type and why shouldn't we use it?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>What is a raw type and why shouldn't we use it?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>807</span>
    </div>
    <div>
     <span>Asker: </span> <span>polygenelubricants</span>
    </div>
    <div>
     <span>Asked: </span> <span>5 May 2010 at 02:48</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/2770321/what-is-a-raw-type-and-why-shouldnt-we-use-it">source</a>
    </div>
   </div>
   <div>
    <h3>Questions:</h3>
    <ul>
     <li>What are raw types in Java, and why do I often hear that they shouldn't be used in new code?</li>
     <li>What is the alternative if we can't use raw types, and how is it better?</li>
    </ul>
   </div>
   <div class="tags">
    <span class="tag">java</span><span class="tag">generics</span><span class="tag">raw-types</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td></td>
       <td><span>the java tutorials still use the JComboBox that causes this warning. Which version of the combobox will not cause this warning ? <a href="http://docs.oracle.com/javase/tutorial/uiswing/components/combobox.html" rel="nofollow noreferrer">docs.oracle.com/javase/tutorial/uiswing/components/…</a></span> <span> - </span> <span class="display-name">SuperStar</span> <span> </span> <span class="date">2 Apr 2013 at 10:04</span></td>
      </tr>
      <tr>
       <td>5</td>
       <td><span>Note that the reason why raw types exist is for backwards compatibility with Java 1.4 and older, which did not have generics at all.</span> <span> - </span> <span class="display-name">Jesper</span> <span> </span> <span class="date">23 May 2016 at 08:07</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>876</span>
     </div>
     <div>
      <span>Answerer: </span> <span>polygenelubricants</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 May 2010 at 04:50</span>
     </div>
    </div>
    <div>
     <h2>What is a raw type?</h2>
     <p>The Java Language Specification defines a <em>raw type</em> as follows:</p>
     <h3><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.8" rel="noreferrer">JLS 4.8 Raw Types</a></h3>
     <blockquote>
      <p>A raw type is defined to be one of:</p>
      <ul>
       <li>
        <p>The reference type that is formed by taking the name of a generic type declaration without an accompanying type argument list.</p></li>
       <li>
        <p>An array type whose element type is a raw type.</p></li>
       <li>
        <p>A non-<code>static</code> member type of a raw type <code>R</code> that is not inherited from a superclass or superinterface of <code>R</code>.</p></li>
      </ul>
     </blockquote>
     <p>Here's an example to illustrate:</p>
     <pre><code>public class MyType&lt;E&gt; {
    class Inner { }
    static class Nested { }
    
    public static void main(String[] args) {
        MyType mt;          // warning: MyType is a raw type
        MyType.Inner inn;   // warning: MyType.Inner is a raw type

        MyType.Nested nest; // no warning: not parameterized type
        MyType&lt;Object&gt; mt1; // no warning: type parameter given
        MyType&lt;?&gt; mt2;      // no warning: type parameter given (wildcard OK!)
    }
}
</code></pre>
     <p>Here, <code>MyType&lt;E&gt;</code> is a <em>parameterized type</em> (<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5" rel="noreferrer">JLS 4.5</a>). It is common to colloquially refer to this type as simply <code>MyType</code> for short, but technically the name is <code>MyType&lt;E&gt;</code>.</p>
     <p><code>mt</code> has a raw type (and generates a compilation warning) by the first bullet point in the above definition; <code>inn</code> also has a raw type by the third bullet point.</p>
     <p><code>MyType.Nested</code> is not a parameterized type, even though it's a member type of a parameterized type <code>MyType&lt;E&gt;</code>, because it's <code>static</code>.</p>
     <p><code>mt1</code>, and <code>mt2</code> are both declared with actual type parameters, so they're not raw types.</p>
     <hr>
     <h2>What's so special about raw types?</h2>
     <p>Essentially, raw types behaves just like they were before generics were introduced. That is, the following is entirely legal at compile-time.</p>
     <pre><code>List names = new ArrayList(); // warning: raw type!
names.add("John");
names.add("Mary");
names.add(Boolean.FALSE); // not a compilation error!
</code></pre>
     <p>The above code runs just fine, but suppose you also have the following:</p>
     <pre><code>for (Object o : names) {
    String name = (String) o;
    System.out.println(name);
} // throws ClassCastException!
  //    java.lang.Boolean cannot be cast to java.lang.String
</code></pre>
     <p>Now we run into trouble at run-time, because <code>names</code> contains something that isn't an <code>instanceof String</code>.</p>
     <p>Presumably, if you want <code>names</code> to contain only <code>String</code>, you <em>could</em> perhaps still use a raw type and <em>manually check every</em> <code>add</code> yourself, and then <em>manually cast</em> to <code>String</code> every item from <code>names</code>. <strong>Even better</strong>, though is NOT to use a raw type and <em>let the compiler do all the work for you</em>, harnessing the power of Java generics.</p>
     <pre><code>List&lt;String&gt; names = new ArrayList&lt;String&gt;();
names.add("John");
names.add("Mary");
names.add(Boolean.FALSE); // compilation error!
</code></pre>
     <p>Of course, if you <em>DO</em> want <code>names</code> to allow a <code>Boolean</code>, then you can declare it as <code>List&lt;Object&gt; names</code>, and the above code would compile.</p>
     <h3>See also</h3>
     <ul>
      <li><a href="https://docs.oracle.com/javase/tutorial/java/generics/" rel="noreferrer">Java Tutorials/Generics</a></li>
     </ul>
     <hr>
     <h2>How's a raw type different from using <code>&lt;Object&gt;</code> as type parameters?</h2>
     <p>The following is a quote from <em>Effective Java 2nd Edition, Item 23: Don't use raw types in new code</em>:</p>
     <blockquote>
      <p>Just what is the difference between the raw type <code>List</code> and the parameterized type <code>List&lt;Object&gt;</code>? Loosely speaking, the former has opted out generic type checking, while the latter explicitly told the compiler that it is capable of holding objects of any type. While you can pass a <code>List&lt;String&gt;</code> to a parameter of type <code>List</code>, you can't pass it to a parameter of type <code>List&lt;Object&gt;</code>. There are subtyping rules for generics, and <code>List&lt;String&gt;</code> is a subtype of the raw type <code>List</code>, but not of the parameterized type <code>List&lt;Object&gt;</code>. As a consequence, <strong>you lose type safety if you use raw type like <code>List</code>, but not if you use a parameterized type like <code>List&lt;Object&gt;</code></strong>.</p>
     </blockquote>
     <p>To illustrate the point, consider the following method which takes a <code>List&lt;Object&gt;</code> and appends a <code>new Object()</code>.</p>
     <pre><code>void appendNewObject(List&lt;Object&gt; list) {
   list.add(new Object());
}
</code></pre>
     <p>Generics in Java are invariant. A <code>List&lt;String&gt;</code> is not a <code>List&lt;Object&gt;</code>, so the following would generate a compiler warning:</p>
     <pre><code>List&lt;String&gt; names = new ArrayList&lt;String&gt;();
appendNewObject(names); // compilation error!
</code></pre>
     <p>If you had declared <code>appendNewObject</code> to take a raw type <code>List</code> as parameter, then this would compile, and you'd therefore lose the type safety that you get from generics.</p>
     <h3>See also</h3>
     <ul>
      <li><a href="https://stackoverflow.com/questions/2770264/what-is-the-difference-between-e-extends-number-and-number/">What is the difference between <code>&lt;E extends Number&gt;</code> and <code>&lt;Number&gt;</code>?</a></li>
      <li><a href="https://stackoverflow.com/questions/2660827/java-generics-covariance">java generics (not) covariance</a></li>
     </ul>
     <hr>
     <h2>How's a raw type different from using <code>&lt;?&gt;</code> as a type parameter?</h2>
     <p><code>List&lt;Object&gt;</code>, <code>List&lt;String&gt;</code>, etc are all <code>List&lt;?&gt;</code>, so it may be tempting to just say that they're just <code>List</code> instead. However, there is a major difference: since a <code>List&lt;E&gt;</code> defines only <code>add(E)</code>, you can't add just any arbitrary object to a <code>List&lt;?&gt;</code>. On the other hand, since the raw type <code>List</code> does not have type safety, you can <code>add</code> just about anything to a <code>List</code>.</p>
     <p>Consider the following variation of the previous snippet:</p>
     <pre><code>static void appendNewObject(List&lt;?&gt; list) {
    list.add(new Object()); // compilation error!
}
//...

List&lt;String&gt; names = new ArrayList&lt;String&gt;();
appendNewObject(names); // this part is fine!
</code></pre>
     <p>The compiler did a wonderful job of protecting you from potentially violating the type invariance of the <code>List&lt;?&gt;</code>! If you had declared the parameter as the raw type <code>List list</code>, then the code would compile, and you'd violate the type invariant of <code>List&lt;String&gt; names</code>.</p>
     <hr>
     <h2>A raw type is the erasure of that type</h2>
     <p>Back to JLS 4.8:</p>
     <blockquote>
      <p>It is possible to use as a type <strong>the erasure</strong> of a parameterized type or the erasure of an array type whose element type is a parameterized type. <strong>Such a type is called a <em>raw type</em>.</strong></p>
      <p><em>[...]</em></p>
      <p>The superclasses (respectively, superinterfaces) of a raw type are the erasures of the superclasses (superinterfaces) of any of the parameterizations of the generic type.</p>
      <p>The type of a constructor, instance method, or non-<code>static</code> field of a raw type <code>C</code> that is not inherited from its superclasses or superinterfaces is the raw type that corresponds to the erasure of its type in the generic declaration corresponding to <code>C</code>.</p>
     </blockquote>
     <p>In simpler terms, when a raw type is used, the constructors, instance methods and non-<code>static</code> fields are <em>also erased</em>.</p>
     <p>Take the following example:</p>
     <pre><code>class MyType&lt;E&gt; {
    List&lt;String&gt; getNames() {
        return Arrays.asList("John", "Mary");
    }

    public static void main(String[] args) {
        MyType rawType = new MyType();
        // unchecked warning!
        // required: List&lt;String&gt; found: List
        List&lt;String&gt; names = rawType.getNames();
        // compilation error!
        // incompatible types: Object cannot be converted to String
        for (String str : rawType.getNames())
            System.out.print(str);
    }
}
</code></pre>
     <p>When we use the raw <code>MyType</code>, <code>getNames</code> becomes erased as well, so that it returns a raw <code>List</code>!</p>
     <p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6" rel="noreferrer">JLS 4.6</a> continues to explain the following:</p>
     <blockquote>
      <p><strong>Type erasure also maps the signature of a constructor or method to a signature that has no parameterized types or type variables.</strong> The erasure of a constructor or method signature <code>s</code> is a signature consisting of the same name as <code>s</code> and the erasures of all the formal parameter types given in <code>s</code>.</p>
      <p><strong>The return type of a method and the type parameters of a generic method or constructor also undergo erasure if the method or constructor's signature is erased.</strong></p>
      <p>The erasure of the signature of a generic method has no type parameters.</p>
     </blockquote>
     <p>The following bug report contains some thoughts from Maurizio Cimadamore, a compiler dev, and Alex Buckley, one of the authors of the JLS, on why this sort of behavior ought to occur: <a href="https://bugs.openjdk.java.net/browse/JDK-6400189" rel="noreferrer">https://bugs.openjdk.java.net/browse/JDK-6400189</a>. (In short, it makes the specification simpler.)</p>
     <hr>
     <h2>If it's unsafe, why is it allowed to use a raw type?</h2>
     <p>Here's another quote from JLS 4.8:</p>
     <blockquote>
      <p>The use of raw types is allowed only as a concession to compatibility of legacy code. <em>The use of raw types in code written after the introduction of genericity into the Java programming language is strongly discouraged. It is possible that future versions of the Java programming language will disallow the use of raw types.</em></p>
     </blockquote>
     <p><em>Effective Java 2nd Edition</em> also has this to add:</p>
     <blockquote>
      <p>Given that you shouldn't use raw types, why did the language designers allow them? To provide compatibility.</p>
      <p>The Java platform was about to enter its second decade when generics were introduced, and there was an enormous amount of Java code in existence that did not use generics. It was deemed critical that all this code remains legal and interoperable with new code that does use generics. It had to be legal to pass instances of parameterized types to methods that were designed for use with ordinary types, and vice versa. This requirement, known as <em>migration compatibility</em>, drove the decision to support raw types.</p>
     </blockquote>
     <p>In summary, raw types should NEVER be used in new code. <strong>You should always use parameterized types</strong>.</p>
     <hr>
     <h2>Are there no exceptions?</h2>
     <p>Unfortunately, because Java generics are non-reified, there are two exceptions where raw types must be used in new code:</p>
     <ul>
      <li>Class literals, e.g. <code>List.class</code>, not <code>List&lt;String&gt;.class</code></li>
      <li><code>instanceof</code> operand, e.g. <code>o instanceof Set</code>, not <code>o instanceof Set&lt;String&gt;</code></li>
     </ul>
     <h3>See also</h3>
     <ul>
      <li><a href="https://stackoverflow.com/questions/2745193/why-is-collectionstring-class-illegal/">Why is <code>Collection&lt;String&gt;.class</code> Illegal?</a></li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>25</td>
        <td><span>What do you mean that, "Java generics are non-reified"?</span> <span> - </span> <span class="display-name">Carl G</span> <span> </span> <span class="date">15 Dec 2012 at 20:07</span></td>
       </tr>
       <tr>
        <td>8</td>
        <td><span>For the second exception, the syntax <code>o instanceof Set&lt;?&gt;</code> is also permitted to avoid the raw type (though it's only superficial in this case).</span> <span> - </span> <span class="display-name">Paul Bellora</span> <span> </span> <span class="date">20 May 2013 at 04:20</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>can you give me an example of " migration compatibility" ??</span> <span> - </span> <span class="display-name">Aladdin</span> <span> </span> <span class="date">31 May 2013 at 13:24</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Raw types are very usefull and reduce boilerplate code in case of JNDI lookups for a bean which extends an interface. This resolves the need to write <code>n</code> remote beans for each implementing class with identical code.</span> <span> - </span> <span class="display-name">djmj</span> <span> </span> <span class="date">19 Sep 2014 at 23:16</span></td>
       </tr>
       <tr>
        <td>12</td>
        <td><span>"Non-reified" is another way of saying that they are erased. The compiler knows what the generic parameters are, but that information is not passed on to the generated bytecode. The JLS requires that class literals have no type parameters.</span> <span> - </span> <span class="display-name">Erick G. Hagstrom</span> <span> </span> <span class="date">21 Jul 2015 at 18:24</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>There might be a thrd exception. A case where you really need to extnd/implement 2 parents with different typed methods that share same erased signature whose names clash. Then the only simple way is using raw type for the parameter of the inherited method to avoid collisions and do the type checking hardcoded according to what each parent expects. It's really ugly, but works as a self-explanatory workarond,,..</span> <span> - </span> <span class="display-name">Whimusical</span> <span> </span> <span class="date">17 Dec 2015 at 23:05</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>When using the generics... why is having an error thrown at compilation time "better" than having an exception thrown at runtime?</span> <span> - </span> <span class="display-name">Jwan622</span> <span> </span> <span class="date">6 Jan 2016 at 16:42</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Radiodef - Wouldn't it be <code>List.&lt;String&gt;class</code>? Like <code>Collections.&lt;String,String&gt;emptyMap();</code> - i.e. the generic <b>after</b> the dot.</span> <span> - </span> <span class="display-name">OldCurmudgeon</span> <span> </span> <span class="date">19 Apr 2016 at 13:52</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@OldCurmudgeon That's interesting. I mean officially it's <i>neither</i>, because a class literal defined as just <code>TypeName.class</code>, where <code>TypeName</code> is a plain identifier (<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.8.2" rel="nofollow noreferrer">jls</a>). Speaking hypothetically, I guess it could really be either. Maybe as a clue, <code>List&lt;String&gt;.class</code> is the variant that the JLS specifically calls a compiler error, so if they ever add it to the language I'd expect that that is the one they use.</span> <span> - </span> <span class="display-name">Radiodef</span> <span> </span> <span class="date">19 Apr 2016 at 14:09</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@Jwan622 because the program is <i>much less likely</i> to leave the developers local PC still in that state.</span> <span> - </span> <span class="display-name">Caleth</span> <span> </span> <span class="date">28 Jul 2017 at 14:45</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>am I the only one here who doesn't get compiler warnings compiling the snippets which are marked to issue warnings?</span> <span> - </span> <span class="display-name">user5818995</span> <span> </span> <span class="date">8 Apr 2018 at 04:51</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>70</span>
     </div>
     <div>
      <span>Answerer: </span> <span>josefx</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 May 2010 at 21:50</span>
     </div>
    </div>
    <div>
     <blockquote>
      <p>What are raw types in Java, and why do I often hear that they shouldn't be used in new code?</p>
     </blockquote>
     <p>Raw-types are ancient history of the Java language. In the beginning there were <code>Collections</code> and they held <code>Objects</code> nothing more and nothing less. Every operation on <code>Collections</code> required casts from <code>Object</code> to the desired type.</p>
     <pre><code>List aList = new ArrayList();
String s = "Hello World!";
aList.add(s);
String c = (String)aList.get(0);
</code></pre>
     <p>While this worked most of the time, errors did happen</p>
     <pre><code>List aNumberList = new ArrayList();
String one = "1";//Number one
aNumberList.add(one);
Integer iOne = (Integer)aNumberList.get(0);//Insert ClassCastException here
</code></pre>
     <p>The old typeless collections could not enforce type-safety so the programmer had to remember what he stored within a collection.<br>
       Generics where invented to get around this limitation, the developer would declare the stored type once and the compiler would do it instead.</p>
     <pre><code>List&lt;String&gt; aNumberList = new ArrayList&lt;String&gt;();
aNumberList.add("one");
Integer iOne = aNumberList.get(0);//Compile time error
String sOne = aNumberList.get(0);//works fine
</code></pre>
     <p>For Comparison:</p>
     <pre><code>// Old style collections now known as raw types
List aList = new ArrayList(); //Could contain anything
// New style collections with Generics
List&lt;String&gt; aList = new ArrayList&lt;String&gt;(); //Contains only Strings
</code></pre>
     <p>More complex the Compareable interface:</p>
     <pre><code>//raw, not type save can compare with Other classes
class MyCompareAble implements CompareAble
{
   int id;
   public int compareTo(Object other)
   {return this.id - ((MyCompareAble)other).id;}
}
//Generic
class MyCompareAble implements CompareAble&lt;MyCompareAble&gt;
{
   int id;
   public int compareTo(MyCompareAble other)
   {return this.id - other.id;}
}
</code></pre>
     <p>Note that it is impossible to implement the <code>CompareAble</code> interface with <code>compareTo(MyCompareAble)</code> with raw types. Why you should not use them:</p>
     <ul>
      <li>Any <code>Object</code> stored in a <code>Collection</code> has to be cast before it can be used</li>
      <li>Using generics enables compile time checks</li>
      <li>Using raw types is the same as storing each value as <code>Object</code></li>
     </ul>
     <p>What the compiler does: Generics are backward compatible, they use the same java classes as the raw types do. The magic happens mostly at compile time.</p>
     <pre><code>List&lt;String&gt; someStrings = new ArrayList&lt;String&gt;();
someStrings.add("one");
String one = someStrings.get(0);
</code></pre>
     <p>Will be compiled as:</p>
     <pre><code>List someStrings = new ArrayList();
someStrings.add("one"); 
String one = (String)someStrings.get(0);
</code></pre>
     <p>This is the same code you would write if you used the raw types directly. Thought I'm not sure what happens with the <code>CompareAble</code> interface, I guess that it creates two <code>compareTo</code> functions, one taking a <code>MyCompareAble</code> and the other taking an <code>Object</code> and passing it to the first after casting it.</p>
     <p>What are the alternatives to raw types: Use <a href="http://java.sun.com/docs/books/tutorial/extra/generics/index.html" rel="noreferrer">generics</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>32</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Adelin</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Aug 2013 at 23:58</span>
     </div>
    </div>
    <div>
     <p>A raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:</p>
     <pre><code>public class Box&lt;T&gt; {
    public void set(T t) { /* ... */ }
    // ...
}
</code></pre>
     <p>To create a parameterized type of <code>Box&lt;T&gt;</code>, you supply an actual type argument for the formal type parameter <code>T</code>:</p>
     <pre><code>Box&lt;Integer&gt; intBox = new Box&lt;&gt;();
</code></pre>
     <p>If the actual type argument is omitted, you create a raw type of <code>Box&lt;T&gt;</code>:</p>
     <pre><code>Box rawBox = new Box();
</code></pre>
     <p>Therefore, <code>Box</code> is the raw type of the generic type <code>Box&lt;T&gt;</code>. However, a non-generic class or interface type is not a raw type.</p>
     <p>Raw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior — a <code>Box</code> gives you <code>Object</code>s. For backward compatibility, assigning a parameterized type to its raw type is allowed:</p>
     <pre><code>Box&lt;String&gt; stringBox = new Box&lt;&gt;();
Box rawBox = stringBox;               // OK
</code></pre>
     <p>But if you assign a raw type to a parameterized type, you get a warning:</p>
     <pre><code>Box rawBox = new Box();           // rawBox is a raw type of Box&lt;T&gt;
Box&lt;Integer&gt; intBox = rawBox;     // warning: unchecked conversion
</code></pre>
     <p>You also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:</p>
     <pre><code>Box&lt;String&gt; stringBox = new Box&lt;&gt;();
Box rawBox = stringBox;
rawBox.set(8);  // warning: unchecked invocation to set(T)
</code></pre>
     <p>The warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.</p>
     <p>The Type Erasure section has more information on how the Java compiler uses raw types.</p>
     <h3>Unchecked Error Messages</h3>
     <p>As mentioned previously, when mixing legacy code with generic code, you may encounter warning messages similar to the following:</p>
     <blockquote>
      <p>Note: Example.java uses unchecked or unsafe operations.</p>
      <p>Note: Recompile with -Xlint:unchecked for details.</p>
     </blockquote>
     <p>This can happen when using an older API that operates on raw types, as shown in the following example:</p>
     <pre><code>public class WarningDemo {
    public static void main(String[] args){
        Box&lt;Integer&gt; bi;
        bi = createBox();
    }

    static Box createBox(){
        return new Box();
    }
}
</code></pre>
     <p>The term "unchecked" means that the compiler does not have enough type information to perform all type checks necessary to ensure type safety. The "unchecked" warning is disabled, by default, though the compiler gives a hint. To see all "unchecked" warnings, recompile with -Xlint:unchecked.</p>
     <p>Recompiling the previous example with -Xlint:unchecked reveals the following additional information:</p>
     <pre><code>WarningDemo.java:4: warning: [unchecked] unchecked conversion
found   : Box
required: Box&lt;java.lang.Integer&gt;
        bi = createBox();
                      ^
1 warning
</code></pre>
     <p>To completely disable unchecked warnings, use the -Xlint:-unchecked flag. The <code>@SuppressWarnings("unchecked")</code> annotation suppresses unchecked warnings. If you are unfamiliar with the <code>@SuppressWarnings</code> syntax, see Annotations.</p>
     <p>Original source: <a href="http://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html" rel="noreferrer">Java Tutorials</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>31</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Andy White</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 May 2010 at 02:58</span>
     </div>
    </div>
    <div>
     <p>A "raw" type in Java is a class which is non-generic and deals with "raw" Objects, rather than type-safe generic type parameters.</p>
     <p>For example, before Java generics was available, you would use a collection class like this:</p>
     <pre><code>LinkedList list = new LinkedList();
list.add(new MyObject());
MyObject myObject = (MyObject)list.get(0);
</code></pre>
     <p>When you add your object to the list, it doesn't care what type of object it is, and when you get it from the list, you have to explicitly cast it to the type you are expecting.</p>
     <p>Using generics, you remove the "unknown" factor, because you must explicitly specify which type of objects can go in the list:</p>
     <pre><code>LinkedList&lt;MyObject&gt; list = new LinkedList&lt;MyObject&gt;();
list.add(new MyObject());
MyObject myObject = list.get(0);
</code></pre>
     <p>Notice that with generics you don't have to cast the object coming from the get call, the collection is pre-defined to only work with MyObject. This very fact is the main driving factor for generics. It changes a source of runtime errors into something that can be checked at compile time.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>More specifically, a raw type is what you get when you simply omit the type parameters for a generic type. Raw types were really only ever a backwards-compatibility feature, and are potentially subject to removal. You can get similar behavior using ? wildcard parameters.</span> <span> - </span> <span class="display-name">John Flatness</span> <span> </span> <span class="date">5 May 2010 at 03:10</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@zerocrates: similar but different! Using <code>?</code> still offers type safety. I covered it in my answer.</span> <span> - </span> <span class="display-name">polygenelubricants</span> <span> </span> <span class="date">5 May 2010 at 05:08</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>20</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Bozho</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Jun 2010 at 07:44</span>
     </div>
    </div>
    <div>
     <pre><code> private static List&lt;String&gt; list = new ArrayList&lt;String&gt;();
</code></pre>
     <p>You should specify the type-parameter.</p>
     <p>The warning advises that types that are defined to support <a href="http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html" rel="noreferrer">generics</a> should be parameterized, rather than using their raw form.</p>
     <p><code>List</code> is defined to support generics: <code>public class List&lt;E&gt;</code>. This allows many type-safe operations, that are checked compile-time.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span>Now replaced by <i>diamond inference</i> in Java 7 -- <code>private static List&lt;String&gt; list = new ArrayList&lt;&gt;();</code></span> <span> - </span> <span class="display-name">Ian Campbell</span> <span> </span> <span class="date">10 Oct 2014 at 14:03</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>18</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Bert F</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 May 2010 at 04:31</span>
     </div>
    </div>
    <div>
     <p><em>What is a raw type and why do I often hear that they shouldn't be used in new code?</em></p>
     <p>A "raw type" is the use of a generic class without specifying a type argument(s) for its parameterized type(s), e.g. using <code>List</code> instead of <code>List&lt;String&gt;</code>. When generics were introduced into Java, several classes were updated to use generics. Using these class as a "raw type" (without specifying a type argument) allowed legacy code to still compile.</p>
     <p>"Raw types" are used for backwards compatibility. Their use in new code is not recommended because using the generic class with a type argument allows for stronger typing, which in turn may improve code understandability and lead to catching potential problems earlier.</p>
     <p><em>What is the alternative if we can't use raw types, and how is it better?</em></p>
     <p>The preferred alternative is to use generic classes as intended - with a suitable type argument (e.g. <code>List&lt;String&gt;</code>). This allows the programmer to specify types more specifically, conveys more meaning to future maintainers about the intended use of a variable or data structure, and it allows compiler to enforce better type-safety. These advantages together may improve code quality and help prevent the introduction of some coding errors.</p>
     <p>For example, for a method where the programmer wants to ensure a List variable called 'names' contains only Strings:</p>
     <pre><code>List&lt;String&gt; names = new ArrayList&lt;String&gt;();
names.add("John");          // OK
names.add(new Integer(1));  // compile error
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>Ah, so tempted to copy <code>polygenelubricants</code>'s "raw type" references from <a href="http://stackoverflow.com/questions/2770111/how-can-we-improve-performance-of-this-piece-of-code/2770253#2770253" title="how can we improve performance of this piece of code">stackoverflow.com/questions/2770111/…</a> into my own answer, but I suppose I'll leave them for use in his/her own answer.</span> <span> - </span> <span class="display-name">Bert F</span> <span> </span> <span class="date">5 May 2010 at 04:38</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>yes, I've been essentially copying-and-pasting that segment everywhere people use raw types on stackoverflow, and finally decided to just have one question to refer to from now on. I hope it's a good contribution for the community.</span> <span> - </span> <span class="display-name">polygenelubricants</span> <span> </span> <span class="date">5 May 2010 at 05:02</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@polygenelubricants I noticed - we hit some of the same questions :-)</span> <span> - </span> <span class="display-name">Bert F</span> <span> </span> <span class="date">5 May 2010 at 05:17</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@ha9u63ar: Indeed. In general concise and simple answers are at least as good as the long and accepted ones.</span> <span> - </span> <span class="display-name">displayName</span> <span> </span> <span class="date">7 Aug 2017 at 15:02</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>What's "stronger syping"?</span> <span> - </span> <span class="display-name">carloswm85</span> <span> </span> <span class="date">19 Sep 2019 at 20:49</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>15</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Vikrant Kashyap</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 May 2016 at 13:51</span>
     </div>
    </div>
    <div>
     <p>Here I am Considering multiple cases through which you can clearify the concept</p>
     <pre><code>1. ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;();
2. ArrayList&lt;String&gt; arr = new ArrayList();
3. ArrayList arr = new ArrayList&lt;String&gt;();
</code></pre>
     <h2>Case 1</h2>
     <p><code>ArrayList&lt;String&gt; arr</code> it is a <code>ArrayList</code> reference variable with type <code>String</code> which reference to a <code>ArralyList</code> Object of Type <code>String</code>. It means it can hold only String type Object.</p>
     <p>It is a Strict to <code>String</code> not a Raw Type so, It will never raise an warning .</p>
     <pre><code>    arr.add("hello");// alone statement will compile successfully and no warning.

    arr.add(23);  //prone to compile time error.
     //error: no suitable method found for add(int)
</code></pre>
     <h2>Case 2</h2>
     <p>In this case <code>ArrayList&lt;String&gt; arr</code> is a strict type but your Object <code>new ArrayList();</code> is a raw type.</p>
     <pre><code>    arr.add("hello"); //alone this compile but raise the warning.
    arr.add(23);  //again prone to compile time error.
    //error: no suitable method found for add(int)
</code></pre>
     <p>here <code>arr</code> is a Strict type. So, It will raise compile time error when adding a <code>integer</code>.</p>
     <blockquote>
      <p><strong>Warning</strong> :- A <code>Raw</code> Type Object is referenced to a <code>Strict</code> type Referenced Variable of <code>ArrayList</code>.</p>
     </blockquote>
     <h2>Case 3</h2>
     <p>In this case <code>ArrayList arr</code> is a raw type but your Object <code>new ArrayList&lt;String&gt;();</code> is a Strict type.</p>
     <pre><code>    arr.add("hello");  
    arr.add(23);  //compiles fine but raise the warning.
</code></pre>
     <p>It will add any type of Object into it because <code>arr</code> is a Raw Type.</p>
     <blockquote>
      <p><strong>Warning</strong> :- A <code>Strict</code> Type Object is referenced to a <code>raw</code> type referenced Variable.</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>In Case 2, are there some other disadvantages except the warning? I mean, if I ignore the warning, I think Case 1 and Case 2 are the same...</span> <span> - </span> <span class="display-name">Lane</span> <span> </span> <span class="date">20 Sep 2020 at 09:51</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>14</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Michael Borgwardt</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Jun 2010 at 07:53</span>
     </div>
    </div>
    <div>
     <p>The compiler wants you to write this:</p>
     <pre><code>private static List&lt;String&gt; list = new ArrayList&lt;String&gt;();
</code></pre>
     <p>because otherwise, you could add any type you like into <code>list</code>, making the instantiation as <code>new ArrayList&lt;String&gt;()</code> pointless. Java generics are a compile-time feature only, so an object created with <code>new ArrayList&lt;String&gt;()</code> will happily accept <code>Integer</code> or <code>JFrame</code> elements if assigned to a reference of the "raw type" <code>List</code> - the object itself knows nothing about what types it's supposed to contain, only the compiler does.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>14</span>
     </div>
     <div>
      <span>Answerer: </span> <span>GuyPaddock</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Dec 2017 at 04:49</span>
     </div>
    </div>
    <div>
     <p>Here's another case where raw types will bite you:</p>
     <pre><code>public class StrangeClass&lt;T&gt; {
  @SuppressWarnings("unchecked")
  public &lt;X&gt; X getSomethingElse() {
    return (X)"Testing something else!";
  }

  public static void main(String[] args) {
    final StrangeClass&lt;String&gt; withGeneric    = new StrangeClass&lt;&gt;();
    final StrangeClass         withoutGeneric = new StrangeClass();
    final String               value1,
                               value2;

    // Compiles
    value1 = withGeneric.getSomethingElse();

    // Produces compile error:
    // incompatible types: java.lang.Object cannot be converted to java.lang.String
    value2 = withoutGeneric.getSomethingElse();
  }
}
</code></pre>
     <p>This is counter-intuitive because you'd expect the raw type to only affect methods bound to the class type parameter, but it actually <em>also</em> affects generic methods with their own type parameters.</p>
     <p>As was mentioned in the accepted answer, you lose all support for generics within the code of the raw type. Every type parameter is converted to its erasure (which in the above example is just <code>Object</code>).</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>9</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Lars Andren</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 May 2010 at 04:44</span>
     </div>
    </div>
    <div>
     <p>A <em>raw</em>-type is the a lack of a <em>type parameter</em> when using a generic type.</p>
     <p>Raw-type should not be used because it could cause runtime errors, like inserting a <code>double</code> into what was supposed to be a <code>Set</code> of <code>int</code>s.</p>
     <pre><code>Set set = new HashSet();
set.add(3.45); //ok
</code></pre>
     <p>When retrieving the stuff from the <code>Set</code>, you don't know what is coming out. Let's assume that you expect it to be all <code>int</code>s, you are casting it to <code>Integer</code>; exception at runtime when the <code>double</code> 3.45 comes along.</p>
     <p>With a <em>type parameter</em> added to your <code>Set</code>, you will get a compile error at once. This preemptive error lets you fix the problem before something blows up during runtime (thus saving on time and effort).</p>
     <pre><code>Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();
set.add(3.45); //NOT ok.
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ashish</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Mar 2019 at 04:50</span>
     </div>
    </div>
    <div>
     <p><strong>Avoid raw types.</strong></p>
     <p>Raw types refer to using a generic type without specifying a type parameter.</p>
     <p>For example:</p>
     <p>A <code>list</code> is a raw type, while <code>List&lt;String&gt;</code> is a parameterized type.</p>
     <p>When generics were introduced in JDK 1.5, raw types were retained only to maintain backwards compatibility with older versions of Java.</p>
     <p>Although using raw types is still possible, they should be avoided:</p>
     <ul>
      <li>They usually require casts.</li>
      <li>They aren't type safe, and some important kinds of errors will only appear at runtime.</li>
      <li>They are less expressive, and don't self-document in the same way as parameterized types..</li>
     </ul>
     <p>Example:</p>
     <pre class="lang-java prettyprint-override"><code>import java.util.*;
public final class AvoidRawTypes {
    void withRawType() {
        //Raw List doesn't self-document, 
        //doesn't state explicitly what it can contain
        List stars = Arrays.asList("Arcturus", "Vega", "Altair");
        Iterator iter = stars.iterator();
        while (iter.hasNext()) {
            String star = (String) iter.next(); //cast needed
            log(star);
        }
    }

    void withParameterizedType() {
        List &lt; String &gt; stars = Arrays.asList("Spica", "Regulus", "Antares");
        for (String star: stars) {
            log(star);
        }
    }

    private void log(Object message) {
        System.out.println(Objects.toString(message));
    }
}
 
</code></pre>
     <p>For reference: <a href="https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html" rel="noreferrer">https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>pakore</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Jun 2010 at 07:47</span>
     </div>
    </div>
    <div>
     <p>What is saying is that your <code>list</code> is a <code>List</code> of unespecified objects. That is that Java does not know what kind of objects are inside the list. Then when you want to iterate the list you have to cast every element, to be able to access the properties of that element (in this case, String).</p>
     <p>In general is a better idea to parametrize the collections, so you don't have conversion problems, you will only be able to add elements of the parametrized type and your editor will offer you the appropiate methods to select.</p>
     <pre><code>private static List&lt;String&gt; list = new ArrayList&lt;String&gt;();
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mike</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 May 2016 at 13:42</span>
     </div>
    </div>
    <div>
     <p><a href="https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html" rel="nofollow noreferrer">tutorial page</a>.</p>
     <p>A raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:</p>
     <pre><code>public class Box&lt;T&gt; {
    public void set(T t) { /* ... */ }
    // ...
}
</code></pre>
     <p>To create a parameterized type of Box, you supply an actual type argument for the formal type parameter T:</p>
     <pre><code>Box&lt;Integer&gt; intBox = new Box&lt;&gt;();
</code></pre>
     <p>If the actual type argument is omitted, you create a raw type of Box:</p>
     <pre><code>Box rawBox = new Box();
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span> <span class="arrow"> <a href="#answer_15">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Alex Blasco</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Dec 2022 at 15:19</span>
     </div>
    </div>
    <div>
     <p>Just to synthesize a little bit: A raw type is a generic type without its type parameter (Example :&nbsp;<code>List</code>&nbsp;is the raw type of&nbsp;<code>List&lt;E&gt;</code>) Raw types shouldn't be used. They exist for compatibility with older versions of Java. We want to discover mistakes as soon as possible (compile time) and using raw types will probably result in error during runtime. We still need to use raw types in two cases :</p>
     <ul>
      <li>Usage of class literals (List.class)</li>
      <li>Usage of instanceof</li>
     </ul>
     <p>Examples :</p>
     <pre><code>//Use of raw type : don't !
private final Collection stamps = ...
stamps.add(new Coin(...)); //Erroneous insertion. Does not throw any error
Stamp s = (Stamp) stamps.get(i); // Throws ClassCastException when getting the Coin

//Common usage of instance of
if (o instanceof Set){
    Set&lt;?&gt; = (Set&lt;?&gt;) o;
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_15"><span>Answer 15</span> <span class="arrow"> <a href="#answer_14">↑</a> </span> <span class="arrow"> <a href="#answer_16">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user2442615</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Mar 2016 at 02:24</span>
     </div>
    </div>
    <div>
     <p>I found this page after doing some sample exercises and having the exact same puzzlement.</p>
     <p>============== I went from this code as provide by the sample ===============</p>
     <pre><code>public static void main(String[] args) throws IOException {

    Map wordMap = new HashMap();
    if (args.length &gt; 0) {
        for (int i = 0; i &lt; args.length; i++) {
            countWord(wordMap, args[i]);
        }
    } else {
        getWordFrequency(System.in, wordMap);
    }
    for (Iterator i = wordMap.entrySet().iterator(); i.hasNext();) {
        Map.Entry entry = (Map.Entry) i.next();
        System.out.println(entry.getKey() + " :\t" + entry.getValue());
    }
</code></pre>
     <p>====================== To This code ========================</p>
     <pre><code>public static void main(String[] args) throws IOException {
    // replace with TreeMap to get them sorted by name
    Map&lt;String, Integer&gt; wordMap = new HashMap&lt;String, Integer&gt;();
    if (args.length &gt; 0) {
        for (int i = 0; i &lt; args.length; i++) {
            countWord(wordMap, args[i]);
        }
    } else {
        getWordFrequency(System.in, wordMap);
    }
    for (Iterator&lt;Entry&lt;String, Integer&gt;&gt; i = wordMap.entrySet().iterator(); i.hasNext();) {
        Entry&lt;String, Integer&gt; entry =   i.next();
        System.out.println(entry.getKey() + " :\t" + entry.getValue());
    }

}
</code></pre>
     <p>===============================================================================</p>
     <p>It may be safer but took 4 hours to demuddle the philosophy...</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_16"><span>Answer 16</span> <span class="arrow"> <a href="#answer_15">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Stefan Reich</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Dec 2017 at 12:58</span>
     </div>
    </div>
    <div>
     <p>Raw types are fine when they express what you want to express.</p>
     <p>For example, a deserialisation function might return a <code>List</code>, but it doesn't know the list's element type. So <code>List</code> is the appropriate return type here.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>You can use ? as type parameter</span> <span> - </span> <span class="display-name">Dániel Kis</span> <span> </span> <span class="date">27 Dec 2017 at 19:29</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Yes, but that is more to type and I am against typing more. :)</span> <span> - </span> <span class="display-name">Stefan Reich</span> <span> </span> <span class="date">31 Dec 2017 at 18:37</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>