<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>How to go about formatting 1200 to 1.2k in java</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>How to go about formatting 1200 to 1.2k in java</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>189</span>
    </div>
    <div>
     <span>Asker: </span> <span>MatBanik</span>
    </div>
    <div>
     <span>Asked: </span> <span>20 Jan 2011 at 22:12</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/4753251/how-to-go-about-formatting-1200-to-1-2k-in-java">source</a>
    </div>
   </div>
   <div>
    <p>I'd like to format following numbers into the numbers next to them with java:</p>
    <pre><code>1000 to 1k
5821 to 5.8k
10500 to 10k
101800 to 101k
2000000 to 2m
7800000 to 7.8m
92150000 to 92m
123200000 to 123m
</code></pre>
    <p>The number on the right will be long or integer the number on the left will be string. How should I approach this. I already did little algorithm for this but I thought there might be already something invented out there that does nicer job at it and doesn't require additional testing if I start dealing with billions and trillions :)</p>
    <p>Additional Requirements:</p>
    <ul>
     <li>The format should have maximum of 4 characters</li>
     <li>The above means 1.1k is OK 11.2k is not. Same for 7.8m is OK 19.1m is not. Only one digit before decimal point is allowed to have decimal point. Two digits before decimal point means not digits after decimal point.</li>
     <li>No rounding is necessary. (Numbers being displayed with k and m appended are more of analog gauge indicating approximation not precise article of logic. Hence rounding is irrelevant mainly due to nature of variable than can increase or decrees several digits even while you are looking at the cached result.)</li>
    </ul>
   </div>
   <div class="tags">
    <span class="tag">java</span><span class="tag">number-formatting</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>1</td>
       <td><span></span> <span> - </span> <span class="display-name">Grammin</span> <span> </span> <span class="date">20 Jan 2011 at 22:15</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span></span> <span> - </span> <span class="display-name">rfeak</span> <span> </span> <span class="date">20 Jan 2011 at 22:22</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span></span> <span> - </span> <span class="display-name">jzd</span> <span> </span> <span class="date">21 Jan 2011 at 18:49</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span></span> <span> - </span> <span class="display-name">maraca</span> <span> </span> <span class="date">7 Jun 2015 at 11:49</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span></span> <span> - </span> <span class="display-name">Wolf</span> <span> </span> <span class="date">10 Jun 2015 at 10:17</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span></span> <span> - </span> <span class="display-name">Amos M. Carpenter</span> <span> </span> <span class="date">10 Jun 2015 at 15:03</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span></span> <span> - </span> <span class="display-name">Wolf</span> <span> </span> <span class="date">10 Jun 2015 at 15:29</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span></span> <span> - </span> <span class="display-name">MatBanik</span> <span> </span> <span class="date">10 Jun 2015 at 20:27</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span></span> <span> - </span> <span class="display-name">Wolf</span> <span> </span> <span class="date">11 Jun 2015 at 10:37</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span></span> <span> - </span> <span class="display-name">Ashav Kothari</span> <span> </span> <span class="date">15 May 2020 at 07:18</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span></span> <span> - </span> <span class="display-name">Richard Muvirimi</span> <span> </span> <span class="date">6 Apr 2021 at 09:18</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>187</span>
     </div>
     <div>
      <span>Answerer: </span> <span>assylias</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Jun 2015 at 08:07</span>
     </div>
    </div>
    <div>
     <p>Here is <em><strong>a solution that works for any long value</strong></em> and that I find quite readable (the core logic is done in the bottom three lines of the <code>format</code> method).</p>
     <p>It leverages <code>TreeMap</code> to find the appropriate suffix. It is surprisingly more efficient than a previous solution I wrote that was using arrays and was more difficult to read.</p>
     <pre><code>private static final NavigableMap&lt;Long, String&gt; suffixes = new TreeMap&lt;&gt; ();
static {
  suffixes.put(1_000L, "k");
  suffixes.put(1_000_000L, "M");
  suffixes.put(1_000_000_000L, "G");
  suffixes.put(1_000_000_000_000L, "T");
  suffixes.put(1_000_000_000_000_000L, "P");
  suffixes.put(1_000_000_000_000_000_000L, "E");
}

public static String format(long value) {
  //Long.MIN_VALUE == -Long.MIN_VALUE so we need an adjustment here
  if (value == Long.MIN_VALUE) return format(Long.MIN_VALUE + 1);
  if (value &lt; 0) return "-" + format(-value);
  if (value &lt; 1000) return Long.toString(value); //deal with easy case

  Entry&lt;Long, String&gt; e = suffixes.floorEntry(value);
  Long divideBy = e.getKey();
  String suffix = e.getValue();

  long truncated = value / (divideBy / 10); //the number part of the output times 10
  boolean hasDecimal = truncated &lt; 100 &amp;&amp; (truncated / 10d) != (truncated / 10);
  return hasDecimal ? (truncated / 10d) + suffix : (truncated / 10) + suffix;
}
</code></pre>
     <hr>
     <h2>Test code</h2>
     <pre><code>public static void main(String args[]) {
  long[] numbers = {0, 5, 999, 1_000, -5_821, 10_500, -101_800, 2_000_000, -7_800_000, 92_150_000, 123_200_000, 9_999_999, 999_999_999_999_999_999L, 1_230_000_000_000_000L, Long.MIN_VALUE, Long.MAX_VALUE};
  String[] expected = {"0", "5", "999", "1k", "-5.8k", "10k", "-101k", "2M", "-7.8M", "92M", "123M", "9.9M", "999P", "1.2P", "-9.2E", "9.2E"};
  for (int i = 0; i &lt; numbers.length; i++) {
    long n = numbers[i];
    String formatted = format(n);
    System.out.println(n + " =&gt; " + formatted);
    if (!formatted.equals(expected[i])) throw new AssertionError("Expected: " + expected[i] + " but found: " + formatted);
  }
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">Cypher</span> <span> </span> <span class="date">5 Jun 2015 at 18:40</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">std.denis</span> <span> </span> <span class="date">8 Jun 2015 at 16:29</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">assylias</span> <span> </span> <span class="date">8 Jun 2015 at 16:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">maraca</span> <span> </span> <span class="date">11 Jun 2015 at 17:24</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">assylias</span> <span> </span> <span class="date">11 Jun 2015 at 18:38</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">maraca</span> <span> </span> <span class="date">11 Jun 2015 at 18:52</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Chandu D</span> <span> </span> <span class="date">17 Jul 2015 at 09:19</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">assylias</span> <span> </span> <span class="date">17 Jul 2015 at 11:37</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">eyadMhanna</span> <span> </span> <span class="date">4 Apr 2016 at 13:23</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Satheesh</span> <span> </span> <span class="date">8 Apr 2018 at 14:54</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">user924</span> <span> </span> <span class="date">28 Jun 2018 at 18:14</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Craigo</span> <span> </span> <span class="date">21 May 2020 at 03:34</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Andre_601</span> <span> </span> <span class="date">26 Mar 2023 at 23:41</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>107</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ilya Saunkin</span>
     </div>
     <div>
      <span> Answered: </span> <span>20 Jan 2011 at 23:28</span>
     </div>
    </div>
    <div>
     <p>I know, this looks more like a C program, but it's super lightweight!</p>
     <pre><code>public static void main(String args[]) {
    long[] numbers = new long[]{1000, 5821, 10500, 101800, 2000000, 7800000, 92150000, 123200000, 9999999};
    for(long n : numbers) {
        System.out.println(n + " =&gt; " + coolFormat(n, 0));
    }
}

private static char[] c = new char[]{'k', 'm', 'b', 't'};

/**
 * Recursive implementation, invokes itself for each factor of a thousand, increasing the class on each invokation.
 * @param n the number to format
 * @param iteration in fact this is the class from the array c
 * @return a String representing the number n formatted in a cool looking way.
 */
private static String coolFormat(double n, int iteration) {
    double d = ((long) n / 100) / 10.0;
    boolean isRound = (d * 10) %10 == 0;//true if the decimal part is equal to 0 (then it's trimmed anyway)
    return (d &lt; 1000? //this determines the class, i.e. 'k', 'm' etc
        ((d &gt; 99.9 || isRound || (!isRound &amp;&amp; d &gt; 9.99)? //this decides whether to trim the decimals
         (int) d * 10 / 10 : d + "" // (int) d * 10 / 10 drops the decimal
         ) + "" + c[iteration]) 
        : coolFormat(d, iteration+1));

}
</code></pre>
     <p>It outputs:</p>
     <pre><code>1000 =&gt; 1k
5821 =&gt; 5.8k
10500 =&gt; 10k
101800 =&gt; 101k
2000000 =&gt; 2m
7800000 =&gt; 7.8m
92150000 =&gt; 92m
123200000 =&gt; 123m
9999999 =&gt; 9.9m
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Michael McGowan</span> <span> </span> <span class="date">20 Jan 2011 at 23:30</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Ilya Saunkin</span> <span> </span> <span class="date">20 Jan 2011 at 23:33</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span></span> <span> - </span> <span class="display-name">Gabe</span> <span> </span> <span class="date">20 Jan 2011 at 23:41</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Ilya Saunkin</span> <span> </span> <span class="date">20 Jan 2011 at 23:48</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Ilya Saunkin</span> <span> </span> <span class="date">21 Jan 2011 at 00:00</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">jzd</span> <span> </span> <span class="date">21 Jan 2011 at 01:55</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">Ilya Saunkin</span> <span> </span> <span class="date">21 Jan 2011 at 06:47</span></td>
       </tr>
       <tr>
        <td>18</td>
        <td><span></span> <span> - </span> <span class="display-name">Andreas Dolk</span> <span> </span> <span class="date">21 Jan 2011 at 07:10</span></td>
       </tr>
       <tr>
        <td>35</td>
        <td><span></span> <span> - </span> <span class="display-name">Ilya Saunkin</span> <span> </span> <span class="date">21 Jan 2011 at 07:20</span></td>
       </tr>
       <tr>
        <td>12</td>
        <td><span></span> <span> - </span> <span class="display-name">Henadzi Rabkin</span> <span> </span> <span class="date">10 Sep 2014 at 08:30</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">stanm</span> <span> </span> <span class="date">10 Sep 2014 at 12:33</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span></span> <span> - </span> <span class="display-name">Oliver Dixon</span> <span> </span> <span class="date">27 May 2015 at 12:23</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Ilya Saunkin</span> <span> </span> <span class="date">27 May 2015 at 12:43</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Roman Vottner</span> <span> </span> <span class="date">5 Jun 2015 at 02:07</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Paizo</span> <span> </span> <span class="date">9 Jun 2015 at 12:09</span></td>
       </tr>
       <tr>
        <td>8</td>
        <td><span></span> <span> - </span> <span class="display-name">Amos M. Carpenter</span> <span> </span> <span class="date">10 Jun 2015 at 05:16</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Amos M. Carpenter</span> <span> </span> <span class="date">10 Jun 2015 at 07:31</span></td>
       </tr>
       <tr>
        <td>13</td>
        <td><span></span> <span> - </span> <span class="display-name">Ilya Saunkin</span> <span> </span> <span class="date">10 Jun 2015 at 08:00</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">maraca</span> <span> </span> <span class="date">10 Jun 2015 at 11:31</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Johnny Willer</span> <span> </span> <span class="date">7 Nov 2015 at 00:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">AzizAhmad</span> <span> </span> <span class="date">23 Nov 2016 at 21:10</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Shifatul</span> <span> </span> <span class="date">21 Mar 2017 at 01:40</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>45</span>
     </div>
     <div>
      <span>Answerer: </span> <span>jzd</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Jan 2011 at 01:53</span>
     </div>
    </div>
    <div>
     <p>Here a solution that makes use of DecimalFormat's engineering notation:</p>
     <pre><code>public static void main(String args[]) {
    long[] numbers = new long[]{7, 12, 856, 1000, 5821, 10500, 101800, 2000000, 7800000, 92150000, 123200000, 9999999};
    for(long number : numbers) {
        System.out.println(number + " = " + format(number));
    }
}

private static String[] suffix = new String[]{"","k", "m", "b", "t"};
private static int MAX_LENGTH = 4;

private static String format(double number) {
    String r = new DecimalFormat("##0E0").format(number);
    r = r.replaceAll("E[0-9]", suffix[Character.getNumericValue(r.charAt(r.length() - 1)) / 3]);
    while(r.length() &gt; MAX_LENGTH || r.matches("[0-9]+\\.[a-z]")){
        r = r.substring(0, r.length()-2) + r.substring(r.length() - 1);
    }
    return r;
}
</code></pre>
     <p>Output:</p>
     <pre><code>7 = 7
12 = 12
856 = 856
1000 = 1k
5821 = 5.8k
10500 = 10k
101800 = 102k
2000000 = 2m
7800000 = 7.8m
92150000 = 92m
123200000 = 123m
9999999 = 10m
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">jzd</span> <span> </span> <span class="date">21 Jan 2011 at 02:24</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">xdumaine</span> <span> </span> <span class="date">3 Nov 2011 at 13:10</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">jzd</span> <span> </span> <span class="date">8 Nov 2011 at 12:45</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">ernazm</span> <span> </span> <span class="date">26 Jun 2013 at 13:55</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">jzd</span> <span> </span> <span class="date">4 Nov 2013 at 14:00</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">SpaceTrucker</span> <span> </span> <span class="date">4 Nov 2013 at 14:08</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">jzd</span> <span> </span> <span class="date">4 Nov 2013 at 14:32</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span></span> <span> - </span> <span class="display-name">k1komans</span> <span> </span> <span class="date">17 Jan 2014 at 20:32</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Joakim Lundborg</span> <span> </span> <span class="date">5 Feb 2014 at 22:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">race_carr</span> <span> </span> <span class="date">29 May 2014 at 03:28</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Dónal</span> <span> </span> <span class="date">22 Jul 2014 at 17:09</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">jzd</span> <span> </span> <span class="date">6 Aug 2014 at 13:24</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span></span> <span> - </span> <span class="display-name">Oliver Dixon</span> <span> </span> <span class="date">27 May 2015 at 12:36</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>24</span>
     </div>
     <div>
      <span>Answerer: </span> <span>jhurtado</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Jan 2011 at 00:30</span>
     </div>
    </div>
    <div>
     <p>Need some improvement, but: StrictMath to the rescue!<br>
       You can put the suffix in a String or array and fetch'em based on power, or something like that.<br>
       The division can also be managed around the power, i think almost everything is about the power value. Hope it helps!</p>
     <pre><code>public static String formatValue(double value) {
int power; 
    String suffix = " kmbt";
    String formattedNumber = "";

    NumberFormat formatter = new DecimalFormat("#,###.#");
    power = (int)StrictMath.log10(value);
    value = value/(Math.pow(10,(power/3)*3));
    formattedNumber=formatter.format(value);
    formattedNumber = formattedNumber + suffix.charAt(power/3);
    return formattedNumber.length()&gt;4 ?  formattedNumber.replaceAll("\\.[0-9]+", "") : formattedNumber;  
}
</code></pre>
     <p>outputs:</p>
     <blockquote>
      <p>999<br>
        1.2k<br>
        98k<br>
        911k<br>
        1.1m<br>
        11b<br>
        712b<br>
        34t</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span></span> <span> - </span> <span class="display-name">jhurtado</span> <span> </span> <span class="date">21 Jan 2011 at 05:13</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Joakim Lundborg</span> <span> </span> <span class="date">5 Feb 2014 at 22:53</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span></span> <span> - </span> <span class="display-name">assylias</span> <span> </span> <span class="date">5 Jun 2015 at 08:03</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>24</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Naman</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Jan 2019 at 13:00</span>
     </div>
    </div>
    <div>
     <p>With <strong>Java-12 +</strong>, you can use <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/text/NumberFormat.html#getCompactNumberInstance(java.util.Locale,java.text.NumberFormat.Style)" rel="noreferrer"><code>NumberFormat.getCompactNumberInstance</code></a> to format the numbers. You can create a <code>NumberFormat</code> first as</p>
     <pre><code>NumberFormat fmt = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT);
</code></pre>
     <p>and then use it to <code>format</code>:</p>
     <blockquote>
      <pre><code>fmt.format(1000)
$5 ==&gt; "1K"

fmt.format(10000000)
$9 ==&gt; "10M"

fmt.format(1000000000)
$11 ==&gt; "1B"
</code></pre>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">eos1d3</span> <span> </span> <span class="date">10 Jul 2022 at 16:54</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>17</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Dónal</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Jul 2014 at 13:47</span>
     </div>
    </div>
    <div>
     <h2>Problems with Current Answers</h2>
     <ul>
      <li>Many of the current solutions are using these prefixes k=10<sup>3</sup>, m=10<sup>6</sup>, b=10<sup>9</sup>, t=10<sup>12</sup>. However, according to <a href="http://physics.nist.gov/cuu/Units/prefixes.html" rel="nofollow noreferrer">various</a> <a href="http://en.wikipedia.org/wiki/Metric_prefix#List_of_SI_prefixes" rel="nofollow noreferrer">sources</a>, the correct prefixes are k=10<sup>3</sup>, M=10<sup>6</sup>, G=10<sup>9</sup>, T=10<sup>12</sup></li>
      <li>Lack of support for negative numbers (or at least a lack of tests demonstrating that negative numbers are supported)</li>
      <li>Lack of support for the inverse operation, e.g. converting 1.1k to 1100 (though this is outside the scope of the original question)</li>
     </ul>
     <h2>Java Solution</h2>
     <p>This solution (an extension of <a href="https://stackoverflow.com/a/4754692/2648">this answer</a>) addresses the above issues.</p>
     <pre><code>import org.apache.commons.lang.math.NumberUtils;

import java.text.DecimalFormat;
import java.text.FieldPosition;
import java.text.Format;
import java.text.ParsePosition;
import java.util.regex.Pattern;


/**
 * Converts a number to a string in &lt;a href="http://en.wikipedia.org/wiki/Metric_prefix"&gt;metric prefix&lt;/a&gt; format.
 * For example, 7800000 will be formatted as '7.8M'. Numbers under 1000 will be unchanged. Refer to the tests for further examples.
 */
class RoundedMetricPrefixFormat extends Format {

    private static final String[] METRIC_PREFIXES = new String[]{"", "k", "M", "G", "T"};

    /**
     * The maximum number of characters in the output, excluding the negative sign
     */
    private static final Integer MAX_LENGTH = 4;

    private static final Pattern TRAILING_DECIMAL_POINT = Pattern.compile("[0-9]+\\.[kMGT]");

    private static final Pattern METRIC_PREFIXED_NUMBER = Pattern.compile("\\-?[0-9]+(\\.[0-9])?[kMGT]");

    @Override
    public StringBuffer format(Object obj, StringBuffer output, FieldPosition pos) {

        Double number = Double.valueOf(obj.toString());

        // if the number is negative, convert it to a positive number and add the minus sign to the output at the end
        boolean isNegative = number &lt; 0;
        number = Math.abs(number);

        String result = new DecimalFormat("##0E0").format(number);

        Integer index = Character.getNumericValue(result.charAt(result.length() - 1)) / 3;
        result = result.replaceAll("E[0-9]", METRIC_PREFIXES[index]);

        while (result.length() &gt; MAX_LENGTH || TRAILING_DECIMAL_POINT.matcher(result).matches()) {
            int length = result.length();
            result = result.substring(0, length - 2) + result.substring(length - 1);
        }

        return output.append(isNegative ? "-" + result : result);
    }

    /**
     * Convert a String produced by &lt;tt&gt;format()&lt;/tt&gt; back to a number. This will generally not restore
     * the original number because &lt;tt&gt;format()&lt;/tt&gt; is a lossy operation, e.g.
     *
     * &lt;pre&gt;
     * {@code
     * def formatter = new RoundedMetricPrefixFormat()
     * Long number = 5821L
     * String formattedNumber = formatter.format(number)
     * assert formattedNumber == '5.8k'
     *
     * Long parsedNumber = formatter.parseObject(formattedNumber)
     * assert parsedNumber == 5800
     * assert parsedNumber != number
     * }
     * &lt;/pre&gt;
     *
     * @param source a number that may have a metric prefix
     * @param pos if parsing succeeds, this should be updated to the index after the last parsed character
     * @return a Number if the the string is a number without a metric prefix, or a Long if it has a metric prefix
     */
    @Override
    public Object parseObject(String source, ParsePosition pos) {

        if (NumberUtils.isNumber(source)) {

            // if the value is a number (without a prefix) don't return it as a Long or we'll lose any decimals
            pos.setIndex(source.length());
            return toNumber(source);

        } else if (METRIC_PREFIXED_NUMBER.matcher(source).matches()) {

            boolean isNegative = source.charAt(0) == '-';
            int length = source.length();

            String number = isNegative ? source.substring(1, length - 1) : source.substring(0, length - 1);
            String metricPrefix = Character.toString(source.charAt(length - 1));

            Number absoluteNumber = toNumber(number);

            int index = 0;

            for (; index &lt; METRIC_PREFIXES.length; index++) {
                if (METRIC_PREFIXES[index].equals(metricPrefix)) {
                    break;
                }
            }

            Integer exponent = 3 * index;
            Double factor = Math.pow(10, exponent);
            factor *= isNegative ? -1 : 1;

            pos.setIndex(source.length());
            Float result = absoluteNumber.floatValue() * factor.longValue();
            return result.longValue();
        }

        return null;
    }

    private static Number toNumber(String number) {
        return NumberUtils.createNumber(number);
    }
}
</code></pre>
     <h2>Groovy Solution</h2>
     <p>The solution was originally written in Groovy as shown below.</p>
     <pre><code>import org.apache.commons.lang.math.NumberUtils

import java.text.DecimalFormat
import java.text.FieldPosition
import java.text.Format
import java.text.ParsePosition
import java.util.regex.Pattern


/**
 * Converts a number to a string in &lt;a href="http://en.wikipedia.org/wiki/Metric_prefix"&gt;metric prefix&lt;/a&gt; format.
 * For example, 7800000 will be formatted as '7.8M'. Numbers under 1000 will be unchanged. Refer to the tests for further examples.
 */
class RoundedMetricPrefixFormat extends Format {

    private static final METRIC_PREFIXES = ["", "k", "M", "G", "T"]

    /**
     * The maximum number of characters in the output, excluding the negative sign
     */
    private static final Integer MAX_LENGTH = 4

    private static final Pattern TRAILING_DECIMAL_POINT = ~/[0-9]+\.[kMGT]/

    private static final Pattern METRIC_PREFIXED_NUMBER = ~/\-?[0-9]+(\.[0-9])?[kMGT]/

    @Override
    StringBuffer format(Object obj, StringBuffer output, FieldPosition pos) {

        Double number = obj as Double

        // if the number is negative, convert it to a positive number and add the minus sign to the output at the end
        boolean isNegative = number &lt; 0
        number = Math.abs(number)

        String result = new DecimalFormat("##0E0").format(number)

        Integer index = Character.getNumericValue(result.charAt(result.size() - 1)) / 3
        result = result.replaceAll("E[0-9]", METRIC_PREFIXES[index])

        while (result.size() &gt; MAX_LENGTH || TRAILING_DECIMAL_POINT.matcher(result).matches()) {
            int length = result.size()
            result = result.substring(0, length - 2) + result.substring(length - 1)
        }

        output &lt;&lt; (isNegative ? "-$result" : result)
    }

    /**
     * Convert a String produced by &lt;tt&gt;format()&lt;/tt&gt; back to a number. This will generally not restore
     * the original number because &lt;tt&gt;format()&lt;/tt&gt; is a lossy operation, e.g.
     *
     * &lt;pre&gt;
     * {@code
     * def formatter = new RoundedMetricPrefixFormat()
     * Long number = 5821L
     * String formattedNumber = formatter.format(number)
     * assert formattedNumber == '5.8k'
     *
     * Long parsedNumber = formatter.parseObject(formattedNumber)
     * assert parsedNumber == 5800
     * assert parsedNumber != number
     * }
     * &lt;/pre&gt;
     *
     * @param source a number that may have a metric prefix
     * @param pos if parsing succeeds, this should be updated to the index after the last parsed character
     * @return a Number if the the string is a number without a metric prefix, or a Long if it has a metric prefix
     */
    @Override
    Object parseObject(String source, ParsePosition pos) {

        if (source.isNumber()) {

            // if the value is a number (without a prefix) don't return it as a Long or we'll lose any decimals
            pos.index = source.size()
            toNumber(source)

        } else if (METRIC_PREFIXED_NUMBER.matcher(source).matches()) {

            boolean isNegative = source[0] == '-'

            String number = isNegative ? source[1..-2] : source[0..-2]
            String metricPrefix = source[-1]

            Number absoluteNumber = toNumber(number)

            Integer exponent = 3 * METRIC_PREFIXES.indexOf(metricPrefix)
            Long factor = 10 ** exponent
            factor *= isNegative ? -1 : 1

            pos.index = source.size()
            (absoluteNumber * factor) as Long
        }
    }

    private static Number toNumber(String number) {
        NumberUtils.createNumber(number)
    }
}
</code></pre>
     <h2>Tests (Groovy)</h2>
     <p>The tests are written in Groovy but can be used to verify either either the Java or Groovy class (because they both have the same name and API).</p>
     <pre><code>import java.text.Format
import java.text.ParseException

class RoundedMetricPrefixFormatTests extends GroovyTestCase {

    private Format roundedMetricPrefixFormat = new RoundedMetricPrefixFormat()

    void testNumberFormatting() {

        [
                7L         : '7',
                12L        : '12',
                856L       : '856',
                1000L      : '1k',
                (-1000L)   : '-1k',
                5821L      : '5.8k',
                10500L     : '10k',
                101800L    : '102k',
                2000000L   : '2M',
                7800000L   : '7.8M',
                (-7800000L): '-7.8M',
                92150000L  : '92M',
                123200000L : '123M',
                9999999L   : '10M',
                (-9999999L): '-10M'
        ].each { Long rawValue, String expectedRoundValue -&gt;

            assertEquals expectedRoundValue, roundedMetricPrefixFormat.format(rawValue)
        }
    }

    void testStringParsingSuccess() {
        [
                '7'    : 7,
                '8.2'  : 8.2F,
                '856'  : 856,
                '-856' : -856,
                '1k'   : 1000,
                '5.8k' : 5800,
                '-5.8k': -5800,
                '10k'  : 10000,
                '102k' : 102000,
                '2M'   : 2000000,
                '7.8M' : 7800000L,
                '92M'  : 92000000L,
                '-92M' : -92000000L,
                '123M' : 123000000L,
                '10M'  : 10000000L

        ].each { String metricPrefixNumber, Number expectedValue -&gt;

            def parsedNumber = roundedMetricPrefixFormat.parseObject(metricPrefixNumber)
            assertEquals expectedValue, parsedNumber
        }
    }

    void testStringParsingFail() {

        shouldFail(ParseException) {
            roundedMetricPrefixFormat.parseObject('notNumber')
        }
    }
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">jhurtado</span> <span> </span> <span class="date">24 Sep 2014 at 20:17</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">assylias</span> <span> </span> <span class="date">5 Jun 2015 at 08:15</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">gbmhunter</span> <span> </span> <span class="date">25 Mar 2016 at 09:08</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>17</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Linh</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Oct 2018 at 06:12</span>
     </div>
    </div>
    <div>
     <p>My function for convert big number to small number (with 2 digits). You can change the number of digits by change <code>#.##</code> in <code>DecimalFormat</code></p>
     <pre><code>public String formatValue(float value) {
    String arr[] = {"", "K", "M", "B", "T", "P", "E"};
    int index = 0;
    while ((value / 1000) &gt;= 1) {
        value = value / 1000;
        index++;
    }
    DecimalFormat decimalFormat = new DecimalFormat("#.##");
    return String.format("%s %s", decimalFormat.format(value), arr[index]);
}
</code></pre>
     <p><strong>Testing</strong></p>
     <pre><code>System.out.println(formatValue(100));     //  100
System.out.println(formatValue(1000));    // 1 K
System.out.println(formatValue(10345));   // 10.35 K
System.out.println(formatValue(10012));   // 10.01 K
System.out.println(formatValue(123456));  // 123.46 K
System.out.println(formatValue(4384324)); // 4.38 M
System.out.println(formatValue(10000000)); // 10 M
System.out.println(formatValue(Long.MAX_VALUE)); // 9.22 E
</code></pre>
     <p>Hope it help</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Kl3jvi</span> <span> </span> <span class="date">28 Apr 2021 at 15:13</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Harry T.</span> <span> </span> <span class="date">16 Dec 2021 at 07:17</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>14</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Landei</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Apr 2011 at 07:13</span>
     </div>
    </div>
    <div>
     <p>The <a href="http://site.icu-project.org/" rel="noreferrer">ICU lib</a> has a rule based formatter for numbers, which can be used for number spellout etc. I think using ICU would give you a readable and maintanable solution.</p>
     <p><strong>[Usage]</strong></p>
     <p>The right class is RuleBasedNumberFormat. The format itself can be stored as separate file (or as String constant, IIRC).</p>
     <p>Example from <a href="http://userguide.icu-project.org/formatparse/numbers" rel="noreferrer">http://userguide.icu-project.org/formatparse/numbers</a></p>
     <pre><code>double num = 2718.28;
NumberFormat formatter = 
    new RuleBasedNumberFormat(RuleBasedNumberFormat.SPELLOUT);
String result = formatter.format(num);
System.out.println(result);
</code></pre>
     <p>The same page shows Roman numerals, so I guess your case should be possible, too.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Grozz</span> <span> </span> <span class="date">23 Feb 2018 at 12:57</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span></span> <span> - </span> <span class="display-name">Gokhan Arik</span> <span> </span> <span class="date">10 Jul 2019 at 01:41</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">lasec0203</span> <span> </span> <span class="date">3 Nov 2020 at 07:01</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>9</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Raniz</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Jun 2015 at 03:14</span>
     </div>
    </div>
    <div>
     <p>Here's a short implementation without recursion and just a very small loop. Doesn't work with negative numbers but supports all positive <code>long</code>s up to <code>Long.MAX_VALUE</code>:</p>
     <pre><code>private static final char[] SUFFIXES = {'k', 'm', 'g', 't', 'p', 'e' };

public static String format(long number) {
    if(number &lt; 1000) {
        // No need to format this
        return String.valueOf(number);
    }
    // Convert to a string
    final String string = String.valueOf(number);
    // The suffix we're using, 1-based
    final int magnitude = (string.length() - 1) / 3;
    // The number of digits we must show before the prefix
    final int digits = (string.length() - 1) % 3 + 1;

    // Build the string
    char[] value = new char[4];
    for(int i = 0; i &lt; digits; i++) {
        value[i] = string.charAt(i);
    }
    int valueLength = digits;
    // Can and should we add a decimal point and an additional number?
    if(digits == 1 &amp;&amp; string.charAt(1) != '0') {
        value[valueLength++] = '.';
        value[valueLength++] = string.charAt(1);
    }
    value[valueLength++] = SUFFIXES[magnitude - 1];
    return new String(value, 0, valueLength);
}
</code></pre>
     <p>Outputs:</p>
     <blockquote>
      <p>1k<br>
        5.8k<br>
        10k<br>
        101k<br>
        2m<br>
        7.8m<br>
        92m<br>
        123m<br>
        9.2e (this is <code>Long.MAX_VALUE</code>)</p>
     </blockquote>
     <p>I also did some really simple benchmarking (formatting 10 million random longs) and it's considerably faster than Elijah's implementation and slightly faster than assylias' implementation.</p>
     <blockquote>
      <p>Mine: 1137.028 ms<br>
        Elijah's: 2664.396 ms<br>
        assylias': 1373.473 ms</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">Sufian</span> <span> </span> <span class="date">23 Sep 2015 at 07:40</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span></span> <span> - </span> <span class="display-name">Raniz</span> <span> </span> <span class="date">23 Sep 2015 at 13:36</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>maraca</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Jun 2015 at 00:09</span>
     </div>
    </div>
    <div>
     <p><strong>Important:</strong> Answers casting to <code>double</code> will fail for numbers like <code>99999999999999999L</code> and return <code>100P</code> instead of <code>99P</code> because <code>double</code> uses the <a href="http://en.wikipedia.org/wiki/Double-precision_floating-point_format" rel="noreferrer"><code>IEEE</code> standard</a>:</p>
     <blockquote>
      <p>If a decimal string with <em>at most 15 significant digits</em> is converted to IEEE 754 double precision representation and then converted back to a string with the same number of significant digits, then the final string should match the original. [<code>long</code> has <em>up to 19 significant digits</em>.]</p>
     </blockquote>
     <pre><code>System.out.println((long)(double)99999999999999992L); // 100000000000000000
System.out.println((long)(double)99999999999999991L); //  99999999999999984
// it is even worse for the logarithm:
System.out.println(Math.log10(99999999999999600L)); // 17.0
System.out.println(Math.log10(99999999999999500L)); // 16.999999999999996
</code></pre>
     <hr>
     <p><strong>This solution cuts off unwanted digits and works for all <code>long</code> values</strong>. Simple but performant implementation (comparison below). -120k can't be expressed with 4 characters, even -0.1M is too long, that's why for negative numbers 5 characters have to be okay:</p>
     <pre><code>private static final char[] magnitudes = {'k', 'M', 'G', 'T', 'P', 'E'}; // enough for long

public static final String convert(long number) {
    String ret;
    if (number &gt;= 0) {
        ret = "";
    } else if (number &lt;= -9200000000000000000L) {
        return "-9.2E";
    } else {
        ret = "-";
        number = -number;
    }
    if (number &lt; 1000)
        return ret + number;
    for (int i = 0; ; i++) {
        if (number &lt; 10000 &amp;&amp; number % 1000 &gt;= 100)
            return ret + (number / 1000) + '.' + ((number % 1000) / 100) + magnitudes[i];
        number /= 1000;
        if (number &lt; 1000)
            return ret + number + magnitudes[i];
    }
}
</code></pre>
     <p>The test in the <code>else if</code> at the beginning is necessairy because the min is <code>-(2^63)</code> and the max is <code>(2^63)-1</code> and therefore the assignment <code>number = -number</code> would fail if <code>number == Long.MIN_VALUE</code>. If we have to do a check, then we can as well include as many numbers as possible instead of just checking for <code>number == Long.MIN_VALUE</code>.</p>
     <p>The comparison of this implementation with the one who got the most upvotes (said to be the fastest currently) showed that it is <strong>more than 5 times faster</strong> (it depends on the test settings, but with more numbers the gain gets bigger and this implementation has to do more checks because it handles all cases, so if the other one would be fixed the difference would become even bigger). It is that fast because there are no floating point operations, no logarithm, no power, no recursion, no regex, no sophisticated formatters and minimization of the amount of objects created.</p>
     <hr>
     <p>Here is the test program:</p>
     <pre><code>public class Test {

    public static void main(String[] args) {
        long[] numbers = new long[20000000];
        for (int i = 0; i &lt; numbers.length; i++)
            numbers[i] = Math.random() &lt; 0.5 ? (long) (Math.random() * Long.MAX_VALUE) : (long) (Math.random() * Long.MIN_VALUE);
        System.out.println(convert1(numbers) + " vs. " + convert2(numbers));
    }

    private static long convert1(long[] numbers) {
        long l = System.currentTimeMillis();
        for (int i = 0; i &lt; numbers.length; i++)
            Converter1.convert(numbers[i]);
        return System.currentTimeMillis() - l;
    }

    private static long convert2(long[] numbers) {
        long l = System.currentTimeMillis();
        for (int i = 0; i &lt; numbers.length; i++)
            Converter2.coolFormat(numbers[i], 0);
        return System.currentTimeMillis() - l;
    }

}
</code></pre>
     <p>Possible output: <code>2309 vs. 11591</code> (about the same when only using positive numbers and much more extreme when reversing the order of execution, maybe it has something to do with garbage collection)</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Chris</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Jun 2016 at 21:02</span>
     </div>
    </div>
    <div>
     <p>For anyone that wants to round. This is a great, easy to read solution, that takes advantage of the Java.Lang.Math library</p>
     <pre><code> public static String formatNumberExample(Number number) {
        char[] suffix = {' ', 'k', 'M', 'B', 'T', 'P', 'E'};
        long numValue = number.longValue();
        int value = (int) Math.floor(Math.log10(numValue));
        int base = value / 3;
        if (value &gt;= 3 &amp;&amp; base &lt; suffix.length) {
            return new DecimalFormat("~#0.0").format(numValue / Math.pow(10, base * 3)) + suffix[base];
        } else {
            return new DecimalFormat("#,##0").format(numValue);
        }
    }
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Eduardo Aviles</span>
     </div>
     <div>
      <span> Answered: </span> <span>19 Nov 2013 at 21:53</span>
     </div>
    </div>
    <div>
     <p>I don't know if it's the best approach but, this is what i did.</p>
     <pre><code>7=&gt;7
12=&gt;12
856=&gt;856
1000=&gt;1.0k
5821=&gt;5.82k
10500=&gt;10.5k
101800=&gt;101.8k
2000000=&gt;2.0m
7800000=&gt;7.8m
92150000=&gt;92.15m
123200000=&gt;123.2m
9999999=&gt;10.0m
</code></pre>
     <p>--- Code---</p>
     <pre><code>public String Format(Integer number){
    String[] suffix = new String[]{"k","m","b","t"};
    int size = (number.intValue() != 0) ? (int) Math.log10(number) : 0;
    if (size &gt;= 3){
        while (size % 3 != 0) {
            size = size - 1;
        }
    }
    double notation = Math.pow(10, size);
    String result = (size &gt;= 3) ? + (Math.round((number / notation) * 100) / 100.0d)+suffix[(size/3) - 1] : + number + "";
    return result
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>paxdiablo</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Jun 2015 at 03:57</span>
     </div>
    </div>
    <div>
     <p>The following code shows how you can do this with easy expansion in mind.</p>
     <p>The "magic" lies mostly in the <code>makeDecimal</code> function which, for the correct values passed in, guarantees you will never have more than four characters in the output.</p>
     <p>It first extracts the whole and tenths portions for a given divisor so, for example, <code>12,345,678</code> with a divisor of <code>1,000,000</code> will give a <code>whole</code> value of <code>12</code> and a <code>tenths</code> value of <code>3</code>.</p>
     <p>From that, it can decide whether it outputs just the whole part or both the whole and tenths part, using the rules:</p>
     <ul>
      <li>If tenths part is zero, just output whole part and suffix.</li>
      <li>If whole part is greater than nine, just output whole part and suffix.</li>
      <li>Otherwise, output whole part, tenths part and suffix.</li>
     </ul>
     <p>The code for that follows:</p>
     <pre><code>static private String makeDecimal(long val, long div, String sfx) {
    val = val / (div / 10);
    long whole = val / 10;
    long tenths = val % 10;
    if ((tenths == 0) || (whole &gt;= 10))
        return String.format("%d%s", whole, sfx);
    return String.format("%d.%d%s", whole, tenths, sfx);
}
</code></pre>
     <p>Then, it's a simple matter of calling that helper function with the correct values, including some constants to make life easier for the developer:</p>
     <pre><code>static final long THOU =                1000L;
static final long MILL =             1000000L;
static final long BILL =          1000000000L;
static final long TRIL =       1000000000000L;
static final long QUAD =    1000000000000000L;
static final long QUIN = 1000000000000000000L;

static private String Xlat(long val) {
    if (val &lt; THOU) return Long.toString(val);
    if (val &lt; MILL) return makeDecimal(val, THOU, "k");
    if (val &lt; BILL) return makeDecimal(val, MILL, "m");
    if (val &lt; TRIL) return makeDecimal(val, BILL, "b");
    if (val &lt; QUAD) return makeDecimal(val, TRIL, "t");
    if (val &lt; QUIN) return makeDecimal(val, QUAD, "q");
    return makeDecimal(val, QUIN, "u");
}
</code></pre>
     <p>The fact that the <code>makeDecimal</code> function does the grunt work means that expanding beyond <code>999,999,999</code> is just a matter of adding an extra line to <code>Xlat</code>, so easy that I've done it for you.</p>
     <p>The final <code>return</code> in <code>Xlat</code> doesn't need a conditional since the largest value you can hold in a 64-bit signed long is only about 9.2 quintillion.</p>
     <p>But if, by some bizarre requirement, Oracle decides to add a 128-bit <code>longer</code> type or a 1024-bit <code>damn_long</code> type, you'll be ready for it :-)</p>
     <hr>
     <p>And, finally, a little test harness you can use for validating the functionality.</p>
     <pre><code>public static void main(String[] args) {
    long vals[] = {
        999L, 1000L, 5821L, 10500L, 101800L, 2000000L,
        7800000L, 92150000L, 123200000L, 999999999L,
        1000000000L, 1100000000L, 999999999999L,
        1000000000000L, 999999999999999L,
        1000000000000000L, 9223372036854775807L
    };
    for (long val: vals)
        System.out.println ("" + val + " -&gt; " + Xlat(val));
    }
}
</code></pre>
     <p>You can see from the output that it gives you what you need:</p>
     <pre><code>999 -&gt; 999
1000 -&gt; 1k
5821 -&gt; 5.8k
10500 -&gt; 10k
101800 -&gt; 101k
2000000 -&gt; 2m
7800000 -&gt; 7.8m
92150000 -&gt; 92m
123200000 -&gt; 123m
999999999 -&gt; 999m
1000000000 -&gt; 1b
1100000000 -&gt; 1.1b
999999999999 -&gt; 999b
1000000000000 -&gt; 1t
999999999999999 -&gt; 999t
1000000000000000 -&gt; 1q
9223372036854775807 -&gt; 9.2u
</code></pre>
     <hr>
     <blockquote>
      <p>And, as an aside, be aware that passing in a negative number to this function will result in a string too long for your requirements, since it follows the <code>&lt; THOU</code> path). I figured that was okay since you only mention non-negative values in the question.</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span> <span class="arrow"> <a href="#answer_15">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ebrahim sadeghi</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Nov 2018 at 14:11</span>
     </div>
    </div>
    <div>
     <p>this is my code. clean and simple .</p>
     <pre><code>public static String getRoughNumber(long value) {
    if (value &lt;= 999) {
        return String.valueOf(value);
    }

    final String[] units = new String[]{"", "K", "M", "B", "P"};
    int digitGroups = (int) (Math.log10(value) / Math.log10(1000));
    return new DecimalFormat("#,##0.#").format(value / Math.pow(1000, digitGroups)) + "" + units[digitGroups];

}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_15"><span>Answer 15</span> <span class="arrow"> <a href="#answer_14">↑</a> </span> <span class="arrow"> <a href="#answer_16">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user565869</span>
     </div>
     <div>
      <span> Answered: </span> <span>20 Jan 2011 at 22:30</span>
     </div>
    </div>
    <div>
     <p>My Java is rusty, but here's how I'd implement it in C#:</p>
     <pre><code>private string  FormatNumber(double value)
    {
    string[]  suffixes = new string[] {" k", " m", " b", " t", " q"};
    for (int j = suffixes.Length;  j &gt; 0;  j--)
        {
        double  unit = Math.Pow(1000, j);
        if (value &gt;= unit)
            return (value / unit).ToString("#,##0.0") + suffixes[--j];
        }
    return value.ToString("#,##0");
    }
</code></pre>
     <p>It'd be easy to adjust this to use CS kilos (1,024) rather than metric kilos, or to add more units. It formats 1,000 as "1.0 k" rather than "1 k", but I trust that's immaterial.</p>
     <p>To meet the more specific requirement "no more than four characters", remove the spaces before the suffixes and adjust the middle block like this:</p>
     <pre><code>if (value &gt;= unit)
  {
  value /= unit;
  return (value).ToString(value &gt;= unit * 9.95 ? "#,##0" : "#,##0.0") + suffixes[--j];
  }
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">assylias</span> <span> </span> <span class="date">5 Jun 2015 at 07:59</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">vin shaba</span> <span> </span> <span class="date">6 Nov 2020 at 12:08</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_16"><span>Answer 16</span> <span class="arrow"> <a href="#answer_15">↑</a> </span> <span class="arrow"> <a href="#answer_17">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>stefan bachert</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 May 2012 at 14:08</span>
     </div>
    </div>
    <div>
     <p>My favorite. You could use "k" and so on as indicator for decimal too, as common in the electronic domain. This will give you an extra digit without additional space</p>
     <p>Second column tries to use as much digits as possible</p>
     <pre><code>1000 =&gt; 1.0k | 1000
5821 =&gt; 5.8k | 5821
10500 =&gt; 10k | 10k5
101800 =&gt; 101k | 101k
2000000 =&gt; 2.0m | 2m
7800000 =&gt; 7.8m | 7m8
92150000 =&gt; 92m | 92m1
123200000 =&gt; 123m | 123m
9999999 =&gt; 9.9m | 9m99
</code></pre>
     <p>This is the code</p>
     <pre><code>public class HTTest {
private static String[] unit = {"u", "k", "m", "g", "t"};
/**
 * @param args
 */
public static void main(String[] args) {
    int[] numbers = new int[]{1000, 5821, 10500, 101800, 2000000, 7800000, 92150000, 123200000, 9999999};
    for(int n : numbers) {
        System.out.println(n + " =&gt; " + myFormat(n) + " | " + myFormat2(n));
    }
}

private static String myFormat(int pN) {
    String str = Integer.toString(pN);
    int len = str.length ()-1;
    if (len &lt;= 3) return str;
    int level = len / 3;
    int mode = len % 3;
    switch (mode) {
    case 0: return str.substring(0, 1) + "." + str.substring(1, 2) + unit[level];
    case 1: return str.substring(0, 2) + unit[level];
    case 2: return str.substring(0, 3) + unit[level];
    }
    return "how that?";
}
private static String trim1 (String pVal) {
    if (pVal.equals("0")) return "";
    return pVal;
}
private static String trim2 (String pVal) {
    if (pVal.equals("00")) return "";
    return pVal.substring(0, 1) + trim1(pVal.substring(1,2));
}
private static String myFormat2(int pN) {
    String str = Integer.toString(pN);
    int len = str.length () - 1;
    if (len &lt;= 3) return str;
    int level = len / 3;
    int mode = len % 3;
    switch (mode) {
    case 0: return str.substring(0, 1) + unit[level] + trim2(str.substring(1, 3));
    case 2: return str.substring(0, 3) + unit[level];
    case 1: return str.substring(0, 2) + unit[level] + trim1(str.substring(2, 3));
    }
    return "how that?";
}
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_17"><span>Answer 17</span> <span class="arrow"> <a href="#answer_16">↑</a> </span> <span class="arrow"> <a href="#answer_18">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Amos M. Carpenter</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Jun 2015 at 14:52</span>
     </div>
    </div>
    <div>
     <p>Staying true to my comment that I'd value readability above performance, here's a version where it should be clear what's happening (assuming you've used <code>BigDecimal</code>s before) without excessive commenting (I believe in self-documenting code), without worrying about performance (since I can't picture a scenario where you'd want to do this so many millions of times that performance even becomes a consideration).</p>
     <p>This version:</p>
     <ul>
      <li>uses <code>BigDecimal</code>s for precision and to avoid rounding issues</li>
      <li>works for rounding down as requested by the OP</li>
      <li>works for other rounding modes, e.g. <code>HALF_UP</code> as in the tests</li>
      <li>allows you to adjust the precision (change <code>REQUIRED_PRECISION</code>)</li>
      <li>uses an <code>enum</code> to define the thresholds, i.e. could easily be adjusted to use KB/MB/GB/TB instead of k/m/b/t, etc., and could of course be extended beyond <code>TRILLION</code> if required</li>
      <li>comes with thorough unit tests, since the test cases in the question weren't testing the borders</li>
      <li>should work for zero and negative numbers</li>
     </ul>
     <p><strong>Threshold.java</strong>:</p>
     <pre><code>import java.math.BigDecimal;

public enum Threshold {
  TRILLION("1000000000000", 12, 't', null),
  BILLION("1000000000", 9, 'b', TRILLION),
  MILLION("1000000", 6, 'm', BILLION),
  THOUSAND("1000", 3, 'k', MILLION),
  ZERO("0", 0, null, THOUSAND);

  private BigDecimal value;
  private int zeroes;
  protected Character suffix;
  private Threshold higherThreshold;

  private Threshold(String aValueString, int aNumberOfZeroes, Character aSuffix,
      Threshold aThreshold) {
    value = new BigDecimal(aValueString);
    zeroes = aNumberOfZeroes;
    suffix = aSuffix;
    higherThreshold = aThreshold;
  }

  public static Threshold thresholdFor(long aValue) {
    return thresholdFor(new BigDecimal(aValue));
  }

  public static Threshold thresholdFor(BigDecimal aValue) {
    for (Threshold eachThreshold : Threshold.values()) {
      if (eachThreshold.value.compareTo(aValue) &lt;= 0) {
        return eachThreshold;
      }
    }
    return TRILLION; // shouldn't be needed, but you might have to extend the enum
  }

  public int getNumberOfZeroes() {
    return zeroes;
  }

  public String getSuffix() {
    return suffix == null ? "" : "" + suffix;
  }

  public Threshold getHigherThreshold() {
    return higherThreshold;
  }
}
</code></pre>
     <p><strong>NumberShortener.java</strong>:</p>
     <pre><code>import java.math.BigDecimal;
import java.math.RoundingMode;

public class NumberShortener {

  public static final int REQUIRED_PRECISION = 2;

  public static BigDecimal toPrecisionWithoutLoss(BigDecimal aBigDecimal,
      int aPrecision, RoundingMode aMode) {
    int previousScale = aBigDecimal.scale();
    int previousPrecision = aBigDecimal.precision();
    int newPrecision = Math.max(previousPrecision - previousScale, aPrecision);
    return aBigDecimal.setScale(previousScale + newPrecision - previousPrecision,
        aMode);
  }

  private static BigDecimal scaledNumber(BigDecimal aNumber, RoundingMode aMode) {
    Threshold threshold = Threshold.thresholdFor(aNumber);
    BigDecimal adjustedNumber = aNumber.movePointLeft(threshold.getNumberOfZeroes());
    BigDecimal scaledNumber = toPrecisionWithoutLoss(adjustedNumber, REQUIRED_PRECISION,
        aMode).stripTrailingZeros();
    // System.out.println("Number: &lt;" + aNumber + "&gt;, adjusted: &lt;" + adjustedNumber
    // + "&gt;, rounded: &lt;" + scaledNumber + "&gt;");
    return scaledNumber;
  }

  public static String shortenedNumber(long aNumber, RoundingMode aMode) {
    boolean isNegative = aNumber &lt; 0;
    BigDecimal numberAsBigDecimal = new BigDecimal(isNegative ? -aNumber : aNumber);
    Threshold threshold = Threshold.thresholdFor(numberAsBigDecimal);
    BigDecimal scaledNumber = aNumber == 0 ? numberAsBigDecimal : scaledNumber(
        numberAsBigDecimal, aMode);
    if (scaledNumber.compareTo(new BigDecimal("1000")) &gt;= 0) {
      scaledNumber = scaledNumber(scaledNumber, aMode);
      threshold = threshold.getHigherThreshold();
    }
    String sign = isNegative ? "-" : "";
    String printNumber = sign + scaledNumber.stripTrailingZeros().toPlainString()
        + threshold.getSuffix();
    // System.out.println("Number: &lt;" + sign + numberAsBigDecimal + "&gt;, rounded: &lt;"
    // + sign + scaledNumber + "&gt;, print: &lt;" + printNumber + "&gt;");
    return printNumber;
  }
}
</code></pre>
     <p>(Uncomment the <code>println</code> statements or change to use your favourite logger to see what it's doing.)</p>
     <p>And finally, the tests in <strong>NumberShortenerTest</strong> (plain JUnit 4):</p>
     <pre><code>import static org.junit.Assert.*;

import java.math.BigDecimal;
import java.math.RoundingMode;

import org.junit.Test;

public class NumberShortenerTest {

  private static final long[] NUMBERS_FROM_OP = new long[] { 1000, 5821, 10500, 101800, 2000000, 7800000, 92150000, 123200000 };
  private static final String[] EXPECTED_FROM_OP = new String[] { "1k", "5.8k", "10k", "101k", "2m", "7.8m", "92m", "123m" };
  private static final String[] EXPECTED_FROM_OP_HALF_UP = new String[] { "1k", "5.8k", "11k", "102k", "2m", "7.8m", "92m", "123m" };
  private static final long[] NUMBERS_TO_TEST = new long[] { 1, 500, 999, 1000, 1001, 1009, 1049, 1050, 1099, 1100, 12345, 123456, 999999, 1000000,
      1000099, 1000999, 1009999, 1099999, 1100000, 1234567, 999999999, 1000000000, 9123456789L, 123456789123L };
  private static final String[] EXPECTED_FROM_TEST = new String[] { "1", "500", "999", "1k", "1k", "1k", "1k", "1k", "1k", "1.1k", "12k", "123k",
      "999k", "1m", "1m", "1m", "1m", "1m", "1.1m", "1.2m", "999m", "1b", "9.1b", "123b" };
  private static final String[] EXPECTED_FROM_TEST_HALF_UP = new String[] { "1", "500", "999", "1k", "1k", "1k", "1k", "1.1k", "1.1k", "1.1k", "12k",
      "123k", "1m", "1m", "1m", "1m", "1m", "1.1m", "1.1m", "1.2m", "1b", "1b", "9.1b", "123b" };

  @Test
  public void testThresholdFor() {
    assertEquals(Threshold.ZERO, Threshold.thresholdFor(1));
    assertEquals(Threshold.ZERO, Threshold.thresholdFor(999));
    assertEquals(Threshold.THOUSAND, Threshold.thresholdFor(1000));
    assertEquals(Threshold.THOUSAND, Threshold.thresholdFor(1234));
    assertEquals(Threshold.THOUSAND, Threshold.thresholdFor(9999));
    assertEquals(Threshold.THOUSAND, Threshold.thresholdFor(999999));
    assertEquals(Threshold.MILLION, Threshold.thresholdFor(1000000));
  }

  @Test
  public void testToPrecision() {
    RoundingMode mode = RoundingMode.DOWN;
    assertEquals(new BigDecimal("1"), NumberShortener.toPrecisionWithoutLoss(new BigDecimal("1.23456"), 1, mode));
    assertEquals(new BigDecimal("1.2"), NumberShortener.toPrecisionWithoutLoss(new BigDecimal("1.23456"), 2, mode));
    assertEquals(new BigDecimal("1.23"), NumberShortener.toPrecisionWithoutLoss(new BigDecimal("1.23456"), 3, mode));
    assertEquals(new BigDecimal("1.234"), NumberShortener.toPrecisionWithoutLoss(new BigDecimal("1.23456"), 4, mode));
    assertEquals(new BigDecimal("999").toPlainString(), NumberShortener.toPrecisionWithoutLoss(new BigDecimal("999"), 4, mode).stripTrailingZeros()
        .toPlainString());
    assertEquals(new BigDecimal("999").toPlainString(), NumberShortener.toPrecisionWithoutLoss(new BigDecimal("999"), 2, mode).stripTrailingZeros()
        .toPlainString());
    assertEquals(new BigDecimal("999").toPlainString(), NumberShortener.toPrecisionWithoutLoss(new BigDecimal("999.9"), 2, mode).stripTrailingZeros()
        .toPlainString());

    mode = RoundingMode.HALF_UP;
    assertEquals(new BigDecimal("1"), NumberShortener.toPrecisionWithoutLoss(new BigDecimal("1.23456"), 1, mode));
    assertEquals(new BigDecimal("1.2"), NumberShortener.toPrecisionWithoutLoss(new BigDecimal("1.23456"), 2, mode));
    assertEquals(new BigDecimal("1.23"), NumberShortener.toPrecisionWithoutLoss(new BigDecimal("1.23456"), 3, mode));
    assertEquals(new BigDecimal("1.235"), NumberShortener.toPrecisionWithoutLoss(new BigDecimal("1.23456"), 4, mode));
    assertEquals(new BigDecimal("999").toPlainString(), NumberShortener.toPrecisionWithoutLoss(new BigDecimal("999"), 4, mode).stripTrailingZeros()
        .toPlainString());
    assertEquals(new BigDecimal("999").toPlainString(), NumberShortener.toPrecisionWithoutLoss(new BigDecimal("999"), 2, mode).stripTrailingZeros()
        .toPlainString());
    assertEquals(new BigDecimal("1000").toPlainString(), NumberShortener.toPrecisionWithoutLoss(new BigDecimal("999.9"), 2, mode)
        .stripTrailingZeros().toPlainString());
  }

  @Test
  public void testNumbersFromOP() {
    for (int i = 0; i &lt; NUMBERS_FROM_OP.length; i++) {
      assertEquals("Index " + i + ": " + NUMBERS_FROM_OP[i], EXPECTED_FROM_OP[i],
          NumberShortener.shortenedNumber(NUMBERS_FROM_OP[i], RoundingMode.DOWN));
      assertEquals("Index " + i + ": " + NUMBERS_FROM_OP[i], EXPECTED_FROM_OP_HALF_UP[i],
          NumberShortener.shortenedNumber(NUMBERS_FROM_OP[i], RoundingMode.HALF_UP));
    }
  }

  @Test
  public void testBorders() {
    assertEquals("Zero: " + 0, "0", NumberShortener.shortenedNumber(0, RoundingMode.DOWN));
    assertEquals("Zero: " + 0, "0", NumberShortener.shortenedNumber(0, RoundingMode.HALF_UP));
    for (int i = 0; i &lt; NUMBERS_TO_TEST.length; i++) {
      assertEquals("Index " + i + ": " + NUMBERS_TO_TEST[i], EXPECTED_FROM_TEST[i],
          NumberShortener.shortenedNumber(NUMBERS_TO_TEST[i], RoundingMode.DOWN));
      assertEquals("Index " + i + ": " + NUMBERS_TO_TEST[i], EXPECTED_FROM_TEST_HALF_UP[i],
          NumberShortener.shortenedNumber(NUMBERS_TO_TEST[i], RoundingMode.HALF_UP));
    }
  }

  @Test
  public void testNegativeBorders() {
    for (int i = 0; i &lt; NUMBERS_TO_TEST.length; i++) {
      assertEquals("Index " + i + ": -" + NUMBERS_TO_TEST[i], "-" + EXPECTED_FROM_TEST[i],
          NumberShortener.shortenedNumber(-NUMBERS_TO_TEST[i], RoundingMode.DOWN));
      assertEquals("Index " + i + ": -" + NUMBERS_TO_TEST[i], "-" + EXPECTED_FROM_TEST_HALF_UP[i],
          NumberShortener.shortenedNumber(-NUMBERS_TO_TEST[i], RoundingMode.HALF_UP));
    }
  }
}
</code></pre>
     <p>Feel free to point out in the comments if I missed a significant test case or if expected values should be adjusted.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Wolf</span> <span> </span> <span class="date">10 Jun 2015 at 15:22</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Amos M. Carpenter</span> <span> </span> <span class="date">10 Jun 2015 at 15:35</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Wolf</span> <span> </span> <span class="date">10 Jun 2015 at 15:51</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Amos M. Carpenter</span> <span> </span> <span class="date">10 Jun 2015 at 23:37</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Amos M. Carpenter</span> <span> </span> <span class="date">10 Jun 2015 at 23:43</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">maraca</span> <span> </span> <span class="date">11 Jun 2015 at 00:25</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">assylias</span> <span> </span> <span class="date">11 Jun 2015 at 14:26</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">Amos M. Carpenter</span> <span> </span> <span class="date">12 Jun 2015 at 00:03</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_18"><span>Answer 18</span> <span class="arrow"> <a href="#answer_17">↑</a> </span> <span class="arrow"> <a href="#answer_19">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>LearningDeveloper</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Sep 2014 at 06:40</span>
     </div>
    </div>
    <div>
     <p>Adding my own answer, Java code, self explanatory code..</p>
     <pre><code>import java.math.BigDecimal;

/**
 * Method to convert number to formatted number.
 * 
 * @author Gautham PJ
 */
public class ShortFormatNumbers
{

    /**
     * Main method. Execution starts here.
     */
    public static void main(String[] args)
    {

        // The numbers that are being converted.
        int[] numbers = {999, 1400, 2500, 45673463, 983456, 234234567};


        // Call the "formatNumber" method on individual numbers to format 
        // the number.
        for(int number : numbers)
        {
            System.out.println(number + ": " + formatNumber(number));
        }

    }


    /**
     * Format the number to display it in short format.
     * 
     * The number is divided by 1000 to find which denomination to be added 
     * to the number. Dividing the number will give the smallest possible 
     * value with the denomination.
     * 
     * @param the number that needs to be converted to short hand notation.
     * @return the converted short hand notation for the number.
     */
    private static String formatNumber(double number)
    {
        String[] denominations = {"", "k", "m", "b", "t"};
        int denominationIndex = 0;

        // If number is greater than 1000, divide the number by 1000 and 
        // increment the index for the denomination.
        while(number &gt; 1000.0)
        {
            denominationIndex++;
            number = number / 1000.0;
        }

        // To round it to 2 digits.
        BigDecimal bigDecimal = new BigDecimal(number);
        bigDecimal = bigDecimal.setScale(2, BigDecimal.ROUND_HALF_EVEN);


        // Add the number with the denomination to get the final value.
        String formattedNumber = bigDecimal + denominations[denominationIndex];
        return formattedNumber;
    }

}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_19"><span>Answer 19</span> <span class="arrow"> <a href="#answer_18">↑</a> </span> <span class="arrow"> <a href="#answer_20">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user2089762</span>
     </div>
     <div>
      <span> Answered: </span> <span>20 Feb 2013 at 04:55</span>
     </div>
    </div>
    <div>
     <pre><code>//code longer but work sure...

public static String formatK(int number) {
    if (number &lt; 999) {
        return String.valueOf(number);
    }

    if (number &lt; 9999) {
        String strNumber = String.valueOf(number);
        String str1 = strNumber.substring(0, 1);
        String str2 = strNumber.substring(1, 2);
        if (str2.equals("0")) {
            return str1 + "k";
        } else {
            return str1 + "." + str2 + "k";
        }
    }

    if (number &lt; 99999) {
        String strNumber = String.valueOf(number);
        String str1 = strNumber.substring(0, 2);
        return str1 + "k";
    }

    if (number &lt; 999999) {
        String strNumber = String.valueOf(number);
        String str1 = strNumber.substring(0, 3);
        return str1 + "k";
    }

    if (number &lt; 9999999) {
        String strNumber = String.valueOf(number);
        String str1 = strNumber.substring(0, 1);
        String str2 = strNumber.substring(1, 2);
        if (str2.equals("0")) {
            return str1 + "m";
        } else {
            return str1 + "." + str2 + "m";
        }
    }

    if (number &lt; 99999999) {
        String strNumber = String.valueOf(number);
        String str1 = strNumber.substring(0, 2);
        return str1 + "m";
    }

    if (number &lt; 999999999) {
        String strNumber = String.valueOf(number);
        String str1 = strNumber.substring(0, 3);
        return str1 + "m";
    }

    NumberFormat formatterHasDigi = new DecimalFormat("###,###,###");
    return formatterHasDigi.format(number);
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span></span> <span> - </span> <span class="display-name">jzd</span> <span> </span> <span class="date">4 Nov 2013 at 14:33</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_20"><span>Answer 20</span> <span class="arrow"> <a href="#answer_19">↑</a> </span> <span class="arrow"> <a href="#answer_21">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>KimKha</span>
     </div>
     <div>
      <span> Answered: </span> <span>31 Aug 2015 at 14:37</span>
     </div>
    </div>
    <div>
     <p>This code snippet just deadly simple, and clean code, and totally works:</p>
     <pre><code>private static char[] c = new char[]{'K', 'M', 'B', 'T'};
private String formatK(double n, int iteration) {
    if (n &lt; 1000) {
        // print 999 or 999K
        if (iteration &lt;= 0) {
            return String.valueOf((long) n);
        } else {
            return String.format("%d%s", Math.round(n), c[iteration-1]);
        }
    } else if (n &lt; 10000) {
        // Print 9.9K
        return String.format("%.1f%s", n/1000, c[iteration]);
    } else {
        // Increase 1 iteration
        return formatK(Math.round(n/1000), iteration+1);
    }
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_21"><span>Answer 21</span> <span class="arrow"> <a href="#answer_20">↑</a> </span> <span class="arrow"> <a href="#answer_22">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>AzizAhmad</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Nov 2016 at 21:47</span>
     </div>
    </div>
    <div>
     <p>try this :</p>
     <pre><code>public String Format(Integer number){
    String[] suffix = new String[]{"k","m","b","t"};
    int size = (number.intValue() != 0) ? (int) Math.log10(number) : 0;
    if (size &gt;= 3){
        while (size % 3 != 0) {
            size = size - 1;
        }
    }
    double notation = Math.pow(10, size);
    String result = (size &gt;= 3) ? + (Math.round((number / notation) * 100) / 100.0d)+suffix[(size/3) - 1] : + number + "";
    return result
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_22"><span>Answer 22</span> <span class="arrow"> <a href="#answer_21">↑</a> </span> <span class="arrow"> <a href="#answer_23">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Elegant.Obj</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 May 2021 at 18:30</span>
     </div>
    </div>
    <div>
     <p>There is a solution on the Maven Central</p>
     <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;com.github.bogdanovmn.humanreadablevalues&lt;/groupId&gt;
  &lt;artifactId&gt;human-readable-values&lt;/artifactId&gt;
  &lt;version&gt;1.0.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
     <p>You can just get values for amount of bytes or seconds. Also you can create you own factorization class.</p>
     <p><strong>Docs</strong> <a href="https://github.com/bogdanovmn/java-human-readable-values" rel="nofollow noreferrer">https://github.com/bogdanovmn/java-human-readable-values</a></p>
     <p><strong>Seconds example</strong></p>
     <pre><code>assertEquals(
    "2h 46m 40s",
    new SecondsValue(10000).fullString()
);

assertEquals(
    "2.8h",
    new SecondsValue(10000).shortString()
);
</code></pre>
     <p><strong>Bytes example</strong></p>
     <pre><code>assertEquals(
    "9K 784b",
    new BytesValue(10000).fullString()
);

assertEquals(
    "9.8K",
    new BytesValue(10000).shortString()
);
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_23"><span>Answer 23</span> <span class="arrow"> <a href="#answer_22">↑</a> </span> <span class="arrow"> <a href="#answer_24">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>adam</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Aug 2021 at 16:38</span>
     </div>
    </div>
    <div>
     <p>Set the divisor according to the the input number: 1000, 100000, 1000000, 1000000000 etc...</p>
     <p>check the whole part(first part without fraction) of the number if its size is 1 then cast the input to long + String. if the size is &gt;= 2 then divide the input and use DecimalFormat to show fractional part as desired.</p>
     <p>you can use // .setRoundingMode(RoundingMode.DOWN) to deal with rounding</p>
     <pre><code>public static String format(long num) {

        String suffix = "", result;
        double divisor = 0;

        DecimalFormat df = new DecimalFormat("##");
        DecimalFormat ds = new DecimalFormat("##.#");
        // ds.setRoundingMode(RoundingMode.DOWN);

        if ( num &gt;= 1000  &amp;&amp; num &lt; 1000000 ) {
            divisor = 1000;
            suffix = "K";
        } else if ( num &gt;= 1000000 &amp;&amp; num &lt; 1000000000 ) {
            divisor = 1000000;
            suffix = "M";
        } else if (num &gt;= 1000000000) {
            divisor = 1000000000;
            suffix = "B";
        } else {
            System.out.print("The number is Too big &gt; T or TOO small &lt; K");
        }

        int numlengt = df.format(num / divisor).length();

        if (numlengt &gt;= 2) {
            result = (long) (num / divisor) + suffix;
        } else {
            result = ds.format(num / divisor) + suffix;
        }
        return result;
    }
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">TheRealChx101</span> <span> </span> <span class="date">9 Aug 2021 at 20:34</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">adam</span> <span> </span> <span class="date">10 Aug 2021 at 10:14</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_24"><span>Answer 24</span> <span class="arrow"> <a href="#answer_23">↑</a> </span> <span class="arrow"> <a href="#answer_25">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ankit Singh</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Feb 2019 at 10:11</span>
     </div>
    </div>
    <div>
     <pre><code>public class NumberToReadableWordFormat {

    public static void main(String[] args) {
        Integer[] numbers = new Integer[]{1000, 5821, 10500, 101800, 2000000, 7800000, 92150000, 123200000, 9999999,999};
        for(int n : numbers) {
            System.out.println(n + " =&gt; " + coolFormat(n));
        }
    }

    private static String[] c = new String[]{"K", "L", "Cr"};
    private static String coolFormat(int n) {
        int size = String.valueOf(n).length();
        if (size&gt;=4 &amp;&amp; size&lt;6) {
                int value = (int) Math.pow(10, 1);
                double d = (double) Math.round(n/1000.0 * value) / value;
                return (double) Math.round(n/1000.0 * value) / value+" "+c[0];
        } else if(size&gt;5 &amp;&amp; size&lt;8) {
                int value = (int) Math.pow(10, 1);
                return (double) Math.round(n/100000.0 * value) / value+" "+c[1];
        } else if(size&gt;=8) {
                int value = (int) Math.pow(10, 1);
                return (double) Math.round(n/10000000.0 * value) / value+" "+c[2];
        } else {
            return n+"";
        }
    }
}
</code></pre>
     <p>Output:</p>
     <pre><code>1000 =&gt; 1.0 K

5821 =&gt; 5.8 K

10500 =&gt; 10.5 K

101800 =&gt; 1.0 L

2000000 =&gt; 20.0 L

7800000 =&gt; 78.0 L

92150000 =&gt; 9.2 Cr

123200000 =&gt; 12.3 Cr

9999999 =&gt; 100.0 L

999 =&gt; 999
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_25"><span>Answer 25</span> <span class="arrow"> <a href="#answer_24">↑</a> </span> <span class="arrow"> <a href="#answer_26">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Sunil Sunny</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Sep 2020 at 16:45</span>
     </div>
    </div>
    <div>
     <p>Here is a another simple solution for your problem. let say</p>
     <pre><code>String abbr="M,K,T,B";
</code></pre>
     <p>double yvalue=some random number; String string ="#.##" //decimal places whatever you want</p>
     <pre><code>public  String format(Double yvalue, String string,String abbr) {
    DecimalFormat df = new DecimalFormat(getnumberformatpattern(string));
      if (yvalue &lt; 0) return "-" + format(-yvalue,string,abbr);
          double finalvalue= yvalue;
          String newnumber="";
          
                if (abbr.indexOf("K")&gt;0){   
                    finalvalue= (yvalue / 1e3);
                    newnumber=df.format(finalvalue) +'K';
                }
                if (abbr.indexOf("M")&gt;0 ){
                if(yvalue&gt;=1e6){
                    finalvalue= (yvalue / 1e6);
                    newnumber=df.format(finalvalue) +'M';
                    };
                }
                if (abbr.indexOf("B")&gt;0 )
                {
                if((newnumber.indexOf("M")&lt;0) || yvalue&gt;=1e9){
                    finalvalue= (yvalue / 1e9);
                    newnumber=df.format(finalvalue) +'B';                   }
                }
                if (abbr.indexOf("T")&gt;0 ){ 
                if((newnumber.indexOf("B")&lt;0) || yvalue&gt;=1e12){
                    finalvalue= (yvalue / 1e12);
                    newnumber=df.format(finalvalue) +'T';                   }
                }
                return newnumber;
    }
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_26"><span>Answer 26</span> <span class="arrow"> <a href="#answer_25">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ranajit Sawant</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Apr 2022 at 09:35</span>
     </div>
    </div>
    <div>
     <pre><code>  fun getKLCrValue(input: Long):String{
        return if(input.toString().length&lt;4){
            input.toString()
        }else if(input.toString().length&lt;5)
            ( ""+getExactValue(input.toString()[0] +"."+ input.toString()[1]) +"K")
        else if(input.toString().length&lt;6)
            (""+getExactValue(""+input.toString().subSequence(0, 2) +"."+ input.toString()[2]) +"K")
        else if(input.toString().length&lt;7)
            (""+ getExactValue( input.toString()[0] +"."+input.toString().subSequence(1, 3))+"L")
        else if(input.toString().length&lt;8)
            (""+ getExactValue( ""+input.toString().subSequence(0, 2)+"."+input.toString().subSequence(2,4))+"L")
        else if(input.toString().length&lt;9)
            (""+ getExactValue( input.toString()[0] +"."+input.toString().subSequence(1,3))+"Cr")
        else
            (""+ getExactValue( ""+input.toString().subSequence(0, input.toString().length-7)+"."+input.toString().subSequence( input.toString().length-7, input.toString().length-5))+"cr")

    }

    private fun getExactValue(value: String): String {
        return value.replace(".00", "")
    }
</code></pre>
     <p>You can just call getKLCrValue(1234) and you will get desired output</p>
     <p>Output--&gt;</p>
     <pre><code>1 -&gt; 1
10 -&gt; 10
12 -&gt; 12
100 -&gt; 100
123 -&gt; 123
1000 -&gt; 1K
1234 -&gt; 1.2K
10000 -&gt; 10K
12345 -&gt; 12.3K
100000 -&gt; 1L
123456 -&gt; 1.23L
1000000 -&gt; 10L
1234567 -&gt; 12.34L
10000000 -&gt; 1cr
12345678 -&gt; 1.23cr
100000000 -&gt; 10cr
123456789 -&gt; 12.34cr
1000000000 -&gt; 100cr
1234567890 -&gt; 123.45cr
10000000000 -&gt; 1000cr
11111111111 -&gt; 1111.11cr
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>