<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>How do I efficiently iterate over each entry in a Java Map?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>How do I efficiently iterate over each entry in a Java Map?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>3922</span>
    </div>
    <div>
     <span>Asker: </span> <span>iMack</span>
    </div>
    <div>
     <span>Asked: </span> <span>5 Sep 2008 at 21:12</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/46898/how-do-i-efficiently-iterate-over-each-entry-in-a-java-map">source</a>
    </div>
   </div>
   <div>
    <p>If I have an object implementing the <code>Map</code> interface in Java and I wish to iterate over every pair contained within it, what is the most efficient way of going through the map?</p>
    <p>Will the ordering of elements depend on the specific map implementation that I have for the interface?</p>
   </div>
   <div class="tags">
    <span class="tag">java</span><span class="tag">dictionary</span><span class="tag">collections</span><span class="tag">iteration</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>46</td>
       <td><span>In Java 8 using Lambda Expression: <a href="http://stackoverflow.com/a/25616206/1503859">stackoverflow.com/a/25616206/1503859</a></span> <span> - </span> <span class="display-name">Nitin Mahesh</span> <span> </span> <span class="date">25 Jul 2015 at 18:31</span></td>
      </tr>
      <tr>
       <td>5</td>
       <td><span>Java 8: <a href="https://stackoverflow.com/questions/46898/how-to-efficiently-iterate-over-each-entry-in-a-java-map/32343110#32343110" title="how to efficiently iterate over each entry in a java map">stackoverflow.com/questions/46898/…</a></span> <span> - </span> <span class="display-name">akhil_mittal</span> <span> </span> <span class="date">10 Oct 2018 at 12:45</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5834</span>
     </div>
     <div>
      <span>Answerer: </span> <span>ScArcher2</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Sep 2008 at 21:15</span>
     </div>
    </div>
    <div>
     <pre class="lang-java prettyprint-override"><code>Map&lt;String, String&gt; map = ...
for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) {
    System.out.println(entry.getKey() + "/" + entry.getValue());
}
</code></pre>
     <p>On Java 10+:</p>
     <pre class="lang-java prettyprint-override"><code>for (var entry : map.entrySet()) {
    System.out.println(entry.getKey() + "/" + entry.getValue());
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>95</td>
        <td><span>If you do that, then it won't work as Entry is a nested Class in Map. <a href="http://java.sun.com/javase/6/docs/api/java/util/Map.html" rel="nofollow noreferrer">java.sun.com/javase/6/docs/api/java/util/Map.html</a></span> <span> - </span> <span class="display-name">ScArcher2</span> <span> </span> <span class="date">22 Mar 2010 at 13:30</span></td>
       </tr>
       <tr>
        <td>291</td>
        <td><span>you can write the import as "import java.util.Map.Entry;" and it will work.</span> <span> - </span> <span class="display-name">jjujuma</span> <span> </span> <span class="date">30 Apr 2010 at 10:34</span></td>
       </tr>
       <tr>
        <td>62</td>
        <td><span>@Pureferret The only reason you might want to use an iterator is if you need to call its <code>remove</code> method. If that is the case, <a href="http://stackoverflow.com/a/1295383/829571">this other answer</a> shows you how to do it. Otherwise, the enhanced loop as shown in the answer above is the way to go.</span> <span> - </span> <span class="display-name">assylias</span> <span> </span> <span class="date">8 Oct 2012 at 10:34</span></td>
       </tr>
       <tr>
        <td>110</td>
        <td><span>I believe the form Map.Entry is clearer than importing the inner class into the current namespace.</span> <span> - </span> <span class="display-name">Josiah Yoder</span> <span> </span> <span class="date">4 Dec 2014 at 20:31</span></td>
       </tr>
       <tr>
        <td>45</td>
        <td><span>Note that you can use <code>map.values()</code> or <code>map.keySet()</code> if you want to loop through values or keys only.</span> <span> - </span> <span class="display-name">dguay</span> <span> </span> <span class="date">12 Oct 2016 at 21:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The order in which register were inserted isn't respected when you loop them after</span> <span> - </span> <span class="display-name">Rubén Colomina Citoler</span> <span> </span> <span class="date">30 Apr 2022 at 11:50</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@JosiahYoder No need to import the inner class <code>Map.Entry</code> since <code>var</code> handling the reference for you.</span> <span> - </span> <span class="display-name">Mo'ath Alshorman</span> <span> </span> <span class="date">26 May 2022 at 21:41</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1571</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Slava Vedenin</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Feb 2016 at 16:37</span>
     </div>
    </div>
    <div>
     <p>To summarize the other answers and combine them with what I know, I found 10 main ways to do this (see below). Also, I wrote some performance tests (see results below). For example, if we want to find the sum of all of the keys and values of a map, we can write:</p>
     <ol>
      <li>
       <p>Using <strong>iterator</strong> and <strong>Map.Entry</strong></p>
       <pre><code>long i = 0;
Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator();
while (it.hasNext()) {
    Map.Entry&lt;Integer, Integer&gt; pair = it.next();
    i += pair.getKey() + pair.getValue();
}
</code></pre></li>
      <li>
       <p>Using <strong>foreach</strong> and <strong>Map.Entry</strong></p>
       <pre><code>long i = 0;
for (Map.Entry&lt;Integer, Integer&gt; pair : map.entrySet()) {
    i += pair.getKey() + pair.getValue();
}
</code></pre></li>
      <li>
       <p>Using <strong>forEach</strong> from Java 8</p>
       <pre><code>final long[] i = {0};
map.forEach((k, v) -&gt; i[0] += k + v);
</code></pre></li>
      <li>
       <p>Using <strong>keySet</strong> and <strong>foreach</strong></p>
       <pre><code>long i = 0;
for (Integer key : map.keySet()) {
    i += key + map.get(key);
}
</code></pre></li>
      <li>
       <p>Using <strong>keySet</strong> and <strong>iterator</strong></p>
       <pre><code>long i = 0;
Iterator&lt;Integer&gt; itr2 = map.keySet().iterator();
while (itr2.hasNext()) {
    Integer key = itr2.next();
    i += key + map.get(key);
}
</code></pre></li>
      <li>
       <p>Using <strong>for</strong> and <strong>Map.Entry</strong></p>
       <pre><code>long i = 0;
for (Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet().iterator(); entries.hasNext(); ) {
    Map.Entry&lt;Integer, Integer&gt; entry = entries.next();
    i += entry.getKey() + entry.getValue();
}
</code></pre></li>
      <li>
       <p>Using the Java 8 <strong>Stream API</strong></p>
       <pre><code>final long[] i = {0};
map.entrySet().stream().forEach(e -&gt; i[0] += e.getKey() + e.getValue());
</code></pre></li>
      <li>
       <p>Using the Java 8 <strong>Stream API parallel</strong></p>
       <pre><code>final long[] i = {0};
map.entrySet().stream().parallel().forEach(e -&gt; i[0] += e.getKey() + e.getValue());
</code></pre></li>
      <li>
       <p>Using <strong>IterableMap</strong> of <code>Apache Collections</code></p>
       <pre><code>long i = 0;
MapIterator&lt;Integer, Integer&gt; it = iterableMap.mapIterator();
while (it.hasNext()) {
    i += it.next() + it.getValue();
}
</code></pre></li>
      <li>
       <p>Using <strong>MutableMap</strong> of Eclipse (CS) collections</p>
       <pre><code>final long[] i = {0};
mutableMap.forEachKeyValue((key, value) -&gt; {
    i[0] += key + value;
});
</code></pre></li>
     </ol>
     <p><strong>Perfomance tests</strong> (mode = AverageTime, system = Windows&nbsp;8.1 64-bit, Intel i7-4790 3.60 GHz, 16&nbsp;GB)</p>
     <ol>
      <li>
       <p>For a small map (100 elements), score 0.308 is the best</p>
       <pre><code>Benchmark                          Mode  Cnt  Score    Error  Units
test3_UsingForEachAndJava8         avgt  10   0.308 ±  0.021  µs/op
test10_UsingEclipseMap             avgt  10   0.309 ±  0.009  µs/op
test1_UsingWhileAndMapEntry        avgt  10   0.380 ±  0.014  µs/op
test6_UsingForAndIterator          avgt  10   0.387 ±  0.016  µs/op
test2_UsingForEachAndMapEntry      avgt  10   0.391 ±  0.023  µs/op
test7_UsingJava8StreamApi          avgt  10   0.510 ±  0.014  µs/op
test9_UsingApacheIterableMap       avgt  10   0.524 ±  0.008  µs/op
test4_UsingKeySetAndForEach        avgt  10   0.816 ±  0.026  µs/op
test5_UsingKeySetAndIterator       avgt  10   0.863 ±  0.025  µs/op
test8_UsingJava8StreamApiParallel  avgt  10   5.552 ±  0.185  µs/op
</code></pre></li>
      <li>
       <p>For a map with 10000 elements, score 37.606 is the best</p>
       <pre><code>Benchmark                           Mode   Cnt  Score      Error   Units
test10_UsingEclipseMap              avgt   10    37.606 ±   0.790  µs/op
test3_UsingForEachAndJava8          avgt   10    50.368 ±   0.887  µs/op
test6_UsingForAndIterator           avgt   10    50.332 ±   0.507  µs/op
test2_UsingForEachAndMapEntry       avgt   10    51.406 ±   1.032  µs/op
test1_UsingWhileAndMapEntry         avgt   10    52.538 ±   2.431  µs/op
test7_UsingJava8StreamApi           avgt   10    54.464 ±   0.712  µs/op
test4_UsingKeySetAndForEach         avgt   10    79.016 ±  25.345  µs/op
test5_UsingKeySetAndIterator        avgt   10    91.105 ±  10.220  µs/op
test8_UsingJava8StreamApiParallel   avgt   10   112.511 ±   0.365  µs/op
test9_UsingApacheIterableMap        avgt   10   125.714 ±   1.935  µs/op
</code></pre></li>
      <li>
       <p>For a map with 100000 elements, score 1184.767 is the best</p>
       <pre><code>Benchmark                          Mode   Cnt  Score        Error    Units
test1_UsingWhileAndMapEntry        avgt   10   1184.767 ±   332.968  µs/op
test10_UsingEclipseMap             avgt   10   1191.735 ±   304.273  µs/op
test2_UsingForEachAndMapEntry      avgt   10   1205.815 ±   366.043  µs/op
test6_UsingForAndIterator          avgt   10   1206.873 ±   367.272  µs/op
test8_UsingJava8StreamApiParallel  avgt   10   1485.895 ±   233.143  µs/op
test5_UsingKeySetAndIterator       avgt   10   1540.281 ±   357.497  µs/op
test4_UsingKeySetAndForEach        avgt   10   1593.342 ±   294.417  µs/op
test3_UsingForEachAndJava8         avgt   10   1666.296 ±   126.443  µs/op
test7_UsingJava8StreamApi          avgt   10   1706.676 ±   436.867  µs/op
test9_UsingApacheIterableMap       avgt   10   3289.866 ±  1445.564  µs/op
</code></pre></li>
     </ol>
     <p>Graphs (performance tests depending on map size)</p>
     <p><a href="https://i.stack.imgur.com/17VGh.png" rel="noreferrer"><img src="17VGh.png" alt="Enter image description here"></a></p>
     <p>Table (perfomance tests depending on map size)</p>
     <pre><code>          100     600      1100     1600     2100
test10    0.333    1.631    2.752    5.937    8.024
test3     0.309    1.971    4.147    8.147   10.473
test6     0.372    2.190    4.470    8.322   10.531
test1     0.405    2.237    4.616    8.645   10.707
test2     0.376    2.267    4.809    8.403   10.910
test7     0.473    2.448    5.668    9.790   12.125
test9     0.565    2.830    5.952   13.220   16.965
test4     0.808    5.012    8.813   13.939   17.407
test5     0.810    5.104    8.533   14.064   17.422
test8     5.173   12.499   17.351   24.671   30.403
</code></pre>
     <p>All tests are on <a href="https://github.com/Vedenin/useful-java-links/blob/master/helloworlds/5.0-other-examples/src/main/java/other_examples/IterateThroughHashMapTest.java" rel="noreferrer">GitHub</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>11</td>
        <td><span>@Viacheslav : very nice answer. Just wondering how Java8 apis are hindered, in your benchmark, by capturing lambdas... (e.g. <code>long sum = 0; map.forEach( /* accumulate in variable sum*/);</code> captures the <code>sum</code> long, which may be slower than say <code>stream.mapToInt(/*whatever*/).sum</code> for example. Of course you can not always avoid capturing state, but that may be a reasonnable addition to the bench.</span> <span> - </span> <span class="display-name">GPI</span> <span> </span> <span class="date">12 May 2016 at 11:53</span></td>
       </tr>
       <tr>
        <td>63</td>
        <td><span>@ZhekaKozlov: look at the mindblowingly large error values. Consider that a test result of <code>x±e</code> implies that there were result within the interval from <code>x-e</code> to <code>x+e</code>, so the fastest result (<code>1184.767±332.968</code>) ranges from <code>852</code> to <code>1518</code>, whereas the second slowest (<code>1706.676±436.867</code>) runs between <code>1270</code> and <code>2144</code>, so the results still overlap significantly. Now look at the slowest result, <code>3289.866±1445.564</code>, which implies diverging between <code>1844</code> and <code>4735</code> and you <i>know</i> that these test results are meaningless.</span> <span> - </span> <span class="display-name">Holger</span> <span> </span> <span class="date">17 Mar 2017 at 18:28</span></td>
       </tr>
       <tr>
        <td>8</td>
        <td><span>What about comparing the 3 main implementations : HashMap, LinkedHashMap and TreeMap ?</span> <span> - </span> <span class="display-name">Thierry</span> <span> </span> <span class="date">7 Nov 2017 at 23:37</span></td>
       </tr>
       <tr>
        <td>25</td>
        <td><span>#1 and #6 are exactly the same. Using <code>while</code> vs. a <code>for</code> loop is not a different technique for iterating. And I am surprised they have such variation between them in your tests—which suggests that the tests are not properly isolated from external factors unrelated to the things you intend to be testing.</span> <span> - </span> <span class="display-name">ErikE</span> <span> </span> <span class="date">14 Jul 2018 at 19:04</span></td>
       </tr>
       <tr>
        <td>9</td>
        <td><span><code>#8</code> is a terrible example, because of the <code>parallel</code> there's now a race condition when adding to <code>i</code>.</span> <span> - </span> <span class="display-name">Todd Sewell</span> <span> </span> <span class="date">2 Jan 2019 at 13:00</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@GPI Two of the java8 apis are slower because they use Streams, which are inherently slower. They do all the work of a for-each loop—that's how they're implemented internally—but they also do some work setting up the stream. So they're never faster than a standard loop, unless you can correctly use parallel processing. Of course, we don't use them for speed but for readability and maintainability. (And we use object oriented languages instead of faster procedural ones because the developer time now costs more than the computer time. They optimize developer time instead of production time.)</span> <span> - </span> <span class="display-name">MiguelMunoz</span> <span> </span> <span class="date">9 Jul 2022 at 00:40</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@ErikE Performance testing in Java is very hard, because we have no control over garbage-collecting, and I think because at some point the compiled classes may get optimized. In my trials, I run my tests for thousands of iterations, I interleave the different test cases, and I repeat my tests multiple times in each run. The first few runs are always slower. And when I plot speeds over time, I see time intervals where all my cases ran more slowly, probably due to garbage collection. And all cases see a performance improvement after a certain point, probably due to byte code optimization.</span> <span> - </span> <span class="display-name">MiguelMunoz</span> <span> </span> <span class="date">9 Jul 2022 at 01:01</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Thanks for the comment, but if it is so hard to understand Java's performance characteristics, then how is it not a piece of junk? Seriously, a for loop and a while loop shouldn't perform so much differently.</span> <span> - </span> <span class="display-name">ErikE</span> <span> </span> <span class="date">11 Jul 2022 at 23:33</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@MiguelMunoz thanks. The idea was not to compare stream vs imperative, but capturing vs non capturing lambdas. just out of curiosity, btw, it's not that important to the question.</span> <span> - </span> <span class="display-name">GPI</span> <span> </span> <span class="date">18 Jul 2022 at 16:03</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>338</span>
     </div>
     <div>
      <span>Answerer: </span> <span>The Coordinator</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Oct 2013 at 10:15</span>
     </div>
    </div>
    <div>
     <p>In Java 8 you can do it clean and fast using the new lambdas features:</p>
     <pre><code> Map&lt;String,String&gt; map = new HashMap&lt;&gt;();
 map.put("SomeKey", "SomeValue");
 map.forEach( (k,v) -&gt; [do something with key and value] );

 // such as
 map.forEach( (k,v) -&gt; System.out.println("Key: " + k + ": Value: " + v));
</code></pre>
     <p>The type of <code>k</code> and <code>v</code> will be inferred by the compiler and there is no need to use <code>Map.Entry</code> anymore.</p>
     <p>Easy-peasy!</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>12</td>
        <td><span>Depending on what you want to do with a map, you can also use stream API on the entries returned by <code>map.entrySet().stream()</code> <a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" rel="nofollow noreferrer">docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.ht‌​ml</a></span> <span> - </span> <span class="display-name">Vitalii Fedorenko</span> <span> </span> <span class="date">28 Jun 2014 at 12:46</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>This won't work if you want to reference non-final variables declared outside your lambda expression from within the forEach()...</span> <span> - </span> <span class="display-name">Chris</span> <span> </span> <span class="date">20 Apr 2017 at 20:29</span></td>
       </tr>
       <tr>
        <td>10</td>
        <td><span>@Chris Correct. It won't work if you try to use <i>effectively non-final</i> variables from outside the lambda.</span> <span> - </span> <span class="display-name">The Coordinator</span> <span> </span> <span class="date">21 Apr 2017 at 21:44</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>265</span>
     </div>
     <div>
      <span>Answerer: </span> <span>pkaeding</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Sep 2008 at 21:15</span>
     </div>
    </div>
    <div>
     <p>Yes, the order depends on the specific Map implementation.</p>
     <p><a href="https://stackoverflow.com/questions/46898/how-to-efficiently-iterate-over-each-entry-in-a-map/46908#46908">@ScArcher2 has the more elegant Java 1.5 syntax</a>. In 1.4, I would do something like this:</p>
     <pre><code>Iterator entries = myMap.entrySet().iterator();
while (entries.hasNext()) {
  Entry thisEntry = (Entry) entries.next();
  Object key = thisEntry.getKey();
  Object value = thisEntry.getValue();
  // ...
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>45</td>
        <td><span>Prefer for-loop than while.. for(Iterator entries = myMap.entrySet().iterator(); entries.hasNext(); ) {...} With this syntax the 'entries' scope is reduced to the for loop only.</span> <span> - </span> <span class="display-name">jai</span> <span> </span> <span class="date">20 Oct 2009 at 13:20</span></td>
       </tr>
       <tr>
        <td>8</td>
        <td><span>@jpredham You are right that using the <code>for</code> construct as <code>for (Entry e : myMap.entrySet)</code> will not allow you to modify the collection, but the example as @HanuAthena mentioned it should work, since it gives you the <code>Iterator</code> in scope. (Unless I'm missing something...)</span> <span> - </span> <span class="display-name">pkaeding</span> <span> </span> <span class="date">10 Jan 2012 at 15:42</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>IntelliJ is giving me errors on <code>Entry thisEntry = (Entry) entries.next();</code>: doesn't recognize <code>Entry</code>. Is that pseudocode for something else?</span> <span> - </span> <span class="display-name">JohnK</span> <span> </span> <span class="date">10 Jan 2015 at 00:06</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@JohnK try importing <code>java.util.Map.Entry</code>.</span> <span> - </span> <span class="display-name">pkaeding</span> <span> </span> <span class="date">14 Jan 2015 at 02:35</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>This solution will not work if you have a integer key and String key.</span> <span> - </span> <span class="display-name">user5778069</span> <span> </span> <span class="date">21 Jan 2017 at 08:09</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>It works perfectly. Thank you!</span> <span> - </span> <span class="display-name">Ali Mamedov</span> <span> </span> <span class="date">13 Jan 2022 at 05:49</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>151</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Tom Hawtin - tackline</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Sep 2008 at 21:26</span>
     </div>
    </div>
    <div>
     <p>Typical code for iterating over a map is:</p>
     <pre><code>Map&lt;String,Thing&gt; map = ...;
for (Map.Entry&lt;String,Thing&gt; entry : map.entrySet()) {
    String key = entry.getKey();
    Thing thing = entry.getValue();
    ...
}
</code></pre>
     <p><code>HashMap</code> is the canonical map implementation and doesn't make guarantees (or though it should not change the order if no mutating operations are performed on it). <code>SortedMap</code> will return entries based on the natural ordering of the keys, or a <code>Comparator</code>, if provided. <code>LinkedHashMap</code> will either return entries in insertion-order or access-order depending upon how it has been constructed. <code>EnumMap</code> returns entries in the natural order of keys.</p>
     <p><strong>(Update: I think this is no longer true.</strong>) Note, <code>IdentityHashMap</code> <code>entrySet</code> iterator currently has a peculiar implementation which returns the same <code>Map.Entry</code> instance for every item in the <code>entrySet</code>! However, every time a new iterator advances the <code>Map.Entry</code> is updated.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>6</td>
        <td><span>EnumMap also has this peculiar behaviour along with IdentityHashMap</span> <span> - </span> <span class="display-name">Premraj</span> <span> </span> <span class="date">10 Mar 2011 at 15:41</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>"LinkedHashMap will either return entries in [...] access-order [...]" ... so you access the elements in the order you access them? Either tautological, or something interesting which could use a digression. ;-)</span> <span> - </span> <span class="display-name">jpaugh</span> <span> </span> <span class="date">26 Jan 2016 at 20:41</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>@jpaugh Only direct accesses to the <code>LinkedHashMap</code> count. Those through <code>iterator</code>, <code>spliterator</code>, <code>entrySet</code>, etc., do not modify the order.</span> <span> - </span> <span class="display-name">Tom Hawtin - tackline</span> <span> </span> <span class="date">26 Jan 2016 at 21:24</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>1. <i>though</i> → <i>if</i>? 2. The last paragraph might benefit from a brush-up.</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">6 Feb 2018 at 22:36</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>133</span>
     </div>
     <div>
      <span>Answerer: </span> <span>serg</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Aug 2009 at 17:34</span>
     </div>
    </div>
    <div>
     <p>Example of using iterator and generics:</p>
     <pre><code>Iterator&lt;Map.Entry&lt;String, String&gt;&gt; entries = myMap.entrySet().iterator();
while (entries.hasNext()) {
  Map.Entry&lt;String, String&gt; entry = entries.next();
  String key = entry.getKey();
  String value = entry.getValue();
  // ...
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>14</td>
        <td><span>You should put <code>Iterator</code> in a for loop to limit its scope.</span> <span> - </span> <span class="display-name">Steve Kuo</span> <span> </span> <span class="date">17 Feb 2012 at 20:32</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@SteveKuo What do you mean by "limit its scope" ?</span> <span> - </span> <span class="display-name">StudioWorks</span> <span> </span> <span class="date">3 Feb 2015 at 16:13</span></td>
       </tr>
       <tr>
        <td>15</td>
        <td><span>@StudioWorks <code>for (Iterator&lt;Map.Entry&lt;K, V&gt;&gt; entries = myMap.entrySet().iterator(); entries.hasNext(); ) { Map.Entry&lt;K, V&gt; entry = entries.next(); }</code>. By using that construct we limit the scope of (visibility of the variable) <code>entries</code> to the for loop.</span> <span> - </span> <span class="display-name">ComFreek</span> <span> </span> <span class="date">13 Mar 2015 at 16:33</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>109</span>
     </div>
     <div>
      <span>Answerer: </span> <span>serg10</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Sep 2008 at 22:15</span>
     </div>
    </div>
    <div>
     <p>This is a two part question:</p>
     <p><em>How to iterate over the entries of a Map</em> - @ScArcher2 has <a href="https://stackoverflow.com/a/46908/1851302">answered</a> that perfectly.</p>
     <p><em>What is the order of iteration</em> - if you are just using <code>Map</code>, then strictly speaking, there are <strong>no ordering guarantees</strong>. So you shouldn't really rely on the ordering given by any implementation. However, the <a href="http://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html" rel="noreferrer"><code>SortedMap</code></a> interface extends <code>Map</code> and provides exactly what you are looking for - implementations will aways give a consistent sort order.</p>
     <p><strong><a href="http://docs.oracle.com/javase/8/docs/api/java/util/NavigableMap.html" rel="noreferrer"><code>NavigableMap</code></a> is another useful extension</strong> - this is a <code>SortedMap</code> with additional methods for finding entries by their ordered position in the key set. So potentially this can remove the need for iterating in the first place - you might be able to find the specific <code>entry</code> you are after using the <code>higherEntry</code>, <code>lowerEntry</code>, <code>ceilingEntry</code>, or <code>floorEntry</code> methods. The <code>descendingMap</code> method even gives you an explicit method of <strong>reversing the traversal order</strong>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>64</span>
     </div>
     <div>
      <span>Answerer: </span> <span>ckpwong</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Sep 2008 at 22:27</span>
     </div>
    </div>
    <div>
     <p>FYI, you can also use <code>map.keySet()</code> and <code>map.values()</code> if you're only interested in keys/values of the map and not the other.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>63</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Chris Dail</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Sep 2008 at 19:48</span>
     </div>
    </div>
    <div>
     <p>The correct way to do this is to use the accepted answer as it is the most efficient. I find the following code looks a bit cleaner.</p>
     <pre><code>for (String key: map.keySet()) {
   System.out.println(key + "/" + map.get(key));
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>15</td>
        <td><span>This is not the best approach, it's much more efficient to use the entrySet(). Findbugs will flag this code (see <a href="http://findbugs.sourceforge.net/bugDescriptions.html#WMI_WRONG_MAP_ITERATOR" rel="nofollow noreferrer">findbugs.sourceforge.net/…</a>)</span> <span> - </span> <span class="display-name">Jeff Olson</span> <span> </span> <span class="date">6 Nov 2009 at 20:46</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>@JeffOlson meh, not really. map lookup is O(1) so both loops behave the same way. admittedly, it will be slightly slower in a micro benchmark but i sometimes do this as well because i hate writing the type arguments over and over again. Also this will quite likely never be your performance bottleneck, so go for it if it makes the code more readable.</span> <span> - </span> <span class="display-name">kritzikratzi</span> <span> </span> <span class="date">8 Oct 2012 at 13:25</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@kritzikratzi but with the entrySet() approach, you're doing one lookup for each element, whereas with the keySet()/get() approach, you're doing two lookups for each element. So in theory (haven't tested it), it is O(1) vs. 2 * O(1). Or twice as long. Right?</span> <span> - </span> <span class="display-name">Jeff Olson</span> <span> </span> <span class="date">8 Oct 2012 at 17:34</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>more in detail: <code>O(1) = 2*O(1)</code> is pretty much the definition of the big O notation. you're right in that it runs a bit slower, but in terms of complexity they're the same.</span> <span> - </span> <span class="display-name">kritzikratzi</span> <span> </span> <span class="date">8 Oct 2012 at 23:26</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Look up in map is O(1), really?))))) Where on Earth it is O(1)?))) HashMap: First - you must calculate hash, second - search in array by hash, third! - linear search through all elements wich has the same hashCode, this calls 'collision', don't you hear about it? =) And what can you say about: TreeMap, ConcurrentSkipListMap are they 'O(1)', too?</span> <span> - </span> <span class="display-name">kornero</span> <span> </span> <span class="date">3 Dec 2012 at 10:43</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@kornero good point, treemap lookup is O(log n), i only had hashmaps in mind (which are ~ O(1), collisions or not)</span> <span> - </span> <span class="display-name">kritzikratzi</span> <span> </span> <span class="date">22 Dec 2012 at 12:29</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@kritzikratzi collisions in hashmaps makes complexity ~ O(n), and there is "Denial of Service via Algorithmic Complexity Attacks" based on this, you can read more about it here: <a href="http://www.cs.rice.edu/~scrosby/hash/CrosbyWallach_UsenixSec2003/" rel="nofollow noreferrer">cs.rice.edu/~scrosby/hash/CrosbyWallach_UsenixSec2003</a></span> <span> - </span> <span class="display-name">kornero</span> <span> </span> <span class="date">23 Dec 2012 at 14:30</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>by collision or not i meant it doesn't matter if you a few collisions, obviously it's a different story if you have only collisions. so you're being pretty petty, but yep, what you're saying is true.</span> <span> - </span> <span class="display-name">kritzikratzi</span> <span> </span> <span class="date">23 Dec 2012 at 16:17</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@Jeff Olson: the comments that the “Big O” complexity doesn’t change, when there is only a constant factor, is correct. Still, to me it matters whether an operation takes one hour or two hours. More important, it must be emphasized that the factor is <b>not</b> <code>2</code>, as iterating over an <code>entrySet()</code> does not bear a lookup at all; it’s just a linear traversal of all entries. In contrast, iterating over the <code>keySet()</code> and performing a lookup per key bears <i>one</i> lookup per key, so we’re talking about zero lookups vs. <i>n</i> lookups here, <i>n</i> being the size of the <code>Map</code>. So the factor is way beyond <code>2</code>…</span> <span> - </span> <span class="display-name">Holger</span> <span> </span> <span class="date">9 Nov 2016 at 12:22</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@kornero: it might be worth noting that you don’t need the keys to have the same hashcode to have a collision; there’s already a collision when <code>hashcode % capacity</code> is the same. Starting with Java 8, the complexity for items having the same <code>hashcode % capacity</code>, but different <code>hashcode</code> or are <code>Comparable</code> falls back to <code>O(log n)</code> and only keys having the same hash code and not being <code>Comparable</code> impose <code>O(n)</code> complexity. But the statement that the complexity of a lookup can be more than <code>O(1)</code> in practice still holds.</span> <span> - </span> <span class="display-name">Holger</span> <span> </span> <span class="date">9 Nov 2016 at 12:35</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>57</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Taras Melnyk</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 May 2018 at 11:25</span>
     </div>
    </div>
    <div>
     <p>With <strong>Java 8</strong>, you can iterate Map using forEach and lambda expression,</p>
     <pre><code>map.forEach((k, v) -&gt; System.out.println((k + ":" + v)));
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>44</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Donald Raab</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Dec 2012 at 23:13</span>
     </div>
    </div>
    <div>
     <p>With <a href="https://github.com/eclipse/eclipse-collections" rel="nofollow noreferrer">Eclipse Collections</a>, you would use the <code>forEachKeyValue</code> method on the <a href="https://github.com/eclipse/eclipse-collections/blob/master/eclipse-collections-api/src/main/java/org/eclipse/collections/api/map/MapIterable.java" rel="nofollow noreferrer"><code>MapIterable</code></a> interface, which is inherited by the <code>MutableMap</code> and <code>ImmutableMap</code> interfaces and their implementations.</p>
     <pre><code>MutableMap&lt;Integer, String&gt; map = 
    Maps.mutable.of(1, "One", 2, "Two", 3, "Three");

MutableBag&lt;String&gt; result = Bags.mutable.empty();
map.forEachKeyValue((key, value) -&gt; result.add(key + value));

MutableBag&lt;String&gt; expected = Bags.mutable.of("1One", "2Two", "3Three");
Assertions.assertEquals(expected, result);
</code></pre>
     <p>The reason using <code>forEachKeyValue</code> with Eclipse Collections (EC) <code>Map</code> implementations will be more efficient than using <code>entrySet</code> is because EC <code>Map</code> implementations do not store <code>Map.Entry</code> objects. Using <code>entrySet</code> with EC <code>Map</code> implementations results in <code>Map.Entry</code> objects being generated dynamically. The <code>forEachKeyValue</code> method is able to avoid creating the <code>Map.Entry</code> objects because it can navigate the internal structure of the <code>Map</code> implementations directly. This is a case where there is a benefit of using an internal iterator over an external iterator.</p>
     <p><strong>Note:</strong> I am a committer for Eclipse Collections.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>43</span>
     </div>
     <div>
      <span>Answerer: </span> <span>akhil_mittal</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Sep 2015 at 01:00</span>
     </div>
    </div>
    <div>
     <h2>Java 8</h2>
     <p>We have got <code>forEach</code> method that accepts a <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" rel="noreferrer">lambda expression</a>. We have also got <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" rel="noreferrer">stream</a> APIs. Consider a map:</p>
     <pre><code>Map&lt;String,String&gt; sample = new HashMap&lt;&gt;();
sample.put("A","Apple");
sample.put("B", "Ball");
</code></pre>
     <p><strong>Iterate over keys:</strong></p>
     <pre><code>sample.keySet().forEach((k) -&gt; System.out.println(k));
</code></pre>
     <p><strong>Iterate over values:</strong></p>
     <pre><code>sample.values().forEach((v) -&gt; System.out.println(v));
</code></pre>
     <p><strong>Iterate over entries (Using forEach and Streams):</strong></p>
     <pre><code>sample.forEach((k,v) -&gt; System.out.println(k + ":" + v)); 
sample.entrySet().stream().forEach((entry) -&gt; {
            Object currentKey = entry.getKey();
            Object currentValue = entry.getValue();
            System.out.println(currentKey + ":" + currentValue);
        });
</code></pre>
     <p>The advantage with streams is they can be parallelized easily in case we want to. We simply need to use <code>parallelStream()</code> in place of <code>stream()</code> above.</p>
     <p><strong><code>forEachOrdered</code> vs <code>forEach</code> with streams ?</strong> The <code>forEach</code> does not follow encounter order (if defined) and is inherently non-deterministic in nature where as the <code>forEachOrdered</code> does. So <code>forEach</code> does not guarantee that the order would be kept. Also check <a href="https://stackoverflow.com/questions/32797579/foreach-vs-foreachordered-in-java-8-stream">this</a> for more.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>41</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Leigh Caldwell</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Sep 2008 at 21:18</span>
     </div>
    </div>
    <div>
     <p>In theory, the most efficient way will depend on which implementation of Map. The official way to do this is to call <code>map.entrySet()</code>, which returns a set of <code>Map.Entry</code>, each of which contains a key and a value (<code>entry.getKey()</code> and <code>entry.getValue()</code>).</p>
     <p>In an idiosyncratic implementation, it might make some difference whether you use <code>map.keySet()</code>, <code>map.entrySet()</code> or something else. But I can't think of a reason why anyone would write it like that. Most likely it makes no difference to performance what you do.</p>
     <p>And yes, the order will depend on the implementation - as well as (possibly) the order of insertion and other hard-to-control factors.</p>
     <p>[edit] I wrote <code>valueSet()</code> originally but of course <code>entrySet()</code> is actually the answer.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span> <span class="arrow"> <a href="#answer_15">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>39</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Nitin Mahesh</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Oct 2015 at 15:07</span>
     </div>
    </div>
    <div>
     <h2><strong>Lambda</strong> Expression Java 8</h2>
     <p>In Java 1.8 (Java 8) this has become lot easier by using <strong>forEach</strong> method from Aggregate operations(<strong>Stream operations</strong>) that looks similar to iterators from <strong>Iterable</strong> Interface.</p>
     <p>Just copy paste below statement to your code and rename the <strong>HashMap</strong> variable from <strong>hm</strong> to your HashMap variable to print out key-value pair.</p>
     <pre><code>HashMap&lt;Integer,Integer&gt; hm = new HashMap&lt;Integer, Integer&gt;();
/*
 *     Logic to put the Key,Value pair in your HashMap hm
 */

// Print the key value pair in one line.

hm.forEach((k, v) -&gt; System.out.println("key: " + k + " value:" + v));

// Just copy and paste above line to your code.
</code></pre>
     <p>Below is the sample code that I tried using <strong>Lambda Expression</strong>. This stuff is so cool. Must try.</p>
     <pre><code>HashMap&lt;Integer, Integer&gt; hm = new HashMap&lt;Integer, Integer&gt;();
    Random rand = new Random(47);
    int i = 0;
    while(i &lt; 5) {
        i++;
        int key = rand.nextInt(20);
        int value = rand.nextInt(50);
        System.out.println("Inserting key: " + key + " Value: " + value);
        Integer imap = hm.put(key, value);
        if( imap == null) {
            System.out.println("Inserted");
        } else {
            System.out.println("Replaced with " + imap);
        }               
    }

    hm.forEach((k, v) -&gt; System.out.println("key: " + k + " value:" + v));
    
Output:

Inserting key: 18 Value: 5
Inserted
Inserting key: 13 Value: 11
Inserted
Inserting key: 1 Value: 29
Inserted
Inserting key: 8 Value: 0
Inserted
Inserting key: 2 Value: 7
Inserted
key: 1 value:29
key: 18 value:5
key: 2 value:7
key: 8 value:0
key: 13 value:11
</code></pre>
     <p>Also one can use <strong>Spliterator</strong> for the same.</p>
     <pre><code>Spliterator sit = hm.entrySet().spliterator();
</code></pre>
     <p><strong>UPDATE</strong></p>
     <hr>
     <p>Including documentation links to Oracle Docs. For more on <strong>Lambda</strong> go to this <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" rel="nofollow noreferrer">link</a> and must read <a href="https://docs.oracle.com/javase/tutorial/collections/streams/" rel="nofollow noreferrer">Aggregate Operations</a> and for Spliterator go to this <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html" rel="nofollow noreferrer">link</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_15"><span>Answer 15</span> <span class="arrow"> <a href="#answer_14">↑</a> </span> <span class="arrow"> <a href="#answer_16">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>36</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Georgios Syngouroglou</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Aug 2014 at 10:30</span>
     </div>
    </div>
    <div>
     <p><strong>Java 8:</strong></p>
     <p>You can use lambda expressions:</p>
     <pre><code>myMap.entrySet().stream().forEach((entry) -&gt; {
    Object currentKey = entry.getKey();
    Object currentValue = entry.getValue();
});
</code></pre>
     <p>For more information, follow <a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" rel="noreferrer">this</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>@injecteer: Seems the motive of lambda expressions</span> <span> - </span> <span class="display-name">humblerookie</span> <span> </span> <span class="date">21 Aug 2014 at 19:49</span></td>
       </tr>
       <tr>
        <td>10</td>
        <td><span>You don’t need a stream if you just want to iterate over a map. <code>myMap.forEach( (currentKey,currentValue) -&gt; /* action */ );</code> is much more concise.</span> <span> - </span> <span class="display-name">Holger</span> <span> </span> <span class="date">9 Nov 2016 at 12:37</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_16"><span>Answer 16</span> <span class="arrow"> <a href="#answer_15">↑</a> </span> <span class="arrow"> <a href="#answer_17">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>31</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Rupesh Yadav</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Jan 2014 at 12:35</span>
     </div>
    </div>
    <div>
     <p>In Map one can Iteration over <code>keys</code> and/or <code>values</code> and/or <code>both (e.g., entrySet)</code> depends on one's interested in_ Like:</p>
     <ol>
      <li>
       <p>Iterate through the <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Map.html#keySet%28%29" rel="nofollow noreferrer"><code>keys -&gt; keySet()</code></a> of the map:</p>
       <pre><code> Map&lt;String, Object&gt; map = ...;

 for (String key : map.keySet()) {
     //your Business logic...
 }
</code></pre></li>
      <li>
       <p>Iterate through the <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Map.html#values%28%29" rel="nofollow noreferrer"><code>values -&gt; values()</code></a> of the map:</p>
       <pre><code> for (Object value : map.values()) {
     //your Business logic...
 }
</code></pre></li>
      <li>
       <p>Iterate through the <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Map.html#entrySet%28%29" rel="nofollow noreferrer"><code>both -&gt; entrySet()</code></a> of the map:</p>
       <pre><code> for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) {
     String key = entry.getKey();
     Object value = entry.getValue();
     //your Business logic...
 }
</code></pre></li>
     </ol>
     <p>Moreover, there are 3 different ways to iterate through a HashMap. They are as below:</p>
     <pre><code>//1.
for (Map.Entry entry : hm.entrySet()) {
    System.out.print("key,val: ");
    System.out.println(entry.getKey() + "," + entry.getValue());
}

//2.
Iterator iter = hm.keySet().iterator();
while(iter.hasNext()) {
    Integer key = (Integer)iter.next();
    String val = (String)hm.get(key);
    System.out.println("key,val: " + key + "," + val);
}

//3.
Iterator it = hm.entrySet().iterator();
while (it.hasNext()) {
    Map.Entry entry = (Map.Entry) it.next();
    Integer key = (Integer)entry.getKey();
    String val = (String)entry.getValue();
    System.out.println("key,val: " + key + "," + val);
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_17"><span>Answer 17</span> <span class="arrow"> <a href="#answer_16">↑</a> </span> <span class="arrow"> <a href="#answer_18">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>30</span>
     </div>
     <div>
      <span>Answerer: </span> <span>abods</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Feb 2010 at 06:10</span>
     </div>
    </div>
    <div>
     <p>Try this with Java 1.4:</p>
     <pre><code>for( Iterator entries = myMap.entrySet().iterator(); entries.hasNext();){

  Entry entry = (Entry) entries.next();

  System.out.println(entry.getKey() + "/" + entry.getValue());

  //...
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_18"><span>Answer 18</span> <span class="arrow"> <a href="#answer_17">↑</a> </span> <span class="arrow"> <a href="#answer_19">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>27</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Witold Kaczurba</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Oct 2016 at 10:56</span>
     </div>
    </div>
    <div>
     <p>The ordering will always depend on the specific map implementation. Using Java&nbsp;8 you can use either of these:</p>
     <pre><code>map.forEach((k,v) -&gt; { System.out.println(k + ":" + v); });
</code></pre>
     <p>Or:</p>
     <pre><code>map.entrySet().forEach((e) -&gt; {
            System.out.println(e.getKey() + " : " + e.getValue());
        });
</code></pre>
     <p>The result will be the same (same order). The entrySet backed by the map so you are getting the same order. The second one is handy as it allows you to use lambdas, e.g. if you want only to print only Integer objects that are greater than 5:</p>
     <pre><code>map.entrySet()
    .stream()
    .filter(e-&gt; e.getValue() &gt; 5)
    .forEach(System.out::println);
</code></pre>
     <p>The code below shows iteration through LinkedHashMap and normal HashMap (example). You will see difference in the order:</p>
     <pre><code>public class HMIteration {


    public static void main(String[] args) {
        Map&lt;Object, Object&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();
        Map&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();

        for (int i=10; i&gt;=0; i--) {
            linkedHashMap.put(i, i);
            hashMap.put(i, i);
        }

        System.out.println("LinkedHashMap (1): ");
        linkedHashMap.forEach((k,v) -&gt; { System.out.print(k + " (#="+k.hashCode() + "):" + v + ", "); });

        System.out.println("\nLinkedHashMap (2): ");

        linkedHashMap.entrySet().forEach((e) -&gt; {
            System.out.print(e.getKey() + " : " + e.getValue() + ", ");
        });


        System.out.println("\n\nHashMap (1): ");
        hashMap.forEach((k,v) -&gt; { System.out.print(k + " (#:"+k.hashCode() + "):" + v + ", "); });

        System.out.println("\nHashMap (2): ");

        hashMap.entrySet().forEach((e) -&gt; {
            System.out.print(e.getKey() + " : " + e.getValue() + ", ");
        });
    }
}
</code></pre>
     <p>Output:</p>
     <pre><code>LinkedHashMap (1):
10 (#=10):10, 9 (#=9):9, 8 (#=8):8, 7 (#=7):7, 6 (#=6):6, 5 (#=5):5, 4 (#=4):4, 3 (#=3):3, 2 (#=2):2, 1 (#=1):1, 0 (#=0):0,
LinkedHashMap (2):
10 : 10, 9 : 9, 8 : 8, 7 : 7, 6 : 6, 5 : 5, 4 : 4, 3 : 3, 2 : 2, 1 : 1, 0 : 0,
HashMap (1):
0 (#:0):0, 1 (#:1):1, 2 (#:2):2, 3 (#:3):3, 4 (#:4):4, 5 (#:5):5, 6 (#:6):6, 7 (#:7):7, 8 (#:8):8, 9 (#:9):9, 10 (#:10):10,
HashMap (2):
0 : 0, 1 : 1, 2 : 2, 3 : 3, 4 : 4, 5 : 5, 6 : 6, 7 : 7, 8 : 8, 9 : 9, 10 : 10,
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_19"><span>Answer 19</span> <span class="arrow"> <a href="#answer_18">↑</a> </span> <span class="arrow"> <a href="#answer_20">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>25</span>
     </div>
     <div>
      <span>Answerer: </span> <span>bluehallu</span>
     </div>
     <div>
      <span> Answered: </span> <span>19 Apr 2018 at 12:32</span>
     </div>
    </div>
    <div>
     <p>Most compact with Java 8:</p>
     <pre><code>map.entrySet().forEach(System.out::println);
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_20"><span>Answer 20</span> <span class="arrow"> <a href="#answer_19">↑</a> </span> <span class="arrow"> <a href="#answer_21">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>24</span>
     </div>
     <div>
      <span>Answerer: </span> <span>anand krish</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Sep 2021 at 15:35</span>
     </div>
    </div>
    <div>
     <p>These are all the possible ways of iterating HashMap.</p>
     <pre><code>HashMap&lt;Integer,String&gt; map=new HashMap&lt;Integer,String&gt;();
    map.put(1,"David");  //Adding elements in Map
    map.put(2,"John");
    map.put(4,"Samyuktha");
    map.put(3,"jasmin");
    System.out.println("Iterating Hashmap...");

    //way 1 (java 8 Method)
    map.forEach((key, value) -&gt; {
        System.out.println(key+" : "+ value);
    });

    //way 2 (java 7 Method)
    for(Map.Entry me : map.entrySet()){
        System.out.println(me.getKey()+" "+me.getValue());
    }
    //way 3 (java 6 Method)
    for (Integer key : map.keySet()) {
        System.out.println(map.get(key));
    }

    //way 4 (Legacy way to iterate HashMap)
    Iterator iterator = map.entrySet().iterator();//map.keySet().iterator()
    while (iterator.hasNext())
    {
        Map.Entry me =(Map.Entry)iterator.next();
        System.out.println(me.getKey()+" : "+ me.getValue());
    }
    
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_21"><span>Answer 21</span> <span class="arrow"> <a href="#answer_20">↑</a> </span> <span class="arrow"> <a href="#answer_22">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>23</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Basil Bourque</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Oct 2019 at 19:44</span>
     </div>
    </div>
    <div>
     <blockquote>
      <p>If I have an object implementing the Map interface in Java and I wish to iterate over every pair contained within it, what is the most efficient way of going through the map?</p>
     </blockquote>
     <p>If efficiency of looping the keys is a priority for your app, then choose a <code>Map</code> implementation that maintains the keys in your desired order.</p>
     <blockquote>
      <p>Will the ordering of elements depend on the specific map implementation that I have for the interface?</p>
     </blockquote>
     <p>Yes, absolutely.</p>
     <ul>
      <li>Some <code>Map</code> implementations promise a certain iteration order, others do not.</li>
      <li>Different implementations of <code>Map</code> maintain different ordering of the key-value pairs.</li>
     </ul>
     <p>See this table I created summarizing the various <code>Map</code> implementations bundled with Java 11. Specifically, notice the <em>iteration order</em> column. Click/tap to zoom.</p>
     <p><a href="https://i.stack.imgur.com/4z5Fb.png" rel="noreferrer"><img src="4z5Fb.png" alt="Table of map implementations in Java 11, comparing their features"></a></p>
     <p>You can see there are <strong>four <code>Map</code> implementations maintaining an order</strong>:</p>
     <ul>
      <li><code>TreeMap</code></li>
      <li><code>ConcurrentSkipListMap</code></li>
      <li><code>LinkedHashMap</code></li>
      <li><code>EnumMap</code></li>
     </ul>
     <h2><code>NavigableMap</code> interface</h2>
     <p>Two of those implement the <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/NavigableMap.html" rel="noreferrer"><code>NavigableMap</code></a> interface: <code>TreeMap</code> &amp; <code>ConcurrentSkipListMap</code>.</p>
     <p>The older <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/SortedMap.html" rel="noreferrer"><code>SortedMap</code></a> interface is effectively supplanted by the newer <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/NavigableMap.html" rel="noreferrer"><code>NavigableMap</code></a> interface. But you may find 3rd-party implementations implementing the older interface only.</p>
     <h2>Natural order</h2>
     <p>If you want a <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html" rel="noreferrer"><code>Map</code></a> that keeps its pairs arranged by the “natural order” of the key, use <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/TreeMap.html" rel="noreferrer"><code>TreeMap</code></a> or <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentSkipListMap.html" rel="noreferrer"><code>ConcurrentSkipListMap</code></a>. The term “natural order” means the class of the keys implements <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Comparable.html" rel="noreferrer"><code>Comparable</code></a>. The value returned by the <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Comparable.html#compareTo(T)" rel="noreferrer"><code>compareTo</code></a> method is used for comparison in sorting.</p>
     <h2>Custom order</h2>
     <p>If you want to specify a custom sorting routine for your keys to be used in maintaining a sorted order, pass a <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Comparator.html" rel="noreferrer"><code>Comparator</code></a> implementation appropriate to the class of your keys. Use either <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/TreeMap.html" rel="noreferrer"><code>TreeMap</code></a> or <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentSkipListMap.html" rel="noreferrer"><code>ConcurrentSkipListMap</code></a>, passing your <code>Comparator</code>.</p>
     <h2>Original insertion order</h2>
     <p>If you want the pairs of your map to be kept in their original order in which you inserted them into the map, use <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/LinkedHashMap.html" rel="noreferrer"><code>LinkedHashMap</code></a>.</p>
     <h2>Enum-definition order</h2>
     <p>If you are using an enum such as <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/DayOfWeek.html" rel="noreferrer"><code>DayOfWeek</code></a> or <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/Month.html" rel="noreferrer"><code>Month</code></a> as your keys, use the <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/EnumMap.html" rel="noreferrer"><code>EnumMap</code></a> class. Not only is this class <em>highly</em> optimized to use very little memory and run very fast, it maintains your pairs in the order defined by the enum. For <code>DayOfWeek</code>, for example, the key of <code>DayOfWeek.MONDAY</code> will be first found when iterated, and the key of <code>DayOfWeek.SUNDAY</code> will be last.</p>
     <h2>Other considerations</h2>
     <p>In choosing a <code>Map</code> implementation, also consider:</p>
     <ul>
      <li>NULLs. Some implementations forbid/accept a NULL as key and/or value.</li>
      <li>Concurrency. If you are manipulating the map across threads, you must use an implementation that supports concurrency. Or wrap the map with <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collections.html#synchronizedMap(java.util.Map)" rel="noreferrer"><code>Collections::synchronizedMap</code></a> (less preferable).</li>
     </ul>
     <p>Both of these considerations are covered in the graphic table above.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>Late comment on an answer that's also late to the party (but very informative). +1 from me for mentioning <code>EnumMap</code>, since it's the first time I've heard of it. There's probably many cases where this might come in handy.</span> <span> - </span> <span class="display-name">filpa</span> <span> </span> <span class="date">16 Feb 2020 at 18:42</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_22"><span>Answer 22</span> <span class="arrow"> <a href="#answer_21">↑</a> </span> <span class="arrow"> <a href="#answer_23">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>22</span>
     </div>
     <div>
      <span>Answerer: </span> <span>dmunozfer</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Nov 2013 at 12:53</span>
     </div>
    </div>
    <div>
     <p>If you have a generic untyped Map you can use:</p>
     <pre><code>Map map = new HashMap();
for (Map.Entry entry : ((Set&lt;Map.Entry&gt;) map.entrySet())) {
    System.out.println(entry.getKey() + "/" + entry.getValue());
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_23"><span>Answer 23</span> <span class="arrow"> <a href="#answer_22">↑</a> </span> <span class="arrow"> <a href="#answer_24">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>21</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Fathah Rehman P</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 May 2012 at 09:21</span>
     </div>
    </div>
    <div>
     <pre><code>public class abcd{
    public static void main(String[] args)
    {
       Map&lt;Integer, String&gt; testMap = new HashMap&lt;Integer, String&gt;();
        testMap.put(10, "a");
        testMap.put(20, "b");
        testMap.put(30, "c");
        testMap.put(40, "d");
        for (Integer key:testMap.keySet()) {
            String value=testMap.get(key);
            System.out.println(value);
        }
    }
}
</code></pre>
     <p>OR</p>
     <pre><code>public class abcd {
    public static void main(String[] args)
    {
       Map&lt;Integer, String&gt; testMap = new HashMap&lt;Integer, String&gt;();
        testMap.put(10, "a");
        testMap.put(20, "b");
        testMap.put(30, "c");
        testMap.put(40, "d");
        for (Entry&lt;Integer, String&gt; entry : testMap.entrySet()) {
            Integer key=entry.getKey();
            String value=entry.getValue();
        }
    }
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_24"><span>Answer 24</span> <span class="arrow"> <a href="#answer_23">↑</a> </span> <span class="arrow"> <a href="#answer_25">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>17</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Fadid</span>
     </div>
     <div>
      <span> Answered: </span> <span>19 Mar 2014 at 17:34</span>
     </div>
    </div>
    <div>
     <pre><code>    Iterator iterator = map.entrySet().iterator();
    while (iterator.hasNext()) {
        Map.Entry element = (Map.Entry)it.next();
        LOGGER.debug("Key: " + element.getKey());
        LOGGER.debug("value: " + element.getValue());    
    }
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_25"><span>Answer 25</span> <span class="arrow"> <a href="#answer_24">↑</a> </span> <span class="arrow"> <a href="#answer_26">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>15</span>
     </div>
     <div>
      <span>Answerer: </span> <span>anandchaugule</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Nov 2018 at 10:24</span>
     </div>
    </div>
    <div>
     <p>An effective iterative solution over a Map is a <code>for</code> loop from Java 5 through Java 7. Here it is:</p>
     <pre><code>for (String key : phnMap.keySet()) {
    System.out.println("Key: " + key + " Value: " + phnMap.get(key));
}
</code></pre>
     <p>From Java 8 you can use a lambda expression to iterate over a Map. It is an enhanced <code>forEach</code></p>
     <pre><code>phnMap.forEach((k,v) -&gt; System.out.println("Key: " + k + " Value: " + v));
</code></pre>
     <p>If you want to write a conditional for lambda you can write it like this:</p>
     <pre><code>phnMap.forEach((k,v)-&gt;{
    System.out.println("Key: " + k + " Value: " + v);
    if("abc".equals(k)){
        System.out.println("Hello abc");
    }
});
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_26"><span>Answer 26</span> <span class="arrow"> <a href="#answer_25">↑</a> </span> <span class="arrow"> <a href="#answer_27">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>14</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Learner</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Jul 2013 at 12:54</span>
     </div>
    </div>
    <div>
     <p>You can do it using generics:</p>
     <pre><code>Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet().iterator();
while (entries.hasNext()) {
    Map.Entry&lt;Integer, Integer&gt; entry = entries.next();
    System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue());
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_27"><span>Answer 27</span> <span class="arrow"> <a href="#answer_26">↑</a> </span> <span class="arrow"> <a href="#answer_28">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>14</span>
     </div>
     <div>
      <span>Answerer: </span> <span>ABHAY JOHRI</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Apr 2018 at 18:46</span>
     </div>
    </div>
    <div>
     <p>Use Java 8:</p>
     <pre><code>map.entrySet().forEach(entry -&gt; System.out.println(entry.getValue()));
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_28"><span>Answer 28</span> <span class="arrow"> <a href="#answer_27">↑</a> </span> <span class="arrow"> <a href="#answer_29">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>13</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Sajad NasiriNezhad</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 Apr 2016 at 07:47</span>
     </div>
    </div>
    <div>
     <pre><code>           //Functional Oprations
            Map&lt;String, String&gt; mapString = new HashMap&lt;&gt;();
            mapString.entrySet().stream().map((entry) -&gt; {
                String mapKey = entry.getKey();
                return entry;
            }).forEach((entry) -&gt; {
                String mapValue = entry.getValue();
            });

            //Intrator
            Map&lt;String, String&gt; mapString = new HashMap&lt;&gt;();
            for (Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = mapString.entrySet().iterator(); it.hasNext();) {
                Map.Entry&lt;String, String&gt; entry = it.next();
                String mapKey = entry.getKey();
                String mapValue = entry.getValue();
            }

            //Simple for loop
            Map&lt;String, String&gt; mapString = new HashMap&lt;&gt;();
            for (Map.Entry&lt;String, String&gt; entry : mapString.entrySet()) {
                String mapKey = entry.getKey();
                String mapValue = entry.getValue();

            }
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_29"><span>Answer 29</span> <span class="arrow"> <a href="#answer_28">↑</a> </span> <span class="arrow"> <a href="#answer_30">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>11</span>
     </div>
     <div>
      <span>Answerer: </span> <span>shivampip</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Nov 2017 at 14:18</span>
     </div>
    </div>
    <div>
     <p>Iterating a <a href="https://docs.oracle.com/javase/10/docs/api/java/util/Map.html" rel="noreferrer">Map</a> is very easy.</p>
     <pre><code>for(Object key: map.keySet()){
   Object value= map.get(key);
   //Do your stuff
}
</code></pre>
     <p>For instance, you have a <code>Map&lt;String, int&gt; data;</code></p>
     <pre><code>for(Object key: data.keySet()){
  int value= data.get(key);
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>Well, this is unnecessarily slow because first get the keys and then the entries. Alternative: Get the entrySets and then for each entryset the key and the value</span> <span> - </span> <span class="display-name">michaeak</span> <span> </span> <span class="date">12 Dec 2018 at 12:00</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_30"><span>Answer 30</span> <span class="arrow"> <a href="#answer_29">↑</a> </span> <span class="arrow"> <a href="#answer_31">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>11</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Utpal Kumar</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 Nov 2017 at 03:52</span>
     </div>
    </div>
    <div>
     <p>There are a lot of ways to do this. Below is a few simple steps:</p>
     <p>Suppose you have one Map like:</p>
     <pre><code>Map&lt;String, Integer&gt; m = new HashMap&lt;String, Integer&gt;();
</code></pre>
     <p>Then you can do something like the below to iterate over map elements.</p>
     <pre><code>// ********** Using an iterator ****************
Iterator&lt;Entry&lt;String, Integer&gt;&gt; me = m.entrySet().iterator();
while(me.hasNext()){
    Entry&lt;String, Integer&gt; pair = me.next();
    System.out.println(pair.getKey() + ":" + pair.getValue());
}

// *********** Using foreach ************************
for(Entry&lt;String, Integer&gt; me : m.entrySet()){
    System.out.println(me.getKey() + " : " + me.getValue());
}

// *********** Using keySet *****************************
for(String s : m.keySet()){
    System.out.println(s + " : " + m.get(s));
}

// *********** Using keySet and iterator *****************
Iterator&lt;String&gt; me = m.keySet().iterator();
while(me.hasNext()){
    String key = me.next();
    System.out.println(key + " : " + m.get(key));
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_31"><span>Answer 31</span> <span class="arrow"> <a href="#answer_30">↑</a> </span> <span class="arrow"> <a href="#answer_32">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>10</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Suresh Atta</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Mar 2013 at 19:33</span>
     </div>
    </div>
    <div>
     <p>Yes, as many people agreed this is the best way to iterate over a <code>Map</code>.</p>
     <p>But there are chances to throw <code>nullpointerexception</code> if the map is <code>null</code>. Don't forget to put <code>null</code> .check in.</p>
     <pre><code>                                                 |
                                                 |
                                         - - - -
                                       |
                                       |
for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) {
    String key = entry.getKey();
    Object value = entry.getValue();
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_32"><span>Answer 32</span> <span class="arrow"> <a href="#answer_31">↑</a> </span> <span class="arrow"> <a href="#answer_33">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>9</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Rupendra Sharma</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Apr 2017 at 06:36</span>
     </div>
    </div>
    <div>
     <pre><code>package com.test;

import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

public class Test {

    public static void main(String[] args) {
        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
        map.put("ram", "ayodhya");
        map.put("krishan", "mathura");
        map.put("shiv", "kailash");

        System.out.println("********* Keys *********");
        Set&lt;String&gt; keys = map.keySet();
        for (String key : keys) {
            System.out.println(key);
        }

        System.out.println("********* Values *********");
        Collection&lt;String&gt; values = map.values();
        for (String value : values) {
            System.out.println(value);
        }

        System.out.println("***** Keys and Values (Using for each loop) *****");
        for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) {
            System.out.println("Key: " + entry.getKey() + "\t Value: "
                    + entry.getValue());
        }

        System.out.println("***** Keys and Values (Using while loop) *****");
        Iterator&lt;Entry&lt;String, String&gt;&gt; entries = map.entrySet().iterator();
        while (entries.hasNext()) {
            Map.Entry&lt;String, String&gt; entry = (Map.Entry&lt;String, String&gt;) entries
                    .next();
            System.out.println("Key: " + entry.getKey() + "\t Value: "
                    + entry.getValue());
        }

        System.out
                .println("** Keys and Values (Using java 8 using lambdas )***");
        map.forEach((k, v) -&gt; System.out
                .println("Key: " + k + "\t value: " + v));
    }
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_33"><span>Answer 33</span> <span class="arrow"> <a href="#answer_32">↑</a> </span> <span class="arrow"> <a href="#answer_34">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ali Akram</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Jan 2020 at 07:44</span>
     </div>
    </div>
    <div>
     <h1><code>Map.forEach</code></h1>
     <p>What about simply using <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html#forEach(java.util.function.BiConsumer)" rel="noreferrer"><code>Map::forEach</code></a> where both the key and the value are passed to your <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/BiConsumer.html" rel="noreferrer"><code>BiConsumer</code></a>?</p>
     <pre><code>map.forEach((k,v)-&gt;{
    System.out.println(k+"-&gt;"+v);
});
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>This was covered in the <a href="https://stackoverflow.com/a/57321787/642706">Answer by Lova Chittumuri</a>. Also covered as item # 3 in the highly-upvoted <a href="https://stackoverflow.com/a/35558955/642706">Answer by Viacheslav Vedenin</a>.</span> <span> - </span> <span class="display-name">Basil Bourque</span> <span> </span> <span class="date">6 Jan 2020 at 07:51</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>But only available in API label 24</span> <span> - </span> <span class="display-name">Mahbubur Rahman Khan</span> <span> </span> <span class="date">5 Mar 2020 at 22:02</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_34"><span>Answer 34</span> <span class="arrow"> <a href="#answer_33">↑</a> </span> <span class="arrow"> <a href="#answer_35">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mr. Polywhirl</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 May 2015 at 12:37</span>
     </div>
    </div>
    <div>
     <p>Here is a generic type-safe method which can be called to dump any given <code>Map</code>.</p>
     <pre><code>import java.util.Iterator;
import java.util.Map;

public class MapUtils {
    static interface ItemCallback&lt;K, V&gt; {
        void handler(K key, V value, Map&lt;K, V&gt; map);
    }

    public static &lt;K, V&gt; void forEach(Map&lt;K, V&gt; map, ItemCallback&lt;K, V&gt; callback) {
        Iterator&lt;Map.Entry&lt;K, V&gt;&gt; it = map.entrySet().iterator();

        while (it.hasNext()) {
            Map.Entry&lt;K, V&gt; entry = it.next();

            callback.handler(entry.getKey(), entry.getValue(), map);
        }
    }

    public static &lt;K, V&gt; void printMap(Map&lt;K, V&gt; map) {
        forEach(map, new ItemCallback&lt;K, V&gt;() {
            @Override
            public void handler(K key, V value, Map&lt;K, V&gt; map) {
                System.out.println(key + " = " + value);
            }
        });
    }
}
</code></pre>
     <h2>Example</h2>
     <p>Here is an example of its use. Notice that the type of the <code>Map</code> is inferred by the method.</p>
     <pre><code>import java.util.*;

public class MapPrinter {
    public static void main(String[] args) {
        List&lt;Map&lt;?, ?&gt;&gt; maps = new ArrayList&lt;Map&lt;?, ?&gt;&gt;() {
            private static final long serialVersionUID = 1L;
            {
                add(new LinkedHashMap&lt;String, Integer&gt;() {
                    private static final long serialVersionUID = 1L;
                    {
                        put("One", 0);
                        put("Two", 1);
                        put("Three", 3);
                    }
                });

                add(new LinkedHashMap&lt;String, Object&gt;() {
                    private static final long serialVersionUID = 1L;
                    {
                        put("Object", new Object());
                        put("Integer", new Integer(0));
                        put("Double", new Double(0.0));
                    }
                });
            }
        };

        for (Map&lt;?, ?&gt; map : maps) {
            MapUtils.printMap(map);
            System.out.println();
        }
    }
}
</code></pre>
     <h2>Output</h2>
     <pre><code>One = 0
Two = 1
Three = 3

Object = java.lang.Object@15db9742
Integer = 0
Double = 0.0
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_35"><span>Answer 35</span> <span class="arrow"> <a href="#answer_34">↑</a> </span> <span class="arrow"> <a href="#answer_36">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Younes El Ouarti</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Jun 2020 at 21:19</span>
     </div>
    </div>
    <div>
     <p>Since Java 10, you can use local variable inference (a.k.a. "var") to make a lot of the already available answers less bloated. For example:</p>
     <pre class="lang-java prettyprint-override"><code>for (var entry : map.entrySet()) {
    System.out.println(entry.getKey() + " : " + entry.getValue());
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_36"><span>Answer 36</span> <span class="arrow"> <a href="#answer_35">↑</a> </span> <span class="arrow"> <a href="#answer_37">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>J.B.Vala</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Jan 2014 at 12:28</span>
     </div>
    </div>
    <div>
     <p>There are several ways to iterate a map. Please refer to the following code.</p>
     <p>When you iterate a map using iterator Interface you must go with <code>Entry&lt;K,V&gt;</code> or <code>entrySet()</code>.</p>
     <p>It looks like this:</p>
     <pre class="lang-java prettyprint-override"><code>    import java.util.*;
    import java.util.HashMap;
    import java.util.Iterator;
    import java.util.Map;

    public class IteratMapDemo{

        public static void main(String arg[]){
            Map&lt;String, String&gt; mapOne = new HashMap&lt;String, String&gt;();
            mapOne.put("1", "January");
            mapOne.put("2", "February");
            mapOne.put("3", "March");
            mapOne.put("4", "April");
            mapOne.put("5", "May");
            mapOne.put("6", "June");
            mapOne.put("7", "July");
            mapOne.put("8", "August");
            mapOne.put("9", "September");
            mapOne.put("10", "Octomber");
            mapOne.put("11", "November");
            mapOne.put("12", "December");

            Iterator it = mapOne.entrySet().iterator();
            while(it.hasNext())
            {
                Map.Entry me = (Map.Entry) it.next();
                //System.out.println("Get Key through While loop = " + me.getKey());
            }
            for(Map.Entry&lt;String, String&gt; entry:mapOne.entrySet()){
                //System.out.println(entry.getKey() + "=" + entry.getValue());
            }

            for (Object key : mapOne.keySet()) {
                System.out.println("Key: " + key.toString() + " Value: " +
                                   mapOne.get(key));
            }
        }
    }
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>keySet() is slow</span> <span> - </span> <span class="display-name">edin-m</span> <span> </span> <span class="date">29 Nov 2019 at 03:38</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_37"><span>Answer 37</span> <span class="arrow"> <a href="#answer_36">↑</a> </span> <span class="arrow"> <a href="#answer_38">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>tomaj</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Aug 2015 at 17:11</span>
     </div>
    </div>
    <div>
     <p>If your reason for iterating trough the <code>Map</code>, is to do an operation on the value and write to a resulting <code>Map</code>. I recommend using the <code>transform</code>-methods in the <a href="https://github.com/google/guava" rel="noreferrer">Google Guava</a> <code>Maps</code> class.</p>
     <pre><code>import com.google.common.collect.Maps;
</code></pre>
     <p>After you have added the <code>Maps</code> to your imports, you can use <code>Maps.transformValues</code> and <code>Maps.transformEntries</code> on your maps, like this:</p>
     <pre><code>public void transformMap(){
    Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
    map.put("a", 2);
    map.put("b", 4);

    Map&lt;String, Integer&gt; result = Maps.transformValues(map, num -&gt; num * 2);
    result.forEach((key, val) -&gt; print(key, Integer.toString(val)));
    // key=a,value=4
    // key=b,value=8

    Map&lt;String, String&gt; result2 = Maps.transformEntries(map, (key, value) -&gt; value + "[" + key + "]");
    result2.forEach(this::print);
    // key=a,value=2[a]
    // key=b,value=4[b]
}

private void print(String key, String val){
    System.out.println("key=" + key + ",value=" + val);
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_38"><span>Answer 38</span> <span class="arrow"> <a href="#answer_37">↑</a> </span> <span class="arrow"> <a href="#answer_39">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user1098063</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Jun 2019 at 19:56</span>
     </div>
    </div>
    <div>
     <p>I like to concat a counter, then save the final value of the counter;</p>
     <pre><code>int counter = 0;
HashMap&lt;String, String&gt; m = new HashMap&lt;String, String&gt;();
for(int i = 0;i&lt;items.length;i++)
{
m.put("firstname"+i, items.get(i).getFirstName());
counter = i;
}

m.put("recordCount",String.valueOf(counter));
</code></pre>
     <p>Then when you want to retrieve:</p>
     <pre><code>int recordCount = Integer.parseInf(m.get("recordCount"));
for(int i =0 ;i&lt;recordCount;i++)
{
System.out.println("First Name :" + m.get("firstname"+i));
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_39"><span>Answer 39</span> <span class="arrow"> <a href="#answer_38">↑</a> </span> <span class="arrow"> <a href="#answer_40">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Lova Chittumuri</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Aug 2019 at 07:30</span>
     </div>
    </div>
    <div>
     <blockquote>
      <p>Using Java 7</p>
     </blockquote>
     <pre><code>Map&lt;String,String&gt; sampleMap = new HashMap&lt;&gt;();
for (sampleMap.Entry&lt;String,String&gt; entry : sampleMap.entrySet()) {
    String key = entry.getKey();
    String value = entry.getValue();

    /* your Code as per the Business Justification  */

}
</code></pre>
     <blockquote>
      <p>Using Java 8</p>
     </blockquote>
     <pre><code>Map&lt;String,String&gt; sampleMap = new HashMap&lt;&gt;();

sampleMap.forEach((k, v) -&gt; System.out.println("Key is :  " + k + " Value is :  " + v));
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_40"><span>Answer 40</span> <span class="arrow"> <a href="#answer_39">↑</a> </span> <span class="arrow"> <a href="#answer_41">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Badri Paudel</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Jan 2021 at 16:04</span>
     </div>
    </div>
    <div>
     <p>You can search for the key and with the help of the key you can find the associated value of the map as map has <strong>unique key</strong>, see what happens when key is duplicate <a href="https://stackoverflow.com/a/20537942/9898251">here</a> or <a href="https://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html#put%28K,%20V%29" rel="nofollow noreferrer">here</a>.</p>
     <p>Demo map :</p>
     <pre><code> Map&lt;String, String&gt; map = new HashMap();
  map.put("name", "Name");
  map.put("age", "23");
  map.put("address", "NP");
  map.put("faculty", "BE");
  map.put("major", "CS");
  map.put("head", "MDK");
 
</code></pre>
     <p>To get key only, you can use <code>map.keySet();</code> like this :</p>
     <pre><code>for(String key : map.keySet()) {
      System.out.println(key);
  }
</code></pre>
     <p>To get value only , you can use <code>map.values();</code> like this:</p>
     <pre><code>      for(String value : map.values()) {
      System.out.println(value);
  }
</code></pre>
     <p>To get both key and its value you still can use <code>map.keySet();</code> and get its corresponding value, like this :</p>
     <pre><code> //this prints the key value pair
  for (String k : map.keySet()) {
        System.out.println(k + " " + map.get(k) + " ");
    }
</code></pre>
     <p><code>map.get(key)</code> gives the value pointed by that key.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_41"><span>Answer 41</span> <span class="arrow"> <a href="#answer_40">↑</a> </span> <span class="arrow"> <a href="#answer_42">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>JohnK</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Jan 2015 at 00:22</span>
     </div>
    </div>
    <div>
     <p>It doesn't quite answer the OP's question, but might be useful to others who find this page:</p>
     <p>If you only need the values and not the keys, you can do this:</p>
     <pre><code>Map&lt;Ktype, Vtype&gt; myMap = [...];
for (Vtype v: myMap.values()) {
  System.out.println("value: " + v);
}
</code></pre>
     <p><code>Ktype</code>, <code>Vtype</code> are pseudocode.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_42"><span>Answer 42</span> <span class="arrow"> <a href="#answer_41">↑</a> </span> <span class="arrow"> <a href="#answer_43">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Syd Lambert</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Oct 2015 at 18:09</span>
     </div>
    </div>
    <div>
     <p>If you want to iterate through the map in the order that the elements were added, use <code>LinkedHashMap</code> as opposed to just <code>Map</code>.</p>
     <p>This approach has worked for me in the past:</p>
     <pre><code>LinkedHashMap&lt;String,Integer&gt; test=new LinkedHashMap();

test.put("foo",69);
test.put("bar",1337);

for(int i=0;i&lt;test.size();i++){
    System.out.println(test.get(test.keySet().toArray()[i]));
}
</code></pre>
     <p>Output:</p>
     <pre><code>69
1337
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_43"><span>Answer 43</span> <span class="arrow"> <a href="#answer_42">↑</a> </span> <span class="arrow"> <a href="#answer_44">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Dubstep</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Sep 2020 at 22:53</span>
     </div>
    </div>
    <div>
     <pre><code>Map&lt;String, String&gt; map = 
for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) {
    MapKey = entry.getKey() 
    MapValue = entry.getValue();
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_44"><span>Answer 44</span> <span class="arrow"> <a href="#answer_43">↑</a> </span> <span class="arrow"> <a href="#answer_45">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>fechidal89</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Aug 2014 at 22:15</span>
     </div>
    </div>
    <div>
     <p>I copied the data of a map to another with this code:</p>
     <pre><code>HashMap product =(HashMap)shopping_truck.get(i);
HashMap tmp = new HashMap();
for (Iterator it = product.entrySet().iterator(); it.hasNext();) {
    Map.Entry thisEntry = (Map.Entry) it.next();
    tmp.put(thisEntry.getKey(), thisEntry.getValue());
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_45"><span>Answer 45</span> <span class="arrow"> <a href="#answer_44">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Joshua Michael Calafell</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 May 2015 at 19:08</span>
     </div>
    </div>
    <div>
     <p>This is the easiest way of doing it I believe...</p>
     <pre><code>/* For example, this could be a map object */
Map&lt;String, Integer&gt; MAP = new Map&lt;&gt;();

// Do something like put keys/value pairs into the map, etc...
MAP.put("Denver", 35);
MAP.put("Patriots", 14);

/* Then, simply use a for each loop like this to iterate */
for (Object o : MAP.entrySet()) {
    Map.Entry pair = (Map.Entry) o;
    // Do whatever with the pair here (i.e. pair.getKey(), or pair.getValue();
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>