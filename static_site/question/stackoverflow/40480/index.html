<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>Is Java "pass-by-reference" or "pass-by-value"?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>Is Java "pass-by-reference" or "pass-by-value"?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>7697</span>
    </div>
    <div>
     <span>Asker: </span> <span>user4315</span>
    </div>
    <div>
     <span>Asked: </span> <span>2 Sep 2008 at 20:14</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/40480">source</a>
    </div>
   </div>
   <div>
    <p>I always thought Java uses <strong>pass-by-reference</strong>. However, I read <a href="http://javadude.com/articles/passbyvalue.htm" rel="noreferrer">a blog post</a> which claims that Java uses <strong>pass-by-value</strong>. I don't think I understand the distinction the author is making.</p>
    <p>What is the explanation?</p>
   </div>
   <div class="tags">
    <span class="tag">java</span><span class="tag">methods</span><span class="tag">parameter-passing</span><span class="tag">pass-by-reference</span><span class="tag">pass-by-value</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>6</td>
       <td><span>We would more commonly say that a variable "passed-by-reference" can be mutated. The term appears in textbooks because language theorists needed a way to distinguish how you treat primitive data types (int, bool, byte) from complex and structured objects (array, streams, class) -- that is to say, those of possibly unbounded memory allocation.</span> <span> - </span> <span class="display-name">jlau</span> <span> </span> <span class="date">4 Aug 2020 at 11:35</span></td>
      </tr>
      <tr>
       <td>6</td>
       <td><span>I want to note that you do not have to think about this in most cases. I programmed java for many years until i learned c++. Until this point in time i had no clue what pass-by-reference and pass-by-value are. The intuitive solution always worked for me, which is why java is one of the best languages for beginners. So if you currently are worried, if your function needs a reference or a value, just pass it as it is and you will be fine.</span> <span> - </span> <span class="display-name">Tobias</span> <span> </span> <span class="date">20 Oct 2020 at 11:44</span></td>
      </tr>
      <tr>
       <td>74</td>
       <td><span>Java pass the reference by value.</span> <span> - </span> <span class="display-name">The Student</span> <span> </span> <span class="date">20 Oct 2020 at 19:05</span></td>
      </tr>
      <tr>
       <td>21</td>
       <td><span>Putting it very concisely, this confusion arises because in Java all non-primitive data types are handled/accessed by <i>references</i>. However, passing is always be value. So for all non-primitive types reference is passed by its value. All primitive types are also passed by value.</span> <span> - </span> <span class="display-name">Ozair Kafray</span> <span> </span> <span class="date">10 Nov 2020 at 06:56</span></td>
      </tr>
      <tr>
       <td>6</td>
       <td><span>I found this quite helpful: <a href="https://www.baeldung.com/java-pass-by-value-or-pass-by-reference" rel="nofollow noreferrer">baeldung.com/java-pass-by-value-or-pass-by-reference</a></span> <span> - </span> <span class="display-name">Natasha Kurian</span> <span> </span> <span class="date">20 Jan 2021 at 09:52</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>It's the difference between foo.bar(sth) and foo = sth. In the 1st one, the object is being changed using the variable that is pointing to it, and the variable itself that is pointing to the object has not been changed. In the 2nd one however, the variable itself that used to point to the object has changed and is now pointing to another object. If you have a C++ background: A pointer is a variable that holds a memory address, while a reference has the same memory address as the item it references. <b>In Java indeed, a pointer is passed by value, but Javaistas happen to call it a <i>reference</i></b>!</span> <span> - </span> <span class="display-name">aderchox</span> <span> </span> <span class="date">28 Feb 2021 at 06:28</span></td>
      </tr>
      <tr>
       <td>3</td>
       <td><span>What would it mean then for some language to pass a reference not by value? Passing pointers to pointers? Are there languages that do such a thing? Don't languages such as C/C++ also pass references and pointers by value??</span> <span> - </span> <span class="display-name">hippietrail</span> <span> </span> <span class="date">3 Jun 2021 at 04:56</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>As Java is an object oriented language and objects are passed by reference, according long time established semantics "modifications of the object apply to the original", it's not clear, how this "pass-by-value"-nonsense could become that famous.</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">15 Feb 2022 at 14:38</span></td>
      </tr>
      <tr>
       <td>3</td>
       <td><span>@SamGinrich Java is always pass-by-value. If you don't understand this basic concept, which is nowhere near an "nonsense" as you call it, I suggest you read the most upvoted answers here until you understand why.</span> <span> - </span> <span class="display-name">Dalija Prasnikar</span> <span> </span> <span class="date">15 Feb 2022 at 18:32</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>for those who like video explanation <a href="https://youtu.be/fL-nXdKWwOg" rel="nofollow noreferrer">youtu.be/fL-nXdKWwOg</a></span> <span> - </span> <span class="display-name">VedantK</span> <span> </span> <span class="date">2 Mar 2022 at 06:48</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>This “objects are passed by value” thing is misleading. References to objects are passed. Not copied/moved values of objects. That the references themselves are passed by value is a tiny detail of not much interest.</span> <span> - </span> <span class="display-name">Pavel Šimerda</span> <span> </span> <span class="date">17 Dec 2022 at 23:06</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>@SamGinrich You are mixing apples and oranges. Programming language paradigm alone is not directly related with what mechanisms language uses for passing parameters. Anyone who knows inner workings of compilers and languages design, know the difference. Terminology is universal, because it conveys meaning to people that know what it means. Just because you refuse to learn the definition, because it does not make sense to you, does not mean that it doesn't hold the value to others who understand it. I suggest that you read the top answer very carefully.</span> <span> - </span> <span class="display-name">Dalija Prasnikar</span> <span> </span> <span class="date">10 Jan 2023 at 08:23</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>@SamGinrich It is not about learning the definition like a parrot. It is about understanding what it means and why definitions like that are needed. Definition is not about single language they are about all languages. They are important because they describe exact behavior in simple words. If you twist the words, then you lose precise description of what happens. It is like math, where we have some definitions that are base ground for everything. You can say some are arbitrarily picked and we could develop math from slightly different ones, but then everything else in math would change, too.</span> <span> - </span> <span class="display-name">Dalija Prasnikar</span> <span> </span> <span class="date">12 Jan 2023 at 07:38</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>@SamGinrich Consistency does not equal knowledge. You can consistently claim that the Earth is flat, and you would still be wrong.</span> <span> - </span> <span class="display-name">Dalija Prasnikar</span> <span> </span> <span class="date">14 Jan 2023 at 14:02</span></td>
      </tr>
      <tr>
       <td>4</td>
       <td><span>Before you post a new answer, consider there are already 93+ answers to this question. Please ensure that your answer contributes information that is not among existing answers. Thanks!</span> <span> - </span> <span class="display-name">Asadullah</span> <span> </span> <span class="date">14 Feb 2023 at 20:30</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>@SamGinrich My moderation activities are not based on what I like or not, but on correctness. However, if you have any problems with anyone's actions or you feel that some post is not handled appropriately, you can always bring that up on Stack Overflow Meta. As far as this Q/A is concerned I don't have anything new to say that I haven't said already.</span> <span> - </span> <span class="display-name">Dalija Prasnikar</span> <span> </span> <span class="date">28 Apr 2023 at 08:46</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6954</span>
     </div>
     <div>
      <span>Answerer: </span> <span>erlando</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Sep 2008 at 20:25</span>
     </div>
    </div>
    <div>
     <p>The terms "pass-by-value" and "pass-by-reference" have special, <a href="https://en.wikipedia.org/w/index.php?title=Pass-by-value" rel="noreferrer">precisely defined</a> meanings in computer science. These meanings differ from the intuition many people have when first hearing the terms. Much of the confusion in this discussion seems to come from this fact.</p>
     <p>The terms "pass-by-value" and "pass-by-reference" are talking about <em>variables.</em> Pass-by-value means that the <em>value</em> of a variable is passed to a function/method. Pass-by-reference means that a <em>reference</em> to that variable is passed to the function. The latter gives the function a way to change the contents of the variable.</p>
     <p>By those definitions, Java is always <strong>pass-by-value</strong>. Unfortunately, when we deal with variables holding objects we are really dealing with object-handles called <em>references</em> which are passed-by-value as well. This terminology and semantics easily confuse many beginners.</p>
     <p>It goes like this:</p>
     <pre><code>public static void main(String[] args) {
    Dog aDog = new Dog("Max");
    Dog oldDog = aDog;

    // we pass the object to foo
    foo(aDog);
    // aDog variable is still pointing to the "Max" dog when foo(...) returns
    aDog.getName().equals("Max"); // true
    aDog.getName().equals("Fifi"); // false
    aDog == oldDog; // true
}

public static void foo(Dog d) {
    d.getName().equals("Max"); // true
    // change d inside of foo() to point to a new Dog instance "Fifi"
    d = new Dog("Fifi");
    d.getName().equals("Fifi"); // true
}
</code></pre>
     <p>In the example above <code>aDog.getName()</code> will still return <code>"Max"</code>. The value <code>aDog</code> within <code>main</code> is not changed in the function <code>foo</code> with the <code>Dog</code> <code>"Fifi"</code> as the object reference is passed by value. If it were passed by reference, then the <code>aDog.getName()</code> in <code>main</code> would return <code>"Fifi"</code> after the call to <code>foo</code>.</p>
     <p>Likewise:</p>
     <pre><code>public static void main(String[] args) {
    Dog aDog = new Dog("Max");
    Dog oldDog = aDog;

    foo(aDog);
    // when foo(...) returns, the name of the dog has been changed to "Fifi"
    aDog.getName().equals("Fifi"); // true
    // but it is still the same dog:
    aDog == oldDog; // true
}

public static void foo(Dog d) {
    d.getName().equals("Max"); // true
    // this changes the name of d to be "Fifi"
    d.setName("Fifi");
}
</code></pre>
     <p>In the above example, <code>Fifi</code> is the dog's name after call to <code>foo(aDog)</code> because the object's name was set inside of <code>foo(...)</code>. Any operations that <code>foo</code> performs on <code>d</code> are such that, for all practical purposes, they are performed on <code>aDog</code>, but it is <strong>not</strong> possible to change the value of the variable <code>aDog</code> itself.</p>
     <p>For more information on pass by reference and pass by value, consult the following answer: <a href="https://stackoverflow.com/a/430958/6005228">https://stackoverflow.com/a/430958/6005228</a>. This explains more thoroughly the semantics and history behind the two and also explains why Java and many other modern languages appear to do both in certain cases.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>9</td>
        <td><span>so what happens to "Fifi" in the 1st example? Does it cease to exist, was it never created, or does it exist in the heap but without a reference variable in the stack?</span> <span> - </span> <span class="display-name">dbrewster</span> <span> </span> <span class="date">29 Sep 2020 at 18:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>What do you mean by the last sentence <code>but it is not possible to change the value of the variable aDog itself.</code>?</span> <span> - </span> <span class="display-name">TMOTTM</span> <span> </span> <span class="date">16 Oct 2020 at 18:33</span></td>
       </tr>
       <tr>
        <td>90</td>
        <td><span>To me, saying that an object's reference is passed by value is the same as saying that the object is passed by reference. I'm a Java novice, but I presume that (in contrast) <i>primitive data</i> is pass by value.</span> <span> - </span> <span class="display-name">user36800</span> <span> </span> <span class="date">27 Oct 2020 at 18:46</span></td>
       </tr>
       <tr>
        <td>19</td>
        <td><span>@user36800: You're wrong. Did you work through the example with Fifi and look carefully through the results? Check that indeed <code>foo(aDog);</code> did <b>not</b> change <code>aDog</code> despite <code>foo</code> overwriting the value of <code>d</code>, showing that indeed all inputs to a function are passed by value.</span> <span> - </span> <span class="display-name">user21820</span> <span> </span> <span class="date">23 Dec 2020 at 15:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@user21820: Yes, I did work through the examples and they both made sense to me. I made two statements in my previous comment. If you can specify which one you disagree with, I can try to better understand your last comment. Thanks.</span> <span> - </span> <span class="display-name">user36800</span> <span> </span> <span class="date">28 Dec 2020 at 02:29</span></td>
       </tr>
       <tr>
        <td>12</td>
        <td><span>@user36800: Well, both statements are wrong. To pass an object by reference would mean that if the function modifies the variable then it modifies the object itself. That is not what happens in Java; objects cannot be passed by reference, but instead one can only pass references as inputs to a function, and when a function performs <code>d = new Dog("Fifi");</code> it overwrites the input variable <code>d</code>, which <b>stores</b> a reference but is not 'the object passed by reference'. Contrast with <code>&amp;d</code> in the function signature in C, which would be pass-by-reference. [cont]</span> <span> - </span> <span class="display-name">user21820</span> <span> </span> <span class="date">28 Dec 2020 at 05:49</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>That was for your first statement. Your second statement is also wrong because <i>everything</i> is passed by value in Java. There is absolutely no difference between object references and primitive data types, except that the operations you are allowed to perform on them differ.</span> <span> - </span> <span class="display-name">user21820</span> <span> </span> <span class="date">28 Dec 2020 at 05:51</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Ah, I see. Thanks for clarifying that. I was just thinking in a gross manner, i.e., equating passing by reference as not creating a new object because pointers are used behinds the scenes, and the pointers are automatically dereferenced when the variable is used. It would be so much clearer if pointers were explicitly used. However, the maxim that all Java objects are handled by reference helps.</span> <span> - </span> <span class="display-name">user36800</span> <span> </span> <span class="date">28 Dec 2020 at 23:32</span></td>
       </tr>
       <tr>
        <td>59</td>
        <td><span>@dbrewster i'm sorry but ... "Fifi" is not among us anymore</span> <span> - </span> <span class="display-name">ghilesZ</span> <span> </span> <span class="date">2 Feb 2021 at 19:51</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>So what is the difference between an "object reference" and the "value of an Object reference" then .</span> <span> - </span> <span class="display-name">redd77</span> <span> </span> <span class="date">30 Apr 2021 at 00:48</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@redd77 when you pass the "value" you are not passing the actual variable, only the value it contains. Meaning you're making a copy of the values and passing in the copy. An object reference (i.e. a pointer) is a variable containing the physical address of the memory which contains the object. The values of an object reference is a copy of that address. Languages which support pass by reference allow you to pass the actual variable and not just a copy so that changing it in the function (like setting it to null) also changes it for the caller.</span> <span> - </span> <span class="display-name">Sanjeev</span> <span> </span> <span class="date">8 Jun 2021 at 22:38</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@redd77 Only difference is that assigning to a "value of Object reference" does not touch the object. In that way it's like a C/C++ pointer.</span> <span> - </span> <span class="display-name">user4945014</span> <span> </span> <span class="date">22 Jun 2021 at 01:14</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Sanjeev that finally made sense. Pass by reference or by pointer means to pass the reference itself, and not a copy of it. Passing a reference in a pass by value only language, is not pass by reference, it is pass by value.</span> <span> - </span> <span class="display-name">the_prole</span> <span> </span> <span class="date">10 Sep 2021 at 22:24</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@the_prole Yes, but just to be clear, the word "Reference" has a different meaning than as used by Java. Therefore pass by reference does not mean pass by pointer (although under-the-hood, pointers could be used to handle PBR, but not necessarily). It just so happens that java uses the same word for pointers. Please see my post for details ==&gt;&gt; <a href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value/54373107#54373107" title="is java pass by reference or pass by value">stackoverflow.com/questions/40480/…</a></span> <span> - </span> <span class="display-name">Sanjeev</span> <span> </span> <span class="date">21 Sep 2021 at 16:04</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@akki2346 because when you pass an object, you are not making a copy of the whole object and passing that, you are passing the value of the reference. There can be multiple references to the same object in Java. When you pass an object to a function, one of those references to the object is on the stack.</span> <span> - </span> <span class="display-name">jmarkmurphy</span> <span> </span> <span class="date">17 Dec 2021 at 19:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@SamGinrich I don't know why you insist on going back to C++ to understand Java. They are not the same. Ok, do this. Create for me a swap function defined like this <code>swap(String str1, String str2)</code>. It should swap the two objects str1 and str2. This will be a simple exercise if Java uses pass by reference semantics for objects.</span> <span> - </span> <span class="display-name">jmarkmurphy</span> <span> </span> <span class="date">20 Dec 2021 at 21:34</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>No it's not. Pass by reference/pass by value is all about what is put onto the call stack. In Java, it is the VALUE of the reference, and the receiver understands it as the VALUE of the reference to the object. If we were using pass by reference semantics, things that are represented by a reference would have the address of the reference rather than the value of the reference put on the stack. The receiver would then understand this and dereference the the parameter, and would then operate on the passed object itself, not a copy of it. Did you make that swap function yet?</span> <span> - </span> <span class="display-name">jmarkmurphy</span> <span> </span> <span class="date">12 Jan 2022 at 14:05</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>So every thing in the world is passed by value. for example in C we always passed by value even if we create a function by input pointer.</span> <span> - </span> <span class="display-name">Amir</span> <span> </span> <span class="date">27 Jan 2022 at 21:58</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Amir think you are wrong on C. <a href="https://www.tutorialspoint.com/cprogramming/c_function_call_by_reference.htm" rel="nofollow noreferrer">tutorialspoint.com/cprogramming/…</a></span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">21 Feb 2022 at 12:02</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@SamGinrich, That cited page is incorrect. And once again, the confusion is in contrasting "Passing by reference" with "Passing <i>a</i> reference <b><i>by</i></b> value". We are going to see a few such confusions, but C similarly follows the PBV rule. If you need <i>a</i> pointer (reference) sent to function, you send it <i>by</i> value. These terms have meanings in computer science. Colloquially we used define PBV by failing "the swap(a,b) test".</span> <span> - </span> <span class="display-name">alife</span> <span> </span> <span class="date">28 Apr 2022 at 02:34</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@SamGinrich, I seem to have put you on the defensive. This will send us down the wrong path, and I'll not discuss things with someone who assumes I need to get an overview of terms. I've overlooked the prior engagements of yours regarding this topic, and they seem emotionally charged. I'll not contrast your CS degree with mine, and these principals are far from "because I said so." So I consider this over.</span> <span> - </span> <span class="display-name">alife</span> <span> </span> <span class="date">28 Apr 2022 at 20:30</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>From this perspective pass-by-reference does never exist in universe, since reference is actually always a value of pointer</span> <span> - </span> <span class="display-name">azis.mrazish</span> <span> </span> <span class="date">15 Jun 2022 at 16:44</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>So basiclly it's passed by pointer?</span> <span> - </span> <span class="display-name">JobHunter69</span> <span> </span> <span class="date">20 Jun 2022 at 20:51</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@azis.mrazish <i>"From this perspective pass-by-reference does never exist in universe"</i> - by "pass-by-reference" is meant a reference to a variable. That makes it possible for the called function to change the value of the variable that is passed. Languages like C and C++ support that concept, Java doesn't.</span> <span> - </span> <span class="display-name">fishinear</span> <span> </span> <span class="date">26 Jul 2022 at 12:02</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@alife <i>"If you need a pointer (reference) sent to function, you send it by value"</i> - a crucial difference between C and Java, is that in C there is a way to pass a <i>reference to a variable</i> to a function, such that the function is able to change the content of that variable. That is impossible in Java. Claiming that both C and Java are pass-by-value, and just leave it at that, ignores that crucial difference.</span> <span> - </span> <span class="display-name">fishinear</span> <span> </span> <span class="date">26 Jul 2022 at 12:18</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@fishinear, "ignore"? No. Yes, C has a way of doing that, but it doesn't define the "pass-by" vs "passing-a" idioms. All languages have peculiarities---it doesn't necessarily affect CS definitions. By the way, here and there I'm seeing stray assertions floating around that Java was a recent oddity. It follows the same passing regimen as smalltalk did, as smalltalk was its primary influence.</span> <span> - </span> <span class="display-name">alife</span> <span> </span> <span class="date">26 Jul 2022 at 23:44</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@fishinear, I just now read your comment to someone else regarding C. PBV is defined by what happens on assignment to the formal parameter. If you can alter the actual parameter by doing so, then you have PBR (or a hybrid, like C++). Being able to send the address of something to a function in C still requires that assigning to the formal parameter does nothing. In C, you'd have to <i>dereference</i> that pointer. It doesn't change that the pointer <i>itself</i> is the formal parameter and gets assigned while leaving the actual alone. Thus C is PBV only.</span> <span> - </span> <span class="display-name">alife</span> <span> </span> <span class="date">27 Jul 2022 at 01:05</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@alife <i>"Thus C is PBV only"</i> - yes, I know that is what the definition says, and I am not claiming that it doesn't. But saying that both C and Java are PBV, without any additional explanation, obscures the important fact that is it is <i>possible</i> to pass the address of a variable to a function in C, while that is not possible in Java. That is not just a peculiarity, but an important architectural difference between the languages that should not be neglected.</span> <span> - </span> <span class="display-name">fishinear</span> <span> </span> <span class="date">28 Jul 2022 at 09:24</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@alife Another way to look at it, is that it is a syntactic peculiarity of C that you need to put an '&amp;' in front of a variable in order to use pass-by-reference.</span> <span> - </span> <span class="display-name">fishinear</span> <span> </span> <span class="date">28 Jul 2022 at 09:33</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@fishinear, Yes, C allows taking addresses of items and dereferencing them directly. Yet: (pseudo-C) <code>actual=5; someFunction(&amp;actual);</code> <i>still</i> requires this conversation: 1. What is being sent? 2. An address. 3. How is it sent? 4. By value. 5. Why? 6. Because the method altering that parameter (an address, remember it's what's actually sent), does not impact the actual parameter, only the formal parameter. That C allows <code>&amp;</code> and dereferencing-<code>*</code> is interesting, but does not impact PBV.</span> <span> - </span> <span class="display-name">alife</span> <span> </span> <span class="date">29 Jul 2022 at 16:04</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3552</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Scott Stanchfield</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Sep 2008 at 14:37</span>
     </div>
    </div>
    <div>
     <p>I just noticed you referenced <a href="http://javadude.com/articles/passbyvalue.htm" rel="noreferrer">my article</a>.</p>
     <p>The Java Spec says that everything in Java is pass-by-value. There is no such thing as "pass-by-reference" in Java.</p>
     <p>The key to understanding this is that something like</p>
     <pre><code>Dog myDog;
</code></pre>
     <p>is <em>not</em> a Dog; it's actually a <em>pointer</em> to a Dog. The use of the term "reference" in Java is very misleading and is what causes most of the confusion here. What they call "references" act/feel more like what we'd call "pointers" in most other languages.</p>
     <p>What that means, is when you have</p>
     <pre><code>Dog myDog = new Dog("Rover");
foo(myDog);
</code></pre>
     <p>you're essentially passing the <em>address</em> of the created <code>Dog</code> object to the <code>foo</code> method.</p>
     <p>(I say essentially because Java pointers/references aren't direct addresses, but it's easiest to think of them that way.)</p>
     <p>Suppose the <code>Dog</code> object resides at memory address 42. This means we pass 42 to the method.</p>
     <p>if the Method were defined as</p>
     <pre><code>public void foo(Dog someDog) {
    someDog.setName("Max");     // AAA
    someDog = new Dog("Fifi");  // BBB
    someDog.setName("Rowlf");   // CCC
}
</code></pre>
     <p>let's look at what's happening.</p>
     <ul>
      <li>the parameter <code>someDog</code> is set to the value 42</li>
      <li>at line "AAA" 
       <ul>
        <li><code>someDog</code> is followed to the <code>Dog</code> it points to (the <code>Dog</code> object at address 42)</li>
        <li>that <code>Dog</code> (the one at address 42) is asked to change his name to Max</li>
       </ul></li>
      <li>at line "BBB" 
       <ul>
        <li>a new <code>Dog</code> is created. Let's say he's at address 74</li>
        <li>we assign the parameter <code>someDog</code> to 74</li>
       </ul></li>
      <li>at line "CCC" 
       <ul>
        <li>someDog is followed to the <code>Dog</code> it points to (the <code>Dog</code> object at address 74)</li>
        <li>that <code>Dog</code> (the one at address 74) is asked to change his name to Rowlf</li>
       </ul></li>
      <li>then, we return</li>
     </ul>
     <p>Now let's think about what happens outside the method:</p>
     <p><em>Did <code>myDog</code> change?</em></p>
     <p>There's the key.</p>
     <p>Keeping in mind that <code>myDog</code> is a <em>pointer</em>, and not an actual <code>Dog</code>, the answer is NO. <code>myDog</code> still has the value 42; it's still pointing to the original <code>Dog</code> (but note that because of line "AAA", its name is now "Max" - still the same Dog; <code>myDog</code>'s value has not changed.)</p>
     <p>It's perfectly valid to <em>follow</em> an address and change what's at the end of it; that does not change the variable, however.</p>
     <p>Java works exactly like C. You can assign a pointer, pass the pointer to a method, follow the pointer in the method and change the data that was pointed to. However, the caller will not see any changes you make to where that pointer points. (In a language with pass-by-reference semantics, the method function <em>can</em> change the pointer and the caller will see that change.)</p>
     <p>In C++, Ada, Pascal and other languages that support pass-by-reference, you can actually change the variable that was passed.</p>
     <p>If Java had pass-by-reference semantics, the <code>foo</code> method we defined above would have changed where <code>myDog</code> was pointing when it assigned <code>someDog</code> on line BBB.</p>
     <p>Think of reference parameters as being aliases for the variable passed in. When that alias is assigned, so is the variable that was passed in.</p>
     <h2>Update</h2>
     <p>A discussion in the comments warrants some clarification...</p>
     <p>In C, you can write</p>
     <pre class="lang-c prettyprint-override"><code>void swap(int *x, int *y) {
    int t = *x;
    *x = *y;
    *y = t;
}

int x = 1;
int y = 2;
swap(&amp;x, &amp;y);
</code></pre>
     <p>This is not a special case in C. Both languages use pass-by-value semantics. Here the call site is creating additional data structure to assist the function to access and manipulate data.</p>
     <p>The function is being passed pointers to data, and follows those pointers to access and modify that data.</p>
     <p>A similar approach in Java, where the caller sets up assisting structure, might be:</p>
     <pre class="lang-java prettyprint-override"><code>void swap(int[] x, int[] y) {
    int temp = x[0];
    x[0] = y[0];
    y[0] = temp;
}

int[] x = {1};
int[] y = {2};
swap(x, y);
</code></pre>
     <p>(or if you wanted both examples to demonstrate features the other language doesn't have, create a mutable IntWrapper class to use in place of the arrays)</p>
     <p>In these cases, both C and Java are <em>simulating</em> pass-by-reference. They're still both passing values (pointers to ints or arrays), and following those pointers inside the called function to manipulate the data.</p>
     <p>Pass-by-reference is all about the function <em>declaration/definition</em>, and how it handles its parameters. Reference semantics apply to <em>every</em> call to that function, and the call site only needs to pass variables, no additional data structure.</p>
     <p>These simulations require the call site and the function to cooperate. No doubt it's useful, but it's still pass-by-value.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Minor clarification question on the above example, so when creating new Dog at BBB at address 72, does this imply upon return the created Dog at 72 and it’s value is lost and reverts back to 42?</span> <span> - </span> <span class="display-name">ebresie</span> <span> </span> <span class="date">13 Mar 2021 at 14:40</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@ebresie <a href="https://javarevisited.blogspot.com/2015/09/difference-between-primitive-and-reference-variable-java.html#:~:text=There%20are%20two%20types%20of,Thread%2C%20File%2C%20and%20others" rel="nofollow noreferrer">javarevisited.blogspot.com/2015/09/…</a>.</span> <span> - </span> <span class="display-name">Ravikumar Rajendran</span> <span> </span> <span class="date">15 Mar 2021 at 17:08</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@ebresie Mostly yes (I'll clarify the "mostly" in a moment). The only pointer to the new dog at 74 (I assume you meant 74 rather than 72) is the parameter to the foo function. When foo returns, all of its parameters are popped off the stack, so nothing is left pointing to 72 and it can be garbage collected. I say "mostly" as there is no "revert" happening; the pointer myDog in the caller was pointing to 42 all along and never changed, no matter what happened in the function, hence, no "revert".</span> <span> - </span> <span class="display-name">Scott Stanchfield</span> <span> </span> <span class="date">16 Mar 2021 at 18:42</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>"However, you cannot change where that pointer points." -&gt; Shouldnt it be "However, you cannot change where that pointer points in some other method."</span> <span> - </span> <span class="display-name">NiharGht</span> <span> </span> <span class="date">8 Jun 2021 at 06:30</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@NiharGht Good point - I've clarified it (please comment again if it's still not clear)</span> <span> - </span> <span class="display-name">Scott Stanchfield</span> <span> </span> <span class="date">10 Jun 2021 at 07:03</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Java does not act exactly like C. If you pass a pointer to a function in C and modify where that pointer points to, the effect of reassigning that pointer is seen at the call sight, not just within the scope of the call. Seeking this behavior out of the languages is the purpose of the const keyword. Please stop saying java is just like C, because it's in many many fundamental ways entirely NOT c (or c++) and all you're doing is confusing people that do know C (or C++) and are trying to get a working overview of java. See: <a href="https://courses.washington.edu/css342/zander/css332/passby.html" rel="nofollow noreferrer">courses.washington.edu/css342/zander/css332/passby.html</a></span> <span> - </span> <span class="display-name">Jonathan</span> <span> </span> <span class="date">24 Jun 2021 at 17:20</span></td>
       </tr>
       <tr>
        <td>11</td>
        <td><span>@Jonathan That link is C++, not C. C does not work that way. C is strictly pass by value, just like Java. If you pass a pointer to something, the <i>pointer</i> is the value that you can follow. You cannot change the pointer but can follow it and change the value it points to. If you re-point it, the caller does not see the change. In C++, you can pass a <i>reference</i> to something (seen in that page you reference as int&amp;), which is similar to an alias; if you change it in a function/method it does actually change the object/primitive/pointer passed as an argument.</span> <span> - </span> <span class="display-name">Scott Stanchfield</span> <span> </span> <span class="date">26 Jun 2021 at 20:14</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@ScottStanchfield Does C have pointers? Java does not! Give this to your favorite c compiler and test the output. C has reference semantics, Java does not. You can't swap values from within a function in java and have it reflected at the call site. <a href="https://pastebin.com/U9QBFrwL" rel="nofollow noreferrer">pastebin.com/U9QBFrwL</a></span> <span> - </span> <span class="display-name">Jonathan</span> <span> </span> <span class="date">25 Jul 2021 at 14:36</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@Jonathan That's similar to this in java: <a href="https://pastebin.com/1tZsVVRw" rel="nofollow noreferrer">pastebin.com/1tZsVVRw</a>. The * is creating a pointer to the argument (which itself could be a pointer), which is similar to creating a "bucket" to hold the value - Java doesn't allow the C syntax and pointers to be created to manipulate existing data, but that doesn't mean Java doesn't <i>have</i> pointers (note that C still doesn't have reference semantics either...). Pascal, for example, uses ^ in a similar way to C's * - just because languages have different syntaxes does not mean they don't have the same concepts (such as pointers).</span> <span> - </span> <span class="display-name">Scott Stanchfield</span> <span> </span> <span class="date">26 Jul 2021 at 16:38</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@ScottStanchfield C indeed has reference semantics, it's achieved using pointers, exactly like what I put in the Pastebin. So what does the address-of operator do in C? HMM? C has reference semantics. It always HAS had reference semantics. I'm sure you've got linguistics and semantics confused here. I'm not talking about the grammar, it can be a *, a ^, or a type&amp;, the meaning is (mostly) all the same, the caviates being the rules of each langauges typesystem, which AGAIN, is another reason that JAVA IS NOT LIKE C</span> <span> - </span> <span class="display-name">Jonathan</span> <span> </span> <span class="date">29 Jul 2021 at 23:49</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>@Jonathan No. C only has pass-by-value (in your example you're passing the value of a pointer - see <a href="https://stackoverflow.com/questions/2229498/passing-by-reference-in-c" title="passing by reference in c">stackoverflow.com/questions/2229498/passing-by-reference-in-‌​c</a> for a good discussion, esp the answer by Ely). Pass-by-reference has a <i>very</i> specific meaning in compiler parlance. FYI - I'm a compiler guy and was on the ANSI C++ 98 committee... C++ has reference semantics; C does not. The difference is whether the actual argument can be modified. When you pass in &amp;i the actual argument value is the address of i, not a reference to i.</span> <span> - </span> <span class="display-name">Scott Stanchfield</span> <span> </span> <span class="date">31 Jul 2021 at 01:37</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Jonathan (Submitted too early and cannot edit) Inside the method you're not changing that address; you're following that address and changing the data residing there.</span> <span> - </span> <span class="display-name">Scott Stanchfield</span> <span> </span> <span class="date">31 Jul 2021 at 01:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@ScottStanchfield You obviously don't understand pointers and references. The only difference between a pointer and a reference is that a pointer's type can be cast away. A reference IS a pointer with type safety. A pointer is simply a variable that holds the address of something else. Guess what a reference is? A variable that holds the address of something else. A reference isn't an instance of that something else. A reference is basically syntactic sugar for pointers with type safety. If a language has pointers, it has reference semantics.</span> <span> - </span> <span class="display-name">Jonathan</span> <span> </span> <span class="date">8 Aug 2021 at 15:05</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@Jonathan You're confusing 'reference' as a type with 'pass-by-reference'. There's a huge difference between "pass by a value by reference" (reference semantics) and "pass a pointer/reference by value" (value semantics). It's all about how you define the FORMAL parameters of a function/method, not the ACTUAL parameters. If the language gives you syntax to automatically de-reference values in the FORMAL parameters (the function/method signature), it has reference semantics. Creating a pointer to something in the ACTUAL arguments (the call site) is still only passing a value.</span> <span> - </span> <span class="display-name">Scott Stanchfield</span> <span> </span> <span class="date">9 Aug 2021 at 08:39</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Jonathan C and Java are strictly pass-by-value. You can SIMULATE pass-by-reference in them by doing something both inside the function/method AND at the call site (for example, in C, using &amp; at the call site and * inside the function/method, or in Java, wrapping the value at the call site and working inside the wrapper inside the function/method), but that's still pass-by-value. Pass-by-reference is a specific compiler term for logically aliasing a variable passed into a function by ONLY specifying this behavior in the FORMAL parameters, not at the call site.</span> <span> - </span> <span class="display-name">Scott Stanchfield</span> <span> </span> <span class="date">9 Aug 2021 at 08:44</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Maybe "pass-by-sharing" is even more precise and disambiguated? <a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing" rel="nofollow noreferrer">en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing</a> Since it incorporates the reason why people resort to calling it "pass-by-reference" in the first place: the danger that functions are able to mutate objects passed in. They don't want to say "pass-by-value" as it implies copying and thus safety from mutating what's passed in.</span> <span> - </span> <span class="display-name">Magne</span> <span> </span> <span class="date">1 Sep 2021 at 11:25</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Magne I've never understood why Liskov felt it necessary to coin "call by sharing"; it's just passing the address/reference by value and following it in the function, and causes confusion. Some people didn't want to use the perfectly-correct word "pointer" (even though they used it in "NullPointerException" in Java...) There's nothing about the definition of "pointer" that says it must be implemented directly as a memory address (though it's easiest to think of it that way) - it's just indirect access to data. You don't pass the <i>object</i> in Java; you pass a <i>pointer</i> to an object.</span> <span> - </span> <span class="display-name">Scott Stanchfield</span> <span> </span> <span class="date">2 Sep 2021 at 12:27</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I think it is because people are not "pointer-oriented", but "value/object-oriented". The pointer is invisible to them. As you said <i>"The mistake they make is in the definition of <code>Dog d;</code> itself. When you write that definition, you are defining a pointer to a Dog object, not a Dog object itself."</i>. Maybe because many languages make it invisible (like Java here), but it's common to humans to "mistake the map for the territory" in real life as well; in effect treating the symbol as the referent). "Call by sharing" takes this cognitive artifact into account, so the intention is clearer, to most.</span> <span> - </span> <span class="display-name">Magne</span> <span> </span> <span class="date">2 Sep 2021 at 13:55</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Magne Pointers are a key concept in programming; trying to word one's way around them is a sure way to cause more confusion, not less.</span> <span> - </span> <span class="display-name">Scott Stanchfield</span> <span> </span> <span class="date">4 Sep 2021 at 14:30</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I can see how that might be the case, when coming to Java from a lower level language where you do have to deal with pointers. But coming from a higher level language, or from no previous language, it’s the other way around. Esp. if working in a language where you don’t directly deal with pointers.</span> <span> - </span> <span class="display-name">Magne</span> <span> </span> <span class="date">4 Sep 2021 at 21:19</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>"In C++, Ada, Pascal and other languages that support pass-by-reference, you can actually change the variable that was passed." Ada doesn't really depend on the actual passing mechanism (for most things) as it has parameter passing modes which have specific semantics. The modes are "in" (read only), "in out" (initial value passed in, modifiable) and "out" (initial value not necessarily passed in, can be updated). For scalars the mechanism for "in out" is copy in/copy out which is much more cache friendly than C's pass by reference.</span> <span> - </span> <span class="display-name">Dale Stanbrough</span> <span> </span> <span class="date">27 Sep 2021 at 04:09</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@DaleStanbrough Didn't know about the cache-friendliness there for scalars; cool. Not sure what you mean by "Ada doesn't really depend on the actual passing mechanism (for most things) as it has parameter passing modes which have specific semantics." I was thinking about "in"/"out"/"in out" when I mentioned Ada (with "out" specifying update of a passed variable). Been a while since I've programmed in Ada, though, so I may be fuzzy on some of the ways terminology is used by the language nowadays</span> <span> - </span> <span class="display-name">Scott Stanchfield</span> <span> </span> <span class="date">29 Sep 2021 at 17:48</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>"It doesn't depend" mainly meant that when designing in Ada you think about the modes (information direction flow) rather than the mechanism - which is such a great way to design subprograms. Ada takes care of the rest.</span> <span> - </span> <span class="display-name">Dale Stanbrough</span> <span> </span> <span class="date">2 Oct 2021 at 12:43</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>i say it is wrong. in C void func(int *i); is a call by reference function. call by value means you can not change the value of original input. it this case you can implement func some thing like void func(int *i){int j = 5; i = &amp;j;}. so if you say java is call by value you have to say every thing is call by value. cuz always new value copied to stack.</span> <span> - </span> <span class="display-name">Amir</span> <span> </span> <span class="date">27 Jan 2022 at 22:06</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Amir Writing func(int *i) means you're passing a pointer value as the parameter (and would have to call it with func(&amp;x). Note that the caller needs to do something special. That's still pass-by-value. Pass-by reference allows the function to state it can change the parameter value without the caller doing anything extra. C++ allows func(int &amp;i) and you can call it directly with an int x variable like func(x). Pass-by-reference is a special construct in the language, and can be simulated in some value-only languages, but it's not true pass-by-reference. (You can't do either of these in Java)</span> <span> - </span> <span class="display-name">Scott Stanchfield</span> <span> </span> <span class="date">29 Jan 2022 at 14:38</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>but <a href="https://www.tutorialspoint.com/cprogramming/c_function_call_by_reference.htm" rel="nofollow noreferrer">tutorialspoint.com/cprogramming/…</a> said it is call by reference. it is better clearly define what is call by reference and what is call by value. So it seems C and Assembly don't have call by reference.</span> <span> - </span> <span class="display-name">Amir</span> <span> </span> <span class="date">29 Jan 2022 at 16:14</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Amir They're incorrect. C only supports value parameters. See <a href="https://stackoverflow.com/questions/2229498/passing-by-reference-in-c" title="passing by reference in c">stackoverflow.com/questions/2229498/passing-by-reference-in-‌​c</a> for some good explanations, particularly the comment about "Illusion of pass-by-reference".</span> <span> - </span> <span class="display-name">Scott Stanchfield</span> <span> </span> <span class="date">29 Jan 2022 at 22:51</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Amir The difference is that "pass by value" is just passing the result of the evaluated expression used as an argument in the function call. "Pass by reference" can be thought of the parameter being an alias for the variable passed in as an argument.</span> <span> - </span> <span class="display-name">Scott Stanchfield</span> <span> </span> <span class="date">29 Jan 2022 at 22:55</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@ScottStanchfield The statement that "Java works exactly like C" is incorrect. The semantic difference between PBV and PBR is, that in the latter it is possible for the callee to change the value of the variable in the caller. In C, although the parameter passing is PBV, it IS possible to achieve PBR semantics by passing the address of the variable instead. That is not possible to achieve at all in Java. Therefore Java and C don't work exactly the same, and users need to be aware of that.</span> <span> - </span> <span class="display-name">fishinear</span> <span> </span> <span class="date">9 Aug 2022 at 12:33</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@ScottStanchfield <i>" "Pass by reference" can be thought of the parameter being an alias for the variable passed in as an argument"</i> - ...or can be thought of the parameter being a pointer to the variable, which is passed as argument.</span> <span> - </span> <span class="display-name">fishinear</span> <span> </span> <span class="date">9 Aug 2022 at 12:34</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2098</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Eng.Fouad</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Sep 2012 at 18:22</span>
     </div>
    </div>
    <div>
     <p>Java always passes arguments <em>by value</em>, NOT by reference.</p>
     <hr>
     <p>Let me explain this through an <a href="https://stackoverflow.com/a/9404727/597657">example</a>:</p>
     <pre class="lang-java prettyprint-override"><code>public class Main {

     public static void main(String[] args) {
          Foo f = new Foo("f");
          changeReference(f); // It won't change the reference!
          modifyReference(f); // It will modify the object that the reference variable "f" refers to!
     }

     public static void changeReference(Foo a) {
          Foo b = new Foo("b");
          a = b;
     }

     public static void modifyReference(Foo c) {
          c.setAttribute("c");
     }

}
</code></pre>
     <p>I will explain this in steps:</p>
     <ol>
      <li>
       <p>Declaring a reference named <code>f</code> of type <code>Foo</code> and assign it a new object of type <code>Foo</code> with an attribute <code>"f"</code>.</p>
       <pre><code>Foo f = new Foo("f");
</code></pre>
       <p><img src="arXpP.png" alt="enter image description here"></p></li>
      <li>
       <p>From the method side, a reference of type <code>Foo</code> with a name <code>a</code> is declared and it's initially assigned <code>null</code>.</p>
       <pre><code>public static void changeReference(Foo a)
</code></pre>
       <p><img src="k2LBD.png" alt="enter image description here"></p></li>
      <li>
       <p>As you call the method <code>changeReference</code>, the reference <code>a</code> will be assigned the object which is passed as an argument.</p>
       <pre><code>changeReference(f);
</code></pre>
       <p><img src="1Ez74.png" alt="enter image description here"></p></li>
      <li>
       <p>Declaring a reference named <code>b</code> of type <code>Foo</code> and assign it a new object of type <code>Foo</code> with an attribute <code>"b"</code>.</p>
       <pre><code>Foo b = new Foo("b");
</code></pre>
       <p><img src="Krx4N.png" alt="enter image description here"></p></li>
      <li>
       <p><code>a = b</code> makes a new assignment to the reference <code>a</code>, <strong>not</strong> <code>f</code>, of the object whose attribute is <code>"b"</code>.</p>
       <p><img src="rCluu.png" alt="enter image description here"></p></li>
      <li>
       <p>As you call <code>modifyReference(Foo c)</code> method, a reference <code>c</code> is created and assigned the object with attribute <code>"f"</code>.</p>
       <p><img src="PRZPg.png" alt="enter image description here"></p></li>
      <li>
       <p><code>c.setAttribute("c");</code> will change the attribute of the object that reference <code>c</code> points to it, and it's the same object that reference <code>f</code> points to it.</p>
       <p><img src="H9Qsf.png" alt="enter image description here"></p></li>
     </ol>
     <p>I hope you understand now how passing objects as arguments works in Java :)</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>64</td>
        <td><span>Java always passes arguments by value, but what you are passing by value is a reference to an object, not a copy of the object. Simple eh?</span> <span> - </span> <span class="display-name">dan carter</span> <span> </span> <span class="date">7 Dec 2020 at 08:48</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>"Object not by Reference", really?</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">4 Dec 2021 at 12:47</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>that was the best answer for references problem in java I have ever see. thanks a lot.</span> <span> - </span> <span class="display-name">Mohammad_Hosein</span> <span> </span> <span class="date">17 Dec 2022 at 04:01</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>850</span>
     </div>
     <div>
      <span>Answerer: </span> <span>SCdF</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Sep 2008 at 20:19</span>
     </div>
    </div>
    <div>
     <p>Java is always pass by value, with no exceptions, <strong>ever</strong>.</p>
     <p>So how is it that anyone can be at all confused by this, and believe that Java is pass by reference, or think they have an example of Java acting as pass by reference? The key point is that Java <strong>never</strong> provides direct access to the values of <em>objects themselves</em>, in <em>any</em> circumstances. The only access to objects is through a <em>reference</em> to that object. Because Java objects are <em>always</em> accessed through a reference, rather than directly, it is common to talk about fields and variables <em>and method arguments</em> as being <em>objects</em>, when pedantically they are only <em>references to objects</em>. <strong>The confusion stems from this (strictly speaking, incorrect) change in nomenclature.</strong></p>
     <p>So, when calling a method</p>
     <ul>
      <li>For primitive arguments (<code>int</code>, <code>long</code>, etc.), the pass by value is <em>the actual value</em> of the primitive (for example, 3).</li>
      <li>For objects, the pass by value is the value of <em>the reference to the object</em>.</li>
     </ul>
     <p>So if you have <code>doSomething(foo)</code> and <code>public void doSomething(Foo foo) { .. }</code> the two Foos have copied <em>references</em> that point to the same objects.</p>
     <p>Naturally, passing by value a reference to an object looks very much like (and is indistinguishable in practice from) passing an object by reference.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>JVMS 2.2 makes this pretty clear: There are ... two kinds of values that can be stored in variables, passed as arguments, returned by methods, and operated upon: <i>primitive values</i> and <i>reference values</i>." Object references are values. Everything is passed by value.</span> <span> - </span> <span class="display-name">Brian Goetz</span> <span> </span> <span class="date">1 Nov 2020 at 15:52</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span><a href="https://www.geeksforgeeks.org/g-fact-31-java-is-strictly-pass-by-value/" rel="nofollow noreferrer">geeksforgeeks.org/g-fact-31-java-is-strictly-pass-by-value</a></span> <span> - </span> <span class="display-name">georgiana_e</span> <span> </span> <span class="date">2 Mar 2021 at 07:28</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The operative implication: <code>f(x)</code> (passing a variable) will never assign to <code>x</code> itself. There is no such thing as a variable address (<i>alias</i>) passed. <i>A solid language design decision.</i></span> <span> - </span> <span class="display-name">Joop Eggen</span> <span> </span> <span class="date">20 Sep 2021 at 09:37</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>So basically we're passing the address and we reference that address in our method for example in c <code>int test(int *a) { int b = *(a); return b;)</code> ?</span> <span> - </span> <span class="display-name">bwass31</span> <span> </span> <span class="date">7 Feb 2022 at 17:31</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>So, when I want to pass an object to some method, I'm doomed, because an object is "not a value" :(</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">16 Feb 2022 at 15:34</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>798</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Marsellus Wallace</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Aug 2011 at 01:22</span>
     </div>
    </div>
    <div>
     <p><strong>This will give you some insights of how Java really works to the point that in your next discussion about Java passing by reference or passing by value you'll just smile :-)</strong></p>
     <p>Step one please erase from your mind that word that starts with 'p' "_ _ _ _ _ _ _", especially if you come from other programming languages. Java and 'p' cannot be written in the same book, forum, or even txt.</p>
     <p>Step two remember that when you pass an Object into a method you're passing the Object reference and not the Object itself.</p>
     <ul>
      <li><em>Student</em>: Master, does this mean that Java is pass-by-reference?</li>
      <li><em>Master</em>: Grasshopper, No.</li>
     </ul>
     <p>Now think of what an Object's reference/variable does/is:</p>
     <ol>
      <li><strong>A variable holds the bits that tell the JVM how to get to the referenced Object in memory (Heap).</strong></li>
      <li>When passing arguments to a method <strong>you ARE NOT passing the reference variable, but a copy of the bits in the reference variable</strong>. Something like this: 3bad086a. 3bad086a represents a way to get to the passed object.</li>
      <li>So you're just passing 3bad086a that it's the value of the reference.</li>
      <li>You're passing the value of the reference and not the reference itself (and not the object).</li>
      <li><strong><em>This value is actually COPIED and given to the method</em></strong>.</li>
     </ol>
     <p>In the following (please don't try to compile/execute this...):</p>
     <pre><code>1. Person person;
2. person = new Person("Tom");
3. changeName(person);
4.
5. //I didn't use Person person below as an argument to be nice
6. static void changeName(Person anotherReferenceToTheSamePersonObject) {
7.     anotherReferenceToTheSamePersonObject.setName("Jerry");
8. }
</code></pre>
     <p>What happens?</p>
     <ul>
      <li>The variable <em>person</em> is created in line #1 and it's null at the beginning.</li>
      <li>A new Person Object is created in line #2, stored in memory, and the variable <em>person</em> is given the reference to the Person object. That is, its address. Let's say 3bad086a.</li>
      <li>The variable <em>person</em> holding the address of the Object is passed to the function in line #3.</li>
      <li>In line #4 you can listen to the sound of silence</li>
      <li>Check the comment on line #5</li>
      <li>A method local variable -<em>anotherReferenceToTheSamePersonObject</em>- is created and then comes the magic in line #6: 
       <ul>
        <li>The variable/reference <em>person</em> is copied bit-by-bit and passed to <em>anotherReferenceToTheSamePersonObject</em> inside the function.</li>
        <li>No new instances of Person are created.</li>
        <li>Both "<em>person</em>" and "<em>anotherReferenceToTheSamePersonObject</em>" hold the same value of 3bad086a.</li>
        <li>Don't try this but person==anotherReferenceToTheSamePersonObject would be true.</li>
        <li>Both variables have IDENTICAL COPIES of the reference and they both refer to the same Person Object, the SAME Object on the Heap and NOT A COPY.</li>
       </ul></li>
     </ul>
     <p>A picture is worth a thousand words:</p>
     <p><img src="Ba3hJ.jpg" alt="Pass by Value"></p>
     <p><strong>Note that the anotherReferenceToTheSamePersonObject arrows is directed towards the Object and not towards the variable person!</strong></p>
     <p>If you didn't get it then just trust me and remember that it's better to say that <strong>Java is pass by value</strong>. Well, <strong>pass by reference value</strong>. Oh well, even better is <strong><em>pass-by-copy-of-the-variable-value! ;)</em></strong></p>
     <p>Now feel free to hate me but note that given this <strong>there is no difference between passing primitive data types and Objects</strong> when talking about method arguments.</p>
     <p>You always pass a copy of the bits of the value of the reference!</p>
     <ul>
      <li>If it's a primitive data type these bits will contain the value of the primitive data type itself.</li>
      <li>If it's an Object the bits will contain the value of the address that tells the JVM how to get to the Object.</li>
     </ul>
     <blockquote>
      <p>Java is pass-by-value because inside a method you can modify the referenced Object as much as you want but no matter how hard you try you'll never be able to modify the passed variable that will keep referencing (not p _ _ _ _ _ _ _) the same Object no matter what!</p>
     </blockquote>
     <hr>
     <blockquote>
      <p>The changeName function above will never be able to modify the actual content (the bit values) of the passed reference. In other word changeName cannot make Person person refer to another Object.</p>
     </blockquote>
     <hr>
     <p>Of course you can cut it short and just say that <strong>Java is pass-by-value!</strong></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>I tried this: &lt;br /&gt; File file = new File("C:/"); changeFile(file); System.out.println(file.getAbsolutePath()); } public static void changeFile(File f) { f = new File("D:/"); }`</span> <span> - </span> <span class="display-name">Excessstone</span> <span> </span> <span class="date">29 Jun 2021 at 09:44</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>391</span>
     </div>
     <div>
      <span>Answerer: </span> <span>ScArcher2</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Sep 2008 at 20:20</span>
     </div>
    </div>
    <div>
     <p>Java passes references by value.</p>
     <p>So you can't change the reference that gets passed in.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Raises the question, whether Java is an Object Oriented of Reference Oriented language, rather than ´a mechanism for passing arguments´. <a href="https://en.wikipedia.org/wiki/Java_(programming_language)#Principles" rel="nofollow noreferrer">en.wikipedia.org/wiki/Java_(programming_language)#Principles</a></span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">8 Mar 2022 at 12:48</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>295</span>
     </div>
     <div>
      <span>Answerer: </span> <span>cutmancometh</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Sep 2013 at 11:34</span>
     </div>
    </div>
    <div>
     <p>I feel like arguing about "pass-by-reference vs pass-by-value" is not super-helpful.</p>
     <p>If you say, "Java is pass-by-whatever (reference/value)", in either case, you're not provide a complete answer. Here's some additional information that will hopefully aid in understanding what's happening in memory.</p>
     <p>Crash course on stack/heap before we get to the Java implementation: Values go on and off the stack in a nice orderly fashion, like a stack of plates at a cafeteria. Memory in the heap (also known as dynamic memory) is haphazard and disorganized. The JVM just finds space wherever it can, and frees it up as the variables that use it are no longer needed.</p>
     <p>Okay. First off, local primitives go on the stack. So this code:</p>
     <pre><code>int x = 3;
float y = 101.1f;
boolean amIAwesome = true;
</code></pre>
     <p>results in this:</p>
     <p><img src="7nGKU.png" alt="primitives on the stack"></p>
     <p>When you declare and instantiate an object. The actual object goes on the heap. What goes on the stack? The address of the object on the heap. C++ programmers would call this a pointer, but some Java developers are against the word "pointer". Whatever. Just know that the address of the object goes on the stack.</p>
     <p>Like so:</p>
     <pre><code>int problems = 99;
String name = "Jay-Z";
</code></pre>
     <p><img src="yTIYp.png" alt="a b*7ch aint one!"></p>
     <p>An array is an object, so it goes on the heap as well. And what about the objects in the array? They get their own heap space, and the address of each object goes inside the array.</p>
     <pre><code>JButton[] marxBros = new JButton[3];
marxBros[0] = new JButton("Groucho");
marxBros[1] = new JButton("Zeppo");
marxBros[2] = new JButton("Harpo");
</code></pre>
     <p><img src="v2b33.png" alt="marx brothers"></p>
     <p>So, what gets passed in when you call a method? If you pass in an object, what you're actually passing in is the address of the object. Some might say the "value" of the address, and some say it's just a reference to the object. This is the genesis of the holy war between "reference" and "value" proponents. What you call it isn't as important as that you understand that what's getting passed in is the address to the object.</p>
     <pre><code>private static void shout(String name){
    System.out.println("There goes " + name + "!");
}

public static void main(String[] args){
    String hisName = "John J. Jingleheimerschmitz";
    String myName = hisName;
    shout(myName);
}
</code></pre>
     <p>One String gets created and space for it is allocated in the heap, and the address to the string is stored on the stack and given the identifier <code>hisName</code>, since the address of the second String is the same as the first, no new String is created and no new heap space is allocated, but a new identifier is created on the stack. Then we call <code>shout()</code>: a new stack frame is created and a new identifier, <code>name</code> is created and assigned the address of the already-existing String.</p>
     <p><img src="q0prc.png" alt="la da di da da da da"></p>
     <p>So, value, reference? You say "potato".</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>12</td>
        <td><span>Such an awesome answer that even a fool like myself was able to understand. I would add also amend that "pass by value" literally means that the literal value in the stack is passed.</span> <span> - </span> <span class="display-name">Dude156</span> <span> </span> <span class="date">12 Sep 2020 at 21:22</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>so cute, and the best answer</span> <span> - </span> <span class="display-name">Mehdi Monzavi</span> <span> </span> <span class="date">4 Jan 2022 at 14:55</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Precisely, the war starts, when you want to say "an object is passed by reference"</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">15 Feb 2022 at 23:46</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Upvoted for the first paragraph. The top answers all stick to a strict, narrow-minded definition of pass-by-value/reference without considering what a programmer is actually interested in.</span> <span> - </span> <span class="display-name">fishinear</span> <span> </span> <span class="date">12 Aug 2022 at 11:55</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>233</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Hank Gay</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Sep 2008 at 20:21</span>
     </div>
    </div>
    <div>
     <p>Basically, reassigning Object parameters doesn't affect the argument, e.g.,</p>
     <pre><code>private static void foo(Object bar) {
    bar = null;
}

public static void main(String[] args) {
    String baz = "Hah!";
    foo(baz);
    System.out.println(baz);
}
</code></pre>
     <p>will print out <code>"Hah!"</code> instead of <code>null</code>. The reason this works is because <code>bar</code> is a copy of the value of <code>baz</code>, which is just a reference to <code>"Hah!"</code>. If it were the actual reference itself, then <code>foo</code> would have redefined <code>baz</code> to <code>null</code>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>219</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Eclipse</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Sep 2008 at 17:38</span>
     </div>
    </div>
    <div>
     <p>Just to show the contrast, compare the following <a href="https://en.wikipedia.org/wiki/C++" rel="noreferrer">C++</a> and <a href="http://en.wikipedia.org/wiki/Java_%28programming_language%29" rel="noreferrer">Java</a> snippets:</p>
     <p>In C++: <strong>Note: Bad code - memory leaks!</strong> But it demonstrates the point.</p>
     <pre><code>void cppMethod(int val, int &amp;ref, Dog obj, Dog &amp;objRef, Dog *objPtr, Dog *&amp;objPtrRef)
{
    val = 7; // Modifies the copy
    ref = 7; // Modifies the original variable
    obj.SetName("obj"); // Modifies the copy of Dog passed
    objRef.SetName("objRef"); // Modifies the original Dog passed
    objPtr-&gt;SetName("objPtr"); // Modifies the original Dog pointed to 
                               // by the copy of the pointer passed.
    objPtr = new Dog("newObjPtr");  // Modifies the copy of the pointer, 
                                   // leaving the original object alone.
    objPtrRef-&gt;SetName("objRefPtr"); // Modifies the original Dog pointed to 
                                    // by the original pointer passed. 
    objPtrRef = new Dog("newObjPtrRef"); // Modifies the original pointer passed
}

int main()
{
    int a = 0;
    int b = 0;
    Dog d0 = Dog("d0");
    Dog d1 = Dog("d1");
    Dog *d2 = new Dog("d2");
    Dog *d3 = new Dog("d3");
    cppMethod(a, b, d0, d1, d2, d3);
    // a is still set to 0
    // b is now set to 7
    // d0 still have name "d0"
    // d1 now has name "objRef"
    // d2 now has name "objPtr"
    // d3 now has name "newObjPtrRef"
}
</code></pre>
     <p>In Java,</p>
     <pre><code>public static void javaMethod(int val, Dog objPtr)
{
   val = 7; // Modifies the copy
   objPtr.SetName("objPtr") // Modifies the original Dog pointed to 
                            // by the copy of the pointer passed.
   objPtr = new Dog("newObjPtr");  // Modifies the copy of the pointer, 
                                  // leaving the original object alone.
}

public static void main()
{
    int a = 0;
    Dog d0 = new Dog("d0");
    javaMethod(a, d0);
    // a is still set to 0
    // d0 now has name "objPtr"
}
</code></pre>
     <p>Java only has the two types of passing: by value for built-in types, and by value of the pointer for object types.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>This shows that java is not pass by value as it doesn't copy the whole object onto the stack like C++ does, as shown in the example above - ..., Dog obj,...</span> <span> - </span> <span class="display-name">Solubris</span> <span> </span> <span class="date">25 Nov 2020 at 23:03</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>No, Java passes references by value. That's why when you overwrite objPtr in the java example, the original Dog object doesn't change. But if modify the object being pointed to by objPtr, it does.</span> <span> - </span> <span class="display-name">Eclipse</span> <span> </span> <span class="date">26 Nov 2020 at 22:03</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>211</span>
     </div>
     <div>
      <span>Answerer: </span> <span>John Channing</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Sep 2008 at 20:23</span>
     </div>
    </div>
    <div>
     <p>Java passes references to objects by value.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>6</td>
        <td><span>Not a useful explanation.</span> <span> - </span> <span class="display-name">Johnes</span> <span> </span> <span class="date">14 Jan 2022 at 15:31</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>What you mean is Java passes by copying the value to the reference.</span> <span> - </span> <span class="display-name">skystar7</span> <span> </span> <span class="date">1 Jan 2023 at 18:59</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>172</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Jörg W Mittag</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Sep 2010 at 22:07</span>
     </div>
    </div>
    <div>
     <p>I can't believe that nobody mentioned Barbara Liskov yet. When she designed CLU in 1974, she ran into this same terminology problem, and she invented the term <em>call by sharing</em> (also known as <em>call by object-sharing</em> and <em>call by object</em>) for this specific case of "call by value where the value is a reference".</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>:) another term, feeding the confusion around the Java Island, just because it's politically incorrect to say "An Object is passed by reference, according to what we find on the stack".</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">6 Dec 2021 at 18:11</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>141</span>
     </div>
     <div>
      <span>Answerer: </span> <span>JacquesB</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Jan 2009 at 20:50</span>
     </div>
    </div>
    <div>
     <p>The crux of the matter is that the word <em>reference</em> in the expression "pass by reference" means something completely different from the usual meaning of the word <em>reference</em> in Java.</p>
     <p>Usually in Java <em>reference</em> means a a <em>reference to an object</em>. But the technical terms <em>pass by reference/value</em> from programming language theory is talking about a <em>reference to the memory cell holding the variable</em>, which is something completely different.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Yes, a object reference is technically a handle, not yet the address, and so even a step further from "by value".</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">6 Dec 2021 at 18:14</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>107</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Sanjeev</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Jan 2019 at 21:37</span>
     </div>
    </div>
    <div>
     <p>There are already great answers that cover this. I wanted to make a small contribution by sharing a <strong>very simple example</strong> (which will compile) contrasting the behaviors between Pass-by-reference in c++ and Pass-by-value in Java.</p>
     <p>A few points:</p>
     <ol>
      <li>The term "reference" is a overloaded with two separate meanings. In Java it simply means a pointer, but in the context of "Pass-by-reference" it means a handle to the original variable which was passed in.</li>
      <li><strong>Java is Pass-by-value</strong>. Java is a descendent of C (among other languages). Before C, several (but not all) earlier languages like FORTRAN and COBOL supported PBR, but C did not. PBR allowed these other languages to make changes to the passed variables inside sub-routines. In order to accomplish the same thing (i.e. change the values of variables inside functions), C programmers passed pointers to variables into functions. Languages inspired by C, such as Java, borrowed this idea and continue to pass pointer to methods as C did, except that Java calls its pointers References. Again, this is a different use of the word "Reference" than in "Pass-By-Reference".</li>
      <li><strong>C++ allows Pass-by-reference</strong> by declaring a reference parameter using the "&amp;" character (which happens to be the same character used to indicate "the address of a variable" in both C and C++). For example, if we pass in a pointer by reference, the parameter and the argument are not just pointing to the same object. Rather, they are the same variable. If one gets set to a different address or to null, so does the other.</li>
      <li>In the C++ example below I'm passing a <strong>pointer</strong> to a null terminated string <strong>by reference</strong>. And in the Java example below I'm passing a Java reference to a String (again, the same as a pointer to a String) by value. Notice the output in the comments.</li>
     </ol>
     <p>C++ pass by reference example:</p>
     <pre><code>using namespace std;
#include &lt;iostream&gt;

void change (char *&amp;str){   // the '&amp;' makes this a reference parameter
    str = NULL;
}

int main()
{
    char *str = "not Null";
    change(str);
    cout&lt;&lt;"str is " &lt;&lt; str;      // ==&gt;str is &lt;null&gt;
}
</code></pre>
     <p>Java pass "a Java reference" by value example</p>
     <pre><code>public class ValueDemo{
    
    public void change (String str){
        str = null;
    }

     public static void main(String []args){
        ValueDemo vd = new ValueDemo();
        String str = "not null";
        vd.change(str);
        System.out.println("str is " + str);    // ==&gt; str is not null!!
                                                // Note that if "str" was
                                                // passed-by-reference, it
                                                // WOULD BE NULL after the
                                                // call to change().
     }
}
</code></pre>
     <p><strong>EDIT</strong></p>
     <p>Several people have written comments which seem to indicate that either they are not looking at my examples or they don't get the c++ example. Not sure where the disconnect is, but guessing the c++ example is not clear. I'm posting the same example in pascal because I think pass-by-reference looks cleaner in pascal, but I could be wrong. I might just be confusing people more; I hope not.</p>
     <p>In pascal, parameters passed-by-reference are called "var parameters". In the procedure setToNil below, please note the keyword 'var' which precedes the parameter 'ptr'. When a pointer is passed to this procedure, it will be passed <strong>by reference</strong>. Note the behavior: when this procedure sets ptr to nil (that's pascal speak for NULL), it will set the argument to nil--you can't do that in Java.</p>
     <pre><code>program passByRefDemo;
type 
   iptr = ^integer;
var
   ptr: iptr;
   
   procedure setToNil(var ptr : iptr);
   begin
       ptr := nil;
   end;

begin
   new(ptr);
   ptr^ := 10;
   setToNil(ptr);
   if (ptr = nil) then
       writeln('ptr seems to be nil');     { ptr should be nil, so this line will run. }
end.
</code></pre>
     <p><strong>EDIT 2</strong></p>
     <p>Some excerpts from <strong>"THE Java Programming Language"</strong> by Ken Arnold, <strong>James Gosling (the guy who invented Java)</strong>, and David Holmes, chapter 2, section 2.6.5</p>
     <blockquote>
      <p><strong>All parameters to methods are passed "by value"</strong>. In other words, values of parameter variables in a method are copies of the invoker specified as arguments.</p>
     </blockquote>
     <p>He goes on to make the same point regarding objects . . .</p>
     <blockquote>
      <p>You should note that when the parameter is an object reference, it is the object reference-not the object itself-that is <strong>passed "by value"</strong>.</p>
     </blockquote>
     <p>And towards the end of the same section he makes a broader statement about java being only pass by value and never pass by reference.</p>
     <blockquote>
      <p>The Java programming language <strong>does not pass objects by reference; it</strong> <strong>passes object references by value</strong>. Because two copies of the same reference refer to the same actual object, changes made through one reference variable are visible through the other. There is exactly one parameter passing mode-<strong>pass by value</strong>-and that helps keep things simple.</p>
     </blockquote>
     <p>This section of the book has a great explanation of parameter passing in Java and of the distinction between pass-by-reference and pass-by-value and it's by the creator of Java. I would encourage anyone to read it, especially if you're still not convinced.</p>
     <p>I think the difference between the two models is very subtle and unless you've done programming where you actually used pass-by-reference, it's easy to miss where two models differ.</p>
     <p>I hope this settles the debate, but probably won't.</p>
     <p><strong>EDIT 3</strong></p>
     <p>I might be a little obsessed with this post. Probably because I feel that the makers of Java inadvertently spread misinformation. If instead of using the word "reference" for pointers they had used something else, say dingleberry, there would've been no problem. You could say, "Java passes dingleberries by value and not by reference", and nobody would be confused.</p>
     <p>That's the reason only Java developers have issue with this. They look at the word "reference" and think they know exactly what that means, so they don't even bother to consider the opposing argument.</p>
     <p>Anyway, I noticed a comment in an older post, which made a balloon analogy which I really liked. So much so that I decided to glue together some clip-art to make a set of cartoons to illustrate the point.</p>
     <p><strong>Passing a reference by value</strong>--Changes to the reference are not reflected in the caller's scope, but the changes to the object are. This is because the reference is copied, but the both the original and the copy refer to the same object. <a href="https://i.stack.imgur.com/RvkqU.png" rel="noreferrer"><img src="RvkqU.png" alt="Passing Object references By Value"></a></p>
     <p><strong>Pass by reference</strong>--There is no copy of the reference. Single reference is shared by both the caller and the function being called. Any changes to the reference or the Object's data are reflected in the caller's scope. <a href="https://i.stack.imgur.com/SHXkC.png" rel="noreferrer"><img src="SHXkC.png" alt="Pass by reference"></a></p>
     <p><strong>EDIT 4</strong></p>
     <p>I have seen posts on this topic which describe the low level implementation of parameter passing in Java, which I think is great and very helpful because it makes an abstract idea concrete. However, to me the question is more about <strong>the behavior described in the language specification</strong> than about the technical implementation of the behavior. This is an exerpt from the <a href="https://docs.oracle.com/javase/specs/jls/se19/html/jls-8.html#jls-8.4.1" rel="noreferrer">Java Language Specification, section 8.4.1</a> :</p>
     <blockquote>
      <p>When the method or constructor is invoked (§15.12), <strong>the values of the actual argument expressions initialize newly created parameter variables, each of the declared type, before execution of the body of the method or constructor.</strong> The Identifier that appears in the DeclaratorId may be used as a simple name in the body of the method or constructor to refer to the formal parameter.</p>
     </blockquote>
     <p>Which means, java creates a copy of the passed parameters before executing a method. Like most people who studied compilers in college, I used <a href="https://rads.stackoverflow.com/amzn/click/com/0201100886" rel="noreferrer">"The Dragon Book"</a> which is <strong>THE</strong> compilers book. It has a good description of "Call-by-value" and "Call-by-Reference" in Chapter 1. The Call-by-value description matches up with Java Specs exactly.</p>
     <p>Back when I studied compilers-in the 90's, I used the first edition of the book from 1986 which pre-dated Java by about 9 or 10 years. However, I just ran across a copy of the <a href="https://rads.stackoverflow.com/amzn/click/com/B009TGD06W" rel="noreferrer">2nd Eddition</a> from 2007 <strong>which actually mentions Java!</strong> Section 1.6.6 labeled "Parameter Passing Mechanisms" describes parameter passing pretty nicely. Here is an excerpt under the heading "Call-by-value" which mentions Java:</p>
     <blockquote>
      <p>In call-by-value, the actual parameter is evaluated (if it is an expression) or copied (if it is a variable). The value is placed in the location belonging to the corresponding formal parameter of the called procedure. <strong>This method is used in C and Java, and is a common option in C++ , as well as in most other languages.</strong></p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>"The Java programming language does not pass objects by reference; it passes object references by value." I think this statement as a whole is wrong. Assume, you want to pass an object to a method ...</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">16 Feb 2022 at 00:22</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@SamGinrich, in this case you are passing a reference to that object. The object exists somewhere in memory. The reference (otherwise known as a pointer) is like a primitive (like a long) which holds the memory address of the object. What's passed into the method is actually a copy of the reference. Since you're passing a COPY of the reference, this is pass by value (i.e. you're passing the reference by value). If you were to set the copy to null inside the method, it would have no affect on the original. If this was pass by reference setting the copy to null would also set the original to nul</span> <span> - </span> <span class="display-name">Sanjeev</span> <span> </span> <span class="date">17 Feb 2022 at 15:40</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@SamGinrich Have a look at my code example and the two diagrams I posted.</span> <span> - </span> <span class="display-name">Sanjeev</span> <span> </span> <span class="date">17 Feb 2022 at 15:41</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Totally agree with your presentation. I doubt that Ken Arnold et al. are qualified to rename long time established concepts, where "passing an object reference" had been equivalent to "passing an object by reference", as you obviously work on shared objects and references for this purpose are invariant, in analogy to pointers. That's how I learned it at university. Now, in the use case "passing an object to some method" focusing on the technical aspect of the reference appears as artificial narrowing, not catching up on: "Does the called method work on the original object or a copy?"</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">17 Feb 2022 at 16:34</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@SamGinrich If you look at the definition of pass-by-value, that's exactly what it boils down to - PBV = passing a copy. And if you look at the Java language definition, that's exactly what Java does. I've included excerpts from both "The dragon book" and the Java language specification (Edit 4). Also, Arnold and Gosling are both highly regarded computer scientists and the creators of Java. They are actually NOT renaming established concepts. If you look at the excerpts form their book (Edit 2), they are saying exactly the same as my post and it's consistent with established Computer Science.</span> <span> - </span> <span class="display-name">Sanjeev</span> <span> </span> <span class="date">18 Feb 2022 at 16:01</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Sure, and I explained, why I'm qualified to reject all of these, according to established Computer Science. And I well understand, that Java wants to have its island, probably driven by testosterone. ;) Terms were well defined and understood before Java, when there was no "look at the definition of some Java-Guru". <a href="https://www.tutorialspoint.com/cprogramming/c_function_call_by_reference.htm" rel="nofollow noreferrer">tutorialspoint.com/cprogramming/…</a></span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">21 Feb 2022 at 12:06</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@SamGinrich These definitions existed BEFORE Java. They are not the definitions of "some Java-Guru". The "Dragon Book" existed BEFORE Java. Computer Science existed BEFORE Java. The link you posted completely missed the point of a swap test. In order for it to be valid you would need to swap the actual pointers, not what they point to. It's silly the take the word of some random guy who wrote a tutorial on the internet over people like Sethi, Ullman, Lam, and Aho. Also, Gosling is no just a "Guru". He's the creator of Java. I'm sure he's more qualified than anyone to comment on Java.</span> <span> - </span> <span class="display-name">Sanjeev</span> <span> </span> <span class="date">21 Feb 2022 at 17:25</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@SamGinrich I don't doubt your qualification. But I have sourced six famous computer scientists with PhDs who are widely published to make my point. And not just any computer scientists. Gosling created Java. Sethi, Ullman, Lam, and Aho are the gods of compilers. They wrote the most widely used text book on compilers. You should look at the list of publications, accomplishments, and awards for these people. In response to that you have to give me something better than a nameless guy with a laptop who writes tutorials for a website.</span> <span> - </span> <span class="display-name">Sanjeev</span> <span> </span> <span class="date">21 Feb 2022 at 17:36</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Think a Guru is someone who creates own rules. Now claiming these rules to be world formula, while the rest of the computer science community does not agree, leads to discussions like the one we have. What have you achieved, if for every statement of mine you refer precisely to the same people, which have called out for their arbitrary change of terms.</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">21 Feb 2022 at 18:17</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@SamGinrich Here is the definition of Guru according to Merriam-Webster : <a href="https://www.merriam-webster.com/dictionary/guru" rel="nofollow noreferrer">merriam-webster.com/dictionary/guru</a>. The assertion, "the rest of the computer science community does not agree", can you site any sources for this? As for, "the same people", if I really tried, I could get you more sources, but I'd have to go digging through text books. Can you at least supply one decent source? Until then here is IBMs documentation on C and C++ which show how of the two only C++ an accomplish this : <a href="https://www.ibm.com/docs/en/zos/2.4.0?topic=calls-pass-by-reference-c-only" rel="nofollow noreferrer">ibm.com/docs/en/zos/2.4.0?topic=calls-pass-by-reference-c-on‌​ly</a>. . .</span> <span> - </span> <span class="display-name">Sanjeev</span> <span> </span> <span class="date">21 Feb 2022 at 19:29</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@SamGinrich . . . also here is a really good article by Scott Stanchfield of on why Java is pass-by-value only. It does a better job than me. <a href="https://www.javadude.com/articles/passbyvalue.htm" rel="nofollow noreferrer">javadude.com/articles/passbyvalue.htm</a></span> <span> - </span> <span class="display-name">Sanjeev</span> <span> </span> <span class="date">21 Feb 2022 at 19:31</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Oops, think I totally agreed with your answer above, though not with citing definitions, which are neither from you nor from me.</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">22 Feb 2022 at 17:55</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@SamGinrich, you're right about citing definitions.</span> <span> - </span> <span class="display-name">Sanjeev</span> <span> </span> <span class="date">22 Feb 2022 at 23:21</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>:) As stated above I reject them. The original semantics of "passing-by-reference" is that an instance is shared among caller and called method. Whoever came later to define for himself something else, cannot allocate computer science as a whole.</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">24 Feb 2022 at 17:59</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@SamGinrich again, nobody has changed the definition. I worked hard to compile all the information in this post, which shows exactly that. If you think someone is trying to changed the definition, please share some evidence of that.</span> <span> - </span> <span class="display-name">Sanjeev</span> <span> </span> <span class="date">24 Feb 2022 at 18:07</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>As stated above, the main post above is an island, even if it's a huge one. I'm still wondering, how someone with IQ&gt;=85% can put out a sentence of shape "Java is &lt;a parameter passing mode&gt;".</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">24 Feb 2022 at 18:17</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Indirect evidence, that other definitions exist is here <a href="https://stackoverflow.com/questions/2229498/passing-by-reference-in-c" title="passing by reference in c">stackoverflow.com/questions/2229498/passing-by-reference-in-‌​c</a></span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">24 Feb 2022 at 19:32</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>A) that is not evidence of "Established Computer Science" disagreeing with Gosling, it's someone asking a question on stack overflow. B) Thats an example of a pointer being passed by value, not pass-by-reference. C) my post explains this. Have you read it carefully?</span> <span> - </span> <span class="display-name">Sanjeev</span> <span> </span> <span class="date">25 Feb 2022 at 17:36</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Established Computer science is here <a href="https://learn.microsoft.com/en-us/dotnet/visual-basic/programming-guide/language-features/procedures/passing-arguments-by-value-and-by-reference" rel="nofollow noreferrer">learn.microsoft.com/en-us/dotnet/visual-basic/programming-gu‌​ide/…</a></span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">25 Feb 2022 at 19:08</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@SamGinrich VB ALLOWS pass-by-reference. Java and C do not!! Am I just wasting my time?</span> <span> - </span> <span class="display-name">Sanjeev</span> <span> </span> <span class="date">25 Feb 2022 at 19:11</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>If you say so and loud enough, Established Computer Science will comply. The expectation of a unique terminology on your base - yes, a waste of time!</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">25 Feb 2022 at 19:13</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@SamGinrich please read the Microsfoft documentation which you yourself posted. Microsoft does not disagree with Gosling. You haven't posted anything that shows this. And please stop speaking for "Established Computer Science". Majority of the people around the world who design languages and write compilers studied from The Dragon Book. THAT is established computer science. Not me, not you.</span> <span> - </span> <span class="display-name">Sanjeev</span> <span> </span> <span class="date">25 Feb 2022 at 19:22</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@SamGinrich here is my reply to the post you posted <a href="https://stackoverflow.com/a/71270573/1028560">stackoverflow.com/a/71270573/1028560</a></span> <span> - </span> <span class="display-name">Sanjeev</span> <span> </span> <span class="date">25 Feb 2022 at 19:32</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@SamGinrich saw your post here <a href="https://stackoverflow.com/a/70586240/1028560">stackoverflow.com/a/70586240/1028560</a>. I think I know the source of the confusion. I think you have a misunderstanding of what pass-by-value is. Please have a look at this link <a href="https://blog.penjee.com/passing-by-value-vs-by-reference-java-graphical/" rel="nofollow noreferrer">blog.penjee.com/passing-by-value-vs-by-reference-java-graphi‌​cal</a>. This does a great job of explaining the difference and shows why Java is Pass-By-Value.</span> <span> - </span> <span class="display-name">Sanjeev</span> <span> </span> <span class="date">25 Feb 2022 at 19:38</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I won't. You do not belong to the generation, that grew up with these things and you don't listen anyway, violating the golden rule. <a href="https://stackoverflow.com/a/2229516/9437799">stackoverflow.com/a/2229516/9437799</a></span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">25 Feb 2022 at 19:40</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>HI @Sanjeev I think you might be able to help me with this question based on your good answer here: <a href="https://stackoverflow.com/questions/75185425/what-is-value-reference-vs-pointer" title="what is value reference vs pointer">stackoverflow.com/questions/75185425/…</a>? Thanks</span> <span> - </span> <span class="display-name">Stan</span> <span> </span> <span class="date">20 Jan 2023 at 21:53</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span> <span class="arrow"> <a href="#answer_15">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>101</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Srle</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Nov 2013 at 16:04</span>
     </div>
    </div>
    <div>
     <p>In java everything is reference, so when you have something like: <code>Point pnt1 = new Point(0,0);</code> Java does following:</p>
     <ol>
      <li>Creates new Point object</li>
      <li>Creates new Point reference and initialize that reference to <em>point (refer to)</em> on previously created Point object.</li>
      <li>From here, through Point object life, you will access to that object through pnt1 reference. So we can say that in Java you manipulate object through its reference.<br></li>
     </ol>
     <p><img src="jM54f.png" alt="enter image description here"></p>
     <p><strong>Java doesn't pass method arguments by reference; it passes them by value.</strong> I will use example from <a href="http://www.javaworld.com/javaqa/2000-05/03-qa-0526-pass.html" rel="noreferrer">this site</a>:</p>
     <pre><code>public static void tricky(Point arg1, Point arg2) {
  arg1.x = 100;
  arg1.y = 100;
  Point temp = arg1;
  arg1 = arg2;
  arg2 = temp;
}
public static void main(String [] args) {
  Point pnt1 = new Point(0,0);
  Point pnt2 = new Point(0,0);
  System.out.println("X1: " + pnt1.x + " Y1: " +pnt1.y); 
  System.out.println("X2: " + pnt2.x + " Y2: " +pnt2.y);
  System.out.println(" ");
  tricky(pnt1,pnt2);
  System.out.println("X1: " + pnt1.x + " Y1:" + pnt1.y); 
  System.out.println("X2: " + pnt2.x + " Y2: " +pnt2.y);  
}
</code></pre>
     <p>Flow of the program:</p>
     <pre><code>Point pnt1 = new Point(0,0);
Point pnt2 = new Point(0,0);
</code></pre>
     <p>Creating two different Point object with two different reference associated. <img src="5LIKC.png" alt="enter image description here"></p>
     <pre><code>System.out.println("X1: " + pnt1.x + " Y1: " +pnt1.y); 
System.out.println("X2: " + pnt2.x + " Y2: " +pnt2.y);
System.out.println(" ");
</code></pre>
     <p>As expected output will be:</p>
     <pre><code>X1: 0     Y1: 0
X2: 0     Y2: 0
</code></pre>
     <p><strong>On this line 'pass-by-value' goes into the play...</strong> <br></p>
     <pre><code>tricky(pnt1,pnt2);           public void tricky(Point arg1, Point arg2);
</code></pre>
     <p>References <code>pnt1</code> and <code>pnt2</code> are <strong>passed by value</strong> to the tricky method, which means that now yours references <code>pnt1</code> and <code>pnt2</code> have their <code>copies</code> named <code>arg1</code> and <code>arg2</code>.So <code>pnt1</code> and <code>arg1</code> <em>points</em> to the same object. (Same for the <code>pnt2</code> and <code>arg2</code>) <img src="qd1GH.png" alt="enter image description here"></p>
     <p>In the <code>tricky</code> method:</p>
     <pre><code> arg1.x = 100;
 arg1.y = 100;
</code></pre>
     <p><img src="o4WT0.png" alt="enter image description here"></p>
     <p>Next in the <code>tricky</code> method</p>
     <pre><code>Point temp = arg1;
arg1 = arg2;
arg2 = temp;
</code></pre>
     <p>Here, you first create new <code>temp</code> Point reference which will <em>point</em> on same place like <code>arg1</code> reference. Then you move reference <code>arg1</code> to <em>point</em> to the same place like <code>arg2</code> reference. Finally <code>arg2</code> will <em>point</em> to the same place like <code>temp</code>.</p>
     <p><img src="fX5Q3.png" alt="enter image description here"></p>
     <p>From here scope of <code>tricky</code> method is gone and you don't have access any more to the references: <code>arg1</code>, <code>arg2</code>, <code>temp</code>. <strong>But important note is that everything you do with these references when they are 'in life' will permanently affect object on which they are <em>point</em> to.</strong></p>
     <p>So after executing method <code>tricky</code>, when you return to <code>main</code>, you have this situation: <img src="LRETe.png" alt="enter image description here"></p>
     <p>So now, completely execution of program will be:</p>
     <pre><code>X1: 0         Y1: 0
X2: 0         Y2: 0
X1: 100       Y1: 100
X2: 0         Y2: 0
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>Half of the rent: "everything" is "objects" in your post.</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">15 Feb 2022 at 23:53</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>You wrote: "In java everything is reference" This is not correct. Only objects are references. Primitives are not. This is what @SamGinrich meant by his comment.</span> <span> - </span> <span class="display-name">platypusguy</span> <span> </span> <span class="date">30 May 2022 at 08:43</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_15"><span>Answer 15</span> <span class="arrow"> <a href="#answer_14">↑</a> </span> <span class="arrow"> <a href="#answer_16">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>99</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ganesh</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Oct 2013 at 07:54</span>
     </div>
    </div>
    <div>
     <p><strong>Java is always pass by value, not pass by reference</strong></p>
     <p>First of all, we need to understand what pass by value and pass by reference are.</p>
     <p><strong>Pass by value means that you are making a copy in memory of the actual parameter's value that is passed in. This is a copy of the contents of the actual parameter</strong>.</p>
     <p><strong>Pass by reference (also called pass by address) means that a copy of the address of the actual parameter is stored</strong>.</p>
     <p>Sometimes Java can give the illusion of pass by reference. Let's see how it works by using the example below:</p>
     <pre><code>public class PassByValue {
    public static void main(String[] args) {
        Test t = new Test();
        t.name = "initialvalue";
        new PassByValue().changeValue(t);
        System.out.println(t.name);
    }
    
    public void changeValue(Test f) {
        f.name = "changevalue";
    }
}

class Test {
    String name;
}
</code></pre>
     <p>The output of this program is:</p>
     <blockquote>
      <pre><code>changevalue
</code></pre>
     </blockquote>
     <p>Let's understand step by step:</p>
     <pre><code>Test t = new Test();
</code></pre>
     <p>As we all know it will create an object in the heap and return the reference value back to t. For example, suppose the value of t is <code>0x100234</code> (we don't know the actual JVM internal value, this is just an example) .</p>
     <p><img src="AVrhI.png" alt="first illustration"></p>
     <pre><code>new PassByValue().changeValue(t);
</code></pre>
     <p>When passing reference t to the function it will not directly pass the actual reference value of object test, but it will create a copy of t and then pass it to the function. Since it is <strong>passing by value</strong>, it passes a copy of the variable rather than the actual reference of it. Since we said the value of t was <code>0x100234</code>, both t and f will have the same value and hence they will point to the same object.</p>
     <p><img src="WwdPh.png" alt="second illustration"></p>
     <p>If you change anything in the function using reference f it will modify the existing contents of the object. That is why we got the output <code>changevalue</code>, which is updated in the function.</p>
     <p>To understand this more clearly, consider the following example:</p>
     <pre><code>public class PassByValue {
    public static void main(String[] args) {
        Test t = new Test();
        t.name = "initialvalue";
        new PassByValue().changeRefence(t);
        System.out.println(t.name);
    }
    
    public void changeRefence(Test f) {
        f = null;
    }
}

class Test {
    String name;
}
</code></pre>
     <p>Will this throw a <code>NullPointerException</code>? No, because it only passes a copy of the reference. In the case of passing by reference, it could have thrown a <code>NullPointerException</code>, as seen below:</p>
     <p><img src="jH6KP.png" alt="third illustration"></p>
     <p>Hopefully this will help.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_16"><span>Answer 16</span> <span class="arrow"> <a href="#answer_15">↑</a> </span> <span class="arrow"> <a href="#answer_17">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>90</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Himanshu arora</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Apr 2017 at 05:51</span>
     </div>
    </div>
    <div>
     <p>Java is a pass by value(stack memory)</p>
     <p>How it works</p>
     <ul>
      <li>
       <p>Let's first understand that where java stores primitive data type and object data type.</p></li>
      <li>
       <p>Primitive data types itself and object references are stored in the stack. Objects themselves are stored in the heap.</p></li>
      <li>
       <p>It means, Stack memory stores primitive data types and also the addresses of objects.</p></li>
      <li>
       <p>And you always pass a copy of the bits of the value of the reference.</p></li>
      <li>
       <p>If it's a primitive data type then these copied bits contain the value of the primitive data type itself, That's why when we change the value of argument inside the method then it does not reflect the changes outside.</p></li>
      <li>
       <p>If it's an object data type like <strong>Foo foo=new Foo()</strong> then in this case copy of the address of the object passes like file shortcut , suppose we have a text file <strong>abc.txt</strong> at <strong>C:\desktop</strong> and suppose we make shortcut of the same file and put this inside <strong>C:\desktop\abc-shortcut</strong> so when you access the file from <strong>C:\desktop\abc.txt</strong> and write <strong>'Stack Overflow'</strong> and close the file and again you open the file from shortcut then you write <strong>' is the largest online community for programmers to learn'</strong> then total file change will be <strong>'Stack Overflow is the largest online community for programmers to learn'</strong> which means it doesn't matter from where you open the file , each time we were accessing the same file , here we can assume <strong>Foo</strong> as a file and suppose foo stored at <strong>123hd7h</strong>(original address like <strong>C:\desktop\abc.txt</strong> ) address and <strong>234jdid</strong>(copied address like <strong>C:\desktop\abc-shortcut</strong> which actually contains the original address of the file inside) .. So for better understanding make shortcut file and feel.</p></li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>What about "Java is a programming language"? What about "Designers of Java built their own terminology, that does not exist outside"?</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">25 Feb 2022 at 13:26</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_17"><span>Answer 17</span> <span class="arrow"> <a href="#answer_16">↑</a> </span> <span class="arrow"> <a href="#answer_18">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>76</span>
     </div>
     <div>
      <span>Answerer: </span> <span>karatedog</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 Dec 2013 at 12:23</span>
     </div>
    </div>
    <div>
     <h2>A reference is always a value when represented, no matter what language you use.</h2>
     <p>Getting an outside of the box view, let's look at Assembly or some low level memory management. At the CPU level a <em>reference</em> to anything immediately becomes a <em>value</em> if it gets written to memory or to one of the CPU registers. (That is why <em>pointer</em> is a good definition. It is a value, which has a purpose at the same time).</p>
     <p>Data in memory has a <strong>Location</strong> and at that location there is a value (byte,word, whatever). In Assembly we have a convenient solution to give a <strong>Name</strong> to certain <strong>Location</strong> (aka variable), but when compiling the code, the assembler simply replaces <strong>Name</strong> with the designated location just like your browser replaces domain names with IP addresses.</p>
     <p>Down to the core it is technically impossible to pass a reference to anything in any language without representing it (when it immediately becomes a value).</p>
     <p>Lets say we have a variable Foo, its <strong>Location</strong> is at the 47th byte in memory and its <strong>Value</strong> is 5. We have another variable <strong>Ref2Foo</strong> which is at 223rd byte in memory, and its value will be 47. This Ref2Foo might be a technical variable, not explicitly created by the program. If you just look at 5 and 47 without any other information, you will see just two <strong>Values</strong>. If you use them as references then to reach to <code>5</code> we have to travel:</p>
     <pre><code>(Name)[Location] -&gt; [Value at the Location]
---------------------
(Ref2Foo)[223]  -&gt; 47
(Foo)[47]       -&gt; 5
</code></pre>
     <p>This is how jump-tables work.</p>
     <p>If we want to call a method/function/procedure with Foo's value, there are a few possible way to pass the variable to the method, depending on the <strong>language</strong> and its several method invocation modes:</p>
     <ol>
      <li>5 gets copied to one of the CPU registers (ie. EAX).</li>
      <li>5 gets PUSHd to the stack.</li>
      <li>47 gets copied to one of the CPU registers</li>
      <li>47 PUSHd to the stack.</li>
      <li>223 gets copied to one of the CPU registers.</li>
      <li>223 gets PUSHd to the stack.</li>
     </ol>
     <p>In every cases above a value - a <strong>copy</strong> of an existing value - has been created, it is now upto the receiving method to handle it. When you write "Foo" inside the method, it is either read out from EAX, or automatically <strong>dereferenced</strong>, or double dereferenced, the process depends on how the language works and/or what the type of Foo dictates. This is hidden from the developer until she circumvents the dereferencing process. So a <em>reference</em> is a <em>value</em> when represented, because a reference is a value that has to be processed (at language level).</p>
     <p>Now we have passed Foo to the method:</p>
     <ul>
      <li>in case 1. and 2. if you change Foo (<code>Foo = 9</code>) it only affects local scope as you have a copy of the Value. From inside the method we cannot even determine where in memory the original Foo was located.</li>
      <li>in case 3. and 4. if you use default language constructs and change Foo (<code>Foo = 11</code>), it could change Foo globally (depends on the language, ie. Java or like Pascal's <code>procedure findMin(x, y, z: integer;</code><strong>var m</strong><code>: integer);</code>). However if the language allows you to circumvent the dereference process, you can change <code>47</code>, say to <code>49</code>. At that point Foo seems to have been changed if you read it, because you have changed the <strong>local pointer</strong> to it. And if you were to modify this Foo inside the method (<code>Foo = 12</code>) you will probably FUBAR the execution of the program (aka. segfault) because you will write to a different memory than expected, you can even modify an area that is destined to hold executable program and writing to it will modify running code (Foo is now not at <code>47</code>). BUT Foo's value of <code>47</code> did not change globally, only the one inside the method, because <code>47</code> was also a copy to the method.</li>
      <li>in case 5. and 6. if you modify <code>223</code> inside the method it creates the same mayhem as in 3. or 4. (a pointer, pointing to a now bad value, that is again used as a pointer) but this is still a local problem, as 223 was <strong>copied</strong>. However if you are able to dereference <code>Ref2Foo</code> (that is <code>223</code>), reach to and modify the pointed value <code>47</code>, say, to <code>49</code>, it will affect Foo <strong>globally</strong>, because in this case the methods got a copy of <code>223</code> but the referenced <code>47</code> exists only once, and changing that to <code>49</code> will lead every <code>Ref2Foo</code> double-dereferencing to a wrong value.</li>
     </ul>
     <p>Nitpicking on insignificant details, even languages that do pass-by-reference will pass values to functions, but those functions know that they have to use it for dereferencing purposes. This pass-the-reference-as-value is just hidden from the programmer because it is practically useless and the terminology is only <em>pass-by-reference</em>.</p>
     <p>Strict <em>pass-by-value</em> is also useless, it would mean that a 100 Mbyte array should have to be copied every time we call a method with the array as argument, therefore Java cannot be stricly pass-by-value. Every language would pass a reference to this huge array (as a value) and either employs copy-on-write mechanism if that array can be changed locally inside the method or allows the method (as Java does) to modify the array globally (from the caller's view) and a few languages allows to modify the Value of the reference itself.</p>
     <p>So in short and in Java's own terminology, Java is <em>pass-by-value</em> where <em>value</em> can be: either a <strong>real value</strong> or a <strong>value</strong> that is a representation of a <strong>reference</strong>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_18"><span>Answer 18</span> <span class="arrow"> <a href="#answer_17">↑</a> </span> <span class="arrow"> <a href="#answer_19">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>67</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user1767316</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Jul 2016 at 08:29</span>
     </div>
    </div>
    <div>
     <p><strong>In Java, method arguments are all passed by value :</strong></p>
     <p>Java arguments are <strong>all passed by value</strong> (the value or reference is copied when used by the method) :</p>
     <p>In the case of primitive types, Java behaviour is simple: The value is copied in another instance of the primitive type.</p>
     <p>In case of Objects, this is the same: Object variables are references (mem buckets holding only Object’s <strong>address</strong> instead of a primitive value) that was created using the "new" keyword, and are copied like primitive types.</p>
     <p>The behaviour can appear different from primitive types: Because the copied object-variable contains the same address (to the same Object). Object's <strong>content/members</strong> might still be modified within a method and later access outside, giving the illusion that the (containing) Object itself was passed by reference.</p>
     <p>"String" Objects appear to be a good <strong>counter-example</strong> to the urban legend saying that "Objects are passed by reference":</p>
     <p>In effect, using a method, you will never be able, to update the value of a String passed as argument:</p>
     <p>A String Object, holds characters by an array declared <strong>final</strong> that can't be modified. Only the address of the Object might be replaced by another using "new". Using "new" to update the variable, will not let the Object be accessed from outside, since the variable was initially passed by value and copied.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_19"><span>Answer 19</span> <span class="arrow"> <a href="#answer_18">↑</a> </span> <span class="arrow"> <a href="#answer_20">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>63</span>
     </div>
     <div>
      <span>Answerer: </span> <span>kukudas</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Apr 2009 at 21:33</span>
     </div>
    </div>
    <div>
     <p>As far as I know, Java only knows call by value. This means for primitive datatypes you will work with an copy and for objects you will work with an copy of the reference to the objects. However I think there are some pitfalls; for example, this will not work:</p>
     <pre><code>public static void swap(StringBuffer s1, StringBuffer s2) {
    StringBuffer temp = s1;
    s1 = s2;
    s2 = temp;
}


public static void main(String[] args) {
    StringBuffer s1 = new StringBuffer("Hello");
    StringBuffer s2 = new StringBuffer("World");
    swap(s1, s2);
    System.out.println(s1);
    System.out.println(s2);
}
</code></pre>
     <p>This will populate Hello World and not World Hello because in the swap function you use copys which have no impact on the references in the main. But if your objects are not immutable you can change it for example:</p>
     <pre><code>public static void appendWorld(StringBuffer s1) {
    s1.append(" World");
}

public static void main(String[] args) {
    StringBuffer s = new StringBuffer("Hello");
    appendWorld(s);
    System.out.println(s);
}
</code></pre>
     <p>This will populate Hello World on the command line. If you change StringBuffer into String it will produce just Hello because String is immutable. For example:</p>
     <pre><code>public static void appendWorld(String s){
    s = s+" World";
}

public static void main(String[] args) {
    String s = new String("Hello");
    appendWorld(s);
    System.out.println(s);
}
</code></pre>
     <p>However you could make a wrapper for String like this which would make it able to use it with Strings:</p>
     <pre><code>class StringWrapper {
    public String value;

    public StringWrapper(String value) {
        this.value = value;
    }
}

public static void appendWorld(StringWrapper s){
    s.value = s.value +" World";
}

public static void main(String[] args) {
    StringWrapper s = new StringWrapper("Hello");
    appendWorld(s);
    System.out.println(s.value);
}
</code></pre>
     <p>edit: i believe this is also the reason to use StringBuffer when it comes to "adding" two Strings because you can modifie the original object which u can't with immutable objects like String is.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_20"><span>Answer 20</span> <span class="arrow"> <a href="#answer_19">↑</a> </span> <span class="arrow"> <a href="#answer_21">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>61</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Herupkhart</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Oct 2012 at 03:00</span>
     </div>
    </div>
    <div>
     <p>No, it's not pass by reference.</p>
     <p>Java is pass by value according to the Java Language Specification:</p>
     <blockquote>
      <p>When the method or constructor is invoked (§15.12), <strong>the values of the actual argument expressions initialize newly created parameter variables</strong>, each of the declared type, before execution of the body of the method or constructor. The Identifier that appears in the DeclaratorId may be used as a simple name in the body of the method or constructor to refer to the <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.1" rel="noreferrer">formal parameter</a>.</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Java defined itself like this. In history of computer science, the concepts and modi of passing data to functions existed long before Kernighan &amp; Ritchie invented the confusion of pointers and values. For Java one can state, that the own dogmatism of being OBJECT ORIENTED is broke, when in context of calls suddenly a reference is a value, rather than the object instance.</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">3 Apr 2022 at 09:06</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_21"><span>Answer 21</span> <span class="arrow"> <a href="#answer_20">↑</a> </span> <span class="arrow"> <a href="#answer_22">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>57</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Sotirios Delimanolis</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Jul 2014 at 06:48</span>
     </div>
    </div>
    <div>
     <p>I thought I'd contribute this answer to add more details from the Specifications.</p>
     <p>First, <a href="https://stackoverflow.com/questions/373419/whats-the-difference-between-passing-by-reference-vs-passing-by-value">What's the difference between passing by reference vs. passing by value?</a></p>
     <blockquote>
      <p>Passing by reference means the called functions' parameter will be the same as the callers' passed argument (not the value, but the identity</p>
      <ul>
       <li>the variable itself).</li>
      </ul>
      <p>Pass by value means the called functions' parameter will be a copy of the callers' passed argument.</p>
     </blockquote>
     <p>Or from wikipedia, <a href="http://en.wikipedia.org/wiki/Call_by_reference#Call_by_reference" rel="noreferrer">on the subject of pass-by-reference</a></p>
     <blockquote>
      <p>In call-by-reference evaluation (also referred to as pass-by-reference), a function receives an implicit reference to a variable used as argument, rather than a copy of its value. This typically means that the function can modify (i.e. assign to) the variable used as argument—something that will be seen by its caller.</p>
     </blockquote>
     <p>And <a href="http://en.wikipedia.org/wiki/Call_by_value#Call_by_value" rel="noreferrer">on the subject of pass-by-value</a></p>
     <blockquote>
      <p>In call-by-value, the argument expression is evaluated, and the resulting value is bound to the corresponding variable in the function [...]. If the function or procedure is able to assign values to its parameters, only its local copy is assigned [...].</p>
     </blockquote>
     <p>Second, we need to know what Java uses in its method invocations. The <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1" rel="noreferrer">Java Language Specification</a> states</p>
     <blockquote>
      <p>When the method or constructor is invoked (§15.12), <strong>the values of the actual argument expressions initialize newly created parameter variables</strong>, each of the declared type, before execution of the body of the method or constructor.</p>
     </blockquote>
     <p>So it assigns (or binds) the value of the argument to the corresponding parameter variable.</p>
     <p><strong>What is the value of the argument?</strong></p>
     <p>Let's consider reference types, the <a href="http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.4" rel="noreferrer">Java Virtual Machine Specification</a> states</p>
     <blockquote>
      <p>There are three kinds of <strong>reference types</strong>: class types, array types, and interface types. <strong>Their values are references to dynamically created class instances, arrays, or class instances or arrays that implement interfaces, respectively.</strong></p>
     </blockquote>
     <p>The <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3.1" rel="noreferrer">Java Language Specification</a> also states</p>
     <blockquote>
      <p><strong>The reference values (often just references) are pointers to these objects</strong>, and a special null reference, which refers to no object.</p>
     </blockquote>
     <p>The value of an argument (of some reference type) is a pointer to an object. Note that a variable, an invocation of a method with a reference type return type, and an instance creation expression (<code>new ...</code>) all resolve to a reference type value.</p>
     <p>So</p>
     <pre><code>public void method (String param) {}
...
String variable = new String("ref");
method(variable);
method(variable.toString());
method(new String("ref"));
</code></pre>
     <p>all bind the value of a reference to a <code>String</code> instance to the method's newly created parameter, <code>param</code>. This is exactly what the definition of pass-by-value describes. As such, <strong>Java is pass-by-value</strong>.</p>
     <p><strong>The fact that you can follow the reference to invoke a method or access a field of the referenced object is completely irrelevant to the conversation.</strong> The definition of pass-by-reference was</p>
     <blockquote>
      <p>This typically means that the function can modify (i.e. assign to) the variable used as argument—something that will be seen by its caller.</p>
     </blockquote>
     <p>In Java, modifying the variable means reassigning it. In Java, if you reassigned the variable within the method, it would go unnoticed to the caller. <strong>Modifying the object referenced by the variable is a different concept entirely.</strong></p>
     <hr>
     <p>Primitive values are also defined in the Java Virtual Machine Specification, <a href="http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3" rel="noreferrer">here</a>. The value of the type is the corresponding integral or floating point value, encoded appropriately (8, 16, 32, 64, etc. bits).</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_22"><span>Answer 22</span> <span class="arrow"> <a href="#answer_21">↑</a> </span> <span class="arrow"> <a href="#answer_23">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>57</span>
     </div>
     <div>
      <span>Answerer: </span> <span>spiderman</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 May 2015 at 21:24</span>
     </div>
    </div>
    <div>
     <p>Let me try to explain my understanding with the help of four examples. Java is pass-by-value, and not pass-by-reference</p>
     <p>/**</p>
     <p>Pass By Value</p>
     <p>In Java, all parameters are passed by value, i.e. assigning a method argument is not visible to the caller.</p>
     <p>*/</p>
     <p><strong>Example 1:</strong></p>
     <pre><code>public class PassByValueString {
    public static void main(String[] args) {
        new PassByValueString().caller();
    }

    public void caller() {
        String value = "Nikhil";
        boolean valueflag = false;
        String output = method(value, valueflag);
        /*
         * 'output' is insignificant in this example. we are more interested in
         * 'value' and 'valueflag'
         */
        System.out.println("output : " + output);
        System.out.println("value : " + value);
        System.out.println("valueflag : " + valueflag);

    }

    public String method(String value, boolean valueflag) {
        value = "Anand";
        valueflag = true;
        return "output";
    }
}
</code></pre>
     <p><strong>Result</strong></p>
     <pre><code>output : output
value : Nikhil
valueflag : false
</code></pre>
     <p><strong>Example 2:</strong></p>
     <p>/** * * Pass By Value * */</p>
     <pre><code>public class PassByValueNewString {
    public static void main(String[] args) {
        new PassByValueNewString().caller();
    }

    public void caller() {
        String value = new String("Nikhil");
        boolean valueflag = false;
        String output = method(value, valueflag);
        /*
         * 'output' is insignificant in this example. we are more interested in
         * 'value' and 'valueflag'
         */
        System.out.println("output : " + output);
        System.out.println("value : " + value);
        System.out.println("valueflag : " + valueflag);

    }

    public String method(String value, boolean valueflag) {
        value = "Anand";
        valueflag = true;
        return "output";
    }
}
</code></pre>
     <p><strong>Result</strong></p>
     <pre><code>output : output
value : Nikhil
valueflag : false
</code></pre>
     <p><strong>Example 3:</strong></p>
     <p>/** This 'Pass By Value has a feeling of 'Pass By Reference'</p>
     <p>Some people say primitive types and 'String' are 'pass by value' and objects are 'pass by reference'.</p>
     <p>But from this example, we can understand that it is infact pass by value only, keeping in mind that here we are passing the reference as the value. ie: reference is passed by value. That's why are able to change and still it holds true after the local scope. But we cannot change the actual reference outside the original scope. what that means is demonstrated by next example of PassByValueObjectCase2.</p>
     <p>*/</p>
     <pre><code>public class PassByValueObjectCase1 {

    private class Student {
        int id;
        String name;
        public Student() {
        }
        public Student(int id, String name) {
            super();
            this.id = id;
            this.name = name;
        }
        public int getId() {
            return id;
        }
        public void setId(int id) {
            this.id = id;
        }
        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
        @Override
        public String toString() {
            return "Student [id=" + id + ", name=" + name + "]";
        }
    }

    public static void main(String[] args) {
        new PassByValueObjectCase1().caller();
    }

    public void caller() {
        Student student = new Student(10, "Nikhil");
        String output = method(student);
        /*
         * 'output' is insignificant in this example. we are more interested in
         * 'student'
         */
        System.out.println("output : " + output);
        System.out.println("student : " + student);
    }

    public String method(Student student) {
        student.setName("Anand");
        return "output";
    }
}
</code></pre>
     <p><strong>Result</strong></p>
     <pre><code>output : output
student : Student [id=10, name=Anand]
</code></pre>
     <p><strong>Example 4:</strong></p>
     <p>/**</p>
     <p>In addition to what was mentioned in Example3 (PassByValueObjectCase1.java), we cannot change the actual reference outside the original scope."</p>
     <p>Note: I am not pasting the code for <code>private class Student</code>. The class definition for <code>Student</code> is same as Example3.</p>
     <p>*/</p>
     <pre><code>public class PassByValueObjectCase2 {

    public static void main(String[] args) {
        new PassByValueObjectCase2().caller();
    }

    public void caller() {
        // student has the actual reference to a Student object created
        // can we change this actual reference outside the local scope? Let's see
        Student student = new Student(10, "Nikhil");
        String output = method(student);
        /*
         * 'output' is insignificant in this example. we are more interested in
         * 'student'
         */
        System.out.println("output : " + output);
        System.out.println("student : " + student); // Will it print Nikhil or Anand?
    }

    public String method(Student student) {
        student = new Student(20, "Anand");
        return "output";
    }

}
</code></pre>
     <p><strong>Result</strong></p>
     <pre><code>output : output
student : Student [id=10, name=Nikhil]
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_23"><span>Answer 23</span> <span class="arrow"> <a href="#answer_22">↑</a> </span> <span class="arrow"> <a href="#answer_24">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>55</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Jared Oberhaus</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Mar 2009 at 06:28</span>
     </div>
    </div>
    <div>
     <p>You can never pass by reference in Java, and one of the ways that is obvious is when you want to return more than one value from a method call. Consider the following bit of code in C++:</p>
     <pre><code>void getValues(int&amp; arg1, int&amp; arg2) {
    arg1 = 1;
    arg2 = 2;
}
void caller() {
    int x;
    int y;
    getValues(x, y);
    cout &lt;&lt; "Result: " &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl;
}
</code></pre>
     <p>Sometimes you want to use the same pattern in Java, but you can't; at least not directly. Instead you could do something like this:</p>
     <pre><code>void getValues(int[] arg1, int[] arg2) {
    arg1[0] = 1;
    arg2[0] = 2;
}
void caller() {
    int[] x = new int[1];
    int[] y = new int[1];
    getValues(x, y);
    System.out.println("Result: " + x[0] + " " + y[0]);
}
</code></pre>
     <p>As was explained in previous answers, in Java you're passing a pointer to the array as a value into <code>getValues</code>. That is enough, because the method then modifies the array element, and by convention you're expecting element 0 to contain the return value. Obviously you can do this in other ways, such as structuring your code so this isn't necessary, or constructing a class that can contain the return value or allow it to be set. But the simple pattern available to you in C++ above is not available in Java.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_24"><span>Answer 24</span> <span class="arrow"> <a href="#answer_23">↑</a> </span> <span class="arrow"> <a href="#answer_25">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>48</span>
     </div>
     <div>
      <span>Answerer: </span> <span>shsteimer</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Sep 2008 at 19:42</span>
     </div>
    </div>
    <div>
     <p>The distinction, or perhaps just the way I remember as I used to be under the same impression as the original poster is this: Java is always pass by value. All objects( in Java, anything except for primitives) in Java are references. These references are passed by value.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_25"><span>Answer 25</span> <span class="arrow"> <a href="#answer_24">↑</a> </span> <span class="arrow"> <a href="#answer_26">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>45</span>
     </div>
     <div>
      <span>Answerer: </span> <span>pek</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Sep 2008 at 20:01</span>
     </div>
    </div>
    <div>
     <p>As many people mentioned it before, <a href="http://academic.regis.edu/dbahr/GeneralPages/IntroToProgramming/JavaPassByValue.htm" rel="noreferrer">Java is always pass-by-value</a></p>
     <p>Here is another example that will help you understand the difference (<a href="http://www.javaranch.com/campfire/StoryPassBy.jsp" rel="noreferrer">the classic swap example</a>):</p>
     <pre><code>public class Test {
  public static void main(String[] args) {
    Integer a = new Integer(2);
    Integer b = new Integer(3);
    System.out.println("Before: a = " + a + ", b = " + b);
    swap(a,b);
    System.out.println("After: a = " + a + ", b = " + b);
  }

  public static swap(Integer iA, Integer iB) {
    Integer tmp = iA;
    iA = iB;
    iB = tmp;
  }
}
</code></pre>
     <p>Prints:</p>
     <blockquote>
      <p>Before: a = 2, b = 3<br>
        After: a = 2, b = 3</p>
     </blockquote>
     <p>This happens because iA and iB are new local reference variables that have the same value of the passed references (they point to a and b respectively). So, trying to change the references of iA or iB will only change in the local scope and not outside of this method.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Hi what is the return type of swap method.?</span> <span> - </span> <span class="display-name">Priyanka</span> <span> </span> <span class="date">9 Dec 2021 at 13:24</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Priyanka Ha! So many years later and you are the first to catch that! It's void.</span> <span> - </span> <span class="display-name">pek</span> <span> </span> <span class="date">7 Jan 2022 at 23:47</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Grammar: Is "pass-by-value" an object of a sentence?</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">17 Feb 2022 at 10:13</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_26"><span>Answer 26</span> <span class="arrow"> <a href="#answer_25">↑</a> </span> <span class="arrow"> <a href="#answer_27">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>41</span>
     </div>
     <div>
      <span>Answerer: </span> <span>SWD</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Sep 2008 at 14:48</span>
     </div>
    </div>
    <div>
     <p>I always think of it as "pass by copy". It is a copy of the value be it primitive or reference. If it is a primitive it is a copy of the bits that are the value and if it is an Object it is a copy of the reference.</p>
     <pre><code>public class PassByCopy{
    public static void changeName(Dog d){
        d.name = "Fido";
    }
    public static void main(String[] args){
        Dog d = new Dog("Maxx");
        System.out.println("name= "+ d.name);
        changeName(d);
        System.out.println("name= "+ d.name);
    }
}
class Dog{
    public String name;
    public Dog(String s){
        this.name = s;
    }
}
</code></pre>
     <p>output of java PassByCopy:</p>
     <blockquote>
      <p>name= Maxx<br>
        name= Fido</p>
     </blockquote>
     <p>Primitive wrapper classes and Strings are immutable so any example using those types will not work the same as other types/objects.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_27"><span>Answer 27</span> <span class="arrow"> <a href="#answer_26">↑</a> </span> <span class="arrow"> <a href="#answer_28">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>38</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Gaurav</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Jul 2013 at 06:31</span>
     </div>
    </div>
    <div>
     <p>Java has only pass by value. A very simple example to validate this.</p>
     <pre><code>public void test() {
    MyClass obj = null;
    init(obj);
    //After calling init method, obj still points to null
    //this is because obj is passed as value and not as reference.
}
private void init(MyClass objVar) {
    objVar = new MyClass();
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_28"><span>Answer 28</span> <span class="arrow"> <a href="#answer_27">↑</a> </span> <span class="arrow"> <a href="#answer_29">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>38</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Michael</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Apr 2018 at 23:48</span>
     </div>
    </div>
    <div>
     <p>Unlike some other languages, Java does not allow you to choose between pass-by-value and pass-by-reference—all arguments are passed by value. A method call can pass two types of values to a method—copies of primitive values (e.g., values of int and double) and copies of references to objects.</p>
     <p>When a method modifies a primitive-type parameter, changes to the parameter have no effect on the original argument value in the calling method.</p>
     <p>When it comes to objects, objects themselves cannot be passed to methods. So we pass the reference(address) of the object. We can manipulate the original object using this reference.</p>
     <p><strong>How Java creates and stores objects:</strong> When we create an object we store the object’s address in a reference variable. Let's analyze the following statement.</p>
     <pre><code>Account account1 = new Account();
</code></pre>
     <p>“Account account1” is the type and name of the reference variable, “=” is the assignment operator, “new” asks for the required amount of space from the system. The constructor to the right of keyword new which creates the object is called implicitly by the keyword new. Address of the created object(result of right value, which is an expression called "class instance creation expression") is assigned to the left value (which is a reference variable with a name and a type specified) using the assign operator.</p>
     <p>Although an object’s reference is passed by value, a method can still interact with the referenced object by calling its public methods using the copy of the object’s reference. Since the reference stored in the parameter is a copy of the reference that was passed as an argument, the parameter in the called method and the argument in the calling method refer to the same object in memory.</p>
     <p>Passing references to arrays, instead of the array objects themselves, makes sense for performance reasons. Because everything in Java is passed by value, if array objects were passed, a copy of each element would be passed. For large arrays, this would waste time and consume considerable storage for the copies of the elements.</p>
     <p>In the image below you can see we have two reference variables(These are called pointers in C/C++, and I think that term makes it easier to understand this feature.) in the main method. Primitive and reference variables are kept in stack memory(left side in images below). array1 and array2 reference variables "point" (as C/C++ programmers call it) or reference to a and b arrays respectively, which are objects (values these reference variables hold are addresses of objects) in heap memory (right side in images below).</p>
     <p><a href="https://i.stack.imgur.com/sF7QZ.png" rel="noreferrer"><img src="sF7QZ.png" alt="Pass by value example 1"></a></p>
     <p>If we pass the value of array1 reference variable as an argument to the reverseArray method, a reference variable is created in the method and that reference variable starts pointing to the same array (a).</p>
     <pre><code>public class Test
{
    public static void reverseArray(int[] array1)
    {
        // ...
    }

    public static void main(String[] args)
    {
        int[] array1 = { 1, 10, -7 };
        int[] array2 = { 5, -190, 0 };

        reverseArray(array1);
    }
}
</code></pre>
     <p><a href="https://i.stack.imgur.com/W1wgZ.png" rel="noreferrer"><img src="W1wgZ.png" alt="Pass by value example 2"></a></p>
     <p>So, if we say</p>
     <pre><code>array1[0] = 5;
</code></pre>
     <p>in reverseArray method, it will make a change in array a.</p>
     <p>We have another reference variable in reverseArray method (array2) that points to an array c. If we were to say</p>
     <pre><code>array1 = array2;
</code></pre>
     <p>in reverseArray method, then the reference variable array1 in method reverseArray would stop pointing to array a and start pointing to array c (Dotted line in second image).</p>
     <p>If we return value of reference variable array2 as the return value of method reverseArray and assign this value to reference variable array1 in main method, array1 in main will start pointing to array c.</p>
     <p>So let's write all the things we have done at once now.</p>
     <pre><code>public class Test
{
    public static int[] reverseArray(int[] array1)
    {
        int[] array2 = { -7, 0, -1 };

        array1[0] = 5; // array a becomes 5, 10, -7

        array1 = array2; /* array1 of reverseArray starts
          pointing to c instead of a (not shown in image below) */
        return array2;
    }

    public static void main(String[] args)
    {
        int[] array1 = { 1, 10, -7 };
        int[] array2 = { 5, -190, 0 };

        array1 = reverseArray(array1); /* array1 of 
         main starts pointing to c instead of a */
    }
}
</code></pre>
     <p><a href="https://i.stack.imgur.com/5hRyX.png" rel="noreferrer"><img src="5hRyX.png" alt="enter image description here"></a></p>
     <p>And now that reverseArray method is over, its reference variables(array1 and array2) are gone. Which means we now only have the two reference variables in main method array1 and array2 which point to c and b arrays respectively. No reference variable is pointing to object (array) a. So it is eligible for garbage collection.</p>
     <p>You could also assign value of array2 in main to array1. array1 would start pointing to b.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_29"><span>Answer 29</span> <span class="arrow"> <a href="#answer_28">↑</a> </span> <span class="arrow"> <a href="#answer_30">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>34</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Paul de Vrieze</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Sep 2008 at 20:53</span>
     </div>
    </div>
    <div>
     <p>To make a long story short, <a href="http://en.wikipedia.org/wiki/Java_%28programming_language%29" rel="noreferrer">Java</a> objects have some very peculiar properties.</p>
     <p>In general, Java has primitive types (<code>int</code>, <code>bool</code>, <code>char</code>, <code>double</code>, etc) that are passed directly by value. Then Java has objects (everything that derives from <code>java.lang.Object</code>). Objects are actually always handled through a reference (a reference being a pointer that you can't touch). That means that in effect, objects are passed by reference, as the references are normally not interesting. It does however mean that you cannot change which object is pointed to as the reference itself is passed by value.</p>
     <p>Does this sound strange and confusing? Let's consider how C implements pass by reference and pass by value. In C, the default convention is pass by value. <code>void foo(int x)</code> passes an int by value. <code>void foo(int *x)</code> is a function that does not want an <code>int a</code>, but a pointer to an int: <code>foo(&amp;a)</code>. One would use this with the <code>&amp;</code> operator to pass a variable address.</p>
     <p>Take this to C++, and we have references. References are basically (in this context) syntactic sugar that hide the pointer part of the equation: <code>void foo(int &amp;x)</code> is called by <code>foo(a)</code>, where the compiler itself knows that it is a reference and the address of the non-reference <code>a</code> should be passed. In Java, all variables referring to objects are actually of reference type, in effect forcing call by reference for most intends and purposes without the fine grained control (and complexity) afforded by, for example, C++.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>This is just wrong. What Java calls "reference" C++ calls "pointer". What C++ calls "reference" does not exist in Java. C++ reference is pointer like type but with global scope. When you change a C++ reference all occurrences of that references are changed, both in called function but also in a calling function. Java can't do that. Java is strictly pass by value, and changes to java references are strictly local. Java called function can't change reference value of calling function. You can emulate C++ reference by using wrapper objects like AtomicReference.</span> <span> - </span> <span class="display-name">Talijanac</span> <span> </span> <span class="date">18 Aug 2020 at 09:14</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>C++ references have nothing to do with scopes. In implementation they are like pointers that are not allowed to have null values. The main difference beyond that is that syntactically they behave as aliases of the referenced data. In Java references work almost the same way, but have special rules that allow for: comparison with null and other reference values (using the == operator). C++ is also pass by value, although that value could be a pointer/reference to the reference.</span> <span> - </span> <span class="display-name">Paul de Vrieze</span> <span> </span> <span class="date">15 Sep 2020 at 17:13</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Changes to C++ references made by called method are also visible by calling method. That doesn't exist in Java and it is not a pointer like behaviour. In Java and C changes to pointer values are local only. I don't know how to properly call to this kind behaviour but it is somewhat similar to "outer scope" of some scripting languages.</span> <span> - </span> <span class="display-name">Talijanac</span> <span> </span> <span class="date">16 Sep 2020 at 08:40</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>For example of proper pass-by-reference see swap program here: <a href="https://www.geeksforgeeks.org/references-in-c/" rel="nofollow noreferrer">geeksforgeeks.org/references-in-c</a> It is not possible to write swap method in Java with same side-effects. There is "quality" (a behaviour of language operators) to C++ references which does not exists in Java references or C pointers.</span> <span> - </span> <span class="display-name">Talijanac</span> <span> </span> <span class="date">16 Sep 2020 at 08:45</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Paul de Vrieze "are not allowed to have null values" - think, in C dialects, exactly when p is a pointer, then *p is a reference; this is valid, even if p is null. Concerning assignment, references in Java behave like pointers and meet the "call-by-reference" semantics of C.</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">24 Feb 2022 at 21:56</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_30"><span>Answer 30</span> <span class="arrow"> <a href="#answer_29">↑</a> </span> <span class="arrow"> <a href="#answer_31">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>31</span>
     </div>
     <div>
      <span>Answerer: </span> <span>sven</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Sep 2008 at 14:54</span>
     </div>
    </div>
    <div>
     <p>I have created a thread devoted to these kind of questions for <em>any</em> programming languages <a href="https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value">here</a>.</p>
     <p><a href="https://stackoverflow.com/questions/2027/pass-by-reference-or-pass-by-value#2028">Java is also mentioned</a>. Here is the short summary:</p>
     <ul>
      <li>Java passes it parameters by value</li>
      <li>"by value" is the only way in java to pass a parameter to a method</li>
      <li>using methods from the object given as parameter will alter the object as the references point to the original objects. (if that method itself alters some values)</li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_31"><span>Answer 31</span> <span class="arrow"> <a href="#answer_30">↑</a> </span> <span class="arrow"> <a href="#answer_32">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>31</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Rusty Shackleford</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Dec 2009 at 20:19</span>
     </div>
    </div>
    <div>
     <p>A few corrections to some posts.</p>
     <p>C does NOT support pass by reference. It is ALWAYS pass by value. C++ does support pass by reference, but is not the default and is quite dangerous.</p>
     <p>It doesn't matter what the value is in Java: primitive or address(roughly) of object, it is ALWAYS passed by value.</p>
     <p>If a Java object "behaves" like it is being passed by reference, that is a property of mutability and has absolutely nothing to do with passing mechanisms.</p>
     <p>I am not sure why this is so confusing, perhaps because so many Java "programmers" are not formally trained, and thus do not understand what is really going on in memory?</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Really? <a href="https://stackoverflow.com/questions/2229498/passing-by-reference-in-c" title="passing by reference in c">stackoverflow.com/questions/2229498/passing-by-reference-in-‌​c</a></span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">6 Dec 2021 at 18:23</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_32"><span>Answer 32</span> <span class="arrow"> <a href="#answer_31">↑</a> </span> <span class="arrow"> <a href="#answer_33">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>27</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Raj S. Rusia</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Sep 2017 at 14:13</span>
     </div>
    </div>
    <div>
     <p>One of the biggest confusion in Java programming language is whether Java is <strong>Pass by Value</strong> or <strong>Pass by Reference</strong>.</p>
     <p>First of all, we should understand what is meant by pass by value or pass by reference.</p>
     <p><strong>Pass by Value:</strong> The method parameter values are copied to another variable and then the copied object is passed, that’s why it’s called pass by value.</p>
     <p><strong>Pass by Reference:</strong> An alias or reference to the actual parameter is passed to the method, that’s why it’s called pass by reference.</p>
     <p>Let’s say we have a class Balloon like below.</p>
     <pre><code>public class Balloon {

    private String color;

    public Balloon(){}

    public Balloon(String c){
        this.color=c;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }
}
</code></pre>
     <p>And we have a simple program with a generic method to swap two objects, the class looks like below.</p>
     <pre><code>public class Test {

    public static void main(String[] args) {

        Balloon red = new Balloon("Red"); //memory reference 50
        Balloon blue = new Balloon("Blue"); //memory reference 100

        swap(red, blue);
        System.out.println("red color="+red.getColor());
        System.out.println("blue color="+blue.getColor());

        foo(blue);
        System.out.println("blue color="+blue.getColor());

    }

    private static void foo(Balloon balloon) { //baloon=100
        balloon.setColor("Red"); //baloon=100
        balloon = new Balloon("Green"); //baloon=200
        balloon.setColor("Blue"); //baloon = 200
    }

    //Generic swap method
    public static void swap(Object o1, Object o2){
        Object temp = o1;
        o1=o2;
        o2=temp;
    }
}
</code></pre>
     <p>When we execute the above program, we get following output.</p>
     <pre><code>red color=Red
blue color=Blue
blue color=Red
</code></pre>
     <p>If you look at the first two lines of the output, it’s clear that swap method didn’t work. This is because Java is passed by value, this swap() method test can be used with any programming language to check whether it’s pass by value or pass by reference.</p>
     <p>Let’s analyze the program execution step by step.</p>
     <pre><code>Balloon red = new Balloon("Red");
Balloon blue = new Balloon("Blue");
</code></pre>
     <p>When we use the new operator to create an instance of a class, the instance is created and the variable contains the reference location of the memory where the object is saved. For our example, let’s assume that “red” is pointing to 50 and “blue” is pointing to 100 and these are the memory location of both Balloon objects.</p>
     <p>Now when we are calling swap() method, two new variables o1 and o2 are created pointing to 50 and 100 respectively.</p>
     <p>So below code snippet explains what happened in the swap() method execution.</p>
     <pre><code>public static void swap(Object o1, Object o2){ //o1=50, o2=100
    Object temp = o1; //temp=50, o1=50, o2=100
    o1=o2; //temp=50, o1=100, o2=100
    o2=temp; //temp=50, o1=100, o2=50
} //method terminated
</code></pre>
     <p>Notice that we are changing values of o1 and o2 but they are copies of “red” and “blue” reference locations, so actually, there is no change in the values of “red” and “blue” and hence the output.</p>
     <p>If you have understood this far, you can easily understand the cause of confusion. Since the variables are just the reference to the objects, we get confused that we are passing the reference so Java is passed by reference. However, we are passing a copy of the reference and hence it’s pass by value. I hope it clears all the doubts now.</p>
     <p>Now let’s analyze <strong>foo()</strong> method execution.</p>
     <pre><code>private static void foo(Balloon balloon) { //baloon=100
    balloon.setColor("Red"); //baloon=100
    balloon = new Balloon("Green"); //baloon=200
    balloon.setColor("Blue"); //baloon = 200
}
</code></pre>
     <p>The first line is the important one when we call a method the method is called on the Object at the reference location. At this point, the balloon is pointing to 100 and hence it’s color is changed to Red.</p>
     <p>In the next line, balloon reference is changed to 200 and any further methods executed are happening on the object at memory location 200 and not having any effect on the object at memory location 100. This explains the third line of our program output printing blue color=Red.</p>
     <p>I hope above explanation clear all the doubts, just remember that variables are references or pointers and its copy is passed to the methods, so Java is always passed by value. It would be more clear when you will learn about Heap and Stack memory and where different objects and references are stored.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_33"><span>Answer 33</span> <span class="arrow"> <a href="#answer_32">↑</a> </span> <span class="arrow"> <a href="#answer_34">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>25</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Christian</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Mar 2015 at 21:35</span>
     </div>
    </div>
    <div>
     <p>Java passes parameters by VALUE, and by value <strong>ONLY</strong>.</p>
     <p><strong>To cut long story short:</strong></p>
     <blockquote>
      <p>For those coming from C#: <strong>THERE IS NO "out" parameter.</strong></p>
      <p>For those coming from PASCAL: <strong>THERE IS NO "var" parameter</strong>.</p>
     </blockquote>
     <p>It means you can't change the reference from the object itself, but you can always change the object's properties.</p>
     <p>A workaround is to use <code>StringBuilder</code> parameter instead <code>String</code>. And you can always use arrays!</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_34"><span>Answer 34</span> <span class="arrow"> <a href="#answer_33">↑</a> </span> <span class="arrow"> <a href="#answer_35">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>24</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Felypp Oliveira</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Feb 2018 at 21:23</span>
     </div>
    </div>
    <div>
     <p>This is the best way to answer the question imo...</p>
     <p>First, we must understand that, in Java, the <em>parameter passing behavior</em>...</p>
     <pre><code>public void foo(Object param)
{
  // some code in foo...
}

public void bar()
{
  Object obj = new Object();

  foo(obj);
}
</code></pre>
     <p>is exactly the same as...</p>
     <pre><code>public void bar()
{
  Object obj = new Object();

  Object param = obj;

  // some code in foo...
}
</code></pre>
     <p>not considering stack locations, which aren't relevant in this discussion.</p>
     <p>So, in fact, what we're looking for in Java is how <em>variable assignment</em> works. I found it in <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op1.html" rel="noreferrer">the docs</a> :</p>
     <blockquote>
      <p>One of the most common operators that you'll encounter is the simple assignment operator "=" [...] <b>it assigns the value</b> on its right to the operand on its left:</p>
      <p>int cadence = 0;<br>
        int speed = 0;<br>
        int gear = 1;</p>
      <p>This operator can also be used on objects to assign <b>object references</b> [...]</p>
     </blockquote>
     <p>It's clear how this operator acts in two distinct ways: assign values and assign references. The last, when it's an object... the first, when it isn't an object, that is, when it's a primitive. But so, can we understand that Java's function params can be <em>pass-by-value</em> and <em>pass-by-reference</em>?</p>
     <p>The truth is in the code. Let's try it:</p>
     <pre><code>public class AssignmentEvaluation
{
  static public class MyInteger
  {
    public int value = 0;
  }

  static public void main(String[] args)
  {
    System.out.println("Assignment operator evaluation using two MyInteger objects named height and width\n");

    MyInteger height = new MyInteger();
    MyInteger width  = new MyInteger();

    System.out.println("[1] Assign distinct integers to height and width values");

    height.value = 9;
    width.value  = 1;

    System.out.println("-&gt;  height is " + height.value + " and width is " + width.value + ", we are different things! \n");

    System.out.println("[2] Assign to height's value the width's value");

    height.value = width.value;

    System.out.println("-&gt;  height is " + height.value + " and width is " + width.value + ", are we the same thing now? \n");

    System.out.println("[3] Assign to height's value an integer other than width's value");

    height.value = 9;

    System.out.println("-&gt;  height is " + height.value + " and width is " + width.value + ", we are different things yet! \n");

    System.out.println("[4] Assign to height the width object");

    height = width;

    System.out.println("-&gt;  height is " + height.value + " and width is " + width.value + ", are we the same thing now? \n");

    System.out.println("[5] Assign to height's value an integer other than width's value");

    height.value = 9;

    System.out.println("-&gt;  height is " + height.value + " and width is " + width.value + ", we are the same thing now! \n");

    System.out.println("[6] Assign to height a new MyInteger and an integer other than width's value");

    height = new MyInteger();
    height.value = 1;

    System.out.println("-&gt;  height is " + height.value + " and width is " + width.value + ", we are different things again! \n");
  }
}
</code></pre>
     <p>This is the output of my run:</p>
     <pre>Assignment operator evaluation using two MyInteger objects named height and width

[1] Assign distinct integers to height and width values
-&gt;  height is 9 and width is 1, we are different things! 

[2] Assign to height's value the width's value
-&gt;  height is 1 and width is 1, are we the same thing now? 

[3] Assign to height's value an integer other than width's value
-&gt;  height is 9 and width is 1, we are different things yet! 

[4] Assign to height the width object
-&gt;  height is 1 and width is 1, are we the same thing now? 

[5] Assign to height's value an integer other than width's value
-&gt;  height is 9 and width is 9, we are the same thing now! 

[6] Assign to height a new MyInteger and an integer other than width's value
-&gt;  height is 1 and width is 9, we are different things again! 
</pre>
     <p>In <em>[2]</em> we have distinct objects and assign one variable's value to the other. But after assigning a new value in <em>[3]</em> the objects had different values, which means that in <em>[2]</em> the assigned value was a copy of the primitive variable, usually called <strong>pass-by-value</strong>, otherwise, the values printed in <em>[3]</em> should be the same.</p>
     <p>In <em>[4]</em> we still have distinct objects and assign one object to the other. And after assigning a new value in <em>[5]</em> the objects had the same values, which means that in <em>[4]</em> the assigned object was not a copy of the other, which should be called <strong>pass-by-reference</strong>. But, if we look carefully in <em>[6]</em>, we can't be so sure that no copy was done... ?????</p>
     <p>We can't be so sure because in <em>[6]</em> the objects were the same, then we assigned a new object to one of them, and after, the objects had different values! How can they be distinct now if they were the same? They should be the same here too! ?????</p>
     <p>We'll need to remember <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op1.html" rel="noreferrer">the docs</a> to understand what's going on:</p>
     <blockquote>
      <p>This operator can also be used on objects to assign <b>object references</b></p>
     </blockquote>
     <p>So our two variables were storing references... our variables had the same reference after <em>[4]</em> and different references after <em>[6]</em>... if such a thing is possible, this means that assignment of objects is done by copy of the object's reference, otherwise, if it was not a copy of reference, the printed value of the variables in <em>[6]</em> should be the same. So objects (references), just like primitives, are copied to variables through assignment, what people usually call <em>pass-by-value</em>. That's the only <em>pass-by-</em> in Java.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_35"><span>Answer 35</span> <span class="arrow"> <a href="#answer_34">↑</a> </span> <span class="arrow"> <a href="#answer_36">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>22</span>
     </div>
     <div>
      <span>Answerer: </span> <span>fastcodejava</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Dec 2009 at 21:05</span>
     </div>
    </div>
    <div>
     <p>Java copies the reference by value. So if you change it to something else (e.g, using <code>new</code>) the reference does not change outside the method. For native types, it is always pass by value.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_36"><span>Answer 36</span> <span class="arrow"> <a href="#answer_35">↑</a> </span> <span class="arrow"> <a href="#answer_37">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>21</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Fernando Espinosa</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Aug 2012 at 17:31</span>
     </div>
    </div>
    <div>
     <p>There are two cases of interest:</p>
     <p>For a variable of primitive type (eg. <code>int</code>, <code>boolean</code>, <code>char</code>, and others...), when you use the variable name in a function argument, you are passing by value. This value (eg. <code>5</code>, <code>true</code>, or <code>'c'</code>) is "copied", and the variable retains its original value after the method invocation, because there are now two copies of the data in existance. One is outside of the function call, the other is inside.</p>
     <p>For a variable of reference type (eg. <code>String</code>, <code>Object</code>, etc...), when you use the variable name for a function argument, you are passing the reference value contained in the variable. The reference value is copied, just as in the first example above, and the variable external to the function also retains its value the method invocation. The reference is still to the same object. What differs in this case is that the function may alter data inside the object which is referenced.</p>
     <p>Either way, you're always passing stuff by value.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_37"><span>Answer 37</span> <span class="arrow"> <a href="#answer_36">↑</a> </span> <span class="arrow"> <a href="#answer_38">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>21</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Michał Żbikowski</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Sep 2014 at 00:23</span>
     </div>
    </div>
    <div>
     <p>Throughout all the answers we see that Java pass-by-value or rather as @Gevorg wrote: "pass-by-copy-of-the-variable-value" and this is the idea that we should have in mind all the time.</p>
     <p>I am focusing on examples that helped me understand the idea and it is rather addendum to previous answers.</p>
     <p>From [1] In Java you always are passing arguments by copy; that is you're always creating a new instance of the value inside the function. But there are certain behaviors that can make you think you're passing by reference.</p>
     <ul>
      <li>
       <p>Passing by copy: When a variable is passed to a method/function, a copy is made (sometimes we hear that when you pass primitives, you're making copies).</p></li>
      <li>
       <p>Passing by reference: When a variable is passed to a method/function, the code in the method/function operates on the original variable (You're still passing by copy, but references to values inside the complex object are parts of both versions of the variable, both the original and the version inside the function. The complex objects themselves are being copied, but the internal references are being retained)</p></li>
     </ul>
     <h2>Examples of Passing by copy/ by value</h2>
     <p><strong>Example from [ref 1]</strong></p>
     <pre><code>void incrementValue(int inFunction){
  inFunction ++;
  System.out.println("In function: " + inFunction);
}

int original = 10;
System.out.print("Original before: " + original);
incrementValue(original);
System.out.println("Original after: " + original);

We see in the console:
 &gt; Original before: 10
 &gt; In Function: 11
 &gt; Original after: 10 (NO CHANGE)
</code></pre>
     <p><strong>Example from [ref 2]</strong></p>
     <blockquote>
      <p>shows nicely the mechanism <a href="https://www.youtube.com/watch?v=W2ysz_6AyJE&amp;list=PL6C11012B1B464EC5#t=502" rel="noreferrer">watch max 5 min</a></p>
     </blockquote>
     <h2>(Passing by reference) pass-by-copy-of-the-variable-value</h2>
     <p><strong>Example from [ref 1]</strong> (remember that an array is an object)</p>
     <pre><code>void incrementValu(int[] inFuncion){
  inFunction[0]++;
  System.out.println("In Function: " + inFunction[0]);
}

int[] arOriginal = {10, 20, 30};
System.out.println("Original before: " + arOriginal[0]);
incrementValue(arOriginal[]);
System.out.println("Original before: " + arOriginal[0]);

We see in the console:
  &gt;Original before: 10
  &gt;In Function: 11
  &gt;Original before: 11 (CHANGE)
</code></pre>
     <p>The complex objects themselves are being copied, but the internal references are being retained.</p>
     <p><strong>Example from[ref 3]</strong></p>
     <pre><code>package com.pritesh.programs;

class Rectangle {
  int length;
  int width;

  Rectangle(int l, int b) {
    length = l;
    width = b;
  }

  void area(Rectangle r1) {
    int areaOfRectangle = r1.length * r1.width;
    System.out.println("Area of Rectangle : " 
                            + areaOfRectangle);
  }
}

class RectangleDemo {
  public static void main(String args[]) {
    Rectangle r1 = new Rectangle(10, 20);
    r1.area(r1);
  }
}
</code></pre>
     <p>The area of the rectangle is 200 and the length=10 and width=20</p>
     <p><strong>Last thing</strong> I would like to share was this moment of the lecture: <strong><a href="https://www.youtube.com/watch?v=W8nNdNZ40EQ#t=1206" rel="noreferrer">Memory Allocation</a></strong> which I found very helpful in understanding the Java passing by value or rather “pass-by-copy-of-the-variable-value” as @Gevorg has written.</p>
     <ol>
      <li><a href="http://www.lynda.com/Android-tutorials/Passing-arguments-reference-value/86005/94989-4.html" rel="noreferrer">REF 1 Lynda.com</a></li>
      <li><a href="http://see.stanford.edu/see/courseinfo.aspx?coll=824a47e1-135f-4508-a5aa-866adcae1111" rel="noreferrer">REF 2 Professor Mehran Sahami</a>
       <ul>
        <li><a href="https://www.youtube.com/watch?v=W2ysz_6AyJE&amp;list=PL6C11012B1B464EC5#t=502" rel="noreferrer">watch max 5 min</a></li>
        <li><a href="https://www.youtube.com/watch?v=W8nNdNZ40EQ#t=1206" rel="noreferrer">Memory Allocation</a></li>
       </ul></li>
      <li><a href="http://www.c4learn.com/" rel="noreferrer">REF 3 c4learn</a>
       <ul>
        <li><a href="http://www.c4learn.com/java/java-passing-object-as-parameter-to-method/" rel="noreferrer">passing-object-as-parameter-to-method</a></li>
       </ul></li>
     </ol>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_38"><span>Answer 38</span> <span class="arrow"> <a href="#answer_37">↑</a> </span> <span class="arrow"> <a href="#answer_39">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>20</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Gee Bee</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Mar 2016 at 15:29</span>
     </div>
    </div>
    <div>
     <p>So many long answers. Let me give a simple one:</p>
     <ul>
      <li>Java always passes everything by value</li>
      <li>that means also references are passed by value</li>
     </ul>
     <p>In short, you can not modify value of any parameter passed, but you can call methods or change attributes of an object reference passed.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>What, if "passing by reference" meant, that you can modify the passed object inside the called method, affecting the object existing outside the method?</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">6 Dec 2021 at 18:32</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This answer is much better than the majority of other answers.</span> <span> - </span> <span class="display-name">FreelanceConsultant</span> <span> </span> <span class="date">16 Mar 2023 at 10:25</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_39"><span>Answer 39</span> <span class="arrow"> <a href="#answer_38">↑</a> </span> <span class="arrow"> <a href="#answer_40">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>19</span>
     </div>
     <div>
      <span>Answerer: </span> <span>NAGHMAAN MOHASEEN</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Oct 2017 at 07:08</span>
     </div>
    </div>
    <div>
     <h3>Java is strictly passed by value</h3>
     <p>When I say <strong><em>pass by value</em></strong> it means whenever caller has invoked the callee the arguments(ie: the data to be passed to the other function) <strong>is copied</strong> and placed in the formal parameters (callee's local variables for receiving the input). Java makes data communications from one function to other function only in a pass by value environment.</p>
     <p>An important point would be to know that even C language is strictly passed by value only:<br><em>ie:</em> Data is copied from caller to the callee and more ever the operation performed by the callee are on the same memory location and what we pass them is the address of that location that we obtain from (&amp;) operator and the identifier used in the formal parameters are declared to be a pointer variable (*) using which we can get inside the memory location for accessing the data in it.</p>
     <p>Hence here the formal parameter is nothing but mere aliases for that location. And any modifications done on that location is visible where ever that scope of the variable (that identifies that location) is alive.</p>
     <p>In Java, there is no concept of pointers (<em>ie:</em> there is nothing called a pointer variable), although we can think of reference variable as a pointer technically in java we call it as a handle. The reason why we call the pointer to an address as a handle in java is because a pointer variable is capable of performing not just single dereferencing but multiple dereferencing for example: <code>int *p;</code> in P means p points to an integer and <code>int **p;</code> in C means p is pointer to a pointer to an integer we dont have this facility in Java, so its absolutely correct and technically legitimate to say it as an handle, also there are rules for pointer arithmetic in C. Which allows performing arithmetic operation on pointers with constraints on it.</p>
     <p>In C we call such mechanism of passing address and receiving them with pointer variables as <em>pass by reference</em> since we are passing their addresses and receiving them as pointer variable in formal parameter but at the compiler level that address is copied into pointer variable (since data here is address even then its data ) hence we can be 100% sure that C is Strictly passed by value (as we are passing data only)</p>
     <p>(and if we pass the data directly in C we call that as pass by value.)</p>
     <p>In java when we do the same we do it with the handles; since they are not called pointer variables like in (as discussed above) even though we are passing the references we cannot say its pass by reference since we are not collecting that with a pointer variable in Java.</p>
     <p>Hence Java <strong>strictly use pass by value mechanism</strong></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>And to where is Java passed?</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">6 Dec 2021 at 18:33</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_40"><span>Answer 40</span> <span class="arrow"> <a href="#answer_39">↑</a> </span> <span class="arrow"> <a href="#answer_41">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>18</span>
     </div>
     <div>
      <span>Answerer: </span> <span>fatma.ekici</span>
     </div>
     <div>
      <span> Answered: </span> <span>31 Dec 2012 at 19:35</span>
     </div>
    </div>
    <div>
     <p>Java is pass by constant reference where a copy of the reference is passed which means that it is basically a pass by value. You might change the contents of the reference if the class is mutable but you cannot change the reference itself. In other words the address can not be changed since it is passed by value but the content that is pointed by the address can be changed. In case of immutable classes, the content of the reference cannot be changed either.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>There is no such thing as a 'constant referenece' in Java unless the programmer specifies 'finally'.</span> <span> - </span> <span class="display-name">user207421</span> <span> </span> <span class="date">2 Aug 2013 at 10:05</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>What I meant by constant reference is, there is no way to change the reference itself by saying new MyClass() in a function. If I put it correctly, there object references are passed by value which means a copy of the reference is passed so you can change the data where that reference refers to but you can not change it with new operator and allocate a new object.</span> <span> - </span> <span class="display-name">fatma.ekici</span> <span> </span> <span class="date">9 Sep 2013 at 13:06</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>So fix your answer. If it was a constant you couldn't reassign it inside the called method, and you can, unless you specify <code>final.</code></span> <span> - </span> <span class="display-name">user207421</span> <span> </span> <span class="date">25 Sep 2014 at 00:41</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>No, idea how to unwind that knot: You pass a object reference and say the object is passed by value. :(</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">6 Dec 2021 at 18:30</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_41"><span>Answer 41</span> <span class="arrow"> <a href="#answer_40">↑</a> </span> <span class="arrow"> <a href="#answer_42">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>18</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Placinta Alexandru</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Jan 2016 at 12:38</span>
     </div>
    </div>
    <div>
     <p>Java always uses <strong>call by value</strong>. That means the method gets copy of all parameter values.</p>
     <p>Consider next 3 situations:</p>
     <h2>1) Trying to change primitive variable</h2>
     <pre><code>public static void increment(int x) { x++; }

int a = 3;
increment(a);
</code></pre>
     <p>x will copy value of a and will increment x, a remains the same</p>
     <h2>2) Trying to change primitive field of an object</h2>
     <pre><code>public static void increment(Person p) { p.age++; }

Person pers = new Person(20); // age = 20
increment(pers);
</code></pre>
     <p>p will copy reference value of pers and will increment age field, variables are referencing to the same object so age is changed</p>
     <h2>3) Trying to change reference value of reference variables</h2>
     <pre><code>public static void swap(Person p1, Person p2) {
    Person temp = p1;
    p1 = p2;
    p2 = temp;
}

Person pers1 = new Person(10);
Person pers2 = new Person(20);
swap(pers1, pers2);
</code></pre>
     <p>after calling swap p1, p2 copy reference values from pers1 and pers2, are swapping with values, so pers1 and pers2 remain the same</p>
     <p>So. you can change only fields of objects in method passing copy of reference value to this object.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_42"><span>Answer 42</span> <span class="arrow"> <a href="#answer_41">↑</a> </span> <span class="arrow"> <a href="#answer_43">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>18</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Rahul Kumar</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Dec 2016 at 08:33</span>
     </div>
    </div>
    <div>
     <p>Java, for sure, without a doubt, is "pass by value". Also, since Java is (mostly) object-oriented and objects work with references, it's easy to get confused and think of it to be "pass by reference"</p>
     <p>Pass by value means you pass the value to the method and if the method changes the passed value, the real entity doesn't change. Pass by reference, on the other hand, means a reference is passed to the method, and if the method changes it, the passed object also changes.</p>
     <p>In Java, usually when we pass an object to a method, we basically pass the reference of the object as-a-value because that's how Java works; it works with references and addresses as far as Object in the heap goes.</p>
     <p>But to test if it is really pass by value or pass by reference, you can use a primitive type and references:</p>
     <pre><code>@Test
public void sampleTest(){
    int i = 5;
    incrementBy100(i);
    System.out.println("passed ==&gt; "+ i);
    Integer j = new Integer(5);
    incrementBy100(j);
    System.out.println("passed ==&gt; "+ j);
}
/**
 * @param i
 */
private void incrementBy100(int i) {
    i += 100;
    System.out.println("incremented = "+ i);
}
</code></pre>
     <p>The output is:</p>
     <pre><code>incremented = 105
passed ==&gt; 5
incremented = 105
passed ==&gt; 5
</code></pre>
     <p>So in both cases, whatever happens inside the method doesn't change the real Object, because the value of that object was passed, and not a reference to the object itself.</p>
     <p>But when you pass a custom object to a method, and the method and changes it, it will change the real object too, because even when you passed the object, you passed it's reference as a value to the method. Let's try another example:</p>
     <pre><code>@Test
public void sampleTest2(){
    Person person = new Person(24, "John");
    System.out.println(person);
    alterPerson(person);
    System.out.println(person);
}

/**
 * @param person
 */
private void alterPerson(Person person) {
    person.setAge(45);
    Person altered = person;
    altered.setName("Tom");
}

private static class Person{
    private int age;
    private String name; 

    public Person(int age, String name) {
        this.age=age;
        this.name =name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("Person [age=");
        builder.append(age);
        builder.append(", name=");
        builder.append(name);
        builder.append("]");
        return builder.toString();
    }

}
</code></pre>
     <p>In this case, the output is:</p>
     <pre><code>Person [age=24, name=John]
Person [age=45, name=Tom]
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_43"><span>Answer 43</span> <span class="arrow"> <a href="#answer_42">↑</a> </span> <span class="arrow"> <a href="#answer_44">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>16</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Soner from The Ottoman Empire</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Nov 2016 at 16:51</span>
     </div>
    </div>
    <div>
     <p>The major cornerstone knowledge must be the quoted one,</p>
     <blockquote>
      <p>When an object reference is passed to a method, the reference itself is passed by use of <em>call-by-value</em>. However, since the value being passed refers to an object, the copy of that value will still refer to the same object referred to by its corresponding argument.</p>
     </blockquote>
     <p>Java: A Beginner's Guide, Sixth Edition, Herbert Schildt</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_44"><span>Answer 44</span> <span class="arrow"> <a href="#answer_43">↑</a> </span> <span class="arrow"> <a href="#answer_45">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>16</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Premraj</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Dec 2017 at 10:19</span>
     </div>
    </div>
    <div>
     <p>Data is shared between functions by passing parameters. Now, there are 2 ways of passing parameters:</p>
     <ul>
      <li>
       <p><strong>passed by reference :</strong> caller and callee use same variable for parameter.</p></li>
      <li>
       <p><strong>passed by value :</strong> caller and callee have two independent variables with same value.</p></li>
     </ul>
     <p>Java uses <em><strong>pass by value</strong></em></p>
     <ul>
      <li>When passing primitive data, it copies the value of primitive data type.</li>
      <li>When passing object, it copies the address of object and passes to callee method variable.</li>
     </ul>
     <p>Java follows the following rules in storing variables:</p>
     <ul>
      <li>Local variables like primitives and object references are created on Stack memory.</li>
      <li>Objects are created on Heap memory.</li>
     </ul>
     <p>Example using primitive data type:</p>
     <pre><code>public class PassByValuePrimitive {
    public static void main(String[] args) {
        int i=5;
        System.out.println(i);  //prints 5
        change(i);
        System.out.println(i);  //prints 5
    }
    
    
    private static void change(int i) {
        System.out.println(i);  //prints 5
        i=10;
        System.out.println(i); //prints 10
        
    }
}
</code></pre>
     <p>Example using object:</p>
     <pre><code>public class PassByValueObject {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("prem");
        list.add("raj");
        new PassByValueObject().change(list);
        System.out.println(list); // prints [prem, raj, ram]
        
    }
    
    
    private  void change(List list) {
        System.out.println(list.get(0)); // prem
        list.add("ram");
        list=null;
        System.out.println(list.add("bheem")); //gets NullPointerException
    }
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_45"><span>Answer 45</span> <span class="arrow"> <a href="#answer_44">↑</a> </span> <span class="arrow"> <a href="#answer_46">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>15</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mr.Robot</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Feb 2020 at 21:30</span>
     </div>
    </div>
    <div>
     <p>I see that all answers contain the same: pass by value. However, a recent Brian Goetz update on project Valhalla actually answers it differently:</p>
     <blockquote>
      <p>Indeed, it is a common “gotcha” question about whether Java objects are passed by value or by reference, and <strong>the answer is “neither”: object references are passed by value.</strong></p>
     </blockquote>
     <p>You can read more here: <a href="http://cr.openjdk.java.net/%7Ebriangoetz/valhalla/sov/02-object-model.html" rel="noreferrer">State of Valhalla. Section 2: Language Model</a></p>
     <p><strong>Edit:</strong> Brian Goetz is Java Language Architect, leading such projects as Project Valhalla and Project Amber.</p>
     <p><strong>Edit-2020-12-08</strong>: Updated <a href="https://github.com/openjdk/valhalla-docs/blob/main/site/design-notes/state-of-valhalla/02-object-model.md" rel="noreferrer">State of Valhalla</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>6</td>
        <td><span>Object references (i.e. pointers) are passed by value and primitives are also passed by value. Meaning everything is always passed by value. I think the operative term here is Pass-by-value.</span> <span> - </span> <span class="display-name">Sanjeev</span> <span> </span> <span class="date">20 Feb 2020 at 22:24</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>I think Java Language Architect, who is leading Project Amber and Project Valhalla is a credible source to claim that it is not pass by value.</span> <span> - </span> <span class="display-name">Mr.Robot</span> <span> </span> <span class="date">2 Apr 2020 at 16:28</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>First, I don't think he's more credible than James Gosling, the creator of Java who clearly state in his book, "THE Java Programming Language", that Java is indeed Pass-by-value (Chapter 2, section 2.6.5). Second, although Goetz says it's neither PBV or PBR, he then goes on to say that references are PASSED BY VALUE, thereby contradicting himself. If you know Java, you also know that primitives are also PASSED BY VALUE. Since everything in Java is passed by value, Java is a PASS BY VALUE language.</span> <span> - </span> <span class="display-name">Sanjeev</span> <span> </span> <span class="date">2 Apr 2020 at 18:17</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Other sources who are way more credible than Goetz are Aho, Lam, Sethi, and Ullman who are well known for their book "Compilers: Principles, Techniques, and Tools", the standard college text book for compiler construction. The 2nd eddition section 1.6.6 of this book also states that Java is Pass-by-value.</span> <span> - </span> <span class="display-name">Sanjeev</span> <span> </span> <span class="date">2 Apr 2020 at 18:49</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>And the most relevant reference of all is the Java Language Specification which states <i>"The effect of this is to assign the argument values to corresponding freshly created parameter variables of the method"</i>. (15.12.4.5). Note that it is avoiding the terminological confusion by not saying "pass by ..." at all. (FWIW, I disagree with the Goetz's characterization of "pass by value" and "pass references by value" as being semantically different. And I agree that he is contradicting himself.)</span> <span> - </span> <span class="display-name">Stephen C</span> <span> </span> <span class="date">5 Apr 2020 at 11:40</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This is the only answer that made sense so far. The objects are not passed as pure values because they aren't copied like in the C++ pass-by-value way.</span> <span> - </span> <span class="display-name">AFP_555</span> <span> </span> <span class="date">17 Nov 2020 at 12:11</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_46"><span>Answer 46</span> <span class="arrow"> <a href="#answer_45">↑</a> </span> <span class="arrow"> <a href="#answer_47">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>14</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Vinay Lodha</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Aug 2010 at 12:21</span>
     </div>
    </div>
    <div>
     <p>Have a look at this code. This code will not throw <code>NullPointerException</code>... It will print "Vinay"</p>
     <pre><code>public class Main {
    public static void main(String[] args) {
        String temp = "Vinay";
        print(temp);
        System.err.println(temp);
    }

    private static void print(String temp) {
        temp = null;
    }
}
</code></pre>
     <p>If Java is pass by reference then it should have thrown <code>NullPointerException</code> as reference is set to Null.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_47"><span>Answer 47</span> <span class="arrow"> <a href="#answer_46">↑</a> </span> <span class="arrow"> <a href="#answer_48">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>14</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Basheer AL-MOMANI</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Mar 2017 at 09:29</span>
     </div>
    </div>
    <div>
     <p>Unlike some other languages, Java does not allow you to choose between pass-by-value and pass-by-reference.</p>
     <p>All arguments are passed by value.</p>
     <p>A method call can pass two <code>types of values</code>to a method</p>
     <ul>
      <li>copies of primitive values (e.g., values of type int and double)</li>
      <li>copies of references to objects.</li>
     </ul>
     <p><code>Objects themselves cannot be passed to methods</code>. When a method modifies a primitive-type parameter, changes to the parameter have no effect on the original argument value in the calling method.</p>
     <p>This is also true for reference-type parameters. If you modify a reference-type parameter so that it refers to another object, only the parameter refers to the new object—the reference stored in the caller’s variable still refers to the original object.</p>
     <p>References: <a href="https://www.safaribooksonline.com/library/view/javatm-how-to/9780133813036/ch07lev2sec11.html" rel="noreferrer">Java™ How To Program (Early Objects), Tenth Edition</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Objects are passed by reference. :)</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">6 Dec 2021 at 18:39</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_48"><span>Answer 48</span> <span class="arrow"> <a href="#answer_47">↑</a> </span> <span class="arrow"> <a href="#answer_49">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>14</span>
     </div>
     <div>
      <span>Answerer: </span> <span>moldovean</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Apr 2019 at 14:50</span>
     </div>
    </div>
    <div>
     <p>Long story short:</p>
     <ol>
      <li>Non-primitives: Java passes the <em>Value of the Reference</em>.</li>
      <li>Primitives: just value.</li>
     </ol>
     <p>The End.</p>
     <p>(2) is too easy. Now if you want to think of what (1) implies, imagine you have a class Apple:</p>
     <pre><code>class Apple {
    private double weight;
    public Apple(double weight) {
        this.weight = weight;
    }
    // getters and setters ...

}
</code></pre>
     <p>then when you pass an instance of this class to the main method:</p>
     <pre><code>class Main {
    public static void main(String[] args) {
        Apple apple = new Apple(3.14);
        transmogrify(apple);
        System.out.println(apple.getWeight()+ " the goose drank wine...";

    }

    private static void transmogrify(Apple apple) {
        // does something with apple ...
        apple.setWeight(apple.getWeight()+0.55);
    }
}
</code></pre>
     <p>oh.. but you probably know that, you're interested in what happens when you do something like this:</p>
     <pre><code>class Main {
    public static void main(String[] args) {
        Apple apple = new Apple(3.14);
        transmogrify(apple);
        System.out.println("Who ate my: "+apple.getWeight()); // will it still be 3.14? 

    }

    private static void transmogrify(Apple apple) {
        // assign a new apple to the reference passed...
        apple = new Apple(2.71);
    }


}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_49"><span>Answer 49</span> <span class="arrow"> <a href="#answer_48">↑</a> </span> <span class="arrow"> <a href="#answer_50">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>13</span>
     </div>
     <div>
      <span>Answerer: </span> <span>georgeawg</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Jul 2018 at 15:40</span>
     </div>
    </div>
    <div>
     <h2>Java passes primitive types by value and class types by reference</h2>
     <p>Now, people like to bicker endlessly about whether "pass by reference" is the correct way to describe what Java et al. actually do. The point is this:</p>
     <ol>
      <li>Passing an object does not copy the object.</li>
      <li>An object passed to a function can have its members modified by the function.</li>
      <li>A primitive value passed to a function cannot be modified by the function. A copy is made.</li>
     </ol>
     <p>In my book that's called passing by reference.</p>
     <p>— <a href="https://www.quora.com/profile/Brian-Bi" rel="noreferrer">Brian Bi</a> - <a href="https://www.quora.com/Which-programming-languages-are-pass-by-reference#" rel="noreferrer">Which programming languages are pass by reference?</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>I'm not sure it's technically correct to mention that copies are made for primitive types. Primitive types are immutable which is why they cannot be modified inside a method they are passed to. The difference is negligible for things like numbers, but there is an important difference for potentially large strings.</span> <span> - </span> <span class="display-name">Dennis</span> <span> </span> <span class="date">25 Aug 2018 at 21:08</span></td>
       </tr>
       <tr>
        <td>13</td>
        <td><span>This answer is completely incorrect and only creates confusion. Java is a pure pass-by-value language. What confuses you is that the value can be a pointer to an object. Pass-by-reference means one would be able to change the identity of an object at the caller's side. E.g. assigning a new object to a method parameter would also affect the pointer that was passed in the code that called the method.</span> <span> - </span> <span class="display-name">Torben</span> <span> </span> <span class="date">3 Oct 2018 at 04:40</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@Dennis Strings are not primitives, they're objects.</span> <span> - </span> <span class="display-name">nasch</span> <span> </span> <span class="date">27 Dec 2018 at 18:49</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>It's not about what's "In your book." "Pass by reference" and "Pass by value" are industry standard terms which have very specific definitions. By those definitions Java is "Pass by value" without exceptions.</span> <span> - </span> <span class="display-name">Sanjeev</span> <span> </span> <span class="date">23 Jan 2019 at 00:01</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>"Passing an object" is not a valid operation in Java. You pass a reference to an object. Doing so is <i>not</i> called "passing by reference". It is called "passing by value". The reference passed is a <i>value</i>, which is <i>copied</i> to a new place on the stack for the method to use, just like any primitive value.</span> <span> - </span> <span class="display-name">AndrewF</span> <span> </span> <span class="date">25 Dec 2019 at 00:00</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>C++ has true pass by value where it copies all the fields of the object onto the stack. Java doesn't do this so its not pass by value..</span> <span> - </span> <span class="display-name">Solubris</span> <span> </span> <span class="date">25 Nov 2020 at 23:25</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Solubris It's true that Java does not allow passing entire objects to a method, but when you pass primitives or references (i.e. pointers) you are passing them by value. And importantly, you never pass anything by reference.</span> <span> - </span> <span class="display-name">Sanjeev</span> <span> </span> <span class="date">26 Apr 2023 at 17:11</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_50"><span>Answer 50</span> <span class="arrow"> <a href="#answer_49">↑</a> </span> <span class="arrow"> <a href="#answer_51">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>12</span>
     </div>
     <div>
      <span>Answerer: </span> <span>khakishoiab</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Sep 2016 at 09:53</span>
     </div>
    </div>
    <div>
     <p>A simple test to check whether a language supports pass-by-reference is simply writing a traditional swap. Can you write a traditional swap(a,b) method/function in Java?</p>
     <p>A traditional swap method or function takes two arguments and swaps them such that variables passed into the function are changed outside the function. Its basic structure looks like</p>
     <p>(Non-Java) Basic swap function structure</p>
     <pre><code>swap(Type arg1, Type arg2) {
    Type temp = arg1;
    arg1 = arg2;
    arg2 = temp;
}
</code></pre>
     <p>If you can write such a method/function in your language such that calling</p>
     <pre><code>Type var1 = ...;
Type var2 = ...;
swap(var1,var2);
</code></pre>
     <p>actually switches the values of the variables var1 and var2, the language supports pass-by-reference. But <strong>Java does not allow such a thing</strong> as it supports passing the values only and not pointers or references.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>You might want to clarify your last sentence. My first reaction to "passing the values only and not pointers..." is that your Java implementation probably does <i>exactly that</i>, passes a pointer. The fact that you cannot dereference that pointer seems irrelevant.</span> <span> - </span> <span class="display-name">Loduwijk</span> <span> </span> <span class="date">2 Aug 2017 at 15:25</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_51"><span>Answer 51</span> <span class="arrow"> <a href="#answer_50">↑</a> </span> <span class="arrow"> <a href="#answer_52">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>12</span>
     </div>
     <div>
      <span>Answerer: </span> <span>jack</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Dec 2020 at 20:49</span>
     </div>
    </div>
    <div>
     <p>Not to repeat, but one point to those who might still be confused after reading many answers:</p>
     <ul>
      <li><code>pass by value</code> in Java is <strong>NOT EQUAL</strong> to <code>pass by value</code> in C++, though it sounds like that, which is probably why there's confusion</li>
     </ul>
     <p>Breaking it down:</p>
     <ul>
      <li><code>pass by value</code> in C++ means passing the value of the object (if object), literarily the copy of the object</li>
      <li><code>pass by value</code> in Java means passing the address value of the object (if object), not really the "value" (a copy) of the object like C++</li>
      <li>By <code>pass by value</code> in Java, operating on an object (e.g. <code>myObj.setName("new")</code>) inside a function <strong>has effects</strong> on the object outside the function; by <code>pass by value</code> in C++, it has <strong>NO</strong> effects on the one outside.</li>
      <li>However, by <code>pass by reference</code> in C++, operating on an object in a function <strong>DOES</strong> have effects on the one outside! Similar (<em>just similar, not the same</em>) to <code>pass by value</code> in Java, no?.. and people always repeat "<em>there's no pass by reference in Java</em>", =&gt; <strong>BOOM, confusion starts...</strong></li>
     </ul>
     <p>So, friends, all is just about the <strong>difference</strong> of terminology definition (across languages), you just need to know how it works and that's it (<em>though sometimes a bit confusing how it's called I admit</em>)!</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>In both languages, "pass by value" means passing the value of the object if it's an object. In no case does it mean passing the address of the value. There is no difference in terminology. There is no case where we call something pass by value and changing the value in the function called changes the value in the caller. If you call a function like this <code>foo(bar)</code> in java, the value of <code>bar</code> never changes -- if <code>bar</code> is a reference to an object, its value is the identity of the object it references and no matter what the function does, it still references the same object in the caller.</span> <span> - </span> <span class="display-name">David Schwartz</span> <span> </span> <span class="date">29 Mar 2021 at 23:37</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>I agree with David Schwartz: there is actually no difference in terminology. The big difference between Java and C++ is that in Java a "value" can <b>never</b> be a whole object. It's always either a reference or a primitive value. You simply can't pass a whole object in Java at all.</span> <span> - </span> <span class="display-name">Joachim Sauer</span> <span> </span> <span class="date">21 Apr 2021 at 15:08</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_52"><span>Answer 52</span> <span class="arrow"> <a href="#answer_51">↑</a> </span> <span class="arrow"> <a href="#answer_53">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>11</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Harald Schilly</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Jan 2009 at 20:34</span>
     </div>
    </div>
    <div>
     <p>It's a bit hard to understand, but Java always copies the value - the point is, normally the value is a reference. Therefore you end up with the same object without thinking about it...</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_53"><span>Answer 53</span> <span class="arrow"> <a href="#answer_52">↑</a> </span> <span class="arrow"> <a href="#answer_54">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>11</span>
     </div>
     <div>
      <span>Answerer: </span> <span>JasonG</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Jun 2013 at 17:12</span>
     </div>
    </div>
    <div>
     <p>In an attempt to add even more to this, I thought I'd include the SCJP Study Guide section on the topic. This is from the guide that is made to pass the Sun/Oracle test on the behaviour of Java so it's a good source to use for this discussion.</p>
     <blockquote>
      <p>Passing Variables into Methods (Objective 7.3)</p>
      <p>7.3 Determine the effect upon object references and primitive values when they are passed into methods that perform assignments or other modifying operations on the parameters.</p>
      <p>Methods can be declared to take primitives and/or object references. You need to know how (or if) the caller's variable can be affected by the called method. The difference between object reference and primitive variables, when passed into methods, is huge and important. To understand this section, you'll need to be comfortable with the assignments section covered in the first part of this chapter.</p>
      <p>Passing Object Reference Variables</p>
      <p>When you pass an object variable into a method, you must keep in mind that you're passing the object reference, and not the actual object itself. Remember that a reference variable holds bits that represent (to the underlying VM) a way to get to a specific object in memory (on the heap). More importantly, you must remember that you aren't even passing the actual reference variable, but rather a copy of the reference variable. A copy of a variable means you get a copy of the bits in that variable, so when you pass a reference variable, you're passing a copy of the bits representing how to get to a specific object. In other words, both the caller and the called method will now have identical copies of the reference, and thus both will refer to the same exact (not a copy) object on the heap.</p>
      <p>For this example, we'll use the Dimension class from the java.awt package:</p>
     </blockquote>
     <pre><code>1. import java.awt.Dimension;
2. class ReferenceTest {
3.     public static void main (String [] args) {
4.         Dimension d = new Dimension(5,10);
5.         ReferenceTest rt = new ReferenceTest();
6.         System.out.println("Before modify() d.height = " + d.height);
7.         rt.modify(d);
8.         System.out.println("After modify() d.height = "
9.     }
10.
11.
12.
13.   }
14. }
</code></pre>
     <blockquote>
      <p>When we run this class, we can see that the modify() method was indeed able to modify the original (and only) Dimension object created on line 4.</p>
     </blockquote>
     <pre>C:\Java Projects\Reference&gt;java ReferenceTest
Before modify() d.height = 10
dim = 11
After modify() d.height = 11
</pre>
     <blockquote>
      <p>Notice when the Dimension object on line 4 is passed to the modify() method, any changes to the object that occur inside the method are being made to the object whose reference was passed. In the preceding example, reference variables d and dim both point to the same object.</p>
      <p>Does Java Use Pass-By-Value Semantics?</p>
      <p>If Java passes objects by passing the reference variable instead, does that mean Java uses pass-by-reference for objects? Not exactly, although you'll often hear and read that it does. Java is actually pass-by-value for all variables running within a single VM. Pass-by-value means pass-by-variable-value. And that means, pass-by-copy-of- the-variable! (There's that word copy again!)</p>
      <p>It makes no difference if you're passing primitive or reference variables, you are always passing a copy of the bits in the variable. So for a primitive variable, you're passing a copy of the bits representing the value. For example, if you pass an int variable with the value of 3, you're passing a copy of the bits representing 3. The called method then gets its own copy of the value, to do with it what it likes.</p>
      <p>And if you're passing an object reference variable, you're passing a copy of the bits representing the reference to an object. The called method then gets its own copy of the reference variable, to do with it what it likes. But because two identical reference variables refer to the exact same object, if the called method modifies the object (by invoking setter methods, for example), the caller will see that the object the caller's original variable refers to has also been changed. In the next section, we'll look at how the picture changes when we're talking about primitives.</p>
      <p>The bottom line on pass-by-value: the called method can't change the caller's variable, although for object reference variables, the called method can change the object the variable referred to. What's the difference between changing the variable and changing the object? For object references, it means the called method can't reassign the caller's original reference variable and make it refer to a different object, or null. For example, in the following code fragment,</p>
     </blockquote>
     <pre><code>        void bar() {
           Foo f = new Foo();
           doStuff(f);
        }
        void doStuff(Foo g) {
           g.setName("Boo");
           g = new Foo();
        }
</code></pre>
     <blockquote>
      <p>reassigning g does not reassign f! At the end of the bar() method, two Foo objects have been created, one referenced by the local variable f and one referenced by the local (argument) variable g. Because the doStuff() method has a copy of the reference variable, it has a way to get to the original Foo object, for instance to call the setName() method. But, the doStuff() method does not have a way to get to the f reference variable. So doStuff() can change values within the object f refers to, but doStuff() can't change the actual contents (bit pattern) of f. In other words, doStuff() can change the state of the object that f refers to, but it can't make f refer to a different object!</p>
      <p>Passing Primitive Variables</p>
      <p>Let's look at what happens when a primitive variable is passed to a method:</p>
     </blockquote>
     <pre><code>class ReferenceTest {
    public static void main (String [] args) {
      int a = 1;
      ReferenceTest rt = new ReferenceTest();
      System.out.println("Before modify() a = " + a);
      rt.modify(a);
      System.out.println("After modify() a = " + a);
    }
    void modify(int number) {
      number = number + 1;
      System.out.println("number = " + number);
    }
}
</code></pre>
     <blockquote>
      <p>In this simple program, the variable a is passed to a method called modify(), which increments the variable by 1. The resulting output looks like this:</p>
     </blockquote>
     <pre><code>  Before modify() a = 1
  number = 2
  After modify() a = 1
</code></pre>
     <blockquote>
      <p>Notice that a did not change after it was passed to the method. Remember, it was a copy of a that was passed to the method. When a primitive variable is passed to a method, it is passed by value, which means pass-by-copy-of-the-bits-in-the-variable.</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_54"><span>Answer 54</span> <span class="arrow"> <a href="#answer_53">↑</a> </span> <span class="arrow"> <a href="#answer_55">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>11</span>
     </div>
     <div>
      <span>Answerer: </span> <span>OverCoder</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Apr 2016 at 14:32</span>
     </div>
    </div>
    <div>
     <p>I made this little diagram that shows how the data gets created and passed</p>
     <p><a href="https://i.stack.imgur.com/77ppY.png" rel="noreferrer"><img src="77ppY.png" alt="Diagram of how data is created and passed"></a></p>
     <p>Note: Primitive values are passed as a value, the first reference to to that value is the method's argument</p>
     <p>That means:</p>
     <ul>
      <li>You can change the value of <code>myObject</code> <em>inside</em> the function</li>
      <li>But you can't change what <code>myObject</code> references to, inside the function, because <code>point</code> is not <code>myObject</code></li>
      <li>Remember, both <code>point</code> and <code>myObject</code> are <strong>references</strong>, different <strong>references</strong>, however, those references <strong>point</strong> at the same <code>new Point(0,0)</code></li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_55"><span>Answer 55</span> <span class="arrow"> <a href="#answer_54">↑</a> </span> <span class="arrow"> <a href="#answer_56">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>11</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Cdaragorn</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 May 2016 at 14:36</span>
     </div>
    </div>
    <div>
     <p>A lot of the confusion surrounding this issue comes from the fact that Java has attempted to redefine what "Pass by value" and "Pass by reference" mean. It's important to understand that these are <a href="https://en.wikipedia.org/wiki/Jargon" rel="noreferrer">Industry Terms</a>, and cannot be correctly understood outside of that context. They are meant to help you as you code and are valuable to understand, so let's first go over what they mean.</p>
     <p>A good description of both can be found <a href="http://cplus.about.com/od/glossar1/g/passbyrefdefn.htm" rel="noreferrer">here</a>.</p>
     <p><strong>Pass By Value</strong> The value the function received is a copy of the object the caller is using. It is entirely unique to the function and anything you do to that object will only be seen within the function.</p>
     <p><strong>Pass By Reference</strong> The value the function received is a reference to the object the caller is using. Anything the function does to the object that value refers to will be seen by the caller and it will be working with those changes from that point on.</p>
     <p>As is clear from those definitions, the fact that the reference is passed by value is irrelevant. If we were to accept that definition, then these terms become meaningless and all languages everywhere are only Pass By Value.</p>
     <p>No matter how you pass the reference in, it can only ever be passed by value. That isn't the point. The point is that you passed a reference to your own object to the function, not a copy of it. The fact that you can throw away the reference you received is irrelevant. Again, if we accepted that definition, these terms become meaningless and everyone is always passing by value.</p>
     <p>And no, C++'s special "pass by reference" syntax is not the exclusive definition of pass by reference. It is purely a convenience syntax meant to make it so that you don't need to use pointer syntax after passing the pointer in. It is still passing a pointer, the compiler is just hiding that fact from you. It also still passes that pointer BY VALUE, the compiler is just hiding that from you.</p>
     <p>So, with this understanding, we can look at Java and see that it actually has both. All Java primitive types are always pass by value because you receive a copy of the caller's object and cannot modify their copy. All Java reference types are always pass by reference because you receive a reference to the caller's object and can directly modify their object.</p>
     <p>The fact that you cannot modify the caller's reference has nothing to do with pass by reference and is true in every language that supports pass by reference.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>Java has not redefined those terms. Nobody has. It has merely avoided the C term 'pointer'.</span> <span> - </span> <span class="display-name">user207421</span> <span> </span> <span class="date">7 Jun 2016 at 04:05</span></td>
       </tr>
       <tr>
        <td>8</td>
        <td><span>Those terms existed long before Java or C. Pointer was only ever a method for implementing one of them. If you accept Java's definition for them, then they become meaningless because by that definition, every language ever created is only Pass by Value.</span> <span> - </span> <span class="display-name">Cdaragorn</span> <span> </span> <span class="date">31 Aug 2016 at 21:05</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>user207421 certainly discussed terms have existed 50 before Java and we never heard something equivalent stupid like "passing a pointer by value", even if entire Java community thinks, it was the gold standard of terminology.</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">6 Dec 2021 at 18:47</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_56"><span>Answer 56</span> <span class="arrow"> <a href="#answer_55">↑</a> </span> <span class="arrow"> <a href="#answer_57">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>11</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Supriya</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Sep 2017 at 18:52</span>
     </div>
    </div>
    <div>
     <p>Java is pass by value.</p>
     <p>There are already great answers on this thread. Somehow, I was never clear on pass by value/reference with respect to primitive data types and with respect to objects. Therefore, I tested it out for my satisfaction and clarity with the following piece of code; might help somebody seeking similar clarity:</p>
     <pre><code>class Test    {

public static void main (String[] args) throws java.lang.Exception
{
    // Primitive type
    System.out.println("Primitve:");
    int a = 5;
    primitiveFunc(a);
    System.out.println("Three: " + a);    //5

    //Object
    System.out.println("Object:");
    DummyObject dummyObject = new DummyObject();
    System.out.println("One: " + dummyObject.getObj());    //555
    objectFunc(dummyObject);
    System.out.println("Four: " + dummyObject.getObj());    //666 (555 if line in method uncommented.)

}

private static void primitiveFunc(int b)    {
    System.out.println("One: " + b);    //5
    b = 10;
    System.out.println("Two:" + b);    //10
}

private static void objectFunc(DummyObject b)   {
    System.out.println("Two: " + b.getObj());    //555
    //b = new DummyObject();
    b.setObj(666);
    System.out.println("Three:" + b.getObj());    //666
}

}

class DummyObject   {
    private int obj = 555;
    public int getObj() { return obj; }
    public void setObj(int num) { obj = num; }
}
</code></pre>
     <p>If the line <code>b = new DummyObject()</code> is uncommented, the modifications made thereafter are made on a <em>new</em> object, a new instantiation. Hence, it is not reflected in the place where the method is called from. However, otherwise, the change is reflected as the modifications are only made on a "reference" of the object, i.e - b points to the same dummyObject.</p>
     <p>Illustrations in one of the answers in this thread (<a href="https://stackoverflow.com/a/12429953/4233180">https://stackoverflow.com/a/12429953/4233180</a>) can help gain a deeper understanding.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Thought, Java is a programming language ;)</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">6 Dec 2021 at 18:48</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_57"><span>Answer 57</span> <span class="arrow"> <a href="#answer_56">↑</a> </span> <span class="arrow"> <a href="#answer_58">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>10</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Luigi R. Viggiano</span>
     </div>
     <div>
      <span> Answered: </span> <span>19 Apr 2012 at 20:25</span>
     </div>
    </div>
    <div>
     <p>Everything is passed by value. Primitives and Object references. But objects can be changed, if their interface allows it.</p>
     <p>When you pass an object to a method, you are passing a reference, and the object can be modified by the method implementation.</p>
     <pre><code>void bithday(Person p) {
    p.age++;
}
</code></pre>
     <p>The reference of the object itself, is passed by value: you can reassign the parameter, but the change is not reflected back:</p>
     <pre><code>void renameToJon(Person p) { 
    p = new Person("Jon"); // this will not work
}

jack = new Person("Jack");
renameToJon(jack);
sysout(jack); // jack is unchanged
</code></pre>
     <p>As matter of effect, "p" is reference (pointer to the object) and can't be changed.</p>
     <p>Primitive types are passed by value. Object's reference can be considered a primitive type too.</p>
     <p>To recap, everything is passed by value.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_58"><span>Answer 58</span> <span class="arrow"> <a href="#answer_57">↑</a> </span> <span class="arrow"> <a href="#answer_59">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>9</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Khaled.K</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Jun 2013 at 05:30</span>
     </div>
    </div>
    <div>
     <p>Java is always pass-by-value, the parameters are copies of what the variables passed, all Objects are defined using a reference, and reference is a variable that stores a memory address of where the object is in memory.</p>
     <p>Check the comments to understand what happens in execution; follow numbers as they show the flow of execution ..</p>
     <pre><code>class Example
{
    public static void test (Cat ref)
    {
        // 3 - &lt;ref&gt; is a copy of the reference &lt;a&gt;
        // both currently reference Grumpy
        System.out.println(ref.getName());

        // 4 - now &lt;ref&gt; references a new &lt;Cat&gt; object named "Nyan"
        ref = new Cat("Nyan");

        // 5 - this should print "Nyan"
        System.out.println( ref.getName() );
    }

    public static void main (String [] args)
    {
        // 1 - a is a &lt;Cat&gt; reference that references a Cat object in memory with name "Grumpy"
        Cat a = new Cat("Grumpy");

        // 2 - call to function test which takes a &lt;Cat&gt; reference
        test (a);

        // 6 - function call ends, and &lt;ref&gt; life-time ends
        // "Nyan" object has no references and the Garbage
        // Collector will remove it from memory when invoked

        // 7 - this should print "Grumpy"
        System.out.println(a.getName());
    }
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>'Pass its inner value' is meaningless.</span> <span> - </span> <span class="display-name">user207421</span> <span> </span> <span class="date">17 Sep 2017 at 10:09</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@EJP thanks for the note, excuse my bad English from 2013, I've edited the whole thing, if you see a better wording, you may suggest or edit</span> <span> - </span> <span class="display-name">Khaled.K</span> <span> </span> <span class="date">17 Sep 2017 at 16:41</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>i would like to add one thing.if you have changed the name of cat instead of creating a new one, it will reflect in the memory even after the method returns</span> <span> - </span> <span class="display-name">user6091735</span> <span> </span> <span class="date">18 Nov 2017 at 16:26</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_59"><span>Answer 59</span> <span class="arrow"> <a href="#answer_58">↑</a> </span> <span class="arrow"> <a href="#answer_60">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>9</span>
     </div>
     <div>
      <span>Answerer: </span> <span>mc01</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Mar 2018 at 23:25</span>
     </div>
    </div>
    <div>
     <h2>PT 1: Of Realty Listings</h2>
     <p>There is a blue, 120sq-ft "Tiny House" currently parked at 1234 Main St with a nicely manicured lawn &amp; flower bed out front.</p>
     <p>A Realtor with a local firm is hired and told to keep a listing for that house.</p>
     <p>Let's call that Realtor "Bob." Hi Bob.</p>
     <p>Bob keeps his Listing, which he calls <code>tinyHouseAt1234Main</code>, up to date with a webcam that allows him to note any changes to the actual house in real time. He also keeps a tally of how many people have asked about the listing. Bob's integer <code>viewTally</code> for the house is at 42 today.</p>
     <p>Whenever someone wants info about the blue Tiny House at 1234 Main St, they ask Bob.</p>
     <p>Bob looks up his Listing <code>tinyHouseAt1234Main</code> and tells them all about it - the color, the nice lawn, the loft bed and the composting toilet, etc. Then he adds their inquiry to his <code>viewTally</code>. He doesn't tell them the real, physical address though, because Bob's firm specializes in Tiny Houses that could be moved at any time. The tally is now 43.</p>
     <p>At another firm, Realtors might explicitly say their listing "points" to the house at 1234 Main St, denoting this with a little <code>*</code> next to it, because they mainly deal with houses that rarely ever move (though presumably there are reasons for doing so). Bob's firm doesn't bother doing this.</p>
     <p>Now, of course Bob doesn't physically go and put the <em>actual</em> house on a truck to show it to clients directly - that would be impractical and a ridiculous waste of resources. Passing a full copy of his tally sheet is one thing, but passing around the whole house all the time is costly and ridiculous.</p>
     <p>(Aside: Bob's firm also doesn't 3D print new &amp; unique copies of a listed house every single time someone asks about it. That's what the upstart, similarly named web-based firm &amp; its spinoffs do - that's expensive and slower, and people often get the 2 firms confused, but they're quite popular anyway).</p>
     <p>At some other, older firms closer to the Sea, a realtor like Bob might not even exist to manage the Listings. Clients might instead consult the Rolodex "Annie" (<code>&amp;</code> for short) for the direct address of the house. Instead of reading off the referenced house details from the listing like Bob does, clients instead get the house address from Annie (<code>&amp;</code>), and go directly to 1234 Main St, sometimes w/no idea what they might find there.</p>
     <p>One day, Bob's firm begins offering a new automated service that needs the listing for a house the client is interested in.</p>
     <p>Well, the person with that info is Bob, so the client has Bob call up the service and send it a copy of the listing.</p>
     <p><code>jobKillingAutomatedListingService(Listing tinyHouseAt1234Main, int viewTally)</code> Bob sends along ...</p>
     <p>The service, on its end, calls this Listing <code>houseToLookAt</code>, but really what it receives is an exact copy of Bob's listing, with the exact same VALUEs in it, that refer to the house at 1234 Main St.</p>
     <p>This new service also has its own internal tally of how many people have viewed the listing. The service accepts Bob's tally out of professional courtesy, but it doesn't really care and overwrites it entirely with its own local copy anyway. It's tally for today is 1, while Bob's is still 43.</p>
     <p>The realty firms call this "pass-by-value" since Bob's passing the current value of his <code>viewTally</code> and his Listing <code>tinyHouseAt1234Main</code>. He's not actually passing along the entire physical house, because that's impractical. Nor is he passing the real physical address like Annie(<code>&amp;</code>) would do.</p>
     <p>But he IS passing a copy of <em>the value OF</em> the reference he has to the house. Seems like a silly pedantic difference in some ways, but that's how his firm works ... ..............</p>
     <h2>PT II: Where things get confusing and dangerous ...</h2>
     <p>The new automated service, not being all functional and math-oriented like some other trendy financial &amp; scientific firms, can have unforeseen side effects...</p>
     <p>Once given a Listing object it allows clients to <em>actually</em> repaint the REAL house at 1234 Main St, using a remote drone robot fleet! It allows clients to control a robot bulldozer to ACTUALLY dig up the flower bed! This is madness!!!</p>
     <p>The service also lets clients completely redirect <code>houseToLookAt</code> to some other house at another address, without involving Bob or his listing. All of a sudden they could be looking at 4321 Elm St. instead, which has no connection whatsoever to Bob's listing (thankfully they can't do anymore damage).</p>
     <p>Bob watches all this on his realtime webcam. Resigned to the drudgery of his sole job responsibility, he tells clients about the new ugly paint job &amp; sudden lack of curb appeal. His Listing <em>is</em> still for 1234 Main St., after all. The new service's <code>houseToLookAt</code> couldn't change that. Bob reports the details of his <code>tinyHouseAt1234Main</code> accurately and dutifully as always, until he gets fired or the house is destroyed entirely by The Nothing.</p>
     <p>Really the only thing the service CAN'T do with its <code>houseToLookAt</code> copy of the Bob's original listing is change the address from 1234 Main St. to some other address, or to a void of nothingness, or to some random type of object like a Platypus. Bob's Listing still always points to 1234 Main St, for whatever it's still worth. He passes its current value around like always.</p>
     <p>This bizarre side-effect of passing a listing to the new automated service is confusing for people who ask about how it works. Really, what's the difference between the ability to remotely control robots that alter the state of the house at 1234 Main, vs. <em>actually</em> physically going there and wreaking havoc because Annie gave you the address??</p>
     <p>Seems like kind of a nitpicky semantic argument if what you generally care about is the <em>state</em> of the house in the listing being copied and passed around, right?</p>
     <p>I mean, if you were in the business of actually picking up houses and physically moving them to other addresses (not like mobile or Tiny Homes where that's sort of an expected function of the platform), or you were accessing, renaming, and shuffling entire neighborhoods like some sort of low-level God-playing madman, THEN maybe you'd care more about passing around those specific address references instead of just copies of the the latest value of the house details ...</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_60"><span>Answer 60</span> <span class="arrow"> <a href="#answer_59">↑</a> </span> <span class="arrow"> <a href="#answer_61">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>bvdb</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Aug 2013 at 10:09</span>
     </div>
    </div>
    <div>
     <p>Shortest answer :)</p>
     <ul>
      <li>Java has pass-by-value (and pass-reference-by-value.)</li>
      <li><strong>C# also has pass-by-reference</strong></li>
     </ul>
     <p>In C# this is accomplished with the "out" and "ref" keywords.</p>
     <p>Pass By Reference: The variable is passed in such a way that <strong>a reassignment inside the method is reflected even outside the method.</strong></p>
     <p>Here follows <strong>an example of passing-by-reference (C#)</strong>. This feature does not exist in java.</p>
     <pre><code>class Example
{
    static void InitArray(out int[] arr)
    {
        arr = new int[5] { 1, 2, 3, 4, 5 };
    }

    static void Main()
    {
        int[] someArray;
        InitArray(out someArray);

        // This is true !
        boolean isTrue = (someArray[0] == 1);
    }
}
</code></pre>
     <p>See also: <a href="http://msdn.microsoft.com/en-us/library/szasx730.aspx" rel="noreferrer" title="MSDN library: passing arrays by ref and out">MSDN library (C#): passing arrays by ref and out</a></p>
     <p>See also: <a href="http://msdn.microsoft.com/en-us/library/0f66670z.aspx" rel="noreferrer" title="MSDN library: passing by reference">MSDN library (C#): passing by by value and by reference</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_61"><span>Answer 61</span> <span class="arrow"> <a href="#answer_60">↑</a> </span> <span class="arrow"> <a href="#answer_62">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user1931858</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Sep 2013 at 02:03</span>
     </div>
    </div>
    <div>
     <p>Java passes parameters by value, but for object variables, the values are essentially references to objects. Since arrays are objects the following <a href="http://theoryapp.com/parameter-passing-in-java/" rel="noreferrer">example code</a> shows the difference.</p>
     <pre><code>public static void dummyIncrease(int[] x, int y)
{
    x[0]++;
    y++;
}
public static void main(String[] args)
{
    int[] arr = {3, 4, 5};
    int b = 1;
    dummyIncrease(arr, b);
    // arr[0] is 4, but b is still 1
}

main()
  arr +---+       +---+---+---+
      | # | ----&gt; | 3 | 4 | 5 |
      +---+       +---+---+---+
  b   +---+             ^
      | 1 |             | 
      +---+             |
                        |
dummyIncrease()         |
  x   +---+             |
      | # | ------------+
      +---+      
  y   +---+ 
      | 1 | 
      +---+ 
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_62"><span>Answer 62</span> <span class="arrow"> <a href="#answer_61">↑</a> </span> <span class="arrow"> <a href="#answer_63">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ramprasad</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Dec 2014 at 18:48</span>
     </div>
    </div>
    <div>
     <p><strong>Simple program</strong></p>
     <pre><code>import java.io.*;
class Aclass
{
    public int a;
}
public class test
{
    public static void foo_obj(Aclass obj)
    {
        obj.a=5;
    }
    public static void foo_int(int a)
    {
        a=3;
    }
    public static void main(String args[])
    {
        //test passing an object
        Aclass ob = new Aclass();
        ob.a=0;
        foo_obj(ob);
        System.out.println(ob.a);//prints 5

        //test passing an integer
        int i=0;
        foo_int(i);
        System.out.println(i);//prints 0
    }
}
</code></pre>
     <p>From a C/C++ programmer's point of view, java uses pass by value, so for primitive data types (int, char etc) changes in the function does not reflect in the calling function. But when you pass an object and in the function you change its data members or call member functions which can change the state of the object, the calling function will get the changes.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>You can only define one class per file. This is not including nested and inner classes. Considering this will be something a new programmer will be reading, you should explain this to the user; allowing them to duplicate the code on their machine.</span> <span> - </span> <span class="display-name">mrres1</span> <span> </span> <span class="date">25 Jan 2015 at 01:30</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@mrres1 Not entirely correct. You can define only one <i>public</i> top-level class/interface per file. Supporting several classes per file is a remnant from the first Java version, which didn't have nested classes, but it is still supported, though often frowned upon.</span> <span> - </span> <span class="display-name">MrBackend</span> <span> </span> <span class="date">19 Mar 2015 at 13:53</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_63"><span>Answer 63</span> <span class="arrow"> <a href="#answer_62">↑</a> </span> <span class="arrow"> <a href="#answer_64">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ravi Sanwal</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Jun 2016 at 03:01</span>
     </div>
    </div>
    <div>
     <p>There is a very simple way to understand this. Lets's take C++ pass by reference.</p>
     <pre><code>#include &lt;iostream&gt;
using namespace std;

class Foo {
    private:
        int x;
    public:
        Foo(int val) {x = val;}
        void foo()
        {
            cout&lt;&lt;x&lt;&lt;endl;
        }
};

void bar(Foo&amp; ref)
{
    ref.foo();
    ref = *(new Foo(99));
    ref.foo();
}

int main()
{
   Foo f = Foo(1);
   f.foo();
   bar(f);
   f.foo();

   return 0;
}
</code></pre>
     <p>What is the outcome?</p>
     <pre>1
1
99
99
</pre>
     <p>So, after bar() assigned a new value to a "reference" passed in, it actually changed the one which was passed in from main itself, explaining the last f.foo() call from main printing 99.</p>
     <p>Now, lets see what java says.</p>
     <pre><code>public class Ref {

    private static class Foo {
        private int x;

        private Foo(int x) {
            this.x = x;
        }

        private void foo() {
            System.out.println(x);
        }
    }

    private static void bar(Foo f) {
        f.foo();
        f = new Foo(99);
        f.foo();
    }

    public static void main(String[] args) {
        Foo f = new Foo(1);
        System.out.println(f.x);
        bar(f);
        System.out.println(f.x);
    }

}
</code></pre>
     <p>It says:</p>
     <pre>1
1
99
1
</pre>
     <p>Voilà, the reference of Foo in main that was passed to bar, is still unchanged!</p>
     <p>This example clearly shows that java is not the same as C++ when we say "pass by reference". Essentially, java is passing "references" as "values" to functions, meaning java is pass by value.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Is there an issue in your c++ version where your risking a segfault when <code>Foo(99)</code> goes out of scope but you reference it in your main method?</span> <span> - </span> <span class="display-name">matt</span> <span> </span> <span class="date">15 Jun 2016 at 08:14</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Indeed. Ah comes from using java for 10 years. But the idea still holds. And I fixed it now.</span> <span> - </span> <span class="display-name">Ravi Sanwal</span> <span> </span> <span class="date">16 Jun 2016 at 15:16</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I think the previous was better because it would compile. I was just curious about the behavior, sorry about that.</span> <span> - </span> <span class="display-name">matt</span> <span> </span> <span class="date">16 Jun 2016 at 17:41</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>This answer only helps for those coming from C++ background who are willing to define "reference" the way you have, according to C++'s definition. That is not always the case.</span> <span> - </span> <span class="display-name">Loduwijk</span> <span> </span> <span class="date">2 Aug 2017 at 15:41</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>"What is the outcome?" - Guess a memory leak</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">6 Dec 2021 at 18:53</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_64"><span>Answer 64</span> <span class="arrow"> <a href="#answer_63">↑</a> </span> <span class="arrow"> <a href="#answer_65">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>asok</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 May 2018 at 12:41</span>
     </div>
    </div>
    <div>
     <p>Java is only passed by value. there is no pass by reference, for example, you can see the following example.</p>
     <pre><code>package com.asok.cop.example.task;
public class Example {
    int data = 50;

    void change(int data) {
        data = data + 100;// changes will be in the local variable 
        System.out.println("after add " + data);
        }

    public static void main(String args[]) {
        Example op = new Example();
        System.out.println("before change " + op.data);
        op.change(500);
        System.out.println("after change " + op.data);
    }
}
</code></pre>
     <p>Output:</p>
     <pre><code>before change 50
after add 600
after change 50
</code></pre>
     <p>as Michael says in the comments:</p>
     <blockquote>
      <p>objects are still passed by value even though operations on them behave like pass-by-reference. Consider <code>void changePerson(Person person){ person = new Person(); }</code> the callers reference to the person object will remain unchanged. Objects themselves are passed by value but their members can be affected by changes. To be true pass-by-reference, we would have to be able to reassign the argument to a new object and have the change be reflected in the caller.</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Describing java as "pass-by-value" is highly misleading. For non-primitive types Java uses "pass by value of the reference". "Pass by value" implies the value is copied when passed to a method. It is not, the reference is copied.</span> <span> - </span> <span class="display-name">AutomatedMike</span> <span> </span> <span class="date">3 May 2019 at 12:18</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Not half the answer.</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">5 Sep 2021 at 13:15</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_65"><span>Answer 65</span> <span class="arrow"> <a href="#answer_64">↑</a> </span> <span class="arrow"> <a href="#answer_66">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>DeC</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Nov 2019 at 03:25</span>
     </div>
    </div>
    <div>
     <p>A: Java does manipulate objects by reference, and all object variables are references. However, Java doesn't pass method arguments by reference; it passes them by value.</p>
     <p>Take the badSwap() method for example:</p>
     <pre><code>public void badSwap(int var1, int var2)
{
  int temp = var1;
  var1 = var2;
  var2 = temp;
}
</code></pre>
     <p>When badSwap() returns, the variables passed as arguments will still hold their original values. The method will also fail if we change the arguments type from int to Object, since Java passes object references by value as well. Now, here is where it gets tricky:</p>
     <pre><code>public void tricky(Point arg1, Point arg2)
{
  arg1.x = 100;
  arg1.y = 100;
  Point temp = arg1;
  arg1 = arg2;
  arg2 = temp;
}
public static void main(String [] args)
{
  Point pnt1 = new Point(0,0);
  Point pnt2 = new Point(0,0);
  System.out.println("X: " + pnt1.x + " Y: " +pnt1.y); 
  System.out.println("X: " + pnt2.x + " Y: " +pnt2.y);
  System.out.println(" ");
  tricky(pnt1,pnt2);
  System.out.println("X: " + pnt1.x + " Y:" + pnt1.y); 
  System.out.println("X: " + pnt2.x + " Y: " +pnt2.y);  
}
</code></pre>
     <p>If we execute this main() method, we see the following output:</p>
     <pre><code>X: 0 Y: 0
X: 0 Y: 0
X: 100 Y: 100
X: 0 Y: 0
</code></pre>
     <p>The method successfully alters the value of pnt1, even though it is passed by value; however, a swap of pnt1 and pnt2 fails! This is the major source of confusion. In the main() method, pnt1 and pnt2 are nothing more than object references. When you pass pnt1 and pnt2 to the tricky() method, Java passes the references by value just like any other parameter. This means the references passed to the method are actually copies of the original references. Figure 1 below shows two references pointing to the same object after Java passes an object to a method.</p>
     <p><a href="https://i.stack.imgur.com/wLEj7.png" rel="nofollow noreferrer"><img src="wLEj7.png" alt="enter image description here"></a><br>
       Figure 1. After being passed to a method, an object will have at least two references</p>
     <p>Java copies and passes the reference by value, not the object. Thus, method manipulation will alter the objects, since the references point to the original objects. But since the references are copies, swaps will fail.The method references swap, but not the original references. Unfortunately, after a method call, you are left with only the unswapped original references. For a swap to succeed outside of the method call, we need to swap the original references, not the copies.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_66"><span>Answer 66</span> <span class="arrow"> <a href="#answer_65">↑</a> </span> <span class="arrow"> <a href="#answer_67">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Pallav Khare</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Nov 2020 at 18:17</span>
     </div>
    </div>
    <div>
     <p>Java is always pass by value, not pass by reference</p>
     <p>First of all, we need to understand what pass by value and pass by reference are.</p>
     <p><strong>Pass by value</strong> means that you are making a copy in memory of the actual parameter's value that is passed in. This is a copy of the contents of the actual parameter.</p>
     <p><strong>Pass by reference</strong> (also called pass by address) means that a copy of the address of the actual parameter is stored.</p>
     <p>Sometimes Java can give the illusion of pass by reference. Let's see how it works by using the example below:</p>
     <pre><code>public class PassByValue {
    public static void main(String[] args) {
        Test t = new Test();
        t.name = "initialvalue";
        new PassByValue().changeValue(t);
        System.out.println(t.name);
    }
    
    public void changeValue(Test f) {
        f.name = "changevalue";
    }
}

class Test {
    String name;
}
</code></pre>
     <p>The output of this program is:</p>
     <pre><code>changevalue
</code></pre>
     <p>Let's understand step by step:</p>
     <pre><code>Test t = new Test();
</code></pre>
     <p>As we all know it will create an object in the heap and return the reference value back to t. For example, suppose the value of t is 0x100234 (we don't know the actual JVM internal value, this is just an example) .</p>
     <p>first illustration</p>
     <pre><code>new PassByValue().changeValue(t);
</code></pre>
     <p>When passing reference t to the function it will not directly pass the actual reference value of object test, but it will create a copy of t and then pass it to the function. Since it is passing by value, it passes a copy of the variable rather than the actual reference of it. Since we said the value of t was 0x100234, both t and f will have the same value and hence they will point to the same object.</p>
     <p>second illustration</p>
     <p>If you change anything in the function using reference f it will modify the existing contents of the object. That is why we got the output changevalue, which is updated in the function.</p>
     <p>To understand this more clearly, consider the following example:</p>
     <pre><code>public class PassByValue {
    public static void main(String[] args) {
        Test t = new Test();
        t.name = "initialvalue";
        new PassByValue().changeRefence(t);
        System.out.println(t.name);
    }
    
    public void changeRefence(Test f) {
        f = null;
    }
}

class Test {
    String name;
}
</code></pre>
     <p>Will this throw a NullPointerException? No, because it only passes a copy of the reference. In the case of passing by reference, it could have thrown a NullPointerException, as seen below:</p>
     <p>third illustration</p>
     <p>Hopefully this will help.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>"Since we said the value of t was 0x100234, both t and f will have the same value and hence they will point to the same object." - That doesn't sound right. Creating a copy of an object should not mean the copy and the original both point to the same object. This smells like pass-by-reference, or minimally, pass-by-object-reference</span> <span> - </span> <span class="display-name">h0r53</span> <span> </span> <span class="date">19 Oct 2021 at 16:25</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_67"><span>Answer 67</span> <span class="arrow"> <a href="#answer_66">↑</a> </span> <span class="arrow"> <a href="#answer_68">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>JAN</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Jan 2014 at 16:23</span>
     </div>
    </div>
    <div>
     <p>Mr @Scott Stanchfield wrote an excellent answer. Here is the class that would you to verify exactly what he meant:</p>
     <pre><code>public class Dog {

    String dog ;
    static int x_static;
    int y_not_static;

    public String getName()
    {
        return this.dog;
    }

    public Dog(String dog)
    {
        this.dog = dog;
    }

    public void setName(String name)
    {
        this.dog = name;
    }

    public static void foo(Dog someDog)
    {
        x_static = 1;
        // y_not_static = 2;  // not possible !!
        someDog.setName("Max");     // AAA
        someDog = new Dog("Fifi");  // BBB
        someDog.setName("Rowlf");   // CCC
    }

    public static void main(String args[])
    {
        Dog myDog = new Dog("Rover");
        foo(myDog);
        System.out.println(myDog.getName());
    }
}
</code></pre>
     <p>So, we pass from main() a dog called <code>Rover</code>, then we assign a new address to the pointer that we passed, but at the end, the name of the dog is not <code>Rover</code>, and not <code>Fifi</code>, and certainly not <code>Rowlf</code>, but <code>Max</code>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_68"><span>Answer 68</span> <span class="arrow"> <a href="#answer_67">↑</a> </span> <span class="arrow"> <a href="#answer_69">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Dustin Deus</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Jul 2014 at 20:19</span>
     </div>
    </div>
    <div>
     <p><strong>Understand it in 2 Steps:</strong></p>
     <p>You can't change the reference to the object itself but you can work with this passed parameter as a reference to the object.</p>
     <p>If you want to change the value behind the reference you will only declare a new variable on the stack with the same name 'd'. Look at the references with the sign <code>@</code> and you will find out that the reference has been changed.</p>
     <pre><code>public static void foo(Dog d) {
  d.Name = "belly";
  System.out.println(d); //Reference: Dog@1540e19d

  d = new Dog("wuffwuff");
  System.out.println(d); //Dog@677327b6
}
public static void main(String[] args) throws Exception{
  Dog lisa = new Dog("Lisa");
  foo(lisa);
  System.out.println(lisa.Name); //belly
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_69"><span>Answer 69</span> <span class="arrow"> <a href="#answer_68">↑</a> </span> <span class="arrow"> <a href="#answer_70">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Raja</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Jan 2017 at 19:51</span>
     </div>
    </div>
    <div>
     <p>I tried to simplify the examples above, keeping only the essense of the problem. Let me present this as a story that is easy to remember and apply correctly. The story goes like this: You have a pet dog, Jimmy, whose tail is 12 inches long. You leave it with a vet for a few weeks while you are travelling abroad.</p>
     <p>The vet doesn't like the long tail of Jimmy, so he wants to cut it by half. But being a good vet, he knows that he has no right to mutilate other people's dogs. So he first makes a clone of the dog (with the <em>new</em> key word) and cuts the tail of the clone. When the dog finally returns to you, it has the original 12 inch tail in tact. Happy ending !</p>
     <p>The next time you travel, you take the dog, unwittingly, to a wicked vet. He is also a hater of long tails, so he cuts it down to a miserable 2 inches. But he does this to your dear Jimmy, not a clone of it. When you return, you are shocked to see Jimmy pathetically wagging a 2 inch stub.</p>
     <p>Moral of the story: When you pass on your pet, you are giving away whole and unfettered custody of the pet to the vet. He is free to play any kind of havoc with it. Passing by <em>value</em>, by <em>reference</em>, by <em>pointer</em> are all just technical wrangling. Unless the vet clones it first, he ends up mutilating the original dog.</p>
     <pre><code>public class Doggie {

    public static void main(String...args) {
        System.out.println("At the owner's home:");
        Dog d = new Dog(12);
        d.wag();
        goodVet(d);
        System.out.println("With the owner again:)");
        d.wag();
        badVet(d);
        System.out.println("With the owner again(:");
        d.wag();
    }

    public static void goodVet (Dog dog) {
        System.out.println("At the good vet:");
        dog.wag();
        dog = new Dog(12); // create a clone
        dog.cutTail(6);    // cut the clone's tail
        dog.wag();
    }

    public static void badVet (Dog dog) {
        System.out.println("At the bad vet:");
        dog.wag();
        dog.cutTail(2);   // cut the original dog's tail
        dog.wag();
    }    
}

class Dog {

    int tailLength;

    public Dog(int originalLength) {
        this.tailLength = originalLength;
    }

    public void cutTail (int newLength) {
        this.tailLength = newLength;
    }

    public void wag()  {
        System.out.println("Wagging my " +tailLength +" inch tail");
    }
}

Output:
At the owner's home:
Wagging my 12 inch tail
At the good vet:
Wagging my 12 inch tail
Wagging my 6 inch tail
With the owner again:)
Wagging my 12 inch tail
At the bad vet:
Wagging my 12 inch tail
Wagging my 2 inch tail
With the owner again(:
Wagging my 2 inch tail
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_70"><span>Answer 70</span> <span class="arrow"> <a href="#answer_69">↑</a> </span> <span class="arrow"> <a href="#answer_71">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Duleepa Wickramasinghe</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Oct 2020 at 03:16</span>
     </div>
    </div>
    <div>
     <p><strong>Java always passes parameters by value.</strong> <br>
      All object references in Java are passed by value. This means that a copy of the value will be passed to a method. But the trick is that passing a copy of the value also changes the real value of the object.</p>
     <p>Please refer to the below example,</p>
     <pre><code>public class ObjectReferenceExample {

    public static void main(String... doYourBest) {
            Student student = new Student();
            transformIntoHomer(student);
            System.out.println(student.name);
    }

    static void transformIntoDuleepa(Student student) {
            student.name = "Duleepa";
    }
}
class Student {
    String name;
}
</code></pre>
     <p>In this case, it will be Duleepa! <br>
      The reason is that Java object variables are simply references that point to real objects in the memory heap. Therefore, even though Java passes parameters to methods by value, if the variable points to an object reference, the real object will also be changed.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Running this program should help anyone understand this concept. <a href="https://pastebin.com/VEc8NQcX" rel="nofollow noreferrer">pastebin.com/VEc8NQcX</a></span> <span> - </span> <span class="display-name">Mohith7548</span> <span> </span> <span class="date">3 Nov 2020 at 10:26</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>In this example you've not copied the Student object, so I think saying "passing a copy of the value also changes the real value of the object" is misleading. The thing that you are copying, and passing-by-value, is the <i>reference</i> to the object. The object stays living on the heap, and there's just one of them. That's why when you use the new reference to mutate the object, you're mutating it for everyone else that has a reference to the object. There's only one object. When the argument of the function is a primitive type, not a reference to an object, it is also copied.</span> <span> - </span> <span class="display-name">Chrispher</span> <span> </span> <span class="date">14 Nov 2020 at 11:57</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_71"><span>Answer 71</span> <span class="arrow"> <a href="#answer_70">↑</a> </span> <span class="arrow"> <a href="#answer_72">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Aniket Thakur</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Dec 2013 at 08:26</span>
     </div>
    </div>
    <div>
     <p><strong>Java passes references to objects by value.</strong></p>
     <p>So if any modification is done to the Object to which the reference argument points it will be reflected back on the original object.</p>
     <p>But if the reference argument point to another Object still the original reference will point to original Object.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_72"><span>Answer 72</span> <span class="arrow"> <a href="#answer_71">↑</a> </span> <span class="arrow"> <a href="#answer_73">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>drew7721</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Oct 2014 at 04:34</span>
     </div>
    </div>
    <div>
     <p>There is a workaround in Java for the reference. Let me explain by this example:</p>
     <pre><code>public class Yo {
public static void foo(int x){
    System.out.println(x); //out 2
    x = x+2;
    System.out.println(x); // out 4
}
public static void foo(int[] x){
    System.out.println(x[0]); //1
    x[0] = x[0]+2;
    System.out.println(x[0]); //3
}
public static void main(String[] args) {
    int t = 2;
    foo(t);
    System.out.println(t); // out 2 (t did not change in foo)

    int[] tab = new int[]{1};
    foo(tab);
    System.out.println(tab[0]); // out 3 (tab[0] did change in foo)
}}
</code></pre>
     <p>I hope this helps!</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>To understand this, one needs to understand that unlike in many languages in Java an array is an <code>Object</code> itself.</span> <span> - </span> <span class="display-name">v010dya</span> <span> </span> <span class="date">21 Apr 2021 at 13:46</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_73"><span>Answer 73</span> <span class="arrow"> <a href="#answer_72">↑</a> </span> <span class="arrow"> <a href="#answer_74">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Vivek Kumar</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Sep 2016 at 17:55</span>
     </div>
    </div>
    <div>
     <p>Java does manipulate objects by reference, and all object variables are references. However, Java doesn't pass method arguments by reference; it passes them by value.</p>
     <p>Take the&nbsp;badSwap()&nbsp;method for example:</p>
     <pre><code>    public void badSwap(int var1, int
 var2{ int temp = var1; var1 = var2; var2 =
 temp; }
</code></pre>
     <p>When&nbsp;badSwap()&nbsp;returns, the variables passed as arguments will still hold their original values. The method will also fail if we change the arguments type from&nbsp;int&nbsp;to&nbsp;Object, since Java passes object references by value as well. Now, here is where it gets tricky:</p>
     <pre><code>public void tricky(Point arg1, Point   arg2)
{ arg1.x = 100; arg1.y = 100; Point temp = arg1; arg1 = arg2; arg2 = temp; }
public static void main(String [] args) { 

 Point pnt1 = new Point(0,0); Point pnt2
 = new Point(0,0); System.out.println("X:
 " + pnt1.x + " Y: " +pnt1.y);

     System.out.println("X: " + pnt2.x + " Y:
 " +pnt2.y); System.out.println(" ");

     tricky(pnt1,pnt2);
 System.out.println("X: " + pnt1.x + " Y:" + pnt1.y);

     System.out.println("X: " + pnt2.x + " Y: " +pnt2.y); }
</code></pre>
     <p>If we execute this&nbsp;main()&nbsp;method, we see the following output:</p>
     <p>X: 0 Y: 0 X: 0 Y: 0 X: 100 Y: 100 X: 0 Y: 0</p>
     <p>The method successfully alters the value ofpnt1, even though it is passed by value; however, a swap of&nbsp;pnt1&nbsp;and&nbsp;pnt2&nbsp;fails! This is the major source of confusion. In themain()&nbsp;method,&nbsp;pnt1&nbsp;and&nbsp;pnt2&nbsp;are nothing more than object references. When you passpnt1&nbsp;and&nbsp;pnt2&nbsp;to the&nbsp;tricky()&nbsp;method, Java passes the references by value just like any other parameter. This means the references passed to the method are actually&nbsp;copies&nbsp;of the original references. Figure 1 below shows two references pointing to the same object after Java passes an object to a method.</p>
     <p>Java copies and passes the&nbsp;reference&nbsp;by value, not the object. Thus, method manipulation will alter the objects, since the references point to the original objects. But since the references are copies, swaps will fail. As Figure 2 illustrates, the method references swap, but not the original references. Unfortunately, after a method call, you are left with only the unswapped original references. For a swap to succeed outside of the method call, we need to swap the original references, not the copies.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_74"><span>Answer 74</span> <span class="arrow"> <a href="#answer_73">↑</a> </span> <span class="arrow"> <a href="#answer_75">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>James Drinkard</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Sep 2013 at 20:22</span>
     </div>
    </div>
    <div>
     <p>The bottom line on pass-by-value: the called method can't change the caller's variable, although for object reference variables, the called method can change the object the variable referred to. What's the difference between changing the variable and changing the object? For object references, it means the called method can't reassign the caller's original reference variable and make it refer to a different object, or null.</p>
     <p>I took this code and explanation from a book on Java Certification and made some minor changes.<br>
       I think it's a good illustration to the pass by value of an object. In the code below, reassigning g does not reassign f! At the end of the bar() method, two Foo objects have been created, one referenced by the local variable f and one referenced by the local (argument) variable g.</p>
     <p>Because the doStuff() method has a copy of the reference variable, it has a way to get to the original Foo object, for instance to call the setName() method. But, the doStuff() method does not have a way to get to the f reference variable. So doStuff() can change values within the object f refers to, but doStuff() can't change the actual contents (bit pattern) of f. In other words, doStuff() can change the state of the object that f refers to, but it can't make f refer to a different object!</p>
     <pre><code>package test.abc;

public class TestObject {

    /**
     * @param args
     */
    public static void main(String[] args) {
        bar();
    }

    static void bar() {
        Foo f = new Foo();
        System.out.println("Object reference for f: " + f);
        f.setName("James");
        doStuff(f);
        System.out.println(f.getName());
        //Can change the state of an object variable in f, but can't change the object reference for f.
        //You still have 2 foo objects.
        System.out.println("Object reference for f: " + f);
        }

    static void doStuff(Foo g) {
            g.setName("Boo");
            g = new Foo();
            System.out.println("Object reference for g: " + g);
        }
}


package test.abc;

public class Foo {
    public String name = "";

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

}
</code></pre>
     <p><strong>Note that the object reference has not changed in the console output below:</strong></p>
     <p><strong>Console output:</strong></p>
     <p>Object reference for f: test.abc.Foo@62f72617</p>
     <p>Object reference for g: test.abc.Foo@4fe5e2c3</p>
     <p>Boo Object reference for f: test.abc.Foo@62f72617</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_75"><span>Answer 75</span> <span class="arrow"> <a href="#answer_74">↑</a> </span> <span class="arrow"> <a href="#answer_76">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>João Oliveira</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Feb 2015 at 18:44</span>
     </div>
    </div>
    <div>
     <p>Java passes everything by value!!</p>
     <p>//create an object by passing in a name and age:</p>
     <pre><code>PersonClass variable1 = new PersonClass("Mary", 32);

PersonClass variable2;
</code></pre>
     <p>//Both variable2 and variable1 now reference the same object</p>
     <pre><code>variable2 = variable1; 


PersonClass variable3 = new PersonClass("Andre", 45);
</code></pre>
     <p>// variable1 now points to variable3</p>
     <pre><code>variable1 = variable3;
</code></pre>
     <p>//WHAT IS OUTPUT BY THIS?</p>
     <pre><code>System.out.println(variable2);
System.out.println(variable1);

Mary 32
Andre 45
</code></pre>
     <p>if you could understand this example we r done. otherwise, please visit this webPage for detailed explanation:</p>
     <p><a href="http://www.programmerinterview.com/index.php/java-questions/does-java-pass-by-reference-or-by-value/" rel="noreferrer">webPage</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>This actually doesn't explain anything in regards to potential by ref/by val property of Java.</span> <span> - </span> <span class="display-name">Mox</span> <span> </span> <span class="date">18 Jan 2017 at 11:38</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_76"><span>Answer 76</span> <span class="arrow"> <a href="#answer_75">↑</a> </span> <span class="arrow"> <a href="#answer_77">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Taleev Aalam</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Nov 2016 at 11:58</span>
     </div>
    </div>
    <div>
     <p>It seems everything is call by value in java as i have tried to understand by the following program</p>
     <p><strong>Class-S</strong></p>
     <pre><code>class S{
String name="alam";
public void setName(String n){
this.name=n; 
}}
</code></pre>
     <p><strong>Class-Sample</strong></p>
     <pre><code>    public class Sample{
    public static void main(String args[]){
    S s=new S();
    S t=new S();
    System.out.println(s.name);
    System.out.println(t.name);
    t.setName("taleev");
    System.out.println(t.name);
    System.out.println(s.name);
    s.setName("Harry");
    System.out.println(t.name);
    System.out.println(s.name);
    }}
</code></pre>
     <p><strong>Output</strong></p>
     <blockquote>
      <p>alam</p>
      <p>alam</p>
      <p>taleev</p>
      <p>alam</p>
      <p>taleev</p>
      <p>harry</p>
     </blockquote>
     <p>As we have define class S with instance variable name with value <strong>taleev</strong> so for all the objects that we initialize from it will have the name variable with value of <strong>taleev</strong> but if we change the name's value of any objects then it is changing the name of only that copy of the class(Object) not for every class so after that also when we do <strong>System.out.println(s.name)</strong> it is printing <strong>taleev</strong> only we can not change the name's value that we have defined originally, and the value that we are changing is the object's value not the instance variable value so once we have define instance variable we are unable to change it</p>
     <p>So i think that is how it shows that java deals with <strong>values</strong> only not with the <strong>references</strong></p>
     <p>The memory allocation for the primitive variables can be understood by <a href="http://www.informit.com/articles/article.aspx?p=31755&amp;seqNum=8" rel="nofollow noreferrer">this</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_77"><span>Answer 77</span> <span class="arrow"> <a href="#answer_76">↑</a> </span> <span class="arrow"> <a href="#answer_78">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>grindlewald</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Aug 2019 at 19:47</span>
     </div>
    </div>
    <div>
     <p>First let's understand Memory allocation in Java: Stack and Heap are part of Memory that JVM allocates for different purposes. The stack memory is pre-allocated to thread, when it is created, therefore, a thread cannot access the Stack of other thread. But Heap is available to all threads in a program.</p>
     <p>For a thread, Stack stores all local data, metadata of program, primitive type data and object reference. And, Heap is responsible for storage of actual object.</p>
     <pre><code>Book book = new Book("Effective Java");
</code></pre>
     <p>In the above example, the reference variable is "book" which is stored in stack. The instance created by new operator -&gt; new Book("Effective Java") is stored in Heap. The ref variable "book" has address of the object allocated in Heap. Let's say the address is 1001.</p>
     <p><a href="https://i.stack.imgur.com/uw7tE.png" rel="noreferrer"><img src="uw7tE.png" alt="enter image description here"></a></p>
     <p>Consider passing a primitive data type i.e. int, float, double etc.</p>
     <pre><code>public class PrimitiveTypeExample { 
    public static void main(string[] args) {
       int num = 10;
       System.out.println("Value before calling method: " + num);
       printNum(num);
       System.out.println("Value after calling method: " + num);
    }
    public static void printNum(int num){
       num = num + 10;
       System.out.println("Value inside printNum method: " + num);
    }
}
</code></pre>
     <p>Output is: Value before calling method: 10 Value inside printNum method: 20 Value after calling method: 10</p>
     <p>int num =10; -&gt; this allocates the memory for "int" in Stack of the running thread, because, it is a primitive type. Now when printNum(..) is called, a private stack is created within the same thread. When "num" is passed to this method, a copy of "num" is created in the method stack frame. num = num+10; -&gt; this adds 10 and modifies the the int variable within the method stack frame. Therefore, the original num outside the method stack frame remains unchanged.</p>
     <p>Consider, the example of passing the object of a custom class as an argument.</p>
     <p><a href="https://i.stack.imgur.com/J1XRW.png" rel="noreferrer"><img src="J1XRW.png" alt="enter image description here"></a></p>
     <p>In the above example, ref variable "book" resides in stack of thread executing the program, and the object of class Book is created in Heap space when program executes new Book(). This memory location in Heap is referred by "book". When "book" is passed as method argument, a copy of "book" is created in private stack frame of method within the same stack of thread. Therefore, the copied reference variable points to the same object of class "Book" in the Heap.</p>
     <p><a href="https://i.stack.imgur.com/ggqd5.png" rel="noreferrer"><img src="ggqd5.png" alt="enter image description here"></a></p>
     <p>The reference variable within method stack frame sets a new value to same object. Therefore, it is reflected when original ref variable "book" gets its value. Note that in case of passing reference variable, if it is initialized again in called method, it then points to new memory location and any operation does not affect the previous object in the Heap.</p>
     <p>Therefore, when anything is passed as method argument, it is always the Stack entity - either primitive or reference variable. We never pass something that is stored in Heap. Hence, in Java, we always pass the value in the stack, and it is pass by value.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_78"><span>Answer 78</span> <span class="arrow"> <a href="#answer_77">↑</a> </span> <span class="arrow"> <a href="#answer_79">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Alexandr</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Oct 2020 at 02:27</span>
     </div>
    </div>
    <div>
     <p>I'd say it in another way:</p>
     <p>In java references are passed (but not objects) and these references are passed-by-value (the reference itself is copied and you have 2 references as a result and you have no control under the 1st reference in the method).</p>
     <p>Just saying: pass-by-value might be not clear enough for beginners. For instance in Python the same situation but there are articles, which describe that they call it <code>pass-by-reference</code>, only cause references are used.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_79"><span>Answer 79</span> <span class="arrow"> <a href="#answer_78">↑</a> </span> <span class="arrow"> <a href="#answer_80">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>frostcs</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Apr 2021 at 06:17</span>
     </div>
    </div>
    <div>
     <p><strong>For simplicity and verbosity</strong> Its <code>pass reference by value</code>:</p>
     <pre><code>public static void main(String[] args) {
    Dog aDog = new Dog("Max");
    Dog oldDog = aDog;

    // we pass the object to foo
    foo(aDog);
    // aDog variable is still pointing to the "Max" dog when foo(...) returns
    aDog.getName().equals("Max"); // true
    aDog.getName().equals("Fifi"); // false
    aDog == oldDog; // true
}

public static void foo(Dog d) {
    d.getName().equals("Max"); // true
    // change d inside of foo() to point to a new Dog instance "Fifi"
    d = new Dog("Fifi");
    d.getName().equals("Fifi"); // true
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Sure, the confusion comes from the fact, that outside the Java community there is other semantics and verbose "Java is not God"</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">6 Dec 2021 at 18:59</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_80"><span>Answer 80</span> <span class="arrow"> <a href="#answer_79">↑</a> </span> <span class="arrow"> <a href="#answer_81">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>charles</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Mar 2021 at 02:24</span>
     </div>
    </div>
    <div>
     <p>Here a more precise definition:</p>
     <ul>
      <li><strong>Pass/call by value:</strong> Formal parameter is like a local variable in scope of function, it evaluates to actual parameter at the moment of function call.</li>
      <li><strong>Pass/call by reference:</strong> Formal parameter is just a alias for the real value, any change of it in the scope of function can have side effects outside in any other part of code.</li>
     </ul>
     <p>So in C/C++ you can create a function that swaps two values passed using the references:</p>
     <pre><code>void swap(int&amp; a, int&amp; b) 
{
    int tmp = a; 
    a = b; 
    b = tmp; 
}
</code></pre>
     <p>You can see it has a unique reference to a and b, so we do not have a copy, tmp just hold unique references.</p>
     <p>The same function in java does not have side effects, the parameter passing is just like the code above without references.</p>
     <p>Although java work with pointers/references, the parameters are not unique pointers, in each attribution, they are copied instead just assigned like C/C++</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_81"><span>Answer 81</span> <span class="arrow"> <a href="#answer_80">↑</a> </span> <span class="arrow"> <a href="#answer_82">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Amit Sharma</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Jul 2019 at 05:10</span>
     </div>
    </div>
    <div>
     <p><strong>Java passes parameters by value, There is no option of passing a reference in Java.</strong></p>
     <p>But at the complier binding level layer, It uses reference internally not exposed to the user.</p>
     <p>It is essential as it saves a lot of memory and improves speed.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>Every time you pas an object, it is passed by reference, cause that is what you find on the stack: a Reference</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">6 Dec 2021 at 19:01</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_82"><span>Answer 82</span> <span class="arrow"> <a href="#answer_81">↑</a> </span> <span class="arrow"> <a href="#answer_83">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>natwar kumar</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Jul 2019 at 03:56</span>
     </div>
    </div>
    <div>
     <pre><code>public class Test {

    static class Dog {
        String name;

        @Override
        public int hashCode() {
            final int prime = 31;
            int result = 1;
            result = prime * result + ((name == null) ? 0 : name.hashCode());
            return result;
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj)
                return true;
            if (obj == null)
                return false;
            if (getClass() != obj.getClass())
                return false;
            Dog other = (Dog) obj;
            if (name == null) {
                if (other.name != null)
                    return false;
            } else if (!name.equals(other.name))
                return false;
            return true;
        }

        public String getName() {
            return name;
        }

        public void setName(String nb) {
            this.name = nb;
        }

        Dog(String sd) {
            this.name = sd;
        }
    }
    /**
     * 
     * @param args
     */
    public static void main(String[] args) {
        Dog aDog = new Dog("Max");

        // we pass the object to foo
        foo(aDog);
        Dog oldDog = aDog;

        System.out.println(" 1: " + aDog.getName().equals("Max")); // false
        System.out.println(" 2 " + aDog.getName().equals("huahua")); // false
        System.out.println(" 3 " + aDog.getName().equals("moron")); // true
        System.out.println(" 4 " + " " + (aDog == oldDog)); // true

        // part2
        Dog aDog1 = new Dog("Max");

        foo(aDog1, 5);
        Dog oldDog1 = aDog;

        System.out.println(" 5 : " + aDog1.getName().equals("huahua")); // true
        System.out.println(" part2 : " + (aDog1 == oldDog1)); // false

        Dog oldDog2 = foo(aDog1, 5, 6);
        System.out.println(" 6 " + (aDog1 == oldDog2)); // true
        System.out.println(" 7 " + (aDog1 == oldDog)); // false
        System.out.println(" 8 " + (aDog == oldDog2)); // false
    }

    /**
     * 
     * @param d
     */
    public static void foo(Dog d) {
        System.out.println(d.getName().equals("Max")); // true

        d.setName("moron");

        d = new Dog("huahua");
        System.out.println(" -:-  " + d.getName().equals("huahua")); // true
    }

    /**
     * 
     * @param d
     * @param a
     */
    public static void foo(Dog d, int a) {
        d.getName().equals("Max"); // true

        d.setName("huahua");
    }

    /**
     * 
     * @param d
     * @param a
     * @param b
     * @return
     */
    public static Dog foo(Dog d, int a, int b) {
        d.getName().equals("Max"); // true
        d.setName("huahua");
        return d;
    }
}
</code></pre>
     <p>The sample code to demonstrate the impact of changes to the object at different functions .</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_83"><span>Answer 83</span> <span class="arrow"> <a href="#answer_82">↑</a> </span> <span class="arrow"> <a href="#answer_84">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Rose</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Sep 2019 at 08:09</span>
     </div>
    </div>
    <div>
     <p>I think this simple explanation might help you understand as I wanted to understand this same thing when I was struggling through this.</p>
     <p>When you pass a primitive data to a function call it's content is being copied to the function's argument and when you pass an object it's reference is being copied to the function's argument. Speaking of object, you can't change the copied reference-<em>the argument variable is referencing to</em> in the calling function.</p>
     <p>Consider this simple example, String is an object in java and when you change the content of a string the reference variable will now point to some new reference as String objects are immutable in java.</p>
     <pre class="lang-java prettyprint-override"><code>String name="Mehrose";  // name referencing to 100

ChangeContenet(String name){
 name="Michael"; // refernce has changed to 1001

} 
System.out.print(name);  //displays Mehrose
</code></pre>
     <p>Fairly simple because as I mentioned you are not allowed to change the copied reference in the calling function. But the problem is with the array when you pass an array of String/Object. Let us see.</p>
     <pre class="lang-java prettyprint-override"><code>String names[]={"Mehrose","Michael"};

changeContent(String[] names){
  names[0]="Rose";
  names[1]="Janet"

}

System.out.println(Arrays.toString(names)); //displays [Rose,Janet]
</code></pre>
     <p>As we said that we can't change the copied reference in the function call and we also have seen in the case of a single String object. The reason is names[] variable referencing to let's say 200 and names[0] referencing to 205 and so on. You see we didn't change the names[] reference it still points to the old same reference still after the function call but now names[0] and names[1] reference has been changed. We Still stand on our definition that we can't change the reference variable's reference so we didn't.</p>
     <p>The same thing happens when you pass a Student object to a method and you are still able to change the Student name or other attributes, the point is we are not changing the actual Student object rather we are changing the contents of it</p>
     <p>You can't do this</p>
     <pre class="lang-java prettyprint-override"><code>Student student1= new Student("Mehrose");

changeContent(Student Obj){
 obj= new Student("Michael") //invalid
 obj.setName("Michael")  //valid

}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_84"><span>Answer 84</span> <span class="arrow"> <a href="#answer_83">↑</a> </span> <span class="arrow"> <a href="#answer_85">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Wellington Costa</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Aug 2021 at 15:29</span>
     </div>
    </div>
    <div>
     <p>Java uses pass-by-value, but the effects differ whether you are using primitive or a reference type.</p>
     <p>When you pass a primitive type as an argument to a method, it's getting a copy of the primitive and any changes inside the block of the method won't change the original variable.</p>
     <p>When you pass a reference type as an argument to a method, it's still getting a copy but it's a copy of the reference to the object <strong>(in other words, you are getting a copy of the memory address in the heap where the object is located)</strong>, so any changes in the object inside the block of the method will affect the original object outside the block.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_85"><span>Answer 85</span> <span class="arrow"> <a href="#answer_84">↑</a> </span> <span class="arrow"> <a href="#answer_86">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Bhushan</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Nov 2013 at 05:43</span>
     </div>
    </div>
    <div>
     <p>The Java programming language passes arguments only by value, that is, you cannot change the argument value in the calling method from within the called method.</p>
     <hr>
     <p>However, when an object instance is passed as an argument to a method, the value of the argument is not the object itself but a reference to the object. You can change the contents of the object in the called method but not the object reference.</p>
     <hr>
     <p>To many people, this looks like pass-by-reference, and behaviorally, it has much in common with pass-by-reference. However, there are two reasons this is inaccurate.</p>
     <ul>
      <li>
       <p>Firstly, the ability to change the thing passed into a method only applies to objects, not primitive values.</p></li>
      <li>
       <p>Second, the actual value associated with a variable of object type is the reference to the object, and not the object itself. This is an important distinction in other ways, and if clearly understood, is entirely supporting of the point that the Java programming language passes arguments by value.</p></li>
     </ul>
     <hr>
     <pre><code>The following code example illustrates this point:
1 public class PassTest {
2
3   // Methods to change the current values
4   public static void changeInt(int value) {
5     value = 55;
6  }
7   public static void changeObjectRef(MyDate ref) {
8     ref = new MyDate(1, 1, 2000);
9  }
10   public static void changeObjectAttr(MyDate ref) {
11     ref.setDay(4);
12   }
13
14 public static void main(String args[]) {
15     MyDate date;
16     int val;
17
18     // Assign the int
19     val = 11;
20     // Try to change it
21     changeInt(val);
22     // What is the current value?
23     System.out.println("Int value is: " + val);
24
25 // Assign the date
26     date = new MyDate(22, 7, 1964);
27     // Try to change it
28     changeObjectRef(date);
29     // What is the current value?
30 System.out.println("MyDate: " + date);
31
32 // Now change the day attribute
33     // through the object reference
34     changeObjectAttr(date);
35     // What is the current value?
36 System.out.println("MyDate: " + date);
37   }
38 }
</code></pre>
     <hr>
     <pre><code>This code outputs the following:
java PassTest
Int value is: 11
MyDate: 22-7-1964
MyDate: 4-7-1964
The MyDate object is not changed by the changeObjectRef method;
however, the changeObjectAttr method changes the day attribute of the
MyDate object.
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>This is very misleading. You certainly <i>can</i> change the value of an argument from within a method.</span> <span> - </span> <span class="display-name">Gray</span> <span> </span> <span class="date">28 Nov 2017 at 20:33</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_86"><span>Answer 86</span> <span class="arrow"> <a href="#answer_85">↑</a> </span> <span class="arrow"> <a href="#answer_87">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Alex de Kruijff</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Mar 2021 at 05:24</span>
     </div>
    </div>
    <div>
     <p>There are only two versions:</p>
     <ul>
      <li>You can pass the value i.e. (4,5)</li>
      <li>You can pass an address i.e. 0xF43A</li>
     </ul>
     <p>Java passes primivates as values and objects as addresses. Those who say, "address are values too", do not make a distinction between the two. Those who focus on the effect of the swap functions focus on what happens after the passing is done.</p>
     <p>In C++ you can do the following:</p>
     <pre><code>Point p = Point(4,5);
</code></pre>
     <p>This reserves 8 bytes on the stack and stores (4,5) in it.</p>
     <pre><code>Point *x = &amp;p;
</code></pre>
     <p>This reserves 4 bytes on the stack and stores 0xF43A in it.</p>
     <pre><code>Point &amp;y = p;
</code></pre>
     <p>This reserves 4 bytes on the stack and stores 0xF43A in it.</p>
     <ol>
      <li>
       <p>I think everyone will agree that a call to f(p) is a pass-by-value if the definition of f is f(Point p). In this case an additional 8 bytes being reserved and (4,5) being copied into it. When f changes p the the the original is guarantieed to be unchanged when f returns.</p></li>
      <li>
       <p>I think that everyone will agree that a call to f(p) is a pass-by-reference if the definition of f is f(Point &amp;p). In this case an additional 4 bytes being reserved and 0xF43A being copied into it. When f changes p the the original is guarantieed to be changed when f returns.</p></li>
      <li>
       <p>A call to f(&amp;p) is also pass-by-reference if the definition of f is f(Point *p). In this case an additional 4 bytes being reserved and 0xF43A being copied into it. When f changes *p the the original is guarantieed to be changed when f returns.</p></li>
      <li>
       <p>A call to f(x) is also pass-by-reference if the definition of f is f(Point *p). In this case an additional 4 bytes being reserved and 0xF43A being copied into it. When f changes *p the the original is guarantieed to be changed when f returns.</p></li>
      <li>
       <p>A call to f(y) is also pass-by-reference if the definition of f is f(Point &amp;p). In this case an additional 4 bytes being reserved and 0xF43A being copied into it. When f changes p the the original is guarantieed to be changed when f returns.</p></li>
     </ol>
     <p>Sure what happens after the passing is done differs, but that is only a language construct. In the case of pointer you have to use -&gt; to access the members and in the case of references you have to use .. If you want to swap the values of the original then you can do tmp=a; a=b; b=tmp; in the case of references and tmp=*a; *b=tmp; *a=tmp for pointers. And in Java you would have do: tmp.set(a); a.set(b); b.set(tmp). Focussing on the assignment statement statement is silly. You can do the exact same thing in Java if you write a little bit of code.</p>
     <p>So Java passes primivates by values and objects by references. And Java copy values to achieve that, but so does C++.</p>
     <p>For completeness:</p>
     <pre><code>Point p = new Point(4,5);
</code></pre>
     <p>This reserves 4 bytes on the stack and stores 0xF43A in it and reserves 8 bytes on the heap and stores (4,5) in it.</p>
     <p>If you want to swap the memory locations like so</p>
     <pre><code>void swap(int&amp; a, int&amp; b) {
    int *tmp = &amp;a;
    &amp;a = &amp;b;
    &amp;b = tmp;
}
</code></pre>
     <p>Then you will find that you run into the limitations of your hardware.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>One of the most complete answers is bumped to the bottom. Your #3 describes the situation in Java the best.</span> <span> - </span> <span class="display-name">v010dya</span> <span> </span> <span class="date">21 Apr 2021 at 13:51</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Not relevant for the semantics: Guess, all Java implementations use two levels of indirection, i.e. a reference is a kind of handle, not yet the object address, which may change by garbage collection.</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">10 Dec 2021 at 12:53</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_87"><span>Answer 87</span> <span class="arrow"> <a href="#answer_86">↑</a> </span> <span class="arrow"> <a href="#answer_88">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Sam Ginrich</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Sep 2021 at 12:57</span>
     </div>
    </div>
    <div>
     <p><strong>Guess, the common canon is wrong based on inaccurate language</strong></p>
     <p>Authors of a programming language do not have the authority to rename established programming concept.</p>
     <p>Primitive Java types <code>byte, char, short, int, long float, double</code> are definitely passed by value.</p>
     <p>All other types are <code>Objects</code>: Object members and parameters technically <strong>are references</strong>.</p>
     <p>So these "references" are passed "by value", but there occurs no object construction on the stack. Any change of object members (or elements in case of an array) apply to the same original Object; such reference precisely meets the logic of pointer of an instance passed to some function in any C-dialect, where we used to call this <strong>passing an object by reference</strong></p>
     <p>Especially we do have this thing <strong>java.lang.NullPointerException</strong>, which makes no sense in a pure by-value-concept</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>It's still pass-by-value even if the value itself is a reference. The argument is copied and reassigning it doesn't affect anything outside the called function - this is the key difference between pass-by-value/reference.</span> <span> - </span> <span class="display-name">Michael</span> <span> </span> <span class="date">21 Sep 2021 at 04:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>We agree, that references and objects are two pairs of shoes</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">25 Sep 2021 at 11:08</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>This seems like the correct answer to me. Why are people so caught up on the technicalities of pass-by-object-reference versus pass-by-reference? If you pass a non-primitive variable to a function, modifications to that variable within the function affect the variable outside of the function. That is pretty much the same behavior as pass-by-reference. "It's still pass-by-value even if the value itself is a reference" - umm, okay, but if the value is a reference then you are passing a reference. Terminology aside, passing objects as arguments can affect the object outside of the function.</span> <span> - </span> <span class="display-name">h0r53</span> <span> </span> <span class="date">19 Oct 2021 at 16:09</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@h0r53 Why are people so caught up? Consistent definitions are import for effective communication. What C does, IS ALSO PASS BY VALUE. It's just the java calls its pointers "References". And that's where the confusion comes from. It's a different use of the word reference than in "pass-by-reference". Under the hood a "reference" in java is just a pointer, meaning it's a primitive which holds an address to the object in memory. Yes, you change the object in memory, but not the reference itself. So if you assign a different object or set it to null, the reference outside the function wont change</span> <span> - </span> <span class="display-name">Sanjeev</span> <span> </span> <span class="date">19 Feb 2022 at 17:08</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@h0r53, I can see from your posts (which are great, btw) that you know C and C++. C does not offer Pass by Reference, but C++ actually does by way of allowing "reference parameters". When you declare a function with a header like , void foo(TreeClass&amp; maple), the ampersand makes this a reference parameter (can't do that in C). Now, if you set maple to null inside the function, the change will also be reflected outside the method. Please see my post for details <a href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value/54373107#54373107" title="is java pass by reference or pass by value">stackoverflow.com/questions/40480/…</a></span> <span> - </span> <span class="display-name">Sanjeev</span> <span> </span> <span class="date">19 Feb 2022 at 17:24</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Sanjeev For that matter, in C++ we have equivalence of parameters of type T&amp; and T const* for some type variable T, which differs in the syntactic dereferentiation level, not in the use cases or requirements for associated objects in calling or called context. Also there is no need to twist these and everyone is able to understand this, if he is willing.</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">19 Feb 2022 at 18:02</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Sanjeev I see your point and the subtle differences in reference v. object-reference are more clear to me. I was admittedly a bit frustrated when writing the prior response because it seemed like the issue was being unnecessarily convoluted with terminology. I just wanted a quick answer - "If I pass an object to a function, and change that object within the function, is it reflected in the caller?" My background causes me to think of everything in terms of pointers, so when I think of pass-by-reference or pass-by-object-reference, I think of pass-by-pointer, which isn't technically correct.</span> <span> - </span> <span class="display-name">h0r53</span> <span> </span> <span class="date">22 Feb 2022 at 16:13</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>"Consistent definitions are import for effective communication." Indeed, Java wanted to be an object-oriented language, until it came to ´passing objects´, then it died from inconsistency. Suddenly references were values and objects did not exists, at all. Living with a lie and forcing everyone not to reference Niklaus Wirth, who got the terms straight.</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">22 Mar 2022 at 15:43</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_88"><span>Answer 88</span> <span class="arrow"> <a href="#answer_87">↑</a> </span> <span class="arrow"> <a href="#answer_89">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>ömer.bozkurt</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Mar 2021 at 13:22</span>
     </div>
    </div>
    <div>
     <p>If you want it to put into a single sentence to understand and remember easily, simplest answer:</p>
     <p>Java is always <strong>pass the value with a new reference</strong></p>
     <p>(So you can modify the original object but can not access the original reference)</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>The object can be modified because it is passed by it's reference ;)</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">6 Dec 2021 at 19:08</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_89"><span>Answer 89</span> <span class="arrow"> <a href="#answer_88">↑</a> </span> <span class="arrow"> <a href="#answer_90">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>v010dya</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Apr 2021 at 15:32</span>
     </div>
    </div>
    <div>
     <p>Every single answer here is tying to take pass pointer by reference from other languages and show how it is impossible to do in Java. For whatever reason nobody is attempting to show how to implement pass-object-by-value from other languages.</p>
     <p>This code shows how something like this can be done:</p>
     <pre><code>public class Test
{
    private static void needValue(SomeObject so) throws CloneNotSupportedException
    {
        SomeObject internalObject = so.clone();
        so=null;
        
        // now we can edit internalObject safely.
        internalObject.set(999);
    }
    public static void main(String[] args)
    {
        SomeObject o = new SomeObject(5);
        System.out.println(o);
        try
        {
            needValue(o);
        }
        catch(CloneNotSupportedException e)
        {
            System.out.println("Apparently we cannot clone this");
        }
        System.out.println(o);
    }
}

public class SomeObject implements Cloneable
{
    private int val;
    public SomeObject(int val)
    {
        this.val = val;
    }
    public void set(int val)
    {
        this.val = val;
    }
    public SomeObject clone()
    {
        return new SomeObject(val);
    }
    public String toString()
    {
        return Integer.toString(val);
    }
}
</code></pre>
     <p>Here we have a function <code>needValue</code> and what it does is right away create a clone of the object, which needs be implemented in the class of the object itself and the class needs to be marked as <code>Cloneable</code>. It is not essential to set <code>so</code> to <code>null</code> after that, but i have done so here to show that we are not going to be using that reference after that.</p>
     <p>It may well be that Java does not have pass-by-reference semantics, but to call the language "pass-by-value" is along the lines of wishful thinking.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span>Note: The <i>safely</i> in "now we can edit internalObject safely" depends on the implementation of the <code>clone()</code> method (i.e. "deep" or "shallow") and how far down the object tree your edits have an impact. For this simple example it is correct though.</span> <span> - </span> <span class="display-name">siegi</span> <span> </span> <span class="date">24 Apr 2021 at 04:59</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Guess, you are the first human being, who ever managed to "pass an object by value" in Java, tend to call you the "Neil Armstrong of Java", henceforth ;)</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">5 Jan 2022 at 08:53</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_90"><span>Answer 90</span> <span class="arrow"> <a href="#answer_89">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>FreelanceConsultant</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Mar 2023 at 10:11</span>
     </div>
    </div>
    <div>
     <p>There are already many answers to this question, and many of them are misleading.</p>
     <p><strong>There are two simple statements which explain how Java behaves in all cases:</strong></p>
     <ol>
      <li>Java is a pass by value language</li>
      <li>Fundamental types are direct values, Java Objects are indirect values</li>
     </ol>
     <p>What does this mean?</p>
     <ul>
      <li>If you have a fundamental type like an <code>int</code>, you literally are holding a value. A variable when initialized to an int value "contains" that value directly. If you pass it to a function, a copy of the value is made in the variable which holds the argument to the function. This variable is called a "parameter". <em>Hence Java is a pass-by-Value language</em>.</li>
      <li>A variable initialized to be a Java Object (recall everything else in the language inherits from <code>Object</code>) holds an indirect reference to a structure of data containing the Objects data. The variable is a <em>label</em>, rather than holding the value directly, it contains a label which is used to reference or lookup an objects data.</li>
     </ul>
     <p>Note I am not describing implementation details above. The implementation details could be anything. I am simply describing the <em>behaviour</em> of the language.</p>
     <hr>
     <p>Some further explanation as to why I think other answers are confusing or misleading.</p>
     <ul>
      <li>Some answers mention the word "pointers". This means the answer is fundamentally wrong because Java was <strong>deliberatly designed to not have pointer semantics</strong>. <em>There are no pointers in Java, they fundamentally do not exist, hence there is no concept of them.</em></li>
     </ul>
     <p>Therefore to even mention pointers is wrong. The implementation details of the JVM might use data which is akin to virtual memory addresses, <strong>but this is totally hidden from the user of the Java language</strong>. That is the point of programming languages, to abstract the programmer away from hardware details. With languages like C and C++, pointers are a key focus of the language because it was designed for systems engineering where detailed control over memory is required.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Parts of this answer that are correct don't add anything new that other answers haven't covered yet, so at best it is just a redundant answer. However, criticism of answers using word pointer is completely wrong as top voted answers that use that phrase clearly explain context in which phrase is used and what it means. Basic definition of pointer is value that points (is a reference, address) to other memory location that holds actual data. In other words, Number of indirections, nor what that value actually represents in JVM implementation is not relevant for this particular question.</span> <span> - </span> <span class="display-name">Dalija Prasnikar</span> <span> </span> <span class="date">16 Mar 2023 at 11:07</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@DalijaPrasnikar That is totally incorrect. There is no such thing as a pointer in Java. That's the whole point of why Java was developed. (In addition to GC.)</span> <span> - </span> <span class="display-name">FreelanceConsultant</span> <span> </span> <span class="date">16 Mar 2023 at 18:07</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>There is no such thing as pointer in language definition. But when you are explaining implementation details then you can use pointer as a term that explains what object variable is - a pointer or reference in sense that it does not hold the content of the object directly but indirectly. In this case using term pointer is warranted as term "reference" is used in two different contexts in this question pass-by-reference and reference type and you need some other terminology to clear the confusion. And at least one of the top answers uses the term pointer rather clearly.</span> <span> - </span> <span class="display-name">Dalija Prasnikar</span> <span> </span> <span class="date">16 Mar 2023 at 20:21</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@DalijaPrasnikar No, the correct term is reference, not pointer, because you have a reference, not a pointer. It is not even correct to say "pointer" when talking about implementation details, here's why: Unless you are an Oracle developer, or work on one of the other Java compilers, who are you to say what the implementation is? You are speculating that a pointer might be used in the implementation, at best.</span> <span> - </span> <span class="display-name">FreelanceConsultant</span> <span> </span> <span class="date">17 Mar 2023 at 09:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The point about software languages is that they define a specification for abstraction. They do not (generally) specify implementation details, because this will vary depending on hardware, and potentially also Operating Systems (if there is one, some environments do not have an OS such as embedded systems).</span> <span> - </span> <span class="display-name">FreelanceConsultant</span> <span> </span> <span class="date">17 Mar 2023 at 09:05</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>In this particular context term reference is source of confusion because term reference is used in two different contexts with very different meaning. Term pointer has broader meaning and references are just special kind of pointers and using the term pointer to explain how passing of reference types (including objects) in Java works is perfectly fine. Java does not have raw pointer types, but nobody claims is has. You cannot explain what is reference by using a word "reference".</span> <span> - </span> <span class="display-name">Dalija Prasnikar</span> <span> </span> <span class="date">17 Mar 2023 at 10:21</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>If you want to criticize particular answer, then post a comment under that answer.</span> <span> - </span> <span class="display-name">Dalija Prasnikar</span> <span> </span> <span class="date">17 Mar 2023 at 10:25</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@DalijaPrasnikar Your comment doesn't make any sense. Pointer does not have broader meaning than reference. A pointer is a literal memory address. A reference is a broader concept than a pointer, if anything. Sorry but your comment is not just wrong, it doesn't make any sense and strongly suggests you have little understanding of the matter.</span> <span> - </span> <span class="display-name">FreelanceConsultant</span> <span> </span> <span class="date">17 Mar 2023 at 20:18</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>