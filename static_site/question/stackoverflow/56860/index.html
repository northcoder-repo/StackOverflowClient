<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>What is an example of the Liskov Substitution Principle?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>What is an example of the Liskov Substitution Principle?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>1208</span>
    </div>
    <div>
     <span>Asker: </span> <span>NotMyself</span>
    </div>
    <div>
     <span>Asked: </span> <span>11 Sep 2008 at 15:17</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/56860/what-is-an-example-of-the-liskov-substitution-principle">source</a>
    </div>
   </div>
   <div>
    <p>I have heard that the Liskov Substitution Principle (LSP) is a fundamental principle of object oriented design. What is it and what are some examples of its use?</p>
   </div>
   <div class="tags">
    <span class="tag">oop</span><span class="tag">definition</span><span class="tag">solid-principles</span><span class="tag">design-principles</span><span class="tag">liskov-substitution-principle</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td></td>
       <td><span>More examples of LSP adherence and violation <a href="http://stackoverflow.com/questions/20861107/liskov-substitution-principle-vehicle-example">here</a></span> <span> - </span> <span class="display-name">StuartLC</span> <span> </span> <span class="date">15 May 2015 at 13:20</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>This is one of the best examples I have found: <a href="https://www.baeldung.com/java-liskov-substitution-principle" rel="nofollow noreferrer">baeldung.com/java-liskov-substitution-principle</a></span> <span> - </span> <span class="display-name">01000001</span> <span> </span> <span class="date">19 Mar 2022 at 23:39</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>The Liskov Substitution Principle states that subclasses should be <b>blindly</b> substitutable for their base classes.</span> <span> - </span> <span class="display-name">Ziaullhaq Savanur</span> <span> </span> <span class="date">10 Jun 2022 at 11:40</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>The Liskov Substitution Principle states that subclasses should be <b>blindly</b> substitutable for their base classes.</span> <span> - </span> <span class="display-name">Ziaullhaq Savanur</span> <span> </span> <span class="date">10 Jun 2022 at 11:44</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>The Liskov Substitution Principle states that subclasses should be <b>blindly</b> substitutable for their base classes.</span> <span> - </span> <span class="display-name">Ziaullhaq Savanur</span> <span> </span> <span class="date">10 Jun 2022 at 11:45</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1203</span>
     </div>
     <div>
      <span>Answerer: </span> <span>m-sharp</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Feb 2009 at 04:44</span>
     </div>
    </div>
    <div>
     <p>A great example illustrating LSP (given by Uncle Bob in a podcast I heard recently) was how sometimes something that sounds right in natural language doesn't quite work in code.</p>
     <p>In mathematics, a <code>Square</code> is a <code>Rectangle</code>. Indeed it is a specialization of a rectangle. The "is a" makes you want to model this with inheritance. However if in code you made <code>Square</code> derive from <code>Rectangle</code>, then a <code>Square</code> should be usable anywhere you expect a <code>Rectangle</code>. This makes for some strange behavior.</p>
     <p>Imagine you had <code>SetWidth</code> and <code>SetHeight</code> methods on your <code>Rectangle</code> base class; this seems perfectly logical. However if your <code>Rectangle</code> reference pointed to a <code>Square</code>, then <code>SetWidth</code> and <code>SetHeight</code> doesn't make sense because setting one would change the other to match it. In this case <code>Square</code> fails the Liskov Substitution Test with <code>Rectangle</code> and the abstraction of having <code>Square</code> inherit from <code>Rectangle</code> is a bad one.</p>
     <p><a href="https://i.stack.imgur.com/ilxzO.jpg" rel="noreferrer"><img src="https://i.stack.imgur.com/ilxzO.jpg" alt="enter image description here"></a></p>
     <p>Y'all should check out the other priceless <a href="https://www.globalnerdy.com/2009/07/15/the-solid-principles-explained-with-motivational-posters/" rel="noreferrer">SOLID Principles Explained With Motivational Posters</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>30</td>
        <td><span>@m-sharp What if it's an immutable Rectangle such that instead of SetWidth and SetHeight, we have the methods GetWidth and GetHeight instead?</span> <span> - </span> <span class="display-name">Pacerier</span> <span> </span> <span class="date">26 Apr 2012 at 19:28</span></td>
       </tr>
       <tr>
        <td>192</td>
        <td><span>Moral of the story: model your classes based on behaviours not on properties; model your data based on properties and not on behaviours. If it behaves like a duck, it's certainly a bird.</span> <span> - </span> <span class="display-name">Sklivvz</span> <span> </span> <span class="date">19 May 2012 at 21:43</span></td>
       </tr>
       <tr>
        <td>275</td>
        <td><span>Well, a square clearly IS a type of rectangle in the real world. Whether we can model this in our code depends on the spec. What the LSP indicates is that subtype behavior should match base type behavior as defined in the base type specification. If the rectangle base type spec says that height and width can be set independently, then LSP says that square cannot be a subtype of rectangle. If the rectangle spec says that a rectangle is immutable, then a square can be a subtype of rectangle. It's all about subtypes maintaining the behavior specified for the base type.</span> <span> - </span> <span class="display-name">SteveT</span> <span> </span> <span class="date">24 Sep 2012 at 15:46</span></td>
       </tr>
       <tr>
        <td>88</td>
        <td><span>@Pacerier there is no issue if it's immutable. The real issue here is that we are not modeling rectangles, but rather "reshapable rectangles," i.e., rectangles whose width or height can be modified after creation (and we still consider it to be the same object). If we look at the rectangle class in this way, it is clear that a square is not a "reshapable rectangle", because a square cannot be reshaped and still be a square (in general). Mathematically, we don't see the problem because mutability doesn't even make sense in a mathematical context.</span> <span> - </span> <span class="display-name">asmeurer</span> <span> </span> <span class="date">20 Jan 2013 at 06:13</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>From <a href="http://youtu.be/dtZ-o96bH9A?t=40m" rel="nofollow noreferrer">Prof Barbara Liskov's lecture</a>: "Objects of subtypes should behave like those of supertypes if used via supertype methods."</span> <span> - </span> <span class="display-name">ruhong</span> <span> </span> <span class="date">4 Feb 2015 at 06:09</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>If width and height can be altered by setters, there should be just a rectangle class and no special square class. Instead, the rectangle class should have a getter that is named IsSquare. Whenever width and height have the same values, IsSquare will return true, otherwise false. Types are not always static, but sometimes - like in this case - can change.</span> <span> - </span> <span class="display-name">brighty</span> <span> </span> <span class="date">10 Feb 2015 at 10:53</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>so why i even need subtyping if my inherited class's behaviour doesn't differ from parent (excluding cases, when it does the same but different way)? why one need all those override methods if they have to behave absolutely similarly to base's? speaking of geometry figures: IDrawable has Draw(). how could you insist Circle:IDrawable's Draw() give the same result as Square:IDrawable's? or, say, Rotated90DegreesSquare:Square draw the same as square?</span> <span> - </span> <span class="display-name">jungle_mole</span> <span> </span> <span class="date">11 Sep 2015 at 05:03</span></td>
       </tr>
       <tr>
        <td>27</td>
        <td><span>I have one question about the principle. Why would be the problem if <code>Square.setWidth(int width)</code> was implemented like this: <code>this.width = width; this.height = width;</code>? In this case it is guaranteed that the width equals the height.</span> <span> - </span> <span class="display-name">MC Emperor</span> <span> </span> <span class="date">28 Oct 2015 at 00:45</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span>That Motivational Poster makes no sense. It should be "If it looks like a Duck, Quacks Like a Duck, But Needs Batteries ... why are you interested in the Batteries, again?" Because in the end it implies that the only substitution for a duck is another duck (best the exact same one). Such radicalism is self-defeating.</span> <span> - </span> <span class="display-name">David Tonhofer</span> <span> </span> <span class="date">5 Jan 2016 at 15:49</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>The Square-Rectangle Problem is also known as <a href="https://en.wikipedia.org/wiki/Circle-ellipse_problem" rel="nofollow noreferrer">Circle-Ellipse Problem</a>.</span> <span> - </span> <span class="display-name">mbx</span> <span> </span> <span class="date">2 Mar 2016 at 07:42</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>The right or wrong, good or bad, depends on one's perspective - whether it is from code consumer side or from the code author side. LSP, IMO, applies to the consumer side. Put in right perspective, many wrongs look right.</span> <span> - </span> <span class="display-name">Sudhir</span> <span> </span> <span class="date">23 May 2016 at 12:42</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Another solution is to define rectangles as aspect-ratio preserving rather than as having independent widths and heights.</span> <span> - </span> <span class="display-name">Ed L</span> <span> </span> <span class="date">16 Jul 2016 at 01:23</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span>Seems to not answer the question. After reading it, I still don't know what LSP is (unless the poster contains the definition, though given the context of such posters, this is not clear).</span> <span> - </span> <span class="display-name">iheanyi</span> <span> </span> <span class="date">12 Aug 2016 at 17:58</span></td>
       </tr>
       <tr>
        <td>10</td>
        <td><span>I also don't get the square example. How does setWidth and setHeight not "make sense" on a square. As you very easily explained, doing one implies the other - that's just the definition of a square. It doesn't explain why there is something wrong or inconsistent with substituting a square for a rectangle.</span> <span> - </span> <span class="display-name">iheanyi</span> <span> </span> <span class="date">12 Aug 2016 at 18:03</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>Couldn't you simply override setWidth or setHeight, and in the definition call the other method with the same parameter and poof, it all works and behaviour is consistent?</span> <span> - </span> <span class="display-name">Ungeheuer</span> <span> </span> <span class="date">22 Nov 2016 at 05:48</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>@MCEmperor if you change the implementation of <code>setHeight()</code> and <code>setWidth()</code> in the <code>Square</code>, so the places in your code where you use a <code>Rectangule</code> would not work anymore if you pass a <code>Square</code> and this is the main point about LSP;</span> <span> - </span> <span class="display-name">sdlins</span> <span> </span> <span class="date">26 Dec 2016 at 03:12</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Thank you for your answer - but so what if the LSP is broken?</span> <span> - </span> <span class="display-name">BenKoshy</span> <span> </span> <span class="date">2 Jan 2017 at 13:30</span></td>
       </tr>
       <tr>
        <td>22</td>
        <td><span>However, the picture is NOT a valid example of a broken LSP (smells of Reddit actually, and that is not something we want to smell here on SO). Subclasses will always be more specific than superclasses. However, their specifics do not necessarily break LSP. It is a question of whether these specifics affect (and break) the common contract. Whether a battery-powered duck breaks the common contract of an abstract duck depends on the specific details of the design.</span> <span> - </span> <span class="display-name">AnT stands with Russia</span> <span> </span> <span class="date">28 Jan 2017 at 01:57</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>Everyone uses this square vs rectangle which such a horrible example. You're overriding the Width Property to set the Height Property, Which seems more like side effect. This would all be solved if you made people explicitly set the width and height.</span> <span> - </span> <span class="display-name">johnny 5</span> <span> </span> <span class="date">28 Feb 2017 at 22:41</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>The <code>o.setDimensions(width, height)</code> would solve that problem, but LSP still would be violated, because a square has stronger preconditions (<code>width == height</code>) than a rectangle. I don't think your post answers anything about LSP.</span> <span> - </span> <span class="display-name">inf3rno</span> <span> </span> <span class="date">9 Oct 2017 at 03:48</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>There is a good complementary information about method override / contracts here <a href="https://softwareengineering.stackexchange.com/a/244783/1451">softwareengineering.stackexchange.com/a/244783/1451</a></span> <span> - </span> <span class="display-name">BrunoLM</span> <span> </span> <span class="date">21 Oct 2017 at 10:06</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Is a rectangle a type of square or is a square a type of rectangle or the other way around? A rectangle can be defined as a square with unequal sides and a square can be defined as a rectangle with equal sides. A square with unequal sides is not a square, but a rectangle with equal sides is still a rectangle and a square. So a square is a rectangle with an additional contract. Therefore, the interface for a square should be the same as one for a rectangle. Setting one dimension should set the other makes perfect sense.</span> <span> - </span> <span class="display-name">ATL_DEV</span> <span> </span> <span class="date">15 Dec 2017 at 20:33</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I wouldn't say there's no issue if they're immuatable. It could throw a reader off to see <code>GetHeight</code> and <code>GetWidth</code> if they're going to do the exact same thing. That might by a tiny issue, but still a reason to do it another way.</span> <span> - </span> <span class="display-name">AustinWBryan</span> <span> </span> <span class="date">8 May 2018 at 23:45</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>İs it calls %100 rule in some books?</span> <span> - </span> <span class="display-name">anilkay</span> <span> </span> <span class="date">17 Jun 2018 at 11:25</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@AustinWBryan no, these are well defined quantities. A square has both a height and a width; they happen to be equal. If the reader is thrown off by this then they either learn something new and important about the code or they don't belong there :)</span> <span> - </span> <span class="display-name">Ben Kushigian</span> <span> </span> <span class="date">19 Jun 2018 at 19:18</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>I think that we are confusing sub-type with "particular case". A square has nothing different in behavior compared with a rectangle. The perimeter, area can be calculated using the same formulas. Square is not an improvement or refinement of a rectangle, it's just a particular case. Square shouldn't be a subclass of a rectangle, it shouldn't even be a separate class.</span> <span> - </span> <span class="display-name">Mircea Ion</span> <span> </span> <span class="date">5 Feb 2019 at 03:17</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@MirceaIon, Square could be a subclass of Rectangle to simplify the interface, eg with <code>SetLength</code> which could internally call <code>SetWidth</code> and <code>SetHeight</code></span> <span> - </span> <span class="display-name">alancalvitti</span> <span> </span> <span class="date">29 Mar 2019 at 16:16</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Its OK to derive Square from Rectangle, but you should not have setWidth and setHeight in the case. But no one could prevent you to have setters for a zone there you put the rectangles. In the case, Square will fill only part of the zone, while Rectangle will fill it completely. :)</span> <span> - </span> <span class="display-name">Alex</span> <span> </span> <span class="date">17 Apr 2019 at 16:45</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Can someone please, for the love of code, tell me how else to model this same example then so that it follows LSP?</span> <span> - </span> <span class="display-name">Saurabh Goyal</span> <span> </span> <span class="date">11 Jun 2019 at 15:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Once I have failed an interview on this exact question about squares. The interviewer rejected my immediate question: "What are we going to do with those rectangles and squares?" Today I'm happy I hadn't got that job. :)</span> <span> - </span> <span class="display-name">Aleksei Guzev</span> <span> </span> <span class="date">15 Dec 2019 at 12:38</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>547</span>
     </div>
     <div>
      <span>Answerer: </span> <span>NotMyself</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Sep 2008 at 15:34</span>
     </div>
    </div>
    <div>
     <p>The Liskov Substitution Principle (LSP, <a href="/questions/tagged/lsp" class="post-tag" title="show questions tagged 'lsp'" rel="tag">lsp</a>) is a concept in Object Oriented Programming that states:</p>
     <blockquote>
      <p>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.</p>
     </blockquote>
     <p>At its heart LSP is about interfaces and contracts as well as how to decide when to extend a class vs. use another strategy such as composition to achieve your goal.</p>
     <p>The most effective way I have seen to illustrate this point was in <a href="http://oreilly.com/catalog/9780596008673/index.html" rel="noreferrer">Head First OOA&amp;D</a>. They present a scenario where you are a developer on a project to build a framework for strategy games.</p>
     <p>They present a class that represents a board that looks like this:</p>
     <p><img src="https://oncodebynotmyself.files.wordpress.com/2011/03/board_thumb.png" alt="Class Diagram"></p>
     <p>All of the methods take X and Y coordinates as parameters to locate the tile position in the two-dimensional array of <code>Tiles</code>. This will allow a game developer to manage units in the board during the course of the game.</p>
     <p>The book goes on to change the requirements to say that the game frame work must also support 3D game boards to accommodate games that have flight. So a <code>ThreeDBoard</code> class is introduced that extends <code>Board</code>.</p>
     <p>At first glance this seems like a good decision. <code>Board</code> provides both the <code>Height</code> and <code>Width</code> properties and <code>ThreeDBoard</code> provides the Z axis.</p>
     <p>Where it breaks down is when you look at all the other members inherited from <code>Board</code>. The methods for <code>AddUnit</code>, <code>GetTile</code>, <code>GetUnits</code> and so on, all take both X and Y parameters in the <code>Board</code> class but the <code>ThreeDBoard</code> needs a Z parameter as well.</p>
     <p>So you must implement those methods again with a Z parameter. The Z parameter has no context to the <code>Board</code> class and the inherited methods from the <code>Board</code> class lose their meaning. A unit of code attempting to use the <code>ThreeDBoard</code> class as its base class <code>Board</code> would be very out of luck.</p>
     <p>Maybe we should find another approach. Instead of extending <code>Board</code>, <code>ThreeDBoard</code> should be composed of <code>Board</code> objects. One <code>Board</code> object per unit of the Z axis.</p>
     <p>This allows us to use good object oriented principles like encapsulation and reuse and doesn’t violate LSP.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>13</td>
        <td><span>See also <a href="http://en.wikipedia.org/wiki/Circle-ellipse_problem" rel="nofollow noreferrer">Circle-Ellipse Problem</a> on Wikipedia for a similar but simpler example.</span> <span> - </span> <span class="display-name">Brian</span> <span> </span> <span class="date">21 Oct 2011 at 17:55</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Requote from @NotMySelf: "I think the example is simply to demonstrate that inheriting from board does not make sense with in the context of ThreeDBoard and all of the method signatures are meaningless with a Z axis.".</span> <span> - </span> <span class="display-name">Contango</span> <span> </span> <span class="date">5 Jun 2013 at 16:40</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Requote from @Chris Ammerman: "Evaluating LSP adherence can be a great tool in determining when composition is the more appropriate mechanism for extending existing functionality, rather than inheritance."</span> <span> - </span> <span class="display-name">Contango</span> <span> </span> <span class="date">5 Jun 2013 at 16:41</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>So if we add another method to a Child class but all the functionality of Parent still makes sense in the Child class would it be breaking LSP? Since on one hand we modified the interface for using the Child a bit on the other hand if we up cast the Child to be a Parent the code that expects a Parent would work fine.</span> <span> - </span> <span class="display-name">Nickolay Kondratyev</span> <span> </span> <span class="date">18 Jun 2013 at 16:45</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span>This is an anti-Liskov example. Liskov makes us to derive Rectangle from the Square. More-parameters-class from less-parameters-class. And you have nicely shown that it is bad. It is really a good joke to have marked as an answer and to have been upvoted 200 times an anti-liskov answer for liskov question. Is Liskov principle a fallacy really?</span> <span> - </span> <span class="display-name">Gangnus</span> <span> </span> <span class="date">18 Oct 2015 at 08:40</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Contango And can you bring an example where inheritance is good, according to the citation in the answer here?</span> <span> - </span> <span class="display-name">Gangnus</span> <span> </span> <span class="date">18 Oct 2015 at 08:42</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>I've seen inheritance work the wrong way. Here is an example. The base class should be 3DBoard and the derived class Board. The Board still has a Z axis of Max(Z) = Min(Z) = 1</span> <span> - </span> <span class="display-name">Paulustrious</span> <span> </span> <span class="date">5 Aug 2017 at 14:52</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Nickolay Kondratyev, yep, doesn't break LSP, you solved it yourself.</span> <span> - </span> <span class="display-name">brgs</span> <span> </span> <span class="date">12 Jul 2018 at 13:55</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Can we solve the problem without using composition? I think it can be done by changing the signature of <code>GetUnits(int x, int y)</code> to <code>GetUnits(Position pos)</code> and same goes for the other functions. That way, it won't violate LSP. Correct me if I'm wrong.</span> <span> - </span> <span class="display-name">du369</span> <span> </span> <span class="date">22 Apr 2020 at 20:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Paulustrious this brakes the open-closed principle. What if you want a FourDBoard? You would have to make that a base class of ThreeDBoard, their by changing the implementation of ThreeDBoard (you might not even have access to).</span> <span> - </span> <span class="display-name">Jupiter</span> <span> </span> <span class="date">19 Jul 2020 at 09:52</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Numpy solved this exact problem with the ndarray. A 3-dimensional, 2-dimensional, and 1-dimensional array are all specializations of the generalized n-dimensional array. Mathematicians figured this out centuries ago. Programmers are gradually reinventing algebra.</span> <span> - </span> <span class="display-name">Adam Acosta</span> <span> </span> <span class="date">22 Dec 2020 at 18:57</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>459</span>
     </div>
     <div>
      <span>Answerer: </span> <span>maysara</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Jul 2017 at 19:58</span>
     </div>
    </div>
    <div>
     <blockquote>
      <p>Substitutability is a principle in object-oriented programming stating that, in a computer program, if S is a subtype of T, then objects of type T may be replaced with objects of type S</p>
     </blockquote>
     <p>Let's do a simple example in Java:</p>
     <h2>Bad example</h2>
     <pre><code>public class Bird{
    public void fly(){}
}
public class Duck extends Bird{}
</code></pre>
     <p>The duck can fly because it is a bird, but what about this:</p>
     <pre><code>public class Ostrich extends Bird{}
</code></pre>
     <p>Ostrich is a bird, but it can't fly, Ostrich class is a subtype of class Bird, but it shouldn't be able to use the fly method, that means we are breaking the LSP principle.</p>
     <h2>Good example</h2>
     <pre><code>public class Bird{}
public class FlyingBirds extends Bird{
    public void fly(){}
}
public class Duck extends FlyingBirds{}
public class Ostrich extends Bird{} 
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>8</td>
        <td><span>Nice example, but what would you do if the client has <code>Bird bird</code>. You have to cast the object to FlyingBirds to make use of fly, which isn't nice right?</span> <span> - </span> <span class="display-name">Moody</span> <span> </span> <span class="date">20 Nov 2017 at 01:05</span></td>
       </tr>
       <tr>
        <td>45</td>
        <td><span>No. If the client has <code>Bird bird</code>, that means it cannot use <code>fly()</code>. That's it. Passing a <code>Duck</code> does not change this fact. If the client has <code>FlyingBirds bird</code>, then even if it gets passed a <code>Duck</code> it should always work the same way.</span> <span> - </span> <span class="display-name">Steve Chamaillard</span> <span> </span> <span class="date">18 Feb 2018 at 18:56</span></td>
       </tr>
       <tr>
        <td>47</td>
        <td><span>Wouldn't this also serve as a good example for Interface Segregation?</span> <span> - </span> <span class="display-name">Saharsh</span> <span> </span> <span class="date">5 Mar 2019 at 18:50</span></td>
       </tr>
       <tr>
        <td>21</td>
        <td><span>How about using Interface 'Flyable' (can't think of a better name). This way we don't commit ourselves into this rigid hierarchy.. Unless we know really need it.</span> <span> - </span> <span class="display-name">Thirdy</span> <span> </span> <span class="date">28 May 2019 at 12:32</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Vet which cures broken wings will see a Bad example like a better one. Some flightless bird species can fly their own way (chicken is a hybrid here). Also flying ability changes in evolution. A default NULL-able fly method is a good decision, to be overridden later.</span> <span> - </span> <span class="display-name">Sławomir Lenart</span> <span> </span> <span class="date">31 Jan 2020 at 18:57</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>So, the parent class should only include the behaviors that its entire children have or in other words, not limiting its children behaviors.</span> <span> - </span> <span class="display-name">Ari</span> <span> </span> <span class="date">25 Feb 2020 at 15:29</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>What about throwing an exception when calling the ostrich fly method and adding the canFly method to check that the bird can fly or not?</span> <span> - </span> <span class="display-name">Nader</span> <span> </span> <span class="date">29 May 2022 at 15:15</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This in my opinion is the best example to understand. It would be very tempting to have Ostrich extend Bird with a NonSupportedException for Fly(), which would be Anti Liskov</span> <span> - </span> <span class="display-name">Ole EH Dufour</span> <span> </span> <span class="date">18 Apr 2023 at 12:58</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>155</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Konrad Rudolph</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Sep 2008 at 13:45</span>
     </div>
    </div>
    <div>
     <p>LSP concerns invariants.</p>
     <p>The classic example is given by the following pseudo-code declaration (implementations omitted):</p>
     <pre><code>class Rectangle {
    int getHeight()
    void setHeight(int value) {
        postcondition: width didn’t change
    }
    int getWidth()
    void setWidth(int value) {
        postcondition: height didn’t change
    }
}

class Square extends Rectangle { }
</code></pre>
     <p>Now we have a problem although the interface matches. The reason is that we have violated invariants stemming from the mathematical definition of squares and rectangles. The way getters and setters work, a <code>Rectangle</code> should satisfy the following invariant:</p>
     <pre><code>void invariant(Rectangle r) {
    r.setHeight(200)
    r.setWidth(100)
    assert(r.getHeight() == 200 and r.getWidth() == 100)
}
</code></pre>
     <p>However, this invariant (as well as the explicit postconditions) <em>must</em> be violated by a correct implementation of <code>Square</code>, therefore it is not a valid substitute of <code>Rectangle</code>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>40</td>
        <td><span>And hence the difficulty of using "OO" to model anything we might want to actually model.</span> <span> - </span> <span class="display-name">DrPizza</span> <span> </span> <span class="date">30 Nov 2009 at 06:54</span></td>
       </tr>
       <tr>
        <td>10</td>
        <td><span>@DrPizza: Absolutely. However, two things. Firstly, such relationships can <i>still</i> be modelled in OOP, albeit incompletely or using more complex detours (pick whichever suits your problem). Secondly, there’s no better alternative. Other mappings/modellings have the same or similar problems. ;-)</span> <span> - </span> <span class="display-name">Konrad Rudolph</span> <span> </span> <span class="date">30 Nov 2009 at 09:11</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@KonradRudolph, It's a good example. What's the right way to declare <code>Square</code> then?</span> <span> - </span> <span class="display-name">ca9163d9</span> <span> </span> <span class="date">23 Jan 2012 at 20:10</span></td>
       </tr>
       <tr>
        <td>8</td>
        <td><span>@NickW In some cases (but not in the above) you can simply invert the inheritance chain – logically speaking, a 2D point is-a 3D point, where the third dimension is disregarded (or 0 – all points lie on the same plane in 3D space). But this is of course not really practical. In general, this is one of the cases where inheritance doesn’t really help, and no natural relationship exists between the entities. Model them separately (at least I don’t know of a better way).</span> <span> - </span> <span class="display-name">Konrad Rudolph</span> <span> </span> <span class="date">24 Jan 2012 at 09:49</span></td>
       </tr>
       <tr>
        <td>9</td>
        <td><span>OOP is meant to model behaviours and not data. Your classes violate encapsulation even before violating LSP.</span> <span> - </span> <span class="display-name">Sklivvz</span> <span> </span> <span class="date">19 May 2012 at 21:47</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Sklivvz I agree. It was hard to come up with a concise example though, and this one is the stock LSP example (you’ll find it in several books). But yes, while common, this is far from good OOP.</span> <span> - </span> <span class="display-name">Konrad Rudolph</span> <span> </span> <span class="date">20 May 2012 at 08:37</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The <code>setHeight()</code> and <code>setWidth()</code> methods probably should not be allowed to exist because that makes a class mutable. However, should they exist, one could just <code>throw NotSupportedException() / NotImplementedException()</code> or something similar.</span> <span> - </span> <span class="display-name">Leonid</span> <span> </span> <span class="date">3 Jul 2012 at 16:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Leonid In a way, that also breaks the contract since it changes the “signature” (i.e. the possible ways in which the function can exit). Now, some frameworks (<i>ahem</i> .NET …) routinely use this route but I consider it very bad interface design.</span> <span> - </span> <span class="display-name">Konrad Rudolph</span> <span> </span> <span class="date">3 Jul 2012 at 18:00</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I dont understand how ls LSP violated here. The invariant states that the getheight and getwidth should return the set height and set width which is always true regardless of weather rectangle is square or rectangle. If client sets different height and width, surely he knows the object is a not a square. Similarly, if client knew the object is square, he will set equal heigh and width. Assuming rectangle class had two functions area and perimeter, the functions would work properly whether rectangle is a square or not. Then how is this violating LSP ?</span> <span> - </span> <span class="display-name">nurabha</span> <span> </span> <span class="date">5 Jun 2013 at 18:31</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@nurabha “which is always true regardless of weather rectangle is square or rectangle” – false. With a properly coded <code>square</code> this will <i>not</i> always true, both setters <i>need</i> to reset both width and height, otherwise they won’t preserve the (implied) invariants of a square. In other words: you have an inconsistent type system, and you never want that.</span> <span> - </span> <span class="display-name">Konrad Rudolph</span> <span> </span> <span class="date">5 Jun 2013 at 21:20</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@nurabha "Assuming rectangle had two functions area and perimeter" would lead to the same problem. <code>SetArea(4); SetPerimeter(10);</code> would make a regular rectangle model a 1x4 rectangle. The calls would make a <code>Square</code> class model first a 2x2, and then either change to a sqrt(10)xsqrt(10) square or throw an <code>InvalidOperationException</code> or something.</span> <span> - </span> <span class="display-name">Wolfzoon</span> <span> </span> <span class="date">7 Aug 2016 at 17:41</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>If there aren't actual invariants, how can you have violated them? How does one know what variants exist to be violated (or conformed)?</span> <span> - </span> <span class="display-name">iheanyi</span> <span> </span> <span class="date">12 Aug 2016 at 18:15</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@iheanyi You either need to make invariants explicit (aka. assertions, or using the type system) or you need to know the domain you’re working in. We know how rectangles and squares are defined, so we know what invariants they impose.</span> <span> - </span> <span class="display-name">Konrad Rudolph</span> <span> </span> <span class="date">13 Aug 2016 at 14:41</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I agree - either the constraints or invariants should be explicit, or they should be forced upon you by the system. But, based on your example, there is nothing forcing me to write a square class with the "implied" invariant you mentioned. I suppose I'd suggest updating your answer to remove "implied" when discussing the invariants, they are actual constraints that give rise to the problem.</span> <span> - </span> <span class="display-name">iheanyi</span> <span> </span> <span class="date">13 Aug 2016 at 21:35</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>LSP should not know what the derived object does, just that derived objects honour the base class contract. For example Square can have <code>SetDepth(int d) =&gt; throw exception</code>. But I wonder...is a rectangle a special type of square that doesn't demand H=W? Alternatively..Quadrilateral ⇒ Trapezoid ⇒ Parallelogram.</span> <span> - </span> <span class="display-name">Paulustrious</span> <span> </span> <span class="date">5 Aug 2017 at 15:00</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Alternatively..<code>Quadrilateral ⇒ Trapezoid ⇒ Parallelogram</code>. Rectangle and Square will ultimately derive. from Parallelogram, although there would be Parallelogram ⇒ Rhombus ⇒ Square. Getting your derivations right is like designing database tables. Get it wrong at the start and you are heading for a screw-up</span> <span> - </span> <span class="display-name">Paulustrious</span> <span> </span> <span class="date">5 Aug 2017 at 15:14</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Would it make more sense for a Rectangle to inherit from a type of Square, or to have Square and Rectangle just be sibling classes?</span> <span> - </span> <span class="display-name">AustinWBryan</span> <span> </span> <span class="date">8 May 2018 at 23:54</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@AustinWBryan You’d avoid this particular issue but the relationship doesn’t really make sense: inheritance models “is-a” relationships and “every rectangle is-a square” is wrong (and, as a consequence, you would run into other issues where you can’t simply replace one for the other). It’s correct the other way round (“every square is-a rectangle”), which is why it’s so tempting to write code that violates LSP.</span> <span> - </span> <span class="display-name">Konrad Rudolph</span> <span> </span> <span class="date">9 May 2018 at 10:01</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@KonradRudolph So then would it be better to keep them as sibling classes that inherit from <code>Shape</code> or <code>Parallelogram</code> or something?</span> <span> - </span> <span class="display-name">AustinWBryan</span> <span> </span> <span class="date">9 May 2018 at 16:35</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>@AustinWBryan Yep; the longer I’ve been working in this field, the more I tend to use inheritance for interfaces and abstract base classes only, and composition for the rest. It’s sometimes a bit more work (typing wise) but it avoids a whole bunch of problems, and is widely echoed advice by other experienced programmers.</span> <span> - </span> <span class="display-name">Konrad Rudolph</span> <span> </span> <span class="date">9 May 2018 at 16:37</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@KonradRudolph Wow, I had no idea, though, on my last project, I did experience the problems of using too much inheritance. I realized I wanted to give some derived classes the properties of other derived classes, and there was no way to do that. Do you think only abstract classes should have children, for the most part?</span> <span> - </span> <span class="display-name">AustinWBryan</span> <span> </span> <span class="date">9 May 2018 at 16:47</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@AustinWBryan For the most part, yes. It’s famously one of the rules of the influential <i>Effective C++</i> books, and a more general rule, <i>Composition over Inheritance</i>, has its own <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance" rel="nofollow noreferrer">Wikipedia page</a>.</span> <span> - </span> <span class="display-name">Konrad Rudolph</span> <span> </span> <span class="date">9 May 2018 at 17:22</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@KonradRudolph Wow, thanks, I'll check this out. Is that book still worth a read for C# development, to learn structures and design patterns?</span> <span> - </span> <span class="display-name">AustinWBryan</span> <span> </span> <span class="date">9 May 2018 at 20:59</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@AustinWBryan Probably not, unfortunately; it’s very specific to C++. Bill Wagner’s <i>Effective C#</i> follows a similar pattern though.</span> <span> - </span> <span class="display-name">Konrad Rudolph</span> <span> </span> <span class="date">9 May 2018 at 21:54</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@ca9163d9 For modeling the <code>Square</code> from a <code>Rectangle</code>, if a polymorphic approach is not a must, I would advocate for a <code>SquareDecorator</code> which takes the <code>Rectangle</code> object. What you or anybody else think of that?</span> <span> - </span> <span class="display-name">Reuel Ribeiro</span> <span> </span> <span class="date">11 Jan 2019 at 16:35</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@ReuelRibeiro This goes into the direction of over-engineering; most of the time it would be better to simply provide orthogonal classes that might both inherit from a <code>Shape</code>. That said, your approach is certainly the correct solution in many real-life use-cases.</span> <span> - </span> <span class="display-name">Konrad Rudolph</span> <span> </span> <span class="date">11 Jan 2019 at 17:29</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I'm not convinced this is a good example of violating LSP. I understand it's somewhat the canonical example used, but the assertion used to prove the violation isn't open and shut. Yes, when you read the code it seems obvious. I just set the width and the height, why is the height not what I set it to? But setting the width and height are two separate operations, and after-all, the reason we have methods to set properties, rather than exposing the properties themselves, is so we can maintain our invariants, which may result in side-effects.</span> <span> - </span> <span class="display-name">wired_in</span> <span> </span> <span class="date">12 Oct 2020 at 21:51</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>In essence, I'm saying that while this may be a violation, it's far from obvious that it is, and thus shouldn't be used as an example for people trying to learn this concept.</span> <span> - </span> <span class="display-name">wired_in</span> <span> </span> <span class="date">12 Oct 2020 at 21:52</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@wired_in I see where you’re coming from but your comment ignores the specific context of the example. Namely, we’re not just calling any old setter on any old object type. We’re specifically assigning width and height of a <i>rectangle</i>. And this comes with implicit expectations (an implicit contract). The (implicit) expectation is that modifying the width <i>does not modify the height</i>, and vice-versa. There are reasons to change this contract (after all, that’s what a square does!). But <i>in general</i> these are the natural expectations. The substitution (with a square) violates that generality.</span> <span> - </span> <span class="display-name">Konrad Rudolph</span> <span> </span> <span class="date">12 Oct 2020 at 22:37</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@KonradRudolph I was not ignoring the fact that the assertion was in the context of a <i>Rectangle</i>, and I never said it wasn't a violation of LSP. It is not obvious at all that there is an implicit contract that says changing the width of the Rectangle cannot change the height, and vice-versa. Since changing the width is a separate operation from changing the height, I don't see an implicit contract that says a square can't enforce its invariants when the width or height is changed in isolation, as a rectangle.</span> <span> - </span> <span class="display-name">wired_in</span> <span> </span> <span class="date">13 Oct 2020 at 01:34</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>83</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Phillip Wells</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Sep 2008 at 13:34</span>
     </div>
    </div>
    <div>
     <p>Robert Martin has an excellent <a href="http://web.archive.org/web/20151128004108/http://www.objectmentor.com/resources/articles/lsp.pdf" rel="noreferrer">paper on the Liskov Substitution Principle</a>. It discusses subtle and not-so-subtle ways in which the principle may be violated.</p>
     <p>Some relevant parts of the paper (note that the second example is heavily condensed):</p>
     <blockquote>
      <h1>A Simple Example of a Violation of LSP</h1>
      <p>One of the most glaring violations of this principle is the use of C++ Run-Time Type Information (RTTI) to select a function based upon the type of an object. i.e.:</p>
      <pre><code>void DrawShape(const Shape&amp; s)
{
  if (typeid(s) == typeid(Square))
    DrawSquare(static_cast&lt;Square&amp;&gt;(s)); 
  else if (typeid(s) == typeid(Circle))
    DrawCircle(static_cast&lt;Circle&amp;&gt;(s));
}
</code></pre>
      <p>Clearly the <code>DrawShape</code> function is badly formed. It must know about every possible derivative of the <code>Shape</code> class, and it must be changed whenever new derivatives of <code>Shape</code> are created. Indeed, many view the structure of this function as anathema to Object Oriented Design.</p>
      <h1>Square and Rectangle, a More Subtle Violation.</h1>
      <p>However, there are other, far more subtle, ways of violating the LSP. Consider an application which uses the <code>Rectangle</code> class as described below:</p>
      <pre><code>class Rectangle
{
  public:
    void SetWidth(double w) {itsWidth=w;}
    void SetHeight(double h) {itsHeight=w;}
    double GetHeight() const {return itsHeight;}
    double GetWidth() const {return itsWidth;}
  private:
    double itsWidth;
    double itsHeight;
};
</code></pre>
      <p>[...] Imagine that one day the users demand the ability to manipulate squares in addition to rectangles. [...]</p>
      <p>Clearly, a square is a rectangle for all normal intents and purposes. Since the ISA relationship holds, it is logical to model the <code>Square</code> class as being derived from <code>Rectangle</code>. [...]</p>
      <p><code>Square</code> will inherit the <code>SetWidth</code> and <code>SetHeight</code> functions. These functions are utterly inappropriate for a <code>Square</code>, since the width and height of a square are identical. This should be a significant clue that there is a problem with the design. However, there is a way to sidestep the problem. We could override <code>SetWidth</code> and <code>SetHeight</code> [...]</p>
      <p>But consider the following function:</p>
      <pre><code>void f(Rectangle&amp; r)
{
  r.SetWidth(32); // calls Rectangle::SetWidth
}
</code></pre>
      <p>If we pass a reference to a <code>Square</code> object into this function, the <code>Square</code> object will be corrupted because the height won’t be changed. This is a clear violation of LSP. The function does not work for derivatives of its arguments.</p>
      <p>[...]</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>17</td>
        <td><span>Way late, but I thought this was an interesting quote in that paper: <code>Now the rule for the preconditions and postconditions for derivatives, as stated by Meyer is: ...when redefining a routine [in a derivative], you may only replace its precondition by a weaker one, and its postcondition by a stronger one.</code> If a child-class pre-condition is stronger than a parent class pre-condition, you couldn't substitute a child for a parent without violating the pre-condition. Hence LSP.</span> <span> - </span> <span class="display-name">user2023861</span> <span> </span> <span class="date">11 Feb 2015 at 15:31</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I have implemented diagram editor in past. Robust implementation may be <code>setHeight(x) { this.height = x; this.width = x }</code> and similar for <code>setWidth()</code>. It will work well for horizontal and vertical resize controls, but will require some workarounds for corner resize controls.</span> <span> - </span> <span class="display-name">x'ES</span> <span> </span> <span class="date">31 Jul 2022 at 05:54</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Actually Rect, from perspective of drawing application, is not something having <code>width</code> and <code>height</code>. Instead it is something having <code>(x1,y1)</code> and <code>(x2,y2)</code>. Even <code>Line</code> and <code>Circle</code> may be represented as box-outlined shape. Additionally, for drawing app it is important to know how we define anchor <code>(x,y)</code>, which may be calculated differently and transparently for different kinds of shapes.</span> <span> - </span> <span class="display-name">x'ES</span> <span> </span> <span class="date">31 Jul 2022 at 06:10</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>43</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Steve Chamaillard</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Feb 2018 at 19:07</span>
     </div>
    </div>
    <div>
     <p>I see rectangles and squares in every answer, and how to violate the LSP.</p>
     <p>I'd like to show how the LSP can be conformed to with a real-world example :</p>
     <pre class="lang-php prettyprint-override"><code>&lt;?php

interface Database 
{
    public function selectQuery(string $sql): array;
}

class SQLiteDatabase implements Database
{
    public function selectQuery(string $sql): array
    {
        // sqlite specific code

        return $result;
    }
}

class MySQLDatabase implements Database
{
    public function selectQuery(string $sql): array
    {
        // mysql specific code

        return $result; 
    }
}
</code></pre>
     <p>This design conforms to the LSP because the behaviour remains unchanged regardless of the implementation we choose to use.</p>
     <p>And yes, you can violate LSP in this configuration doing one simple change like so :</p>
     <pre class="lang-php prettyprint-override"><code>&lt;?php

interface Database 
{
    public function selectQuery(string $sql): array;
}

class SQLiteDatabase implements Database
{
    public function selectQuery(string $sql): array
    {
        // sqlite specific code

        return $result;
    }
}

class MySQLDatabase implements Database
{
    public function selectQuery(string $sql): array
    {
        // mysql specific code

        return ['result' =&gt; $result]; // This violates LSP !
    }
}
</code></pre>
     <p>Now the subtypes cannot be used the same way since they don't produce the same result anymore.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>10</td>
        <td><span>The example does not violate LSP only as long as we constrain the semantics of <code>Database::selectQuery</code> to support just the subset of SQL supported by <b>all</b> DB engines. That's hardly practical... That said, the example is still easier to grasp than most others used here.</span> <span> - </span> <span class="display-name">Palec</span> <span> </span> <span class="date">25 Feb 2018 at 13:02</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>I found this answer the easiest to grasp out of the rest.</span> <span> - </span> <span class="display-name">Malcolm Salvador</span> <span> </span> <span class="date">11 Feb 2019 at 17:14</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>is it practical to apply LSP on databases? i see that most, if not all the, of db operations will need to be wrapped, and is vulnerable to mistakes. Though the good side is the API stays the same even if it's SQL vs NoSQL.</span> <span> - </span> <span class="display-name">Sean W</span> <span> </span> <span class="date">23 Aug 2020 at 15:59</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>42</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Cù Đức Hiếu</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 Aug 2016 at 14:26</span>
     </div>
    </div>
    <div>
     <p>There is a checklist to determine whether or not you are violating Liskov.</p>
     <ul>
      <li>If you violate one of the following items -&gt; you violate Liskov.</li>
      <li>If you don't violate any -&gt; can't conclude anything.</li>
     </ul>
     <p>Check list:</p>
     <ul>
      <li>
       <p><strong>No new exceptions should be thrown in derived class</strong>: If your base class threw ArgumentNullException then your sub classes were only allowed to throw exceptions of type ArgumentNullException or any exceptions derived from ArgumentNullException. Throwing IndexOutOfRangeException is a violation of Liskov.</p></li>
      <li>
       <p><strong>Pre-conditions cannot be strengthened</strong>: Assume your base class works with a member int. Now your sub-type requires that int to be positive. This is strengthened pre-conditions, and now any code that worked perfectly fine before with negative ints is broken.</p></li>
      <li>
       <p><strong>Post-conditions cannot be weakened</strong>: Assume your base class required all connections to the database should be closed before the method returned. In your sub-class you overrode that method and left the connection open for further reuse. You have weakened the post-conditions of that method.</p></li>
      <li>
       <p><strong>Invariants must be preserved</strong>: The most difficult and painful constraint to fulfill. Invariants are sometimes hidden in the base class and the only way to reveal them is to read the code of the base class. Basically you have to be sure when you override a method anything unchangeable must remain unchanged after your overridden method is executed. The best thing I can think of is to enforce these invariant constraints in the base class but that would not be easy.</p></li>
      <li>
       <p><strong>History Constraint</strong>: When overriding a method you are not allowed to modify an unmodifiable property in the base class. Take a look at these code and you can see Name is defined to be unmodifiable (private set) but SubType introduces new method that allows modifying it (through reflection):</p>
       <pre><code> public class SuperType
 {
     public string Name { get; private set; }
     public SuperType(string name, int age)
     {
         Name = name;
         Age = age;
     }
 }
 public class SubType : SuperType
 {
     public void ChangeName(string newName)
     {
         var propertyType = base.GetType().GetProperty("Name").SetValue(this, newName);
     }
 }
</code></pre></li>
     </ul>
     <p>There are 2 others items: <strong>Contravariance of method arguments</strong> and <strong>Covariance of return types</strong>. But it is not possible in C# (I'm a C# developer) so I don't care about them.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>I'm a C# developer also and I will tell your last statement isn't true as of Visual Studio 2010, with the .Net 4.0 framework. Covariance of return types allows for a more derived return type than what was defined by the interface. Example: Example: IEnumerable&lt;T&gt; (T is covariant) IEnumerator&lt;T&gt; (T is covariant) IQueryable&lt;T&gt; (T is covariant) IGrouping&lt;TKey, TElement&gt; (TKey and TElement are covariant) IComparer&lt;T&gt; (T is contravariant) IEqualityComparer&lt;T&gt; (T is contravariant) IComparable&lt;T&gt; (T is contravariant) <a href="https://msdn.microsoft.com/en-us/library/dd233059(v=vs.100).aspx" rel="nofollow noreferrer">msdn.microsoft.com/en-us/library/dd233059(v=vs.100).aspx</a></span> <span> - </span> <span class="display-name">LCarter</span> <span> </span> <span class="date">5 Sep 2017 at 03:48</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>41</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Shelby Moore III</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Nov 2011 at 16:35</span>
     </div>
    </div>
    <div>
     <p>LSP is necessary where some code thinks it is calling the methods of a type <code>T</code>, and may unknowingly call the methods of a type <code>S</code>, where <code>S extends T</code> (i.e. <code>S</code> inherits, derives from, or is a subtype of, the supertype <code>T</code>).</p>
     <p>For example, this occurs where a function with an input parameter of type <code>T</code>, is called (i.e. invoked) with an argument value of type <code>S</code>. Or, where an identifier of type <code>T</code>, is assigned a value of type <code>S</code>.</p>
     <pre class="lang-scala prettyprint-override"><code>val id : T = new S() // id thinks it's a T, but is a S
</code></pre>
     <p>LSP requires the expectations (i.e. invariants) for methods of type <code>T</code> (e.g. <code>Rectangle</code>), not be violated when the methods of type <code>S</code> (e.g. <code>Square</code>) are called instead.</p>
     <pre class="lang-scala prettyprint-override"><code>val rect : Rectangle = new Square(5) // thinks it's a Rectangle, but is a Square
val rect2 : Rectangle = rect.setWidth(10) // height is 10, LSP violation
</code></pre>
     <p>Even a type with <em>immutable fields</em> still has invariants, e.g. the <em>immutable</em> Rectangle setters expect dimensions to be independently modified, but the <em>immutable</em> Square setters violate this expectation.</p>
     <pre class="lang-scala prettyprint-override"><code>class Rectangle( val width : Int, val height : Int )
{
   def setWidth( w : Int ) = new Rectangle(w, height)
   def setHeight( h : Int ) = new Rectangle(width, h)
}

class Square( val side : Int ) extends Rectangle(side, side)
{
   override def setWidth( s : Int ) = new Square(s)
   override def setHeight( s : Int ) = new Square(s)
}
</code></pre>
     <p>LSP requires that each method of the subtype <code>S</code> must have contravariant input parameter(s) and a covariant output.</p>
     <p>Contravariant means the variance is contrary to the direction of the inheritance, i.e. the type <code>Si</code>, of each input parameter of each method of the subtype <code>S</code>, must be the same or a <em>supertype</em> of the type <code>Ti</code> of the corresponding input parameter of the corresponding method of the supertype <code>T</code>.</p>
     <p>Covariance means the variance is in the same direction of the inheritance, i.e. the type <code>So</code>, of the output of each method of the subtype <code>S</code>, must be the same or a <em>subtype</em> of the type <code>To</code> of the corresponding output of the corresponding method of the supertype <code>T</code>.</p>
     <p>This is because if the caller thinks it has a type <code>T</code>, thinks it is calling a method of <code>T</code>, then it supplies argument(s) of type <code>Ti</code> and assigns the output to the type <code>To</code>. When it is actually calling the corresponding method of <code>S</code>, then each <code>Ti</code> input argument is assigned to a <code>Si</code> input parameter, and the <code>So</code> output is assigned to the type <code>To</code>. Thus if <code>Si</code> were not contravariant w.r.t. to <code>Ti</code>, then a subtype <code>Xi</code>—which would not be a subtype of <code>Si</code>—could be assigned to <code>Ti</code>.</p>
     <p>Additionally, for languages (e.g. Scala or Ceylon) which have definition-site variance annotations on type polymorphism parameters (i.e. generics), the co- or contra- direction of the variance annotation for each type parameter of the type <code>T</code> must be <a href="https://stackoverflow.com/q/5278591">opposite</a> or same direction respectively to every input parameter or output (of every method of <code>T</code>) that has the type of the type parameter.</p>
     <p>Additionally, for each input parameter or output that has a function type, the variance direction required is reversed. This rule is applied recursively.</p>
     <hr>
     <p><a href="https://stackoverflow.com/a/8352969">Subtyping is appropriate</a> where the invariants can be enumerated.</p>
     <p>There is much ongoing research on how to model invariants, so that they are enforced by the compiler.</p>
     <p><a href="http://www.cs.cmu.edu/~aldrich/papers/onward2009-state.pdf#page3" rel="nofollow noreferrer">Typestate</a> (see page 3) declares and enforces state invariants orthogonal to type. Alternatively, invariants can be enforced by <a href="http://lambda-the-ultimate.org/node/4009#comment-60775" rel="nofollow noreferrer">converting assertions to types</a>. For example, to assert that a file is open before closing it, then File.open() could return an OpenFile type, which contains a close() method that is not available in File. A <a href="http://blog.tmorris.net/scala-exercise-with-types-and-abstraction/" rel="nofollow noreferrer">tic-tac-toe API</a> can be another example of employing typing to enforce invariants at compile-time. The type system may even be Turing-complete, e.g. <a href="https://stackoverflow.com/a/4050833">Scala</a>. Dependently-typed languages and theorem provers formalize the models of higher-order typing.</p>
     <p>Because of the need for semantics to <a href="http://lambda-the-ultimate.org/node/4009#comment-60765" rel="nofollow noreferrer">abstract over extension</a>, I expect that employing typing to model invariants, i.e. unified higher-order denotational semantics, is superior to the Typestate. ‘Extension’ means the unbounded, permuted composition of uncoordinated, modular development. Because it seems to me to be the antithesis of unification and thus degrees-of-freedom, to have two mutually-dependent models (e.g. types and Typestate) for expressing the shared semantics, which can't be unified with each other for extensible composition. For example, <a href="http://en.wikipedia.org/wiki/Expression_problem" rel="nofollow noreferrer">Expression Problem</a>-like extension was unified in the subtyping, function overloading, and parametric typing domains.</p>
     <p>My theoretical position is that for <a href="http://www.coolpage.com/commentary/economic/shelby/Understand%20Everything%20Fundamentally.html" rel="nofollow noreferrer">knowledge to exist</a> (see section “Centralization is blind and unfit”), there will <em>never</em> be a general model that can enforce 100% coverage of all possible invariants in a Turing-complete computer language. For knowledge to exist, unexpected possibilities much exist, i.e. disorder and entropy must always be increasing. This is the entropic force. To prove all possible computations of a potential extension, is to compute a priori all possible extension.</p>
     <p>This is why the Halting Theorem exists, i.e. it is undecidable whether every possible program in a Turing-complete programming language terminates. It can be proven that some specific program terminates (one which all possibilities have been defined and computed). But it is impossible to prove that all possible extension of that program terminates, unless the possibilities for extension of that program is not Turing complete (e.g. via dependent-typing). Since the fundamental requirement for Turing-completeness is <a href="https://stackoverflow.com/q/8283566">unbounded recursion</a>, it is intuitive to understand how Gödel's incompleteness theorems and Russell's paradox apply to extension.</p>
     <p>An interpretation of these theorems incorporates them in a generalized conceptual understanding of the entropic force:</p>
     <ul>
      <li><strong>Gödel's incompleteness theorems</strong>: any formal theory, in which all arithmetic truths can be proved, is inconsistent.</li>
      <li><strong><a href="http://plato.stanford.edu/entries/russell-paradox/#SOTP" rel="nofollow noreferrer">Russell's paradox</a></strong>: every membership rule for a set that can contain a set, either enumerates the specific type of each member or contains itself. Thus sets either cannot be extended or they are unbounded recursion. For example, the set of everything that is not a teapot, includes itself, which includes itself, which includes itself, etc…. Thus a rule is inconsistent if it (may contain a set and) does not enumerate the specific types (i.e. allows all unspecified types) and does not allow unbounded extension. This is the set of sets that are not members of themselves. This inability to be both consistent and completely enumerated over all possible extension, is Gödel's incompleteness theorems.</li>
      <li><strong>Liskov Substition Principle</strong>: generally it is an undecidable problem whether any set is the subset of another, i.e. inheritance is generally undecidable.</li>
      <li><strong>Linsky Referencing</strong>: it is undecidable what the computation of something is, when it is described or perceived, i.e. perception (reality) has no absolute point of reference.</li>
      <li><strong>Coase's theorem</strong>: there is no external reference point, thus any barrier to unbounded external possibilities will fail.</li>
      <li><strong><a href="http://en.wikipedia.org/wiki/Second_law_of_thermodynamics#Mathematical_descriptions" rel="nofollow noreferrer">Second law of thermodynamics</a></strong>: the entire universe (a closed system, i.e. everything) trends to maximum disorder, i.e. maximum independent possibilities.</li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>20</td>
        <td><span>@Shelyby: You have mixed too many things. Things are not as confusing as you state them. Much of your theoretical assertions stand on flimsy grounds, like 'For knowledge to exist, unexpected possibilities much exist, .........' AND 'generally it is an undecidable problem whether any set is the subset of another, i.e. inheritance is generally undecidable' . You can start up a separate blog for each of these points. Anyways, your assertions and assumptions are highly questionable. One must not use things which one is not aware of!</span> <span> - </span> <span class="display-name">aknon</span> <span> </span> <span class="date">27 Dec 2013 at 05:03</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@aknon I <a href="http://unheresy.com" rel="nofollow noreferrer">have a blog</a> that explains these matters in more depth. My TOE model of infinite spacetime is unbounded frequencies. It is not confusing to me that a recursive inductive function has a known start value with an infinite end bound, or a coinductive function has an unknown end value and a known start bound. Relativity is the problem once recursion is introduced. This is why <a href="http://stackoverflow.com/questions/7284/what-is-turing-complete/8283566#8283566">Turing complete is equivalent to unbounded recursion</a>.</span> <span> - </span> <span class="display-name">Shelby Moore III</span> <span> </span> <span class="date">16 Mar 2014 at 08:38</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>@ShelbyMooreIII You are going in too many directions. This is not an answer.</span> <span> - </span> <span class="display-name">Soldalma</span> <span> </span> <span class="date">9 Dec 2016 at 14:48</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Soldalma it is an answer. Don't you see it in the Answer section. Yours is a comment because it is in the comment section.</span> <span> - </span> <span class="display-name">Shelby Moore III</span> <span> </span> <span class="date">23 Dec 2016 at 12:54</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@aknon as for your allegations of "flimsy", I've <a href="https://steemit.com/science/@anonymint/the-golden-knowledge-age-is-rising" rel="nofollow noreferrer">blogged</a> and <a href="https://github.com/keean/zenscript/issues/17#issuecomment-265502060" rel="nofollow noreferrer">written</a> since my reply to you in 2014.</span> <span> - </span> <span class="display-name">Shelby Moore III</span> <span> </span> <span class="date">23 Dec 2016 at 13:01</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Like your mixing with scala world!</span> <span> - </span> <span class="display-name">Ehsan M. Kermani</span> <span> </span> <span class="date">28 Jun 2017 at 18:38</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>36</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Lukas Lukac</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Oct 2017 at 23:10</span>
     </div>
    </div>
    <div>
     <p><strong>Long</strong> story short, let's leave rectangles rectangles and squares squares, practical example when extending a parent class, you have to either PRESERVE the exact parent API or to EXTEND IT.</p>
     <p>Let's say you have a <strong>base</strong> ItemsRepository.</p>
     <pre class="lang-php prettyprint-override"><code>class ItemsRepository
{
    /**
    * @return int Returns number of deleted rows
    */
    public function delete()
    {
        // perform a delete query
        $numberOfDeletedRows = 10;

        return $numberOfDeletedRows;
    }
}
</code></pre>
     <p>And a sub class extending it:</p>
     <pre class="lang-php prettyprint-override"><code>class BadlyExtendedItemsRepository extends ItemsRepository
{
    /**
     * @return void Was suppose to return an INT like parent, but did not, breaks LSP
     */
    public function delete()
    {
        // perform a delete query
        $numberOfDeletedRows = 10;

        // we broke the behaviour of the parent class
        return;
    }
}
</code></pre>
     <p>Then you could have a <strong>Client</strong> working with the Base ItemsRepository API and relying on it.</p>
     <pre class="lang-php prettyprint-override"><code>/**
 * Class ItemsService is a client for public ItemsRepository "API" (the public delete method).
 *
 * Technically, I am able to pass into a constructor a sub-class of the ItemsRepository
 * but if the sub-class won't abide the base class API, the client will get broken.
 */
class ItemsService
{
    /**
     * @var ItemsRepository
     */
    private $itemsRepository;

    /**
     * @param ItemsRepository $itemsRepository
     */
    public function __construct(ItemsRepository $itemsRepository)
    {
        $this-&gt;itemsRepository = $itemsRepository;
    }

    /**
     * !!! Notice how this is suppose to return an int. My clients expect it based on the
     * ItemsRepository API in the constructor !!!
     *
     * @return int
     */
    public function delete()
    {
        return $this-&gt;itemsRepository-&gt;delete();
    }
} 
</code></pre>
     <p>The <strong>LSP</strong> is broken when <strong>substituting</strong> <strong>parent</strong> class with a <strong>sub class breaks the API's contract</strong>.</p>
     <pre class="lang-php prettyprint-override"><code>class ItemsController
{
    /**
     * Valid delete action when using the base class.
     */
    public function validDeleteAction()
    {
        $itemsService = new ItemsService(new ItemsRepository());
        $numberOfDeletedItems = $itemsService-&gt;delete();

        // $numberOfDeletedItems is an INT :)
    }

    /**
     * Invalid delete action when using a subclass.
     */
    public function brokenDeleteAction()
    {
        $itemsService = new ItemsService(new BadlyExtendedItemsRepository());
        $numberOfDeletedItems = $itemsService-&gt;delete();

        // $numberOfDeletedItems is a NULL :(
    }
}
</code></pre>
     <p>You can learn more about writing maintainable software in my course: <a href="https://www.udemy.com/enterprise-php/" rel="noreferrer">https://www.udemy.com/enterprise-php/</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>This is a much better example. Thank you!</span> <span> - </span> <span class="display-name">Kurt Campher</span> <span> </span> <span class="date">14 Feb 2021 at 17:39</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>29</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Khaled Qasem</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Feb 2019 at 10:56</span>
     </div>
    </div>
    <div>
     <p>Let’s illustrate in Java:</p>
     <pre><code>class TrasportationDevice
{
   String name;
   String getName() { ... }
   void setName(String n) { ... }

   double speed;
   double getSpeed() { ... }
   void setSpeed(double d) { ... }

   Engine engine;
   Engine getEngine() { ... }
   void setEngine(Engine e) { ... }

   void startEngine() { ... }
}

class Car extends TransportationDevice
{
   @Override
   void startEngine() { ... }
}
</code></pre>
     <p>There is no problem here, right? A car is definitely a transportation device, and here we can see that it overrides the startEngine() method of its superclass.</p>
     <p>Let’s add another transportation device:</p>
     <pre><code>class Bicycle extends TransportationDevice
{
   @Override
   void startEngine() /*problem!*/
}
</code></pre>
     <p>Everything isn’t going as planned now! Yes, a bicycle is a transportation device, however, it does not have an engine and hence, the method startEngine() cannot be implemented.</p>
     <blockquote>
      <p>These are the kinds of problems that violation of Liskov Substitution Principle leads to, and they can most usually be recognized by a method that does nothing, or even can’t be implemented.</p>
     </blockquote>
     <p>The solution to these problems is a correct inheritance hierarchy, and in our case we would solve the problem by differentiating classes of transportation devices with and without engines. Even though a bicycle is a transportation device, it doesn’t have an engine. In this example our definition of transportation device is wrong. It should not have an engine.</p>
     <p>We can refactor our TransportationDevice class as follows:</p>
     <pre><code>class TrasportationDevice
{
   String name;
   String getName() { ... }
   void setName(String n) { ... }

   double speed;
   double getSpeed() { ... }
   void setSpeed(double d) { ... }
}
</code></pre>
     <p>Now we can extend TransportationDevice for non-motorized devices.</p>
     <pre><code>class DevicesWithoutEngines extends TransportationDevice
{  
   void startMoving() { ... }
}
</code></pre>
     <p>And extend TransportationDevice for motorized devices. Here is is more appropriate to add the Engine object.</p>
     <pre><code>class DevicesWithEngines extends TransportationDevice
{  
   Engine engine;
   Engine getEngine() { ... }
   void setEngine(Engine e) { ... }

   void startEngine() { ... }
}
</code></pre>
     <p>Thus our Car class becomes more specialized, while adhering to the Liskov Substitution Principle.</p>
     <pre><code>class Car extends DevicesWithEngines
{
   @Override
   void startEngine() { ... }
}
</code></pre>
     <p>And our Bicycle class is also in compliance with the Liskov Substitution Principle.</p>
     <pre><code>class Bicycle extends DevicesWithoutEngines
{
   @Override
   void startMoving() { ... }
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Your example is more about Interface segregation principle.</span> <span> - </span> <span class="display-name">Eugene Maysyuk</span> <span> </span> <span class="date">11 Dec 2022 at 20:36</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>27</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Charlie Martin</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Nov 2008 at 17:53</span>
     </div>
    </div>
    <div>
     <p>The LSP is a rule about the contract of the clases: if a base class satisfies a contract, then by the LSP derived classes must also satisfy that contract.</p>
     <p>In Pseudo-python</p>
     <pre><code>class Base:
   def Foo(self, arg): 
       # *... do stuff*

class Derived(Base):
   def Foo(self, arg):
       # *... do stuff*
</code></pre>
     <p>satisfies LSP if every time you call Foo on a Derived object, it gives exactly the same results as calling Foo on a Base object, as long as arg is the same.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>12</td>
        <td><span>But ... if you always get the same behavior, then what is the point of having the derived class?</span> <span> - </span> <span class="display-name">Leonid</span> <span> </span> <span class="date">3 Jul 2012 at 17:14</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>You missed a point: it's the same <i>observed</i> behavior. You might, for example replace something with O(n) performance with something functionally equivalent, but with O(lg n) performance. Or you might replace something that accesses data implemented with MySQL and replace it with an in-memory database.</span> <span> - </span> <span class="display-name">Charlie Martin</span> <span> </span> <span class="date">4 Jul 2012 at 18:06</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Charlie Martin, coding to an interface rather than an implementation - I dig that. This is not unique to OOP; functional languages such as Clojure promote that as well. Even in terms of Java or C#, I think that using an interface rather than using an abstract class plus class hierarchies would be natural for the examples that you provide. Python is not strongly typed and does not really have interfaces, at least not explicitly. My difficulty is that I have been doing OOP for several years without adhering to SOLID. Now that I came across it, it seems limiting and almost self-contradicting.</span> <span> - </span> <span class="display-name">Hamish Grubijan</span> <span> </span> <span class="date">6 Jul 2012 at 18:09</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Well, you need to go back and check out Barbara's original paper. <a href="http://reports-archive.adm.cs.cmu.edu/anon/1999/CMU-CS-99-156.ps" rel="nofollow noreferrer">reports-archive.adm.cs.cmu.edu/anon/1999/CMU-CS-99-156.ps</a> It's not really stated in terms of interfaces, and it is a logical relation that holds (or doesn't) in any programming language that has some form of inheritance.</span> <span> - </span> <span class="display-name">Charlie Martin</span> <span> </span> <span class="date">7 Jul 2012 at 19:22</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@HamishGrubijan I don't know who told you that Python is not strongly typed, but they were lying to you (and if you don't believe me, fire up a Python interpreter and try <code>2 + "2"</code>). Perhaps you confuse "strongly typed" with "statically typed"?</span> <span> - </span> <span class="display-name">asmeurer</span> <span> </span> <span class="date">20 Jan 2013 at 06:19</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@asmeurer Hamish is not wrong. <i>"Strongly typed"</i> isn't a well defined term; sometimes it's used to mean "has some kind of static type-checking" (Hamish's meaning), sometimes to mean "doesn't perform type coercion" (your meaning, and as usual only with regard to the specific case of 'string-to-number type coercion' - I've never seen anyone argue that C is weakly typed because you can multiply ints by floats, or that Python is because you can concatenate <code>u'hello'</code> with <code>'world'</code>), and sometimes to mean one of many other things. <a href="http://en.wikipedia.org/wiki/Strong_and_weak_typing" rel="nofollow noreferrer">en.wikipedia.org/wiki/Strong_and_weak_typing</a></span> <span> - </span> <span class="display-name">Mark Amery</span> <span> </span> <span class="date">27 Dec 2013 at 10:57</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Well from the point of view of Liskov, those are different, because they always work. If a language supports <code>2 + '2'</code>, it still won't support <code>2 + 'two'</code>.</span> <span> - </span> <span class="display-name">asmeurer</span> <span> </span> <span class="date">27 Dec 2013 at 17:13</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Oddly, @MarkAmery, the wiki article you link supports my use of 'strongly typed'. Just because people have been using it wrongly doesn't make the definition wrong. "In 1974, Liskov and Zilles described a strong-typed language as one in which "whenever an object is passed from a calling function to a called function, its type must be compatible with the type declared in the called function."</span> <span> - </span> <span class="display-name">Charlie Martin</span> <span> </span> <span class="date">27 Dec 2013 at 18:11</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@CharlieMartin, if I understand your answer correctly, then LSP is the ability to replace any instance of a parent class with an instance of one of its child classes without negative side effects, correct?</span> <span> - </span> <span class="display-name">Daniel</span> <span> </span> <span class="date">26 Oct 2018 at 22:11</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>23</span>
     </div>
     <div>
      <span>Answerer: </span> <span>snagpaul</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Dec 2016 at 16:54</span>
     </div>
    </div>
    <div>
     <p>I guess everyone kind of covered what LSP is technically: You basically want to be able to abstract away from subtype details and use supertypes safely.</p>
     <p>So Liskov has 3 underlying rules:</p>
     <ol>
      <li>
       <p>Signature Rule : There should be a valid implementation of every operation of the supertype in the subtype syntactically. Something a compiler will be able to check for you. There is a little rule about throwing fewer exceptions and being at least as accessible as the supertype methods.</p></li>
      <li>
       <p>Methods Rule: The implementation of those operations is semantically sound.</p>
       <ul>
        <li>Weaker Preconditions : The subtype functions should take at least what the supertype took as input, if not more.</li>
        <li>Stronger Postconditions: They should produce a subset of the output the supertype methods produced.</li>
       </ul></li>
      <li>
       <p>Properties Rule : This goes beyond individual function calls.</p>
       <ul>
        <li>Invariants : Things that are always true must remain true. Eg. a Set's size is never negative.</li>
        <li>Evolutionary Properties : Usually something to do with immutability or the kind of states the object can be in. Or maybe the object only grows and never shrinks so the subtype methods shouldn't make it.</li>
       </ul></li>
     </ol>
     <p>All these properties need to be preserved and the extra subtype functionality shouldn't violate supertype properties.</p>
     <p>If these three things are taken care of , you have abstracted away from the underlying stuff and you are writing loosely coupled code.</p>
     <p>Source: Program Development in Java - Barbara Liskov</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>22</span>
     </div>
     <div>
      <span>Answerer: </span> <span>avandeursen</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Mar 2013 at 21:26</span>
     </div>
    </div>
    <div>
     <p>An important example of the <em>use</em> of LSP is in <strong>software testing</strong>.</p>
     <p>If I have a class A that is an LSP-compliant subclass of B, then I can reuse the test suite of B to test A.</p>
     <p>To fully test subclass A, I probably need to add a few more test cases, but at the minimum I can reuse all of superclass B's test cases.</p>
     <p>A way to realize is this by building what McGregor calls a "Parallel hierarchy for testing": My <code>ATest</code> class will inherit from <code>BTest</code>. Some form of injection is then needed to ensure the test case works with objects of type A rather than of type B (a simple template method pattern will do).</p>
     <p>Note that reusing the super-test suite for all subclass implementations is in fact a way to test that these subclass implementations are LSP-compliant. Thus, one can also argue that one <em>should</em> run the superclass test suite in the context of any subclass.</p>
     <p>See also the answer to the Stackoverflow question "<a href="https://stackoverflow.com/a/9367854/165292">Can I implement a series of reusable tests to test an interface's implementation?</a>"</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span> <span class="arrow"> <a href="#answer_15">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>20</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Chris Ammerman</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Sep 2008 at 16:04</span>
     </div>
    </div>
    <div>
     <blockquote>
      <p>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.</p>
     </blockquote>
     <p>When I first read about LSP, I assumed that this was meant in a very strict sense, essentially equating it to interface implementation and type-safe casting. Which would mean that LSP is either ensured or not by the language itself. For example, in this strict sense, ThreeDBoard is certainly substitutable for Board, as far as the compiler is concerned.</p>
     <p>After reading up more on the concept though I found that LSP is generally interpreted more broadly than that.</p>
     <p>In short, what it means for client code to "know" that the object behind the pointer is of a derived type rather than the pointer type is not restricted to type-safety. Adherence to LSP is also testable through probing the objects actual behavior. That is, examining the impact of an object's state and method arguments on the results of the method calls, or the types of exceptions thrown from the object.</p>
     <p>Going back to the example again, <strong>in theory</strong> the Board methods can be made to work just fine on ThreeDBoard. In practice however, it will be very difficult to prevent differences in behavior that client may not handle properly, without hobbling the functionality that ThreeDBoard is intended to add.</p>
     <p>With this knowledge in hand, evaluating LSP adherence can be a great tool in determining when composition is the more appropriate mechanism for extending existing functionality, rather than inheritance.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_15"><span>Answer 15</span> <span class="arrow"> <a href="#answer_14">↑</a> </span> <span class="arrow"> <a href="#answer_16">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>14</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Rahamath</span>
     </div>
     <div>
      <span> Answered: </span> <span>19 Aug 2019 at 11:55</span>
     </div>
    </div>
    <div>
     <p><strong>The Liskov Substitution Principle</strong></p>
     <ul>
      <li>The overridden method shouldn’t remain empty</li>
      <li>The overridden method shouldn’t throw an error</li>
      <li>Base class or interface behavior should not go for modification (rework) as because of derived class behaviors.</li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_16"><span>Answer 16</span> <span class="arrow"> <a href="#answer_15">↑</a> </span> <span class="arrow"> <a href="#answer_17">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>12</span>
     </div>
     <div>
      <span>Answerer: </span> <span>johannesMatevosyan</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Jan 2020 at 12:19</span>
     </div>
    </div>
    <div>
     <p><a href="https://dev.to/erikwhiting88/liskov-substitution-principle-in-3-minutes-2dc6" rel="noreferrer">The LSP in simple terms</a> states that objects of the same superclass should be able to be <strong>swapped</strong> with each other without breaking anything.</p>
     <p>For example, if we have a <code>Cat</code> and a <code>Dog</code> class derived from an <code>Animal</code> class, any functions using the Animal class should be able to use <code>Cat</code> or <code>Dog</code> and behave normally.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_17"><span>Answer 17</span> <span class="arrow"> <a href="#answer_16">↑</a> </span> <span class="arrow"> <a href="#answer_18">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>10</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Damien Pollet</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Apr 2009 at 00:11</span>
     </div>
    </div>
    <div>
     <p>This formulation of the LSP is way too strong:</p>
     <blockquote>
      <p>If for each object o1 of type S there is an object o2 of type T such that for all programs P deﬁned in terms of T, the behavior of P is unchanged when o1 is substituted for o2, then S is a subtype of T.</p>
     </blockquote>
     <p>Which basically means that S is another, completely encapsulated implementation of the exact same thing as T. And I could be bold and decide that performance is part of the behavior of P...</p>
     <p>So, basically, any use of late-binding violates the LSP. It's the whole point of OO to to obtain a different behavior when we substitute an object of one kind for one of another kind!</p>
     <p>The formulation cited <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="noreferrer">by wikipedia</a> is better since the property depends on the context and does not necessarily include the whole behavior of the program.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>Erm, that formulation is Barbara Liskov's own. Barbara Liskov, “Data Abstraction and Hierarchy,” SIGPLAN Notices, 23,5 (May, 1988). It is not "way too strong", it is "exactly right", and it does not have the implication you think it has. It is strong, but has just the right amount of strength.</span> <span> - </span> <span class="display-name">DrPizza</span> <span> </span> <span class="date">30 Nov 2009 at 07:08</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Then, there are very few subtypes in the real life :)</span> <span> - </span> <span class="display-name">Damien Pollet</span> <span> </span> <span class="date">8 Dec 2009 at 22:26</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>"Behavior is unchanged" does not mean that a subtype will give you the exact same concrete result value(s). It means that the subtype's behavior matches what is expected in the base type. Example: base type Shape could have a draw() method and stipulate that this method should render the shape. Two subtypes of Shape (e.g. Square and Circle) would both implement the draw() method and the results would look different. But as long as the behavior (rendering the shape) matched the specified behavior of Shape, then Square and Circle would be subtypes of Shape in accordance with the LSP.</span> <span> - </span> <span class="display-name">SteveT</span> <span> </span> <span class="date">11 Oct 2012 at 19:38</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_18"><span>Answer 18</span> <span class="arrow"> <a href="#answer_17">↑</a> </span> <span class="arrow"> <a href="#answer_19">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>10</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Alireza Rahmani Khalili</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Aug 2017 at 08:40</span>
     </div>
    </div>
    <div>
     <p>In a very simple sentence, we can say:</p>
     <p>The child class must not violate its base class characteristics. It must be capable with it. We can say it's same as subtyping.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_19"><span>Answer 19</span> <span class="arrow"> <a href="#answer_18">↑</a> </span> <span class="arrow"> <a href="#answer_20">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>10</span>
     </div>
     <div>
      <span>Answerer: </span> <span>GauRang Omar</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 May 2018 at 09:01</span>
     </div>
    </div>
    <div>
     <blockquote>
      <p><strong>Liskov's Substitution Principle(LSP)</strong></p>
      <p>All the time we design a program module and we create some class hierarchies. Then we extend some classes creating some derived classes.</p>
      <p>We must make sure that the new derived classes just extend without replacing the functionality of old classes. Otherwise, the new classes can produce undesired effects when they are used in existing program modules.</p>
      <p>Liskov's Substitution Principle states that if a program module is using a Base class, then the reference to the Base class can be replaced with a Derived class without affecting the functionality of the program module.</p>
     </blockquote>
     <p><strong>Example:</strong></p>
     <p>Below is the classic example for which the Liskov's Substitution Principle is violated. In the example, 2 classes are used: Rectangle and Square. Let's assume that the Rectangle object is used somewhere in the application. We extend the application and add the Square class. The square class is returned by a factory pattern, based on some conditions and we don't know the exact what type of object will be returned. But we know it's a Rectangle. We get the rectangle object, set the width to 5 and height to 10 and get the area. For a rectangle with width 5 and height 10, the area should be 50. Instead, the result will be 100</p>
     <pre><code>    // Violation of Likov's Substitution Principle
class Rectangle {
    protected int m_width;
    protected int m_height;

    public void setWidth(int width) {
        m_width = width;
    }

    public void setHeight(int height) {
        m_height = height;
    }

    public int getWidth() {
        return m_width;
    }

    public int getHeight() {
        return m_height;
    }

    public int getArea() {
        return m_width * m_height;
    }
}

class Square extends Rectangle {
    public void setWidth(int width) {
        m_width = width;
        m_height = width;
    }

    public void setHeight(int height) {
        m_width = height;
        m_height = height;
    }

}

class LspTest {
    private static Rectangle getNewRectangle() {
        // it can be an object returned by some factory ...
        return new Square();
    }

    public static void main(String args[]) {
        Rectangle r = LspTest.getNewRectangle();

        r.setWidth(5);
        r.setHeight(10);
        // user knows that r it's a rectangle.
        // It assumes that he's able to set the width and height as for the base
        // class

        System.out.println(r.getArea());
        // now he's surprised to see that the area is 100 instead of 50.
    }
}
</code></pre>
     <blockquote>
      <p><strong>Conclusion:</strong></p>
      <p>This principle is just an extension of the Open Close Principle and it means that we must make sure that new derived classes are extending the base classes without changing their behavior.</p>
     </blockquote>
     <p>See also: <strong><a href="https://en.wikipedia.org/wiki/Open/closed_principle" rel="noreferrer">Open Close Principle</a></strong></p>
     <p>Some similar concepts for better structure: <a href="https://en.wikipedia.org/wiki/Convention_over_configuration" rel="noreferrer">Convention over configuration</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_20"><span>Answer 20</span> <span class="arrow"> <a href="#answer_19">↑</a> </span> <span class="arrow"> <a href="#answer_21">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>9</span>
     </div>
     <div>
      <span>Answerer: </span> <span>GTRekter</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Mar 2020 at 17:54</span>
     </div>
    </div>
    <div>
     <p>This principle was introduced by <strong>Barbara Liskov</strong> in 1987 and extends the Open-Closed Principle by focusing on the behavior of a superclass and its subtypes.</p>
     <p>Its importance becomes obvious when we consider the consequences of violating it. Consider an application that uses the following class.</p>
     <pre><code>public class Rectangle 
{ 
  private double width;

  private double height; 

  public double Width 
  { 
    get 
    { 
      return width; 
    } 
    set 
    { 
      width = value; 
    }
  } 

  public double Height 
  { 
    get 
    { 
      return height; 
    } 
    set 
    { 
      height = value; 
    } 
  } 
}
</code></pre>
     <p>Imagine that one day, the client demands the ability to manipulate squares in addition to rectangles. Since a square is a rectangle, the square class should be derived from the Rectangle class.</p>
     <pre><code>public class Square : Rectangle
{
} 
</code></pre>
     <p>However, by doing that we will encounter two problems:</p>
     <p>A square does not need both height and width variables inherited from the rectangle and this could create a significant waste in memory if we have to create hundreds of thousands of square objects. The width and height setter properties inherited from the rectangle are inappropriate for a square since the width and height of a square are identical. In order to set both height and width to the same value, we can create two new properties as follows:</p>
     <pre><code>public class Square : Rectangle
{
  public double SetWidth 
  { 
    set 
    { 
      base.Width = value; 
      base.Height = value; 
    } 
  } 

  public double SetHeight 
  { 
    set 
    { 
      base.Height = value; 
      base.Width = value; 
    } 
  } 
}
</code></pre>
     <p>Now, when someone will set the width of a square object, its height will change accordingly and vice-versa.</p>
     <pre><code>Square s = new Square(); 
s.SetWidth(1); // Sets width and height to 1. 
s.SetHeight(2); // sets width and height to 2. 
</code></pre>
     <p>Let's move forward and consider this other function:</p>
     <pre><code>public void A(Rectangle r) 
{ 
  r.SetWidth(32); // calls Rectangle.SetWidth 
} 
</code></pre>
     <p>If we pass a reference to a square object into this function, we would violate the LSP because the function does not work for derivatives of its arguments. The properties width and height aren't polymorphic because they aren't declared virtual in rectangle (the square object will be corrupted because the height won't be changed).</p>
     <p>However, by declaring the setter properties to be virtual we will face another violation, the OCP. In fact, the creation of a derived class square is causing changes to the base class rectangle.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>In method <code>A()</code> I think you meant <code>r.Width = 32;</code> since a <code>Rectangle</code> doesn't have a <code>SetWidth()</code> method.</span> <span> - </span> <span class="display-name">wired_in</span> <span> </span> <span class="date">12 Oct 2020 at 21:02</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_21"><span>Answer 21</span> <span class="arrow"> <a href="#answer_20">↑</a> </span> <span class="arrow"> <a href="#answer_22">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>aknon</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Dec 2013 at 05:20</span>
     </div>
    </div>
    <div>
     <p>Some addendum:<br>
       I wonder why didn't anybody write about the Invariant , preconditions and post conditions of the base class that must be obeyed by the derived classes. For a derived class D to be completely sustitutable by the Base class B, class D must obey certain conditions:</p>
     <ul>
      <li>In-variants of base class must be preserved by the derived class</li>
      <li>Pre-conditions of the base class must not be strengthened by the derived class</li>
      <li>Post-conditions of the base class must not be weakened by the derived class.</li>
     </ul>
     <p>So the derived must be aware of the above three conditions imposed by the base class. Hence, the rules of subtyping are pre-decided. Which means, 'IS A' relationship shall be obeyed only when certain rules are obeyed by the subtype. These rules, in the form of invariants, precoditions and postcondition, should be decided by a formal '<a href="http://en.wikipedia.org/wiki/Design_by_contract" rel="noreferrer">design contract</a>'.</p>
     <p>Further discussions on this available at my blog: <a href="http://design-principle-pattern.blogspot.in/2013/12/liskov-substitution-principle.html" rel="noreferrer">Liskov Substitution principle</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_22"><span>Answer 22</span> <span class="arrow"> <a href="#answer_21">↑</a> </span> <span class="arrow"> <a href="#answer_23">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Sarmad Sohail</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Nov 2020 at 05:09</span>
     </div>
    </div>
    <div>
     <p>It states that if C is a subtype of E then E can be replaced with objects of type C without changing or breaking the behavior of the program. In simple words, derived classes should be substitutable for their parent classes. For example, if a <strong>Farmer’s son</strong> is Farmer then he can work in place of his father but if a <strong>Farmer’s son</strong> is a cricketer then he can’t work in place of his father.</p>
     <h3>Violation Example:</h3>
     <pre><code>public class Plane{

  public void startEngine(){}      

}        
public class FighterJet extends Plane{}
    
public class PaperPlane extends Plane{}
</code></pre>
     <p>In the given example <code>FighterPlane</code> and <code>PaperPlane</code> classes both extending the <code>Plane</code> class which contain <code>startEngine()</code> method. So it's clear that <code>FighterPlane</code> can start engine but <code>PaperPlane</code> can’t so it’s breaking <code>LSP</code>.</p>
     <p><code>PaperPlane</code> class although extending <code>Plane</code> class and should be substitutable in place of it but is not an eligible entity that Plane’s instance could be replaced by, because a paper plane can’t start the engine as it doesn’t have one. So the good example would be,</p>
     <h3>Respected Example:</h3>
     <pre><code>public class Plane{ 
} 
public class RealPlane{

  public void startEngine(){} 

}
public class FighterJet extends RealPlane{} 
public class PaperPlane extends Plane{}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>In essence, another way to word it is: All of the methods residing in a super class, need to appropriately apply to all of its sub classes. However this would only be one criteria of the substitution principle.</span> <span> - </span> <span class="display-name">Rstew</span> <span> </span> <span class="date">15 Aug 2021 at 14:17</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_23"><span>Answer 23</span> <span class="arrow"> <a href="#answer_22">↑</a> </span> <span class="arrow"> <a href="#answer_24">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Wouter</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Jul 2015 at 21:56</span>
     </div>
    </div>
    <div>
     <p>A square is a rectangle where the width equals the height. If the square sets two different sizes for the width and height it violates the square invariant. This is worked around by introducing side effects. But if the rectangle had a setSize(height, width) with precondition 0 &lt; height and 0 &lt; width. The derived subtype method requires height == width; a stronger precondition (and that violates lsp). This shows that though square is a rectangle it is not a valid subtype because the precondition is strengthened. The work around (in general a bad thing) cause a side effect and this weakens the post condition (which violates lsp). setWidth on the base has post condition 0 &lt; width. The derived weakens it with height == width.</p>
     <p>Therefore a resizable square is not a resizable rectangle.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_24"><span>Answer 24</span> <span class="arrow"> <a href="#answer_23">↑</a> </span> <span class="arrow"> <a href="#answer_25">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>jferard</span>
     </div>
     <div>
      <span> Answered: </span> <span>20 Sep 2021 at 10:50</span>
     </div>
    </div>
    <div>
     <p>The big picture :</p>
     <ul>
      <li>What is Liskov Substitution Principle about ? It's about what is (and what is not) a <strong>subtype</strong> of a given type.</li>
      <li>Why is it so important ? Because there is a difference between a <strong>subtype</strong> and a <strong>subclass</strong>.</li>
     </ul>
     <h1>Example</h1>
     <p>Unlike the other answers, I won't start with a Liskov Substitution Principle (LSP) violation, but with a LSP compliance. I use Java but it would be almost the same in every OOP language.</p>
     <h2><code>Circle</code> and <code>ColoredCircle</code></h2>
     <p>Geometrical examples seem pretty popular here.</p>
     <pre><code>class Circle {
    private int radius;

    public Circle(int radius) {
        if (radius &lt; 0) {
            throw new RuntimeException("Radius should be &gt;= 0");
        }
        this.radius = radius;
    }

    public int getRadius() {
        return this.radius;
    }
}
</code></pre>
     <p>The radius is not allowed to be negative. Here's a suclass:</p>
     <pre><code>class ColoredCircle extends Circle {
    private Color color; // defined elsewhere

    public ColoredCircle(int radius, Color color) {
        super(radius);
        this.color = color;
    }

    public Color getColor() {
        return this.color;
    }
}
</code></pre>
     <p>This subclass is a subtype of <code>Circle</code>, according to the LSP.</p>
     <p>The LSP states that:</p>
     <blockquote>
      <p>If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2, then S is a subtype of T. <em>(Barbara Liskov, "Data Abstraction and Hierarchy", SIGPLAN Notices, 23,5 (May, 1988))</em></p>
     </blockquote>
     <p>Here, for each <code>ColoredCircle</code> instance <code>o1</code>, consider the <code>Circle</code> instance having the same radius <code>o2</code>. For every program using <code>Circle</code> objects, if you replace <code>o2</code> by <code>o1</code>, the behavior of any program using <code>Circle</code> will remain the same after the substitution. (Note that this is theoretical : you will exhaust the memory faster using <code>ColoredCircle</code> instances than using <code>Circle</code> instances, but that's not relevant here.)</p>
     <p>How do we find the <code>o2</code> depending on <code>o1</code> ? We just strip the <code>color</code> attribute and keep the <code>radius</code> attribute. I call the transformation <code>o1</code> -&gt; <code>o2</code> a <em>projection</em> from the <code>CircleColor</code> space on the <code>Circle</code> space.</p>
     <h1>Counter Example</h1>
     <p>Let's create another example to illustrate the violation of the LSP.</p>
     <h2><code>Circle</code> and <code>Square</code></h2>
     <p>Imagine this subclass of the previous <code>Circle</code> class:</p>
     <pre><code>class Square extends Circle {
    private int sideSize;

    public Square(int sideSize) {
        super(0);
        this.sideSize = sideSize;
    }

    @Override
    public int getRadius() {
        return -1; // I'm a square, I don't care
    }

    public int getSideSize() {
        return this.sideSize;
    }
}
</code></pre>
     <h2>The violation of the LSP</h2>
     <p>Now, look at this program :</p>
     <pre><code>public class Liskov {
    public static void program(Circle c) {
        System.out.println("The radius is "+c.getRadius());
    }
</code></pre>
     <p>We test the program with a <code>Circle</code> object and with a <code>Square</code> object.</p>
     <pre><code>    public static void main(String [] args){
        Liskov.program(new Circle(2)); // prints "The radius is 2"
        Liskov.program(new Square(2)); // prints "The radius is -1"
    }
}
</code></pre>
     <p>What happened ? Intuitively, although <code>Square</code> is a subclass of <code>Circle</code>, <code>Square</code> is <em>not</em> a subtype of <code>Circle</code> because no regular <code>Circle</code> instance would ever have a radius of -1.</p>
     <p>Formally, this is a violation of Liskov Substitution Principle.</p>
     <p>We have a program defined in terms of <code>Circle</code> and there is no <code>Circle</code> object that can replace <code>new Square(2)</code> (or any <code>Square</code> instance by the way) in this program and leave the behavior unchanged: remember that radius of any <code>Circle</code> is always positive.</p>
     <h1>Subclass and subtype</h1>
     <p>Now we know why a <strong>subclass</strong> is not always <strong>subtype</strong>. When a subclass is not a subtype, i.e. when there is a LSP violation, the behavior of some programs (at least one) won't always be the expected behavior. This is very frustrating and is usually interpreted as a bug.</p>
     <p>In an ideal world, the compiler or interpreter would be able to check is a given subclass is a real subtype, but we are not in an ideal world.</p>
     <h2>Static typing</h2>
     <p>If there is some static typing, you are bound by the superclass signature at compile time. <code>Square.getRadius()</code> can't return a <code>String</code> or a <code>List</code>.</p>
     <p>If there is no static typing, you'll get an error at runtime if the type of one argument is wrong (unless the typing is weak) or the number of arguments is inconsistent (unless the language is very permissive).</p>
     <p><em>Note about the static typing: there is a mechanism of covariance of the return type (a method of S can return a subclass of the return type of the same method of T) and contravariance of the parameters types (a method of S can accept a superclass of a parameter of the same parameter of the same method of T). That is a specific case of precondition and postcondition explained below.</em></p>
     <h2>Design by contract</h2>
     <p>There's more. Some languages (I think of Eiffel) provide a mechanism to enforce the compliance with the LSP.</p>
     <p>Let alone the determination the projection <code>o2</code> of the initial object <code>o1</code>, we can expect the same behavior of any program if <code>o1</code> is substituted for <code>o2</code> if, <strong>for any argument <code>x</code> and any method <code>f</code></strong>:</p>
     <ul>
      <li>if <code>o2.f(x)</code> is a valid call, then <code>o1.f(x)</code> should also be a valid call (1).</li>
      <li>the result (return value, display on console, etc.) of <code>o1.f(x)</code> should be equal to the result of <code>o2.f(x)</code>, or at least equally valid (2).</li>
      <li><code>o1.f(x)</code> should let <code>o1</code> in an internal state and <code>o2.f(x)</code> should let <code>o2</code> in an internal state so that next function calls will ensure that (1), (2) and (3) will still be valid (3).</li>
     </ul>
     <p>(<em>Note that (3) is given for free if the function <code>f</code> is pure. That's why we like to have immutable objects.</em>)</p>
     <p>These conditions are about the <strong>semantics</strong> (what to expect) of the class, not only the syntax of the class. Also, these conditions are very strong. But they can be approximated by assertions in design by contract programming. These assertions are a way to ensure that the semantic of the type is upheld. Breaking the contract leads to runtime errors.</p>
     <ul>
      <li>The precondition defines what is a valid call. When subclassing a class, the precondition may only be weakened (<code>S.f</code> accepts more than <code>T.f</code>) (a).</li>
      <li>The postcondition defines what is a valid result. When subclassing a class, the postcondition may only be strengthened (<code>S.f</code> provides more than <code>T.f</code>) (b).</li>
      <li>The invariant defines what is a valid internal state. When subclassing a class, the invariant must remain the same (c).</li>
     </ul>
     <p>We see that, roughly, (a) ensures (1) and (b) ensures (2), but (c) is weaker than (3). Moreover, assertions are sometimes difficult to express.</p>
     <p>Think of a class <code>Counter</code> having a unique method <code>Counter.counter()</code> that returns the next integer. How do you write a postcondition for that ? Think of a class <code>Random</code> having a method <code>Random.gaussian()</code> that returns a float between 0.0 and 1.0 . How do you write a postcondition to check that the distribution is gaussian ? It may be possible, but the cost would be so high that we would rely on test rather than on postconditions.</p>
     <h1>Conclusion</h1>
     <p>Unfortunately, a subclass is not always a subtype. This can lead to an unexpected behavior -- a bug.</p>
     <p>OOP languages provide mechanism to avoid this situation. At syntactic level first. At semantical level too, depending on the programming language: a part of the semantics can be encoded in the text of the program using assertions. But it's up to you to ensure that a subclass is a subtype.</p>
     <p>Remember when you began to learn OOP ? "If the relation is IS-A, then use inheritance". That's true the other way: <strong>if you use inheritance, be sure that the relation is IS-A</strong>.</p>
     <p>The LSP defines, at a higher level than assertions, what is a subtype. Assertions are a valuable tool to ensure that the LSP is upheld.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_25"><span>Answer 25</span> <span class="arrow"> <a href="#answer_24">↑</a> </span> <span class="arrow"> <a href="#answer_26">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Tom Hawtin - tackline</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Sep 2008 at 15:28</span>
     </div>
    </div>
    <div>
     <p>Would implementing ThreeDBoard in terms of an array of Board be that useful?</p>
     <p>Perhaps you may want to treat slices of ThreeDBoard in various planes as a Board. In that case you may want to abstract out an interface (or abstract class) for Board to allow for multiple implementations.</p>
     <p>In terms of external interface, you might want to factor out a Board interface for both TwoDBoard and ThreeDBoard (although none of the above methods fit).</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>I think the example is simply to demonstrate that inheriting from board does not make sense with in the context of ThreeDBoard and all of the method signatures are meaningless with a Z axis.</span> <span> - </span> <span class="display-name">NotMyself</span> <span> </span> <span class="date">11 Sep 2008 at 15:32</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_26"><span>Answer 26</span> <span class="arrow"> <a href="#answer_25">↑</a> </span> <span class="arrow"> <a href="#answer_27">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Prasa</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 May 2016 at 19:34</span>
     </div>
    </div>
    <div>
     <p>The clearest explanation for LSP I found so far has been "The Liskov Substitution Principle says that the object of a derived class should be able to replace an object of the base class without bringing any errors in the system or modifying the behavior of the base class" from <a href="http://www.infragistics.com/community/blogs/dhananjay_kumar/archive/2015/06/30/simplifying-the-liskov-substitution-principle-of-solid-in-c.aspx" rel="nofollow">here</a>. The article gives code example for violating LSP and fixing it.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>Please provide the examples of code on stackoverflow.</span> <span> - </span> <span class="display-name">sebenalern</span> <span> </span> <span class="date">3 May 2016 at 19:51</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_27"><span>Answer 27</span> <span class="arrow"> <a href="#answer_26">↑</a> </span> <span class="arrow"> <a href="#answer_28">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>inf3rno</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Oct 2017 at 04:26</span>
     </div>
    </div>
    <div>
     <p>Let's say we use a rectangle in our code</p>
     <pre><code>r = new Rectangle();
// ...
r.setDimensions(1,2);
r.fill(colors.red());
canvas.draw(r);
</code></pre>
     <p>In our geometry class we learned that a square is a special type of rectangle because its width is the same length as its height. Let's make a <code>Square</code> class as well based on this info:</p>
     <pre><code>class Square extends Rectangle {
    setDimensions(width, height){
        assert(width == height);
        super.setDimensions(width, height);
    }
} 
</code></pre>
     <p>If we replace the <code>Rectangle</code> with <code>Square</code> in our first code, then it will break:</p>
     <pre><code>r = new Square();
// ...
r.setDimensions(1,2); // assertion width == height failed
r.fill(colors.red());
canvas.draw(r);
</code></pre>
     <p>This is because the <code>Square</code> has a new precondition we did not have in the <code>Rectangle</code> class: <code>width == height</code>. According to LSP the <code>Rectangle</code> instances should be substitutable with <code>Rectangle</code> subclass instances. This is because these instances pass the type check for <code>Rectangle</code> instances and so they will cause unexpected errors in your code.</p>
     <p>This was an example for the <em>"preconditions cannot be strengthened in a subtype"</em> part in the <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="nofollow noreferrer">wiki article</a>. So to sum up, violating LSP will probably cause errors in your code at some point.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_28"><span>Answer 28</span> <span class="arrow"> <a href="#answer_27">↑</a> </span> <span class="arrow"> <a href="#answer_29">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Zahra.HY</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Apr 2019 at 12:55</span>
     </div>
    </div>
    <div>
     <p>LSP says that ''Objects should be replaceable by their subtypes''. On the other hand, this principle points to</p>
     <blockquote>
      <p>Child classes should never break the parent class`s type definitions.</p>
     </blockquote>
     <p>and the following example helps to have a better understanding of LSP.</p>
     <p>Without LSP:</p>
     <pre><code>public interface CustomerLayout{

    public void render();
}


public FreeCustomer implements CustomerLayout {
     ...
    @Override
    public void render(){
        //code
    }
}


public PremiumCustomer implements CustomerLayout{
    ...
    @Override
    public void render(){
        if(!hasSeenAd)
            return; //it isn`t rendered in this case
        //code
    }
}

public void renderView(CustomerLayout layout){
    layout.render();
}
</code></pre>
     <p>Fixing by LSP:</p>
     <pre><code>public interface CustomerLayout{
    public void render();
}


public FreeCustomer implements CustomerLayout {
     ...
    @Override
    public void render(){
        //code
    }
}


public PremiumCustomer implements CustomerLayout{
    ...
    @Override
    public void render(){
        if(!hasSeenAd)
            showAd();//it has a specific behavior based on its requirement
        //code
    }
}

public void renderView(CustomerLayout layout){
    layout.render();
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_29"><span>Answer 29</span> <span class="arrow"> <a href="#answer_28">↑</a> </span> <span class="arrow"> <a href="#answer_30">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ryszard Dżegan</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Sep 2013 at 07:32</span>
     </div>
    </div>
    <div>
     <p>I encourage you to read the article: <a href="http://www.codeproject.com/Articles/648987/Violating-Liskov-Substitution-Principle-LSP" rel="nofollow">Violating Liskov Substitution Principle (LSP)</a>.</p>
     <p>You can find there an explanation what is the Liskov Substitution Principle, general clues helping you to guess if you have already violated it and an example of approach that will help you to make your class hierarchy be more safe.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_30"><span>Answer 30</span> <span class="arrow"> <a href="#answer_29">↑</a> </span> <span class="arrow"> <a href="#answer_31">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Raghu Reddy Muttana</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Aug 2016 at 17:16</span>
     </div>
    </div>
    <div>
     <p>LISKOV SUBSTITUTION PRINCIPLE (From Mark Seemann book) states that we should be able to replace one implementation of an interface with another without breaking either client or implementation.It’s this principle that enables to address requirements that occur in the future, even if we can’t foresee them today.</p>
     <p>If we unplug the computer from the wall (Implementation), neither the wall outlet (Interface) nor the computer (Client) breaks down (in fact, if it’s a laptop computer, it can even run on its batteries for a period of time). With software, however, a client often expects a service to be available. If the service was removed, we get a NullReferenceException. To deal with this type of situation, we can create an implementation of an interface that does “nothing.” This is a design pattern known as Null Object,[4] and it corresponds roughly to unplugging the computer from the wall. Because we’re using loose coupling, we can replace a real implementation with something that does nothing without causing trouble.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_31"><span>Answer 31</span> <span class="arrow"> <a href="#answer_30">↑</a> </span> <span class="arrow"> <a href="#answer_32">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ishan Aggarwal</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Sep 2017 at 19:26</span>
     </div>
    </div>
    <div>
     <p>Likov's Substitution Principle states that <em>if a program module is using a Base class, then the reference to the Base class can be replaced with a Derived class without affecting the functionality of the program module.</em></p>
     <p>Intent - Derived types must be completely substitute able for their base types.</p>
     <p>Example - Co-variant return types in java.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_32"><span>Answer 32</span> <span class="arrow"> <a href="#answer_31">↑</a> </span> <span class="arrow"> <a href="#answer_33">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Vadim Samokhin</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Aug 2018 at 17:10</span>
     </div>
    </div>
    <div>
     <p>Here is an excerpt from <a href="https://dzone.com/articles/liskov-substitution-principle-or-how-to-create-bea" rel="nofollow noreferrer">this post</a> that clarifies things nicely:</p>
     <p>[..] in order to comprehend some principles, it’s important to realize when it’s been violated. This is what I will do now.</p>
     <p>What does the violation of this principle mean? It implies that an object doesn’t fulfill the contract imposed by an abstraction expressed with an interface. In other words, it means that you identified your abstractions wrong.</p>
     <p>Consider the following example:</p>
     <pre><code>interface Account
{
    /**
     * Withdraw $money amount from this account.
     *
     * @param Money $money
     * @return mixed
     */
    public function withdraw(Money $money);
}
class DefaultAccount implements Account
{
    private $balance;
    public function withdraw(Money $money)
    {
        if (!$this-&gt;enoughMoney($money)) {
            return;
        }
        $this-&gt;balance-&gt;subtract($money);
    }
}
</code></pre>
     <p>Is this a violation of LSP? Yes. This is because the account’s contract tells us that an account would be withdrawn, but this is not always the case. So, what should I do in order to fix it? I just modify the contract:</p>
     <pre><code>interface Account
{
    /**
     * Withdraw $money amount from this account if its balance is enough.
     * Otherwise do nothing.
     *
     * @param Money $money
     * @return mixed
     */
    public function withdraw(Money $money);
}
</code></pre>
     <p>Voilà, now the contract is satisfied.</p>
     <p>This subtle violation often imposes a client with the ability to tell the difference between concrete objects employed. For example, given the first Account’s contract, it could look like the following:</p>
     <pre><code>class Client
{
    public function go(Account $account, Money $money)
    {
        if ($account instanceof DefaultAccount &amp;&amp; !$account-&gt;hasEnoughMoney($money)) {
            return;
        }
        $account-&gt;withdraw($money);
    }
}
</code></pre>
     <p>And, this automatically violates the open-closed principle [that is, for money withdrawal requirement. Because you never know what happens if an object violating the contract doesn't have enough money. Probably it just returns nothing, probably an exception will be thrown. So you have to check if it <code>hasEnoughMoney()</code> -- which is not part of an interface. So this forced concrete-class-dependent check is an OCP violation].</p>
     <p>This point also addresses a misconception that I encounter quite often about LSP violation. It says the “if a parent’s behavior changed in a child, then, it violates LSP.” However, it doesn’t — as long as a child doesn’t violate its parent’s contract.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_33"><span>Answer 33</span> <span class="arrow"> <a href="#answer_32">↑</a> </span> <span class="arrow"> <a href="#answer_34">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>yoAlex5</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Nov 2020 at 15:08</span>
     </div>
    </div>
    <div>
     <p><strong>Liskov Substitution Principle</strong></p>
     <p><a href="https://stackoverflow.com/a/66087638/4770877">[SOLID]</a></p>
     <p><strong>Inheritance</strong> Subtyping</p>
     <p><a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="nofollow noreferrer">Wiki Liskov substitution principle (LSP)</a></p>
     <blockquote>
      <p>Preconditions cannot be strengthened in a subtype.<br>
        Postconditions cannot be weakened in a subtype.<br>
        Invariants of the supertype must be preserved in a subtype.</p>
     </blockquote>
     <ul>
      <li>Subtype should not require(Preconditions) from caller more than supertype</li>
      <li>Subtype should not expose(Postconditions) for caller less than supertype</li>
     </ul>
     <p>*Precondition + Postcondition = <code>function (method) types</code><sup><a href="https://stackoverflow.com/a/60988242/4770877">[Swift Function type. Swift function vs method]</a></sup></p>
     <pre><code>//Swift function
func foo(parameter: Class1) -&gt; Class2

//function type
(Class1) -&gt; Class2

//Precondition
Class1

//Postcondition
Class2
</code></pre>
     <p>Example</p>
     <pre><code>//C3 -&gt; C2 -&gt; C1

class C1 {}
class C2: C1 {}
class C3: C2 {}
</code></pre>
     <ul>
      <li>
       <p>Preconditions(e.g. function <code>parameter type</code>) can be the same or <strong>weaker</strong>(strives for -&gt; C1)</p></li>
      <li>
       <p>Postconditions(e.g. function <code>returned type</code>) can be the same or <strong>stronger</strong>(strives for -&gt; C3)</p></li>
      <li>
       <p>Invariant variable<a href="https://stackoverflow.com/a/64788342/4770877"><sup>[About]</sup></a> of super type should stay invariant</p></li>
     </ul>
     <p>Swift</p>
     <pre><code>class A {
    func foo(a: C2) -&gt; C2 {
        return C2()
    }
}

class B: A {
    override func foo(a: C1) -&gt; C3 {
        return C3()
    }
}
</code></pre>
     <p>Java</p>
     <pre><code>class A {
    public C2 foo(C2 a) {
        return new C2();
    }
}

class B extends A {
    @Override
    public C3 foo(C2 a) { //You are available pass only C2 as parameter
        return new C3();
    }
}
</code></pre>
     <p><strong>Behavioral subtyping</strong></p>
     <p><a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="nofollow noreferrer">Wiki Liskov substitution principle (LSP)</a></p>
     <blockquote>
      <p>Contravariance of method parameter types in the subtype. <br>
        Covariance of method return types in the subtype. <br>
        New exceptions cannot be thrown by the methods in the subtype, except if they are subtypes of exceptions thrown by the methods of the supertype.</p>
     </blockquote>
     <p><a href="https://stackoverflow.com/a/62752867/4770877">[Variance, Covariance, Contravariance, Invariance]</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_34"><span>Answer 34</span> <span class="arrow"> <a href="#answer_33">↑</a> </span> <span class="arrow"> <a href="#answer_35">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>prady00</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Apr 2019 at 06:59</span>
     </div>
    </div>
    <div>
     <p>Let me try, consider an interface:</p>
     <pre><code>interface Planet{
}
</code></pre>
     <p>This is implemented by class:</p>
     <pre><code>class Earth implements Planet {
    public $radius;
    public function construct($radius) {
        $this-&gt;radius = $radius;
    }
}
</code></pre>
     <p>You will use Earth as:</p>
     <pre><code>$planet = new Earth(6371);
$calc = new SurfaceAreaCalculator($planet);
$calc-&gt;output();
</code></pre>
     <p>Now consider one more class which extends Earth:</p>
     <pre><code>class LiveablePlanet extends Earth{
   public function color(){
   }
}
</code></pre>
     <p>Now according to LSP, you should be able to use LiveablePlanet in place of Earth and it should not break your system. Like:</p>
     <pre><code>$planet = new LiveablePlanet(6371);  // Earlier we were using Earth here
$calc = new SurfaceAreaCalculator($planet);
$calc-&gt;output();
</code></pre>
     <p>Examples taken from <a href="https://bootsity.com/php/understanding-the-solid-principles-of-software-engineering" rel="nofollow noreferrer">here</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>Poor example. <code>Earth</code> is an instance of <code>plant</code>, why would it get derived from it?</span> <span> - </span> <span class="display-name">zar</span> <span> </span> <span class="date">3 May 2019 at 15:46</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_35"><span>Answer 35</span> <span class="arrow"> <a href="#answer_34">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>mathematics-and-caffeine</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Dec 2021 at 23:53</span>
     </div>
    </div>
    <div>
     <blockquote>
      <p>Let q(x) be a property provable about objects of x of type T. Then q(y) should be provable for objects y of type S where S is a subtype of T.</p>
     </blockquote>
     <hr>
     <p>Actually, the accepted answer is not a counterexample for the Liskov principle. A square naturally is a specific rectangle, so it makes perfect sense that inherits from the class rectangle. You simply need to implement it in this way:</p>
     <pre><code>@Override
public void setHeight(double height) {
   this.height = height;
   this.width = height; // since it's a square
}

@Override
public void setWidth(double width) {
   setHeight(width);
}
</code></pre>
     <hr>
     <p>So, having provided a good example, this, however, is a counterexample:</p>
     <pre><code>class Family:
-- getChildrenCount()

class FamilyWithKids extends Family:
-- getChildrenCount() { return childrenCount; } // always &gt; 0

class DeadFamilyWithKids extends FamilyWithKids:
-- getChildrenCount() { return 0; }
-- getChildrenCountWhenAlive() { return childrenCountWhenAlive; }
</code></pre>
     <p>In this implementation, <code>DeadFamilyWithKids</code> cannot inherit from <code>FamilyWithKids</code> since <code>getChildrenCount()</code> returns <code>0</code>, while from <code>FamilyWithKids</code> it should always return something greater <code>0</code>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>