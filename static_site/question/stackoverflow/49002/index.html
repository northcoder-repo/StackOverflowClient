<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Prefer composition over inheritance?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>Prefer composition over inheritance?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>1954</span>
    </div>
    <div>
     <span>Asker: </span> <span>readonly</span>
    </div>
    <div>
     <span>Asked: </span> <span>8 Sep 2008 at 01:58</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/49002/prefer-composition-over-inheritance">source</a>
    </div>
   </div>
   <div>
    <p>Why prefer <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance" rel="noreferrer"><em>composition</em> instead of <em>inheritance</em></a>? What trade-offs are there for each approach? And the converse question: when should I choose <em>inheritance</em> instead of <em>composition</em>?</p>
   </div>
   <div class="tags">
    <span class="tag">language-agnostic</span><span class="tag">oop</span><span class="tag">inheritance</span><span class="tag">composition</span><span class="tag">aggregation</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>6</td>
       <td><span>See also <a href="http://stackoverflow.com/questions/38820/which-class-design-is-better">which class design is better</a></span> <span> - </span> <span class="display-name">maccullt</span> <span> </span> <span class="date">10 Sep 2008 at 02:22</span></td>
      </tr>
      <tr>
       <td>6</td>
       <td><span>in one sentence inheritance is public if you have a public method and you change it it changes the published api. if you have composition and the object composed has changed you don't have to change your published api.</span> <span> - </span> <span class="display-name">Tomer Ben David</span> <span> </span> <span class="date">26 Aug 2015 at 11:00</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>This is a good read on the topic: <a href="https://medium.com/geekculture/composition-vs-inheritance-pros-and-cons-ff1797d72f68" rel="nofollow noreferrer">Medium.com: Composition vs. Inheritance: Pros and Cons</a></span> <span> - </span> <span class="display-name">Gabriel Staples</span> <span> </span> <span class="date">9 Mar 2023 at 06:50</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1428</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Gishu</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Sep 2008 at 03:04</span>
     </div>
    </div>
    <div>
     <p><em>Prefer composition over inheritance as it is more malleable / easy to modify later, but do not use a compose-always approach.</em> With composition, it's easy to change behavior on the fly with Dependency Injection / Setters. Inheritance is more rigid as most languages do not allow you to derive from more than one type. So the goose is more or less cooked once you derive from TypeA.</p>
     <p>My acid test for the above is:</p>
     <ul>
      <li>
       <p>Does TypeB want to expose the complete interface (all public methods no less) of TypeA such that TypeB can be used where TypeA is expected? Indicates <strong>Inheritance</strong>.</p>
       <ul>
        <li>e.g. A Cessna biplane will expose the complete interface of an airplane, if not more. So that makes it fit to derive from Airplane.</li>
       </ul></li>
      <li>
       <p>Does TypeB want only some/part of the behavior exposed by TypeA? Indicates need for <strong>Composition.</strong></p>
       <ul>
        <li>e.g. A Bird may need only the fly behavior of an Airplane. In this case, it makes sense to extract it out as an interface / class / both and make it a member of both classes.</li>
       </ul></li>
     </ul>
     <p><strong>Update:</strong> Just came back to my answer and it seems now that it is incomplete without a specific mention of Barbara Liskov's <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="noreferrer">Liskov Substitution Principle</a> as a test for 'Should I be inheriting from this type?'</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>110</td>
        <td><span>The second example is straight out of the Head First Design Patterns (<a href="https://rads.stackoverflow.com/amzn/click/com/0596007124" rel="nofollow noreferrer">amazon.com/First-Design-Patterns-Elisabeth-Freeman/dp/…</a>) book :) I would highly recommend that book to anyone who was googling this question.</span> <span> - </span> <span class="display-name">Jeshurun</span> <span> </span> <span class="date">22 Jun 2011 at 04:59</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>It's very clear, but it may miss something : "Does TypeB want to expose the complete interface (all public methods no less) of TypeA such that TypeB can be used where TypeA is expected?" But what if this is true, and TypeB also expose the complete interface of TypeC ? And what if TypeC hasn't been modeled yet ?</span> <span> - </span> <span class="display-name">Tristan</span> <span> </span> <span class="date">26 Aug 2011 at 12:04</span></td>
       </tr>
       <tr>
        <td>8</td>
        <td><span>You allude to what I think should be the most basic test: "Should this object be usable by code which expects objects of (what would be) the base type". If the answer is yes, the object <i>must</i> inherit. If no, then it probably should not. If I had my druthers, languages would provide a keyword to refer to "this class", and provide a means of defining a class which should behave just like another class, but not be substitutable for it (such a class would have all "this class" references replaced with itself).</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">8 Dec 2011 at 16:16</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>"Cessna biplane will expose the complete interface of an airplane" does not look like a good analogy to me, and makes me think of <a href="http://en.wikipedia.org/wiki/Circle-ellipse_problem" rel="nofollow noreferrer">"square-rectangle problem"</a>. Is "airplane" here an abstract class, one that does not fly and only has some specifications on paper? I prefer to think of inheritance examples like: "RedToyota &lt; UnpaintedToyota &lt; ToyotaChassis".</span> <span> - </span> <span class="display-name">Alexey</span> <span> </span> <span class="date">27 Oct 2012 at 20:35</span></td>
       </tr>
       <tr>
        <td>32</td>
        <td><span>@Alexey - the point is 'Can I pass in a Cessna biplane to all clients that expect an airplane without surprising them?'. If yes, then chances are you want inheritance.</span> <span> - </span> <span class="display-name">Gishu</span> <span> </span> <span class="date">28 Oct 2012 at 04:18</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Gishu, thanks for the clarification. However, my opinion is that a producer cannot build just an "airplane", but a producer can build a Toyota chassis. So "airplane" here looks like it serves as an abstract class, that is like an "interface" for customer. I was trying to think of a good analogy of inheritance of ready-to-use classes. I've heard that OOP originated in an attempt to model states and changes of states of real-life objects, but IMO in real life it makes no sense to say that Bus and Motorcycle inherit from MotorVehicle.</span> <span> - </span> <span class="display-name">Alexey</span> <span> </span> <span class="date">28 Oct 2012 at 08:06</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>About airplane analogy, i would prefer: CessnaBiplanePilot &lt; PilotSchoolStudent.</span> <span> - </span> <span class="display-name">Alexey</span> <span> </span> <span class="date">28 Oct 2012 at 09:09</span></td>
       </tr>
       <tr>
        <td>10</td>
        <td><span>I'm actually struggling to think of any examples where inheritance would have been my answer, I often find aggregation, composition and interfaces result in more elegant solutions. Many of the above examples could possibly be better explained using those approaches...</span> <span> - </span> <span class="display-name">Stuart Wakefield</span> <span> </span> <span class="date">23 Nov 2012 at 11:33</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@supercat your comment is a good way to explain how to make the choice. If you cannot change the type of object a method accepts, then you are forced to subclass. Otherwise composition is preferred.</span> <span> - </span> <span class="display-name">Kelvin</span> <span> </span> <span class="date">10 May 2013 at 17:10</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Alexey: your example fails the "is a" test: RedToyota is not a ToyotaChassis, so RedToyota shouldn't inherit from ToyotaChassis. Likewise, CessnaBiplanePilot "is a" PilotSchoolStudent is also wrong.</span> <span> - </span> <span class="display-name">Lie Ryan</span> <span> </span> <span class="date">25 May 2013 at 14:48</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Lie Ryan: i think it depends on what is understood by "is a" (can you give a formal definition?). A square is a rectangle, but in certain contexts you cannot inherit <code>Square</code> from <code>Rectangle</code> (<a href="http://en.wikipedia.org/wiki/Circle-ellipse_problem" rel="nofollow noreferrer">en.wikipedia.org/wiki/Circle-ellipse_problem</a>). I am not convinced that without further precisions "is a" is a meaningful test.</span> <span> - </span> <span class="display-name">Alexey</span> <span> </span> <span class="date">26 May 2013 at 10:31</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>I can say that RedToyota is a ToyotaChassis with some stuff mounded on it (which i may not need). And i can say that CessnaBiplanePilot knows at least as much as an average PilotSchoolStudent, and could take notes or pass exams in his place.</span> <span> - </span> <span class="display-name">Alexey</span> <span> </span> <span class="date">26 May 2013 at 10:51</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Alexey: I think there's no controversy about the definition of "is a" test, it's supposed to mean "A is a (kind of) B". What is controversial is whether or not "Square is a Rectangle" depends on what you meant by Square and Rectangle. One you've properly defined the properties you want out of a Square and a Rectangle, the Circle-Ellipse problem will have an obvious solution.</span> <span> - </span> <span class="display-name">Lie Ryan</span> <span> </span> <span class="date">26 May 2013 at 11:00</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>I do not see in what sense "is a" is less controversial than "whether square is a rectangle". A square is a rectangle, but probably a mutable square is not a mutable rectangle. Whether something "is a" something else depends on how it is intended to be used, otherwise i do not see how it would possible to say that one data structure IS another (different) data structure.</span> <span> - </span> <span class="display-name">Alexey</span> <span> </span> <span class="date">26 May 2013 at 11:35</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>In the 2nd example: Wouldn't I just create a class Flyable and subclass with Airplane and Bird? I don't see where composition would fit in this example.</span> <span> - </span> <span class="display-name">Binarian</span> <span> </span> <span class="date">18 May 2015 at 10:49</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@ViktorLexington - what if Bird already had to subclass Vertebrate ? Even if the language allows multiple inheritance - it usually results in a messier type design</span> <span> - </span> <span class="display-name">Gishu</span> <span> </span> <span class="date">20 May 2015 at 06:44</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Lets talk about real life example which from time to time I rememeber. I need to return data in formated way. Like array('status' =&gt; 'succes', 'data' =&gt; $data$). I want to have this format in one place and so I have it in function. Now I alwayws add class as dependency for this funciton. But many dependencies are bad, so that sucks. So I am thinking that I could add this function to parent class. But I do not understand from Biplane - Airplane examples. Can I inherit and how would I call base class then? Maybe just 'BaseClass' and thats it?Do I have to use all methods from base class in child?</span> <span> - </span> <span class="display-name">Dariux</span> <span> </span> <span class="date">13 Aug 2015 at 11:49</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>A RedToyota <i>has-a</i> ToyotaChassis (but may not); a RedToyata <i>has-a</i> Chassis, which may or may not be a ToyotaChassis. A RedToyota is also not a great example because a Car has-a color, and a brand. And, of course, there are the inevitable flying car discussions. UI components are still among the best examples of inheritance available.</span> <span> - </span> <span class="display-name">Dave Newton</span> <span> </span> <span class="date">26 Jan 2016 at 19:53</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Jeshurun It's a great book, but the Ducks example seems broken. Even though they used composition, in the end the <code>RubberDuck</code> class still <i>is-a</i> <code>Duck</code>, and as such it still suffers from a rigid design. The <code>FlyNoWay</code> class' empty <code>fly()</code> method is the same as an empty <code>fly()</code> in a bad use of inheritance in the first place. This might also violate the LSP, since clients of all <code>Duck</code> objects are going to expect them to <code>performFly()</code>. A rubber duck that does <code>performFly()</code> won't have moved, for example, and the client might expect a duck to not be in the same place after flying.</span> <span> - </span> <span class="display-name">Fuhrmanator</span> <span> </span> <span class="date">17 Mar 2016 at 14:16</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Gishu not sure if this statement is generally applicable to determine if class should inherit - <i>Does TypeB want to expose the complete interface (all public methods no less) of TypeA such that TypeB can be used where TypeA is expected? Indicates Inheritance</i> For example, if I have Rectangle class and I want red color rectangle. I should not create RedRectangle inheriting from Rectangle. It is more like Rectangle should compose Color class. Isn't ?</span> <span> - </span> <span class="display-name">rahulaga-msft</span> <span> </span> <span class="date">17 Nov 2018 at 05:26</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>My problem with this answer is that it claims "but do not use a compose-always approach" without explaining why. In my experience in Banking, CRMs, Digital document management Inheritance is always an annoying obstacle that has to be refactored out. Because our "classifications" are always too naive &amp; don't fit reality. Even biologists have complains about hierarchical taxonomy. Inheritance is good only with interfaces, in which case is just good ole ad hoc polymorphism in other languages like Haskell.</span> <span> - </span> <span class="display-name">kisai</span> <span> </span> <span class="date">17 Jul 2019 at 06:30</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Gishu the "it" pronouns are ambiguous in this sentence: <code>In this case, it makes sense to extract **it** out as an interface / class / both and make **it** a member of both classes.</code> Are you referring to the "fly" behaviour?</span> <span> - </span> <span class="display-name">iono</span> <span> </span> <span class="date">25 Sep 2019 at 14:46</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Gishu By applying your first test (basically LCP), is the following true? A. Define class HumanBeing; B. Define class HasBannaHumanBeing; C. Since HasBannaHumanBeing want to expose the complete interface of HumanBeing, HasBannaHumanBeing <b>must</b> inherit HumanBeing.</span> <span> - </span> <span class="display-name">Clint</span> <span> </span> <span class="date">20 Jul 2020 at 17:16</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I would like to add some minor/transient info here and call out one of my favorite breakdowns of this axiom which is <i>Item 18 from Joshua Bloch's Effective Java, Third Edition</i>. It both lays out when inheritance is appropriate for reuse but also uses a clear example of inheritance breaking encapsulation and the consequences based on issues encountered by Java language designers while updating the collections api for modern Java versions. A good resource along with the Head First publication mentioned earlier.</span> <span> - </span> <span class="display-name">Taylor Bird</span> <span> </span> <span class="date">13 Sep 2021 at 23:53</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Gishu "** if not more**. So that makes it fit to derive from Airplane." What do you want me to pay attention to by say "if not more"?</span> <span> - </span> <span class="display-name">John</span> <span> </span> <span class="date">18 Apr 2022 at 12:15</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>553</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Nick Zalutskiy</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Sep 2008 at 02:09</span>
     </div>
    </div>
    <div>
     <p>Think of containment as a <strong>has a</strong> relationship. A car "has an" engine, a person "has a" name, etc.</p>
     <p>Think of inheritance as an <strong>is a</strong> relationship. A car "is a" vehicle, a person "is a" mammal, etc.</p>
     <p>I take no credit for this approach. I took it straight from the <a href="https://rads.stackoverflow.com/amzn/click/com/0735619670" rel="noreferrer">Second Edition of Code Complete</a> by <a href="https://stevemcconnell.com/" rel="noreferrer">Steve McConnell</a>, <em>Section 6.3</em>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>132</td>
        <td><span>This is not always a perfect approach, it's simply a good guideline. the Liskov Substitution Principle is much more accurate (fails less).</span> <span> - </span> <span class="display-name">Bill K</span> <span> </span> <span class="date">17 Sep 2008 at 00:25</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Can't you convert most <b>is a</b> to <b>has a</b> relationships? Hence a car has a basicVehicle object and a person has a basicMammal object, etc.</span> <span> - </span> <span class="display-name">Morgan Bengtsson</span> <span> </span> <span class="date">12 Aug 2011 at 21:51</span></td>
       </tr>
       <tr>
        <td>48</td>
        <td><span>"My car has a vehicle." If you consider that as a separate sentence, not in a programming context, that makes absolutely no sense. And that's the whole point of this technique. If it sounds awkward, it is probably wrong.</span> <span> - </span> <span class="display-name">Nick Zalutskiy</span> <span> </span> <span class="date">14 Aug 2011 at 18:27</span></td>
       </tr>
       <tr>
        <td>52</td>
        <td><span>@Nick Sure, but "My Car has a VehicleBehavior" makes more sense (I guess your "Vehicle" class could be named "VehicleBehavior"). So you cannot base your decision on "has a" vs "is a" comparision, you have to use LSP, or you will make mistakes</span> <span> - </span> <span class="display-name">Tristan</span> <span> </span> <span class="date">26 Aug 2011 at 11:53</span></td>
       </tr>
       <tr>
        <td>44</td>
        <td><span>Instead of "is a" think of "behaves like." Inheritance is about inheriting behavior, not just semantics.</span> <span> - </span> <span class="display-name">ybakos</span> <span> </span> <span class="date">31 Mar 2012 at 19:25</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>@ybakos "Behaves like" can be achieved via interfaces without the need for inheritance. <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance#Basics" rel="nofollow noreferrer">From Wikipedia</a>: <i>"An implementation of composition over inheritance typically begins with the creation of various interfaces representing the behaviors that the system must exhibit...Thus, system behaviors are realized without inheritance."</i></span> <span> - </span> <span class="display-name">DavidRR</span> <span> </span> <span class="date">27 Oct 2015 at 12:59</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@DavidRR Yes, and this is what the previous comment is really begging for. But this question is about inheritance, and when we extend a class, we do inherit the behavior of the parent. That's all I'm saying. Of course interfaces should be preferred over inheritance.</span> <span> - </span> <span class="display-name">ybakos</span> <span> </span> <span class="date">28 Oct 2015 at 13:46</span></td>
       </tr>
       <tr>
        <td>12</td>
        <td><span>This doesn't answer the question. The question is "why" not "what".</span> <span> - </span> <span class="display-name">Nick Bull</span> <span> </span> <span class="date">20 Oct 2017 at 10:57</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span><b>VehicleBehavior</b> is a behavior (<i>mobility</i> behavior) not an entity. So <b>VehicleBehavior</b> is neither a <i>part</i> or <i>Superclass</i> for the type <b>Car</b>. Having some behavior/treat is better modeled by including a <i>Mixin Class</i> the represent this behavior.</span> <span> - </span> <span class="display-name">adnanmuttaleb</span> <span> </span> <span class="date">1 Jul 2020 at 09:46</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I don't see why behaves-like is better. When X inherits from Y, then yes, X behaves-like Y. But, you can't flip that around and use behaves-like as a tool to decide when to inherit, after all, a cat behaves-like a dog in many ways. You'd have to add a lot of asterisks to the behave-like rule to coerce it to work, and by then, you'd basically be explaining Liskov's Substitution. Can't we just toss is-a/has-a/behaves-like and say you can't inherit unless it obeys Liskov's substitution, and even then, other code-reuse and polymorphic tools may do the job better, depending on the job.</span> <span> - </span> <span class="display-name">Scotty Jamison</span> <span> </span> <span class="date">6 Apr 2022 at 17:09</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>277</span>
     </div>
     <div>
      <span>Answerer: </span> <span>aleemb</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 May 2009 at 07:54</span>
     </div>
    </div>
    <div>
     <p>If you understand the difference, it's easier to explain.</p>
     <h2>Procedural Code</h2>
     <p>An example of this is PHP without the use of classes (particularly before PHP5). All logic is encoded in a set of functions. You may include other files containing helper functions and so on and conduct your business logic by passing data around in functions. This can be very hard to manage as the application grows. PHP5 tries to remedy this by offering a more object-oriented design.</p>
     <h2>Inheritance</h2>
     <p>This encourages the use of classes. Inheritance is one of the three tenets of OO design (inheritance, polymorphism, encapsulation).</p>
     <pre><code>class Person {
   String Title;
   String Name;
   Int Age
}

class Employee : Person {
   Int Salary;
   String Title;
}
</code></pre>
     <p>This is inheritance at work. The <code>Employee</code> "<strong>is a</strong>" <code>Person</code> or inherits from <code>Person</code>. All inheritance relationships are "is-a" relationships. <code>Employee</code> also shadows the <code>Title</code> property from <code>Person</code>, meaning <code>Employee.Title</code> will return the <code>Title</code> for the <code>Employee</code> and not the <code>Person</code>.</p>
     <h2>Composition</h2>
     <p>Composition is favoured over inheritance. To put it very simply you would have:</p>
     <pre><code>class Person {
   String Title;
   String Name;
   Int Age;

   public Person(String title, String name, String age) {
      this.Title = title;
      this.Name = name;
      this.Age = age;
   }

}

class Employee {
   Int Salary;
   private Person person;

   public Employee(Person p, Int salary) {
       this.person = p;
       this.Salary = salary;
   }
}

Person johnny = new Person ("Mr.", "John", 25);
Employee john = new Employee (johnny, 50000);
</code></pre>
     <p>Composition is typically "<strong>has a</strong>" or "<strong>uses a</strong>" relationship. Here the <code>Employee</code> class has a <code>Person</code>. It does not inherit from <code>Person</code> but instead gets the <code>Person</code> object passed to it, which is why it "has a" Person.</p>
     <h2>Composition over Inheritance</h2>
     <p>Now say you want to create a <code>Manager</code> type so you end up with:</p>
     <pre><code>class Manager : Person, Employee {
   ...
}
</code></pre>
     <p>This example will work fine, however, what if <code>Person</code> and <code>Employee</code> both declared <code>Title</code>? Should <code>Manager.Title</code> return "Manager of Operations" or "Mr."? Under composition this ambiguity is better handled:</p>
     <pre><code>Class Manager {
   public string Title;
   public Manager(Person p, Employee e)
   {
      this.Title = e.Title;
   }
}
</code></pre>
     <p>The <code>Manager</code> object is composed of an <code>Employee</code> and a <code>Person</code>. The <code>Title</code> behaviour is taken from <code>Employee</code>. This explicit composition removes ambiguity among other things and you'll encounter fewer bugs.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>8</td>
        <td><span>For inheritence: There is no ambiguity. You are implementing the Manager class based on requirements. So you would return "Manager of Operations" if thats what your requirements specified, else you would just use the base class's implementation. Also you could make Person an abstract class and thereby make sure down-stream classes implement a Title property.</span> <span> - </span> <span class="display-name">Raj Rao</span> <span> </span> <span class="date">12 Nov 2010 at 20:21</span></td>
       </tr>
       <tr>
        <td>92</td>
        <td><span>Its important to remember that one might say "Composition over inheritence" but that does not mean "Composition always over Inheritence". "Is a" means inheritence and leads to code reuse. Employee is a Person (Employee does not have a person).</span> <span> - </span> <span class="display-name">Raj Rao</span> <span> </span> <span class="date">12 Nov 2010 at 20:26</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>You would have to know at the time of creating the initial person class that you want to be able to change what title means, abstract properties are a sign of poor design, behavior should be abstract, not state.</span> <span> - </span> <span class="display-name">Po-ta-toe</span> <span> </span> <span class="date">24 Jan 2012 at 20:40</span></td>
       </tr>
       <tr>
        <td>47</td>
        <td><span>The example is confusing.Employee is a person, so it should use inheritance. You should not use composition for this example, because it is wrong relationship in domain model, even if technically you can declare it in the code.</span> <span> - </span> <span class="display-name">Michael Freidgeim</span> <span> </span> <span class="date">24 Jul 2013 at 13:54</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Here's more about composition implementations (and limitations): <a href="http://stackoverflow.com/questions/554145/liskov-substition-and-composition" title="liskov substition and composition">stackoverflow.com/questions/554145/…</a></span> <span> - </span> <span class="display-name">cregox</span> <span> </span> <span class="date">4 Sep 2013 at 20:06</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>I actually quite like this example, because, what if an Employee is both a Manager and and an Agent. In environments where you can't inherit from more that one class, you have a problem and you most likely end up with duplicate data. With composition you can handle this in an elegant way. And the overhead is minimal, even in environments where multiple inheritance is possible I would prefer this solution.</span> <span> - </span> <span class="display-name">netiul</span> <span> </span> <span class="date">14 Apr 2014 at 08:21</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Classes certainly aren't required for composing things together. Indeed, classes often <i>prevent</i> composition by hiding the composable bits inside application-specific wrappers.</span> <span> - </span> <span class="display-name">Warbo</span> <span> </span> <span class="date">30 May 2014 at 11:36</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@netiul, it's still not that good an example: a better model would be that an Employee is a Person, but has a Role.</span> <span> - </span> <span class="display-name">Celos</span> <span> </span> <span class="date">3 Oct 2014 at 12:08</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@Celos It's the same idea. Being an Employee is some kind of a role. I'm an Employee but I'm also a Father. So make Employee and Father a Role and compose them with the same Person.</span> <span> - </span> <span class="display-name">netiul</span> <span> </span> <span class="date">16 Oct 2014 at 07:45</span></td>
       </tr>
       <tr>
        <td>29</td>
        <td><span>I disagree with this example. An Employee <i>is-a</i> Person, which is a textbook case of proper use of inheritance. I also think that the "issue" the redefinition of the Title field does not make sense. The fact that Employee.Title shadows Person.Title is a sign of poor programming. After all, are "Mr." and "Manager of Operations" really referring to the same aspect of a person (lowercase)? I would rename Employee.Title, and thus be able to reference the Title and JobTitle attributes of an Employee, both of which make sense in real life. Furthermore, there is no reason for Manager (continued...)</span> <span> - </span> <span class="display-name">Resigned June 2023</span> <span> </span> <span class="date">10 Nov 2014 at 00:09</span></td>
       </tr>
       <tr>
        <td>20</td>
        <td><span>(... continued) to inherit from both Person and Employee -- after all, Employee already inherits from Person. In more complex models, where a person might be a Manager and an Agent, it is true that multiple inheritance can be used (carefully!), but it would be preferable in many environments to have an abstract Role class from which Manager (contains Employees s/he manages) and Agent (contains Contracts, and other information) inherit. Then, an Employee is-a Person who has-multiple Roles. Thus, both composition and inheritance are used properly.</span> <span> - </span> <span class="display-name">Resigned June 2023</span> <span> </span> <span class="date">10 Nov 2014 at 00:13</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@raxod502 Textbook examples are often wrong - after all, textbooks simplify reality as much as they can, to focus on <i>one</i> key concept at a time. And it sounds like you didn't read the previous comments, which show <i>why</i> it can very well be the wrong relationship - and those aren't some weird outliers, they're the kind of problem you see in almost every kind of application. I actually use inheritance less and less over time - it just doesn't quite seem to pay rent for most design. Liskov's Substitution Principle seems to be the best "back-of-the-hand" quick decider in my experience.</span> <span> - </span> <span class="display-name">Luaan</span> <span> </span> <span class="date">11 Jan 2016 at 17:33</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Luaan I've re-read the previous comments, and don't understand what you think is wrong with my model's relationships. Also, by "textbook", I meant "conforming to or corresponding to a standard or type that is prescribed or widely held by theorists", not "from a literal textbook". As in, if the best way to describe the relationship between A and B is "A is a special type of B", then most people agree inheritance is the most appropriate approach to the situation.</span> <span> - </span> <span class="display-name">Resigned June 2023</span> <span> </span> <span class="date">11 Jan 2016 at 23:59</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@raxod502 But whether Employee <i>is a</i> Person depends on your domain and overal design. As netiul noted, it may be much more practical for Employee to be a <i>role</i> of Person (i.e. "Person has an Employee, Manager, Son role"). What if you're both Agent and Manager? Or your Manager is a Company? Do your theorists recommend using inheritance like this in a language that doesn't support multiple inheritance? Textbook examples usually have a context within which they make sense; a lot of the papers written on inheritance assume <i>multiple</i> inheritance to be possible (and desirable).</span> <span> - </span> <span class="display-name">Luaan</span> <span> </span> <span class="date">12 Jan 2016 at 09:18</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Luaan OK, I was assuming that the software was some sort of employee management system. Of course if you want an extremely general model capable of handling every aspect of people and their actions, then you would need to make a Person class (or something more general?) with (extremely general) Roles and every sort of attribute a Person could possibly have. Here composition is obviously superior. But in many real-world systems, you have a much simpler (and better-defined) model—the complexity being in the actual functionality of the code—and inheritance is a more elegant approach.</span> <span> - </span> <span class="display-name">Resigned June 2023</span> <span> </span> <span class="date">13 Jan 2016 at 15:29</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@raxod502 The thing is, while I've used (and observed) inheritance for years, I've never seen elegancy in it. Combining state and behaviour? Sure. Virtual dispatch? Sure. But inheritance? It only really works when you have a tree-like hierarchy, and then after half a year of development you suddenly notice that your hierarchy is no longer tree-like and you can start over. That said, it's definitely true that many modern languages have poor support for composition - which may make composition a lot clunkier than inheritance in some cases (e.g. having to explicitly route interfaces to children).</span> <span> - </span> <span class="display-name">Luaan</span> <span> </span> <span class="date">13 Jan 2016 at 16:37</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Luann OK—I certainly concede that in some cases composition is preferable. Composition, however, just like inheritance, can be either the perfect tool or exactly the wrong tool, depending on the situation. My main point is the answer is invalid because it prescribes composition <i>always</i>, and then tries to shoehorn it into an example where it doesn't fit. (The model in the example would be better off with a combination of both composition <i>and</i> inheritance, as I described in my first comment.)</span> <span> - </span> <span class="display-name">Resigned June 2023</span> <span> </span> <span class="date">15 Jan 2016 at 03:36</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Object lifecycle should be considered when choosing inheritance. Manager "is an" Employee is no good if the Manager chooses a different role and then all of their persistent Employee data has to be destroyed then recreated.</span> <span> - </span> <span class="display-name">SPB</span> <span> </span> <span class="date">14 Feb 2017 at 06:24</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>In inheritance modeling between Person and Employee, i would investigate the possibility of modeling this problem through an association of type has-a between Person and Job (naturally paid). Therefore, if a person has a job, the person will have a salary, and this association should be mapped as composition.</span> <span> - </span> <span class="display-name">Carlos Ribeiro</span> <span> </span> <span class="date">12 Feb 2021 at 00:16</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>IMO, 'composition over inheritance' is a work-around for situations where design smells are present in your domain model. I think this answer goes a long way toward proving that point. If you come across sub-type anomalies (such as a property that needs a new value, like the <i>title</i> property in the example,) there are most likely mistakes in the model. Everything in the Person class should be true for ALL people. If not, it should not be in the super in the first place. As long as you follow this rule, you will not have issues defining the sub-types.</span> <span> - </span> <span class="display-name">Nate T</span> <span> </span> <span class="date">19 Mar 2021 at 15:57</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Work arounds, such as defining is-a relationships using composition, may get you by at the moment, but they will also mask the underlying issues. Eventually, these issues add up.</span> <span> - </span> <span class="display-name">Nate T</span> <span> </span> <span class="date">19 Mar 2021 at 15:58</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>211</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ahmed</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 May 2009 at 08:34</span>
     </div>
    </div>
    <div>
     <p>With all the undeniable benefits provided by inheritance, here's some of its disadvantages.</p>
     <p><strong>Disadvantages of Inheritance:</strong></p>
     <ol>
      <li>You can't change the implementation inherited from super classes at runtime (obviously because inheritance is defined at compile time).</li>
      <li>Inheritance exposes a subclass to details of its parent class implementation, that's why it's often said that inheritance breaks encapsulation (in a sense that you really need to focus on interfaces only not implementation, so reusing by sub classing is not always preferred).</li>
      <li>The tight coupling provided by inheritance makes the implementation of a subclass very bound up with the implementation of a super class that any change in the parent implementation will force the sub class to change.</li>
      <li>Excessive reusing by sub-classing can make the inheritance stack very deep and very confusing too.</li>
     </ol>
     <p>On the other hand <b>Object composition</b> is defined at runtime through objects acquiring references to other objects. In such a case these objects will never be able to reach each-other's protected data (no encapsulation break) and will be forced to respect each other's interface. And in this case also, implementation dependencies will be a lot less than in case of inheritance.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>13</td>
        <td><span>This is one of the better answers, in my opinion - I will add to this that trying to re-think your problems in terms of composition, in my experience, tends to lead to smaller, simpler, more self-contained, more reusable classes, with a clearer, smaller, more focused scope of responsibility. Often this means there is less need for things like dependency injection or mocking (in tests) as smaller components are usually able to stand on their own. Just my experience. YMMV :-)</span> <span> - </span> <span class="display-name">mindplay.dk</span> <span> </span> <span class="date">17 Jan 2014 at 00:51</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>The last paragraph in this post really clicked for me. Thank you.</span> <span> - </span> <span class="display-name">Salx</span> <span> </span> <span class="date">25 May 2016 at 19:00</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Even though you mention a good technique, I don't think you're answering the question. It's not comparing runtime against compile time, but inheritance against composition, which REUSES code from either ONE or MANY classes and can OVERRIDE or ADD new logic. What you describe as object composition, is simply injecting logic via objects assigned as properties in a class, which is a great alternative for runtime manipulation. Thanks!</span> <span> - </span> <span class="display-name">Isaak Eriksson</span> <span> </span> <span class="date">24 Jun 2021 at 09:13</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Inheritance exposes a subclass to details of its parent class implementation...Is this through protected members?</span> <span> - </span> <span class="display-name">AlexBor</span> <span> </span> <span class="date">30 Jan 2023 at 09:53</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>111</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Tim Howland</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Sep 2008 at 02:48</span>
     </div>
    </div>
    <div>
     <p>Another, very pragmatic reason, to prefer composition over inheritance has to do with your domain model, and mapping it to a relational database. It's really hard to map inheritance to the SQL model (you end up with all sorts of hacky workarounds, like creating columns that aren't always used, using views, etc). Some ORMLs try to deal with this, but it always gets complicated quickly. Composition can be easily modeled through a foreign-key relationship between two tables, but inheritance is much harder.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>103</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Pavel Feldman</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 May 2009 at 22:29</span>
     </div>
    </div>
    <div>
     <p>While in short words I would agree with "Prefer composition over inheritance", very often for me it sounds like "prefer potatoes over coca-cola". There are places for inheritance and places for composition. You need to understand difference, then this question will disappear. What it really means for me is "if you are going to use inheritance - think again, chances are you need composition".</p>
     <p>You should prefer potatoes over coca cola when you want to eat, and coca cola over potatoes when you want to drink.</p>
     <p>Creating a subclass should mean more than just a convenient way to call superclass methods. You should use inheritance when subclass "is-a" super class both structurally and functionally, when it can be used as superclass and you are going to use that. If it is not the case - it is not inheritance, but something else. Composition is when your objects consists of another, or has some relationship to them.</p>
     <p>So for me it looks like if someone does not know if he needs inheritance or composition, the real problem is that he does not know if he want to drink or to eat. Think about your problem domain more, understand it better.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>6</td>
        <td><span>The right tool for the right job. A hammer may be better at pounding things than a wrench, but that doesn't mean one should view a wrench as "an inferior hammer". Inheritance can be helpful when the things that are added to the subclass are necessary for the object to behave as a superclass object. For example, consider a base class <code>InternalCombustionEngine</code> with a derived class <code>GasolineEngine</code>. The latter adds things like spark plugs, which the base class lacks, but using the thing as an <code>InternalCombustionEngine</code> will cause the spark plugs to get used.</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">29 Oct 2012 at 15:07</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>74</span>
     </div>
     <div>
      <span>Answerer: </span> <span>lcn</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Sep 2015 at 05:22</span>
     </div>
    </div>
    <div>
     <p>Didn't find a satisfactory answer here, so I wrote a new one.</p>
     <p>To understand why "<em>prefer</em> composition over inheritance", we need first get back the assumption omitted in this shortened idiom.</p>
     <p>There are two benefits of inheritance: <a href="https://www.cs.princeton.edu/courses/archive/fall98/cs441/mainus/node12.html" rel="noreferrer">subtyping and subclassing</a></p>
     <ol>
      <li>
       <p><strong>Subtyping</strong> means conforming to a type (interface) signature, i.e. a set of APIs, and one can override part of the signature to achieve subtyping polymorphism.</p></li>
      <li>
       <p><strong>Subclassing</strong> means implicit reuse of method implementations.</p></li>
     </ol>
     <p>With the two benefits comes two different purposes for doing inheritance: subtyping oriented and code reuse oriented.</p>
     <p>If code reuse is the <em>sole</em> purpose, subclassing may give one more than what he needs, i.e. some public methods of the parent class don't make much sense for the child class. In this case, instead of favoring composition over inheritance, composition is <em>demanded</em>. This is also where the "is-a" vs. "has-a" notion comes from.</p>
     <p>So only when subtyping is purposed, i.e. to use the new class later in a polymorphic manner, do we face the problem of choosing inheritance or composition. This is the assumption that gets omitted in the shortened idiom under discussion.</p>
     <p>To subtype is to conform to a type signature, this means composition has always to expose no less amount of APIs of the type. Now the trade offs kick in:</p>
     <ol>
      <li>
       <p>Inheritance provides straightforward code reuse if not overridden, while composition has to re-code every API, even if it's just a simple job of delegation.</p></li>
      <li>
       <p>Inheritance provides straightforward <a href="https://en.wikipedia.org/wiki/This_%28computer_programming%29#Open_recursion" rel="noreferrer">open recursion</a> via the internal polymorphic site <code>this</code>, i.e. invoking overriding method (or even <a href="http://www.scala-lang.org/old/node/1637.html#comment-5489" rel="noreferrer">type</a>) in another member function, either public or private (though <a href="https://softwareengineering.stackexchange.com/questions/35946/is-it-bad-code-smell-if-private-method-calls-public-one">discouraged</a>). Open recursion can be <a href="https://github.com/akottr/edu-pattern/blob/master/org.akottr.patterns.composition/src/org/akottr/patterns/composition/inheritance/Compositon.java" rel="noreferrer">simulated via composition</a>, but it requires extra effort and may not always viable(?). This <a href="https://stackoverflow.com/a/2238735/2073130">answer</a> to a duplicated question talks something similar.</p></li>
      <li>
       <p>Inheritance exposes <em>protected</em> members. This breaks encapsulation of the parent class, and if used by subclass, another dependency between the child and its parent is introduced.</p></li>
      <li>
       <p>Composition has the befit of inversion of control, and its dependency can be injected dynamically, as is shown in <a href="https://en.wikipedia.org/wiki/Decorator_pattern#Java" rel="noreferrer">decorator pattern</a> and <a href="https://en.wikipedia.org/wiki/Proxy_pattern#Java" rel="noreferrer">proxy pattern</a>.</p></li>
      <li>
       <p>Composition has the benefit of <a href="http://www.codecommit.com/blog/scala/the-magic-behind-parser-combinators" rel="noreferrer">combinator-oriented</a> programming, i.e. working in a way like the <a href="https://en.wikipedia.org/wiki/Composite_pattern#Java" rel="noreferrer">composite pattern</a>.</p></li>
      <li>
       <p>Composition immediately follows <a href="https://stackoverflow.com/questions/383947/what-does-it-mean-to-program-to-an-interface">programming to an interface</a>.</p></li>
      <li>
       <p>Composition has the benefit of easy <a href="https://stackoverflow.com/questions/3556652/how-do-java-interfaces-simulate-multiple-inheritance">multiple inheritance</a>.</p></li>
     </ol>
     <p>With the above trade offs in mind, we hence <em>prefer</em> composition over inheritance. Yet for tightly related classes, i.e. when implicit code reuse really make benefits, or the magic power of open recursion is desired, inheritance shall be the choice.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>I think you mean subclassing entails subtyping, as is the case with most OOP languages. To rephrase, "Subclassing means implicit reuse of method implementations <b>AND</b> conforming to a type (interface) signature.</span> <span> - </span> <span class="display-name">wlnirvana</span> <span> </span> <span class="date">18 Apr 2022 at 06:17</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Point number 3 does not break encapsulation as claimed, as it is the parent that decides whether members are protected or private. You want your parent class fully encapsulated? Declare everything private: job done. You want to use protected for the purpose for which it exists? Then use it, and rest assured that you aren't exposing anything that you didn't intend to be exposed.</span> <span> - </span> <span class="display-name">Trevortni</span> <span> </span> <span class="date">30 May 2023 at 19:42</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>65</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mike Valenty</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Jan 2010 at 19:55</span>
     </div>
    </div>
    <div>
     <p>Inheritance is pretty enticing especially coming from procedural-land and it often looks deceptively elegant. I mean all I need to do is add this one bit of functionality to some other class, right? Well, one of the problems is that</p>
     <h2>inheritance is probably the worst form of coupling you can have</h2>
     <p></p>
     <p>Your base class breaks encapsulation by exposing implementation details to subclasses in the form of protected members. This makes your system rigid and fragile. The more tragic flaw however is the new subclass brings with it all the baggage and opinion of the inheritance chain.</p>
     <p>The article, <a href="http://www.agileatwork.com/inheritance-is-evil-the-story-of-the-epic-fail-of-dataannotationsmodelbinder/" rel="noreferrer">Inheritance is Evil: The Epic Fail of the DataAnnotationsModelBinder</a>, walks through an example of this in C#. It shows the use of inheritance when composition should have been used and how it could be refactored.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>5</td>
        <td><span>Inheritance isn't good or bad, it's merely a special case of Composition. Where, indeed, the subclass is implementing a similar functionality to the superclass. If your proposed subclass is not re-implementing but merely <i>using</i> the functionality of the superclass, then you have used Inheritance incorrectly. That is the programmer's mistake, not a reflection on Inheritance.</span> <span> - </span> <span class="display-name">iPherian</span> <span> </span> <span class="date">19 Apr 2017 at 22:31</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This entire answer appears to be based on the author's ignorance of the difference between private and protected, as it gives literally no other problem than one issue (that could theoretically be) caused by not knowing basic keywords.</span> <span> - </span> <span class="display-name">Trevortni</span> <span> </span> <span class="date">30 May 2023 at 19:52</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>60</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Boris Dalstein</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Jun 2016 at 22:23</span>
     </div>
    </div>
    <div>
     <h1>When can you use composition?</h1>
     <p>You can always use composition. In some cases, inheritance is also possible and may lead to a more powerful and/or intuitive API, but composition is always an option.</p>
     <h1>When can you use inheritance?</h1>
     <p>It is often said that if "a bar is a foo", then the class <code>Bar</code> can inherit the class <code>Foo</code>. Unfortunately, this test alone is not reliable, use the following instead:</p>
     <blockquote>
      <ol>
       <li>a bar is a foo, <strong>AND</strong></li>
       <li>bars can do everything that foos can do.</li>
      </ol>
     </blockquote>
     <p>The first test ensures that all <em>getters</em> of <code>Foo</code> make sense in <code>Bar</code> (= shared properties), while the second test makes sure that all <em>setters</em> of <code>Foo</code> make sense in <code>Bar</code> (= shared functionality).</p>
     <p><strong>Example: Dog/Animal</strong></p>
     <p>A dog is an animal AND dogs can do everything that animals can do (such as breathing, moving, etc.). Therefore, the class <code>Dog</code> <strong>can</strong> inherit the class <code>Animal</code>.</p>
     <p><strong>Counter-example: Circle/Ellipse</strong></p>
     <p>A circle is an ellipse BUT circles can't do everything that ellipses can do. For example, circles can't stretch, while ellipses can. Therefore, the class <code>Circle</code> <strong>cannot</strong> inherit the class <code>Ellipse</code>.</p>
     <p>This is called the <a href="https://en.wikipedia.org/wiki/Circle-ellipse_problem" rel="noreferrer">Circle-Ellipse problem</a>, which isn't really a problem, but more an indication that "a bar is a foo" isn't a reliable test by itself. In particular, this example highlights that derived classes should <em>extend</em> the functionality of base classes, never <em>restrict</em> it. Otherwise, the base class couldn't be used polymorphically. Adding the test "bars can do everything that foos can do" ensures that polymorphic use is possible, and is equivalent to the <a href="http://web.archive.org/web/20110722014513/http://www.objectmentor.com/resources/articles/lsp.pdf" rel="noreferrer">Liskov Substitution Principle</a>:</p>
     <blockquote>
      <p>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it</p>
     </blockquote>
     <h1>When should you use inheritance?</h1>
     <p>Even if you <em>can</em> use inheritance doesn't mean you <em>should</em>: using composition is always an option. Inheritance is a powerful tool allowing implicit code reuse and dynamic dispatch, but it does come with a few disadvantages, which is why composition is often preferred. The trade-offs between inheritance and composition aren't obvious, and in my opinion are best explained in <a href="https://stackoverflow.com/a/32557773/1951907">lcn's answer</a>.</p>
     <p>As a rule of thumb, I tend to choose inheritance over composition when polymorphic use is expected to be very common, in which case the power of dynamic dispatch can lead to a much more readable and elegant API. For example, having a polymorphic class <code>Widget</code> in GUI frameworks, or a polymorphic class <code>Node</code> in XML libraries allows to have an API which is much more readable and intuitive to use than what you would have with a solution purely based on composition.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>The circle-ellipse and square-rectangle scenarios are poor examples. Subclasses are invariably more complex than their superclass, so the problem is contrived. This problem is solved by inverting the relationship. An ellipse derives from a circle and a rectangle derives from a square. It's extremely silly to use composition in these scenarios.</span> <span> - </span> <span class="display-name">Fuzzy Logic</span> <span> </span> <span class="date">18 Oct 2018 at 01:12</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@FuzzyLogic Agreed, but in fact, my post never advocates for using composition in this case. I've only said that the circle-ellipse problem is a great example of why "is-a" is not a good test alone to conclude that Circle should derive from Ellipse. Once we conclude that actually, Circle shouldn't derive from Ellipse due to violation of LSP, then possible options are to invert the relationship, or use composition, or use template classes, or use a more complex design involving additional classes or helper functions, etc... and the decision obviously should be taken on a case-by-case basis.</span> <span> - </span> <span class="display-name">Boris Dalstein</span> <span> </span> <span class="date">18 Oct 2018 at 09:44</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@FuzzyLogic And if you are curious about what I would advocate for the specific case of Circle-Ellipse: I would advocate not implementing the Circle class. The issue with inverting the relationship is that it also violates LSP: imagine the function <code>computeArea(Circle* c) { return pi * square(c-&gt;radius()); }</code>. It is obviously broken if passed an Ellipse (what does radius() even mean?). An Ellipse is not a Circle, and as such shouldn't derive from Circle.</span> <span> - </span> <span class="display-name">Boris Dalstein</span> <span> </span> <span class="date">18 Oct 2018 at 09:59</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span><code>computeArea(Circle *c) { return pi * width * height / 4.0; }</code> Now it's generic.</span> <span> - </span> <span class="display-name">Fuzzy Logic</span> <span> </span> <span class="date">18 Oct 2018 at 10:59</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@FuzzyLogic I disagree: you realize that this means that the class Circle anticipated the existence of the derived class Ellipse, and therefore provided <code>width()</code> and <code>height()</code>? What if now a library user decides to create another class called "EggShape"? Should it also derive from "Circle"? Of course not. An egg-shape is not a circle, and an ellipse is not a circle either, so none should derive from Circle since it breaks LSP. Methods performing operation on a Circle* class make strong assumptions about what a circle is, and breaking these assumptions will almost certainly lead to bugs.</span> <span> - </span> <span class="display-name">Boris Dalstein</span> <span> </span> <span class="date">18 Oct 2018 at 16:54</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@FuzzyLogic More precisely, by adding the (possibly virtual) functions width() and height() to Circle, you didn't truly make the class generic. You just made it "slightly" more generic, and the concept that your class now represents is in fact CircleOrEllipse, which would be a better name for this class. But yet a better design is to have a class Shape with a virtual method computeArea(), and two independent subclasses called Circle and Ellipse. One has a method radius() while the other has two methods width() and height().</span> <span> - </span> <span class="display-name">Boris Dalstein</span> <span> </span> <span class="date">18 Oct 2018 at 16:58</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I was just kidding :) My only bone was wedging the problem into the composition model but you cleared that up.</span> <span> - </span> <span class="display-name">Fuzzy Logic</span> <span> </span> <span class="date">18 Oct 2018 at 20:39</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@FuzzyLogic Ah, sorry, didn't get the sarcasm :)</span> <span> - </span> <span class="display-name">Boris Dalstein</span> <span> </span> <span class="date">19 Oct 2018 at 13:37</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>You are awesome, loved this answer :)</span> <span> - </span> <span class="display-name">Nom1fan</span> <span> </span> <span class="date">1 Feb 2022 at 13:39</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Nom1fan Thanks, I'm glad the answer was helpful!</span> <span> - </span> <span class="display-name">Boris Dalstein</span> <span> </span> <span class="date">2 Feb 2022 at 15:35</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Very helpful answer. Just one further question: In the case of GUI or XML processing, do you mean subclassing (inheritance) can lead to an elegant API, or subtyping (interface "inheritance/implementation")</span> <span> - </span> <span class="display-name">wlnirvana</span> <span> </span> <span class="date">18 Apr 2022 at 06:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@wlnirvana I would say both. Let's use GUI widgets as an example. Subtyping alone (= sharing the interface) allows polymorphism and makes it easier to use widgets. In addition, subclassing (= also sharing the base implementation) makes it easier to implement new widgets. For example, in QtWidgets (C++), if you want to implement a new button type, you can inherit from QPushButton (both its interface and implementation), and you just need the reimplement a few methods to customize what you need.</span> <span> - </span> <span class="display-name">Boris Dalstein</span> <span> </span> <span class="date">18 Apr 2022 at 13:22</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>50</span>
     </div>
     <div>
      <span>Answerer: </span> <span>dance2die</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Sep 2008 at 02:25</span>
     </div>
    </div>
    <div>
     <p>In Java or C#, an object cannot change its type once it has been instantiated.</p>
     <p>So, if your object need to appear as a different object or behave differently depending on an object state or conditions, then use <strong>Composition</strong>: Refer to <a href="http://www.dofactory.com/Patterns/PatternState.aspx" rel="noreferrer">State</a> and <a href="http://www.dofactory.com/Patterns/PatternStrategy.aspx" rel="noreferrer">Strategy</a> Design Patterns.</p>
     <p>If the object need to be of the same type, then use <strong>Inheritance</strong> or implement interfaces.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>10</td>
        <td><span>+1 I've found less and less that inheritance works in most situations. I much prefer shared/inherited interfaces and composition of objects....or is it called aggregation? Don't ask me, I've got a EE degree!!</span> <span> - </span> <span class="display-name">kenny</span> <span> </span> <span class="date">21 May 2009 at 10:46</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I believe that this is the most common scenario where "composition over inheritance" applies since both could be fitting in theory. For instance, in a marketing system you might have a the concept of a <code>Client</code>. Then, a new concept of a <code>PreferredClient</code> pops up later on. Should <code>PreferredClient</code> inherit <code>Client</code>? A preferred client 'is a' client afterall, no? Well, not so fast... like you said objects cannot change their class at runtime. How would you model the <code>client.makePreferred()</code> operation? Perhaps the answer lies in using composition with a missing concept, an <code>Account</code> perhaps?</span> <span> - </span> <span class="display-name">plalx</span> <span> </span> <span class="date">31 Aug 2015 at 17:23</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Rather than having different type of <code>Client</code> classes, perhaps there's just one that encapsulates the concept of an <code>Account</code> which could be a <code>StandardAccount</code> or a <code>PreferredAccount</code>...</span> <span> - </span> <span class="display-name">plalx</span> <span> </span> <span class="date">31 Aug 2015 at 17:25</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>39</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mecki</span>
     </div>
     <div>
      <span> Answered: </span> <span>31 Jan 2013 at 19:34</span>
     </div>
    </div>
    <div>
     <p>Personally I learned to always prefer composition over inheritance. There is no programmatic problem you can solve with inheritance which you cannot solve with composition; though you may have to use Interfaces(Java) or Protocols(Obj-C) in some cases. Since C++ doesn't know any such thing, you'll have to use abstract base classes, which means you cannot get entirely rid of inheritance in C++.</p>
     <p>Composition is often more logical, it provides better abstraction, better encapsulation, better code reuse (especially in very large projects) and is less likely to break anything at a distance just because you made an isolated change anywhere in your code. It also makes it easier to uphold the "<em>Single Responsibility Principle</em>", which is often summarized as "<em>There should never be more than one reason for a class to change.</em>", and it means that every class exists for a specific purpose and it should only have methods that are directly related to its purpose. Also having a very shallow inheritance tree makes it much easier to keep the overview even when your project starts to get really large. Many people think that inheritance represents our <em>real world</em> pretty well, but that isn't the truth. The real world uses much more composition than inheritance. Pretty much every real world object you can hold in your hand has been composed out of other, smaller real world objects.</p>
     <p>There are downsides of composition, though. If you skip inheritance altogether and only focus on composition, you will notice that you often have to write a couple of extra code lines that weren't necessary if you had used inheritance. You are also sometimes forced to repeat yourself and this violates the <em>DRY Principle</em> (DRY = Don't Repeat Yourself). Also composition often requires delegation, and a method is just calling another method of another object with no other code surrounding this call. Such "double method calls" (which may easily extend to triple or quadruple method calls and even farther than that) have much worse performance than inheritance, where you simply inherit a method of your parent. Calling an inherited method may be equally fast as calling a non-inherited one, or it may be slightly slower, but is usually still faster than two consecutive method calls.</p>
     <p>You may have noticed that most OO languages don't allow multiple inheritance. While there are a couple of cases where multiple inheritance can really buy you something, but those are rather exceptions than the rule. Whenever you run into a situation where you think "multiple inheritance would be a really cool feature to solve this problem", you are usually at a point where you should re-think inheritance altogether, since even it may require a couple of extra code lines, a solution based on composition will usually turn out to be much more elegant, flexible and future proof.</p>
     <p>Inheritance is really a cool feature, but I'm afraid it has been overused the last couple of years. People treated inheritance as the one hammer that can nail it all, regardless if it was actually a nail, a screw, or maybe a something completely different.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>"Many people think that inheritance represents our real world pretty well, but that isn't the truth." So much this! Contrary to pretty much all the programming tutorials in the world ever, modeling real-world objects as inheritance chains is probably a bad idea in the long run. You should use inheritance only when there's an incredibly obvious, innate, simple is-a relationship. Like <code>TextFile</code> is a <code>File</code>.</span> <span> - </span> <span class="display-name">neonblitzer</span> <span> </span> <span class="date">6 May 2020 at 10:22</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@neonblitzer Even TextFile is-a File could be modeled without too much trouble via other techniques. For example, you could make "File" be an interface, with concrete TextFile and BinaryFile implementations, or, maybe a "File" is a class that can be instantiated with an instance of BinaryFileBehaviors or TextFileBehaviors (i.e. using the strategy pattern). I've given up on is-a, and now just follow the mantra of "inheritance is a last resort, use it when no other option will work sufficiently".</span> <span> - </span> <span class="display-name">Scotty Jamison</span> <span> </span> <span class="date">26 Apr 2022 at 01:50</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>27</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Peter Tseng</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 May 2012 at 01:59</span>
     </div>
    </div>
    <div>
     <p>My general rule of thumb: <em>Before using inheritance, consider if composition makes more sense.</em></p>
     <p>Reason: <em>Subclassing usually means more complexity and connectedness, i.e. harder to change, maintain, and scale without making mistakes.</em></p>
     <p>A much more complete and concrete <a href="http://www.javalobby.org/forums/thread.jspa?forumID=61&amp;threadID=16487#91822172" rel="noreferrer">answer from Tim Boudreau</a> of Sun:</p>
     <blockquote>
      <p>Common problems to the use of inheritance as I see it are:</p>
      <ul>
       <li><em>Innocent acts can have unexpected results</em> - The classic example of this is calls to overridable methods from the superclass constructor, before the subclasses instance fields have been initialized. In a perfect world, nobody would ever do that. This is not a perfect world.</li>
       <li><em>It offers perverse temptations for subclassers to make assumptions about order of method calls and such</em> - such assumptions tend not to be stable if the superclass may evolve over time. See also <a href="http://www.javalobby.org/forums/thread.jspa?threadID=16036&amp;messageID=91819530#91819530" rel="noreferrer">my toaster and coffee pot analogy</a>.</li>
       <li><em>Classes get heavier</em> - you don't necessarily know what work your superclass is doing in its constructor, or how much memory it's going to use. So constructing some innocent would-be lightweight object can be far more expensive than you think, and this may change over time if the superclass evolves</li>
       <li><em>It encourages an explosion of subclasses</em>. Classloading costs time, more classes costs memory. This may be a non-issue until you're dealing with an app on the scale of NetBeans, but there, we had real issues with, for example, menus being slow because the first display of a menu triggered massive class loading. We fixed this by moving to more declarative syntax and other techniques, but that cost time to fix as well.</li>
       <li><em>It makes it harder to change things later</em> - if you've made a class public, swapping the superclass is going to break subclasses - it's a choice which, once you've made the code public, you're married to. So if you're not altering the real functionality to your superclass, you get much more freedom to change things later if you use, rather than extend the thing you need. Take, for example, subclassing JPanel - this is usually wrong; and if the subclass is public somewhere, you never get a chance to revisit that decision. If it's accessed as JComponent getThePanel() , you can still do it (hint: expose models for the components within as your API).</li>
       <li><em>Object hierarchies don't scale (or making them scale later is much harder than planning ahead)</em> - this is the classic "too many layers" problem. I'll go into this below, and how the AskTheOracle pattern can solve it (though it may offend OOP purists).</li>
      </ul>
      <p>...</p>
      <p>My take on what to do, if you do allow for inheritance, which you may take with a grain of salt is:</p>
      <ul>
       <li>Expose no fields, ever, except constants</li>
       <li>Methods shall be either abstract or final</li>
       <li>Call no methods from the superclass constructor</li>
      </ul>
      <p>...</p>
      <p>all of this applies less to small projects than large ones, and less to private classes than public ones</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>20</span>
     </div>
     <div>
      <span>Answerer: </span> <span>yukondude</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Sep 2008 at 02:29</span>
     </div>
    </div>
    <div>
     <p>Inheritance is very powerful, but you can't force it (see: the <a href="http://en.wikipedia.org/wiki/Circle-ellipse_problem" rel="noreferrer">circle-ellipse problem</a>). If you really can't be completely sure of a true "is-a" subtype relationship, then it's best to go with composition.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span> <span class="arrow"> <a href="#answer_15">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>18</span>
     </div>
     <div>
      <span>Answerer: </span> <span>egaga</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 May 2009 at 08:11</span>
     </div>
    </div>
    <div>
     <p>Inheritance creates a strong relationship between a subclass and super class; subclass must be aware of super class'es implementation details. Creating the super class is much harder, when you have to think about how it can be extended. You have to document class invariants carefully, and state what other methods overridable methods use internally.</p>
     <p>Inheritance is sometimes useful, if the hierarchy really represents a is-a-relationship. It relates to Open-Closed Principle, which states that classes should be closed for modification but open to extension. That way you can have polymorphism; to have a generic method that deals with super type and its methods, but via dynamic dispatch the method of subclass is invoked. This is flexible, and helps to create indirection, which is essential in software (to know less about implementation details).</p>
     <p>Inheritance is easily overused, though, and creates additional complexity, with hard dependencies between classes. Also understanding what happens during execution of a program gets pretty hard due to layers and dynamic selection of method calls.</p>
     <p>I would suggest using composing as the default. It is more modular, and gives the benefit of late binding (you can change the component dynamically). Also it's easier to test the things separately. And if you need to use a method from a class, you are not forced to be of certain form (Liskov Substitution Principle).</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>It's worth noting that inheritance is not the only way to achieve polymorphism. The Decorator Pattern provides the appearance of polymorphism through composition.</span> <span> - </span> <span class="display-name">BitMask777</span> <span> </span> <span class="date">20 Sep 2012 at 20:16</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@BitMask777: Subtype polymorphism is only one kind of polymorphism, another would be parametric polymorphism, you don't need inheritance for that. Also more importantly: when talking about inheritance, one means class inheritance; .i.e. you can have subtype polymorphism by having a common interface for multiple classes, and you don't get the problems of inheritance.</span> <span> - </span> <span class="display-name">egaga</span> <span> </span> <span class="date">23 Sep 2012 at 11:41</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@engaga: I interpreted your comment <code>Inheritance is sometimes useful... That way you can have polymorphism</code> as hard-linking the concepts of inheritance and polymorphism (subtyping assumed given the context). My comment was intended to point out what you clarify in your comment: that inheritance is not the only way to implement polymorphism, and in fact is not necessarily the determining factor when deciding between composition and inheritance.</span> <span> - </span> <span class="display-name">BitMask777</span> <span> </span> <span class="date">1 Oct 2012 at 20:09</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_15"><span>Answer 15</span> <span class="arrow"> <a href="#answer_14">↑</a> </span> <span class="arrow"> <a href="#answer_16">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>18</span>
     </div>
     <div>
      <span>Answerer: </span> <span>simplfuzz</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Nov 2010 at 10:54</span>
     </div>
    </div>
    <div>
     <p>Suppose an aircraft has only two parts: an engine and wings.<br>
       Then there are two ways to design an aircraft class.</p>
     <pre><code>Class Aircraft extends Engine{
  var wings;
}
</code></pre>
     <p>Now your aircraft can start with having fixed wings<br>
       and change them to rotary wings on the fly. It's essentially<br>
       an engine with wings. But what if I wanted to change<br>
       the engine on the fly as well?</p>
     <p>Either the base class <code>Engine</code> exposes a mutator to change its<br>
       properties, or I redesign <code>Aircraft</code> as:</p>
     <pre><code>Class Aircraft {
  var wings;
  var engine;
}
</code></pre>
     <p>Now, I can replace my engine on the fly as well.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Your post brings up a point I'd not considered before--to continue your an analogy of mechanical objects with multiple parts, on something like a firearm, there is generally one part marked with a serial number, whose serial number is considered to be that of the firearm as a whole (for a handgun, it would typically be the frame). One may replace all the other parts and still have the same firearm, but if the frame cracks and needs to be replaced, the result of assembling a new frame with all the other parts from the original gun would be a new gun. Note that...</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">19 Aug 2012 at 16:56</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>...the fact that multiple parts of a gun might have serial numbers marked on them does not mean that a gun can have multiple identities. Only the serial number on the frame identifies the gun; the serial number on any other part identifies which gun those parts were manufactured to be assembled with, which may not be the gun to which they are assembled at any given time.</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">19 Aug 2012 at 17:00</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>In this particular case of aircraft I would definitely not recommend to 'change the engine on the fly'</span> <span> - </span> <span class="display-name">Paramvir Singh Karwal</span> <span> </span> <span class="date">30 Aug 2020 at 16:00</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_16"><span>Answer 16</span> <span class="arrow"> <a href="#answer_15">↑</a> </span> <span class="arrow"> <a href="#answer_17">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>17</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Scotty Jamison</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Mar 2022 at 07:17</span>
     </div>
    </div>
    <div>
     <p>If you want the canonical, textbook answer people have been giving since the rise of OOP (which you see many people giving in these answers), then apply the following rule: "if you have an is-a relationship, use inheritance. If you have a has-a relationship, use composition".</p>
     <p>This is the traditional advice, and if that satisfies you, you can stop reading here and go on your merry way. For everyone else...</p>
     <h1>is-a/has-a comparisons have problems</h1>
     <p>For example:</p>
     <ul>
      <li>A square is-a rectangle, but if your rectangle class has <code>setWidth()</code>/<code>setHeight()</code> methods, then there's no reasonable way to make a <code>Square</code> inherit from <code>Rectangle</code> without breaking <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="nofollow noreferrer">Liskov's substitution principle</a>.</li>
      <li>An is-a relationship can often be rephrased to sound like a has-a relationship. For example, an employee is-a person, but a person also has-an employment status of "employed".</li>
      <li>is-a relationships can lead to nasty multiple inheritance hierarchies if you're not careful. After all, there's no rule in English that states that an object <em>is</em> exactly one thing.</li>
      <li>People are quick to pass this "rule" around, but has anyone ever tried to back it up, or explain why it's a good heuristic to follow? Sure, it fits nicely into the idea that OOP is supposed to model the real world, but that's not in-and-of-itself a reason to adopt a principle.</li>
     </ul>
     <p>See <a href="https://stackoverflow.com/questions/453738/inheritance-or-composition-rely-on-is-a-and-has-a">this</a> StackOverflow question for more reading on this subject.</p>
     <p>To know when to use inheritance vs composition, we first need to understand the pros and cons of each.</p>
     <h1>The problems with implementation inheritance</h1>
     <p>Other answers have done a wonderful job at explaining the issues with inheritance, so I'll try to not delve into too many details here. But, here's a brief list:</p>
     <ul>
      <li>It can be difficult to follow a logic that weaves between base and sub-class methods.</li>
      <li>Carelessly implementing one method in your class by calling another overridable method will cause you to leak implementation details and break encapsulation, as the end-user could override your method and detect when you internally call it. (See "Effective Java" item 18).</li>
      <li>The <a href="https://en.wikipedia.org/wiki/Fragile_base_class" rel="nofollow noreferrer">fragile base problem</a>, which simply states that your end-user's code will break if they happen to depend on the leakage of implementation details when you attempt to change them. To make matters worse, most OOP languages allow inheritance by default - API designers who aren't proactively preventing people from inheriting from their public classes need to be extra cautious whenever they refactor their base classes. Unfortunately, the fragile base problem is often misunderstood, causing many to not understand what it takes to maintain a class that anyone can inherit from.</li>
      <li>The <a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem" rel="nofollow noreferrer">deadly diamond of death</a></li>
     </ul>
     <h1>The problems with composition</h1>
     <ul>
      <li>It can sometimes be a little verbose.</li>
     </ul>
     <p>That's it. I'm serious. This is still a real issue and can sometimes create conflict with the DRY principle, but it's generally not that bad, at least compared to the myriad of pitfalls associated with inheritance.</p>
     <h1>When should inheritance be used?</h1>
     <p>Next time you're drawing out your fancy UML diagrams for a project (if you do that), and you're thinking about adding in some inheritance, please adhere to the following advice: don't.</p>
     <p>At least, not yet.</p>
     <p>Inheritance is sold as a tool to achieve polymorphism, but bundled with it is this powerful code-reuse system, that frankly, most code doesn't need. The problem is, as soon as you publicly expose your inheritance hierarchy, you're locked into this particular style of code-reuse, even if it's overkill to solve your particular problem.</p>
     <p>To avoid this, my two cents would be to never expose your base classes publicly.</p>
     <ul>
      <li>If you need polymorphism, use an interface.</li>
      <li>If you need to allow people to customize the behavior of your class, provide explicit hook-in points via <a href="https://en.wikipedia.org/wiki/Strategy_pattern" rel="nofollow noreferrer">the strategy pattern</a>, it's a more readable way to accomplish this, plus, it's easier to keep this sort of API stable as you're in full control over what behaviors they can and can not change.</li>
      <li>If you're trying to follow the open-closed principle by using inheritance to avoid adding a much-needed update to a class, just don't. Update the class. Your codebase will be much cleaner if you actually take ownership of the code you're hired to maintain instead of trying to tack stuff onto the side of it. If you're scared about introducing bugs, then get the existing code under test.</li>
      <li>If you need to reuse code, start out by trying to use composition or helper functions.</li>
     </ul>
     <p>Finally, if you've decided that there's no other good option, and you must use inheritance to achieve the code-reuse that you need, then you can use it, but, follow these four <strong>P.A.I.L.</strong> rules of restricted inheritance to keep it sane.</p>
     <ol>
      <li>Use inheritance as a <strong>private</strong> implementation detail. Don't expose your base class publicly, use interfaces for that. This lets you freely add or remove inheritance as you see fit without making a breaking change.</li>
      <li>Keep your base class <strong>abstract</strong>. It makes it easier to divide out the logic that needs to be shared from the logic that doesn't.</li>
      <li><strong>Isolate</strong> your base and child classes. Don't let your subclass override base class methods (use the strategy pattern for that), and avoid having them expect properties/methods to exist on each other, use other forms of code-sharing to achieve that. Use appropriate language features to force all methods on the base class to be non-overridable ("final" in Java, or non-virtual in C#).</li>
      <li>Inheritance is a <strong>last</strong> resort.</li>
     </ol>
     <p>The <strong>Isolate</strong> rule in particular may sound a little rough to follow, but if you discipline yourself, you'll get some pretty nice benefits. In particular, it gives you the freedom to avoid all of the main nasty pitfalls associated with the inheritance that were mentioned above.</p>
     <ul>
      <li>It's much easier to follow the code because it doesn't weave in and out of base/sub classes.</li>
      <li>You can not accidentally leak when your methods are internally calling other overridable methods if you never make any of your methods overridable. In other words, you won't accidentally break encapsulation.</li>
      <li>The fragile base class problem stems from the ability to depend on accidentally leaked implementation details. Since the base class is now isolated, it will be no more fragile than a class depending on another via composition.</li>
      <li>The deadly diamond of death isn't an issue anymore, since there's simply no need to have multiple layers of inheritance. If you have the abstract base classes B and C, which both share a lot of functionality, just move that functionality out of B and C and into a new abstract base class, class D. Anyone who inherited from B should update to inherit from both B and D, and anyone who inherited from C should inherit from C and D. Since your base classes are all private implementation details, it shouldn't be too difficult to figure out who's inheriting from what, to make these changes.</li>
     </ul>
     <h2>Conclusion</h2>
     <p>My primary suggestion would be to use your brain on this matter. What's far more important than a list of dos and don'ts about when to use inheritance is an intuitive understanding of inheritance and its associated pros and cons, along with a good understanding of the other tools out there that can be used instead of inheritance (composition isn't the only alternative. For example, the strategy pattern is an amazing tool that's forgotten far too often). Perhaps when you have a good, solid understanding of all of these tools, you'll choose to use inheritance more often than I would recommend, and that's completely fine. At least, you're making an informed decision, and aren't just using inheritance because that's the only way you know how to do it.</p>
     <p>Further reading:</p>
     <ul>
      <li><a href="https://javascript.plainenglish.io/composition-alone-cant-replace-inheritance-606760f03d60?source=friends_link&amp;sk=24f58b20b2d4162404376c6f7ec16301" rel="nofollow noreferrer">An article</a> I wrote on this subject, that dives even deeper and provides examples.</li>
      <li><a href="https://yourbasic.org/golang/inheritance-object-oriented/" rel="nofollow noreferrer">A webpage</a> talking about three different jobs that inheritance does, and how those jobs can be done via other means in the Go language.</li>
      <li><a href="https://programming.guide/java/when-to-create-a-final-class.html" rel="nofollow noreferrer">A list</a> of reasons why it can be good to declare your class as non-inheritable (e.g. "final" in Java).</li>
      <li>The "Effective Java" book by Joshua Bloch, item 18, which discusses composition over inheritance, and some of the dangers of inheritance.</li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_17"><span>Answer 17</span> <span class="arrow"> <a href="#answer_16">↑</a> </span> <span class="arrow"> <a href="#answer_18">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>14</span>
     </div>
     <div>
      <span>Answerer: </span> <span>nabeelfarid</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Oct 2010 at 11:57</span>
     </div>
    </div>
    <div>
     <p>You need to have a look at <strong><a href="http://web.archive.org/web/20110722014513/http://www.objectmentor.com/resources/articles/lsp.pdf" rel="noreferrer">The Liskov Substitution Principle</a></strong> in Uncle Bob's <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" rel="noreferrer">SOLID</a> principles of class design. :)</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_18"><span>Answer 18</span> <span class="arrow"> <a href="#answer_17">↑</a> </span> <span class="arrow"> <a href="#answer_19">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>10</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Scott Hannen</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 May 2016 at 20:24</span>
     </div>
    </div>
    <div>
     <p>To address this question from a different perspective for newer programmers:</p>
     <p>Inheritance is often taught early when we learn object-oriented programming, so it's seen as an easy solution to a common problem.</p>
     <blockquote>
      <p>I have three classes that all need some common functionality. So if I write a base class and have them all inherit from it, then they will all have that functionality and I'll only need to maintain it in once place.</p>
     </blockquote>
     <p>It sounds great, but in practice it almost never, ever works, for one of several reasons:</p>
     <ul>
      <li>We discover that there are some other functions that we want our classes to have. If the way that we add functionality to classes is through inheritance, we have to decide - do we add it to the existing base class, even though not every class that inherits from it needs that functionality? Do we create another base class? But what about classes that already inherit from the other base class?</li>
      <li>We discover that for just one of the classes that inherits from our base class we want the base class to behave a little differently. So now we go back and tinker with our base class, maybe adding some virtual methods, or even worse, some code that says, "If I'm inherited type A, do this, but if I'm inherited type B, do that." That's bad for lots of reasons. One is that every time we change the base class, we're effectively changing every inherited class. So we're really changing class A, B, C, and D because we need a slightly different behavior in class A. As careful as we think we are, we might break one of those classes for reasons that have nothing to do with those classes.</li>
      <li>We might know why we decided to make all of these classes inherit from each other, but it might not (probably won't) make sense to someone else who has to maintain our code. We might force them into a difficult choice - do I do something really ugly and messy to make the change I need (see the previous bullet point) or do I just rewrite a bunch of this.</li>
     </ul>
     <p>In the end, we tie our code in some difficult knots and get no benefit whatsoever from it except that we get to say, "Cool, I learned about inheritance and now I used it." That's not meant to be condescending because we've all done it. But we all did it because no one told us not to.</p>
     <p>As soon as someone explained "favor composition over inheritance" to me, I thought back over every time I tried to share functionality between classes using inheritance and realized that most of the time it didn't really work well.</p>
     <p>The antidote is the <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noreferrer">Single Responsibility Principle</a>. Think of it as a constraint. My class <em>must</em> do one thing. I <em>must</em> be able to give my class a name that somehow describes that one thing it does. (There are exceptions to everything, but absolute rules are sometimes better when we're learning.) It follows that I cannot write a base class called <code>ObjectBaseThatContainsVariousFunctionsNeededByDifferentClasses</code>. Whatever distinct functionality I need must be in its own class, and then other classes that need that functionality can depend on that class, <em>not</em> inherit from it.</p>
     <p>At the risk of oversimplifying, that's composition - composing multiple classes to work together. And once we form that habit we find that it's much more flexible, maintainable, and testable than using inheritance.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>That classes can't use multiple base classes is not a poor reflection on Inheritance but rather a poor reflection on a particular language's lack of capability.</span> <span> - </span> <span class="display-name">iPherian</span> <span> </span> <span class="date">19 Apr 2017 at 22:22</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>In the time since writing this answer, I read <a href="http://blog.cleancoder.com/uncle-bob/2015/01/08/InterfaceConsideredHarmful.html" rel="nofollow noreferrer">this post</a> from "Uncle Bob" which addresses that lack of capability. I've never used a language that allows multiple inheritance. But looking back, the question is tagged "language agnostic" and my answer assumes C#. I need to broaden my horizons.</span> <span> - </span> <span class="display-name">Scott Hannen</span> <span> </span> <span class="date">23 Apr 2017 at 14:04</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The second bullet point merely seems to be explaining the need for overrides, which I've never heard of a language that doesn't provide.</span> <span> - </span> <span class="display-name">Trevortni</span> <span> </span> <span class="date">30 May 2023 at 19:26</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>That works if it was understood in advance which behaviors we’ll need to override and the class is organized to make that simple. Otherwise the result is confusing control flow or we still end up modifying other classes. It’s possible to do it for the right reasons and get it right. More often we couple unrelated classes to each other via a base class and it then the problems start to show up.</span> <span> - </span> <span class="display-name">Scott Hannen</span> <span> </span> <span class="date">30 May 2023 at 22:57</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_19"><span>Answer 19</span> <span class="arrow"> <a href="#answer_18">↑</a> </span> <span class="arrow"> <a href="#answer_20">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Anzurio</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 May 2009 at 01:43</span>
     </div>
    </div>
    <div>
     <p>When you want to "copy"/Expose the base class' API, you use inheritance. When you only want to "copy" functionality, use delegation.</p>
     <p>One example of this: You want to create a Stack out of a List. Stack only has pop, push and peek. You shouldn't use inheritance given that you don't want push_back, push_front, removeAt, et al.-kind of functionality in a Stack.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>@Anzurio....How do you differentiate API vs functionlaity? According to me exposed methods of a class we call them as api methods of that class. These are the functionality of the class as well. If you use composition, You use public methods of rhe class, we have already called them API.</span> <span> - </span> <span class="display-name">sdindiver</span> <span> </span> <span class="date">26 Jun 2020 at 18:06</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@sdindiver sorry for the confusion. The point I was trying to make is that, when using inheritance, you will expose the complete API of the parent class but, if the child class needn't expose that full parent's API, you use composition instead such that the child class will have access to the parent class' functionality without exposing its full API.</span> <span> - </span> <span class="display-name">Anzurio</span> <span> </span> <span class="date">27 Jun 2020 at 01:11</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_20"><span>Answer 20</span> <span class="arrow"> <a href="#answer_19">↑</a> </span> <span class="arrow"> <a href="#answer_21">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Tero Tolonen</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Apr 2013 at 20:15</span>
     </div>
    </div>
    <div>
     <p>These two ways can live together just fine and actually support each other.</p>
     <p>Composition is just playing it modular: you create interface similar to the parent class, create new object and delegate calls to it. If these objects need not to know of each other, it's quite safe and easy to use composition. There are so many possibilites here.</p>
     <p>However, if the parent class for some reason needs to access functions provided by the "child class" for inexperienced programmer it may look like it's a great place to use inheritance. The parent class can just call it's own abstract "foo()" which is overwritten by the subclass and then it can give the value to the abstract base.</p>
     <p>It looks like a nice idea, but in many cases it's better just give the class an object which implements the foo() (or even set the value provided the foo() manually) than to inherit the new class from some base class which requires the function foo() to be specified.</p>
     <p>Why?</p>
     <p><strong>Because inheritance is a poor way of moving information</strong>.</p>
     <p>The composition has a real edge here: the relationship can be reversed: the "parent class" or "abstract worker" can aggregate any specific "child" objects implementing certain interface + <strong>any child can be set inside any other type of parent, which accepts it's type</strong>. And there can be any number of objects, for example MergeSort or QuickSort could sort any list of objects implementing an abstract Compare -interface. Or to put it another way: any group of objects which implement "foo()" and other group of objects which can make use of objects having "foo()" can play together.</p>
     <p>I can think of three real reasons for using inheritance:</p>
     <ol>
      <li>You have many classes with <strong>same interface</strong> and you want to save time writing them</li>
      <li>You have to use same Base Class for each object</li>
      <li>You need to modify the private variables, which can not be public in any case</li>
     </ol>
     <p>If these are true, then it is probably necessary to use inheritance.</p>
     <p>There is nothing bad in using reason 1, it is very good thing to have a solid interface on your objects. This can be done using composition or with inheritance, no problem - if this interface is simple and does not change. Usually inheritance is quite effective here.</p>
     <p>If the reason is number 2 it gets a bit tricky. Do you really only need to use the same base class? In general, just using the same base class is not good enough, but it may be a requirement of your framework, a design consideration which can not be avoided.</p>
     <p>However, if you want to use the private variables, the case 3, then you may be in trouble. <strong>If you consider global variables unsafe, then you should consider using inheritance to get access to private variables also unsafe</strong>. Mind you, global variables are not all THAT bad - databases are essentially big set of global variables. But if you can handle it, then it's quite fine.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_21"><span>Answer 21</span> <span class="arrow"> <a href="#answer_20">↑</a> </span> <span class="arrow"> <a href="#answer_22">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Jon Limjap</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Sep 2008 at 03:00</span>
     </div>
    </div>
    <div>
     <p>Aside from is a/has a considerations, one must also consider the "depth" of inheritance your object has to go through. Anything beyond five or six levels of inheritance deep might cause unexpected casting and boxing/unboxing problems, and in those cases it might be wise to compose your object instead.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_22"><span>Answer 22</span> <span class="arrow"> <a href="#answer_21">↑</a> </span> <span class="arrow"> <a href="#answer_23">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Amir Aslam</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Dec 2013 at 01:57</span>
     </div>
    </div>
    <div>
     <p>When you have an <strong>is-a</strong> relation between two classes (example dog is a canine), you go for inheritance.</p>
     <p>On the other hand when you have <strong>has-a</strong> or some adjective relationship between two classes (student has courses) or (teacher studies courses), you chose composition.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>You said inheritance and inheritance. don't you mean inheritance and composition?</span> <span> - </span> <span class="display-name">trevorKirkby</span> <span> </span> <span class="date">30 Dec 2013 at 02:21</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>No, you don't. You can just as well define a canine interface and let every dog implement it and you'll end up with more SOLID code.</span> <span> - </span> <span class="display-name">markus</span> <span> </span> <span class="date">4 Oct 2015 at 13:49</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_23"><span>Answer 23</span> <span class="arrow"> <a href="#answer_22">↑</a> </span> <span class="arrow"> <a href="#answer_24">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Yash Sampat</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Jun 2014 at 11:36</span>
     </div>
    </div>
    <div>
     <p>A simple way to make sense of this would be that inheritance should be used when you need an object of your class to have the same <em>interface</em> as its parent class, so that it can thereby be treated as an object of the parent class (upcasting). Moreover, function calls on a derived class object would remain the same everywhere in code, but the specific method to call would be determined at runtime (i.e. the low-level <em>implementation</em> differs, the high-level <em>interface</em> remains the same).</p>
     <p>Composition should be used when you do not need the new class to have the same interface, i.e. you wish to conceal certain aspects of the class' implementation which the user of that class need not know about. So composition is more in the way of supporting <em>encapsulation</em> (i.e. concealing the implementation) while inheritance is meant to support <em>abstraction</em> (i.e. providing a simplified representation of something, in this case the <strong>same</strong> interface for a range of types with different internals).</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>+1 for mention of interface. I use this approach often to hide existing classes and make my new class properly unit testable by mocking out the object used for composition. This requires the owner of the new object to pass it the candidate parent class instead.</span> <span> - </span> <span class="display-name">Kell</span> <span> </span> <span class="date">13 Jun 2014 at 10:39</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_24"><span>Answer 24</span> <span class="arrow"> <a href="#answer_23">↑</a> </span> <span class="arrow"> <a href="#answer_25">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Shelby Moore III</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Dec 2011 at 07:40</span>
     </div>
    </div>
    <div>
     <p>Subtyping is appropriate and more powerful where the <a href="https://stackoverflow.com/a/8352969">invariants can be enumerated</a>, else use function composition for extensibility.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_25"><span>Answer 25</span> <span class="arrow"> <a href="#answer_24">↑</a> </span> <span class="arrow"> <a href="#answer_26">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Parag</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Dec 2011 at 10:40</span>
     </div>
    </div>
    <div>
     <p>I agree with @Pavel, when he says, there are places for composition and there are places for inheritance.</p>
     <p>I think inheritance should be used if your answer is an affirmative to any of these questions.</p>
     <ul>
      <li>Is your class part of a structure that benefits from polymorphism ? For example, if you had a Shape class, which declares a method called draw(), then we clearly need Circle and Square classes to be subclasses of Shape, so that their client classes would depend on Shape and not on specific subclasses.</li>
      <li>Does your class need to re-use any high level interactions defined in another class ? The <a href="http://en.wikipedia.org/wiki/Template_method_pattern" rel="nofollow noreferrer">template method</a> design pattern would be impossible to implement without inheritance. I believe all extensible frameworks use this pattern.</li>
     </ul>
     <p>However, if your intention is purely that of code re-use, then composition most likely is a better design choice.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_26"><span>Answer 26</span> <span class="arrow"> <a href="#answer_25">↑</a> </span> <span class="arrow"> <a href="#answer_27">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Enrique Molinari</span>
     </div>
     <div>
      <span> Answered: </span> <span>31 Aug 2013 at 13:41</span>
     </div>
    </div>
    <div>
     <p>Inheritance is a very powerfull machanism for code reuse. But needs to be used properly. I would say that inheritance is used correctly if the subclass is also a subtype of the parent class. As mentioned above, the Liskov Substitution Principle is the key point here.</p>
     <p>Subclass is not the same as subtype. You might create subclasses that are not subtypes (and this is when you should use composition). To understand what a subtype is, lets start giving an explanation of what a type is.</p>
     <p>When we say that the number 5 is of type integer, we are stating that 5 belongs to a set of possible values (as an example, see the possible values for the Java primitive types). We are also stating that there is a valid set of methods I can perform on the value like addition and subtraction. And finally we are stating that there are a set of properties that are always satisfied, for example, if I add the values 3 and 5, I will get 8 as a result.</p>
     <p>To give another example, think about the abstract data types, Set of integers and List of integers, the values they can hold are restricted to integers. They both support a set of methods, like add(newValue) and size(). And they both have different properties (class invariant), Sets does not allow duplicates while List does allow duplicates (of course there are other properties that they both satisfy).</p>
     <p>Subtype is also a type, which has a relation to another type, called parent type (or supertype). The subtype must satisfy the features (values, methods and properties) of the parent type. The relation means that in any context where the supertype is expected, it can be substitutable by a subtype, without affecting the behaviour of the execution. Let’s go to see some code to exemplify what I’m saying. Suppose I write a List of integers (in some sort of pseudo language):</p>
     <pre><code>class List {
  data = new Array();

  Integer size() {
    return data.length;
  }

  add(Integer anInteger) {
    data[data.length] = anInteger;
  }
}
</code></pre>
     <p>Then, I write the Set of integers as a subclass of the List of integers:</p>
     <pre><code>class Set, inheriting from: List {
  add(Integer anInteger) {
     if (data.notContains(anInteger)) {
       super.add(anInteger);
     }
  }
}
</code></pre>
     <p>Our Set of integers class is a subclass of List of Integers, but is not a subtype, due to it is not satisfying all the features of the List class. The values, and the signature of the methods are satisfied but the properties are not. The behaviour of the add(Integer) method has been clearly changed, not preserving the properties of the parent type. Think from the point of view of the client of your classes. They might receive a Set of integers where a List of integers is expected. The client might want to add a value and get that value added to the List even if that value already exist in the List. But her wont get that behaviour if the value exists. A big suprise for her!</p>
     <p>This is a classic example of an improper use of inheritance. Use composition in this case.</p>
     <p>(a fragment from: <a href="http://www.copypasteisforword.com/notes/use-inheritance-properly" rel="nofollow">use inheritance properly</a>).</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_27"><span>Answer 27</span> <span class="arrow"> <a href="#answer_26">↑</a> </span> <span class="arrow"> <a href="#answer_28">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ravindra babu</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Sep 2016 at 09:31</span>
     </div>
    </div>
    <div>
     <p>Even though Composition is preferred, I would like to highlight pros of <em>Inheritance</em> and cons of <em>Composition</em>.</p>
     <p><strong><em>Pros of Inheritance:</em></strong></p>
     <ol>
      <li>
       <p>It establishes a logical "<strong>IS A"</strong> relation. If <em>Car</em> and <em>Truck</em> are two types of <em>Vehicle</em> ( base class), child class <strong>IS A</strong> base class.</p>
       <p>i.e.</p>
       <p><em>Car is a Vehicle</em></p>
       <p><em>Truck is a Vehicle</em></p></li>
      <li>
       <p>With inheritance, you can define/modify/extend a capability</p>
       <ol>
        <li>Base class provides no implementation and sub-class has to override complete method (abstract) =&gt; <strong><em>You can implement a contract</em></strong></li>
        <li>Base class provides default implementation and sub-class can change the behaviour =&gt; <strong><em>You can re-define contract</em></strong></li>
        <li>Sub-class adds extension to base class implementation by calling super.methodName() as first statement =&gt; <strong><em>You can extend a contract</em></strong></li>
        <li>Base class defines structure of the algorithm and sub-class will override a part of algorithm =&gt; <strong><em>You can implement <a href="https://en.wikipedia.org/wiki/Template_method_pattern" rel="nofollow noreferrer">Template_method</a> without change in base class skeleton</em></strong></li>
       </ol></li>
     </ol>
     <p><strong><em>Cons of Composition:</em></strong></p>
     <ol>
      <li>In inheritance, subclass can directly invoke base class method even though it's not implementing base class method because of <strong><em>IS A</em></strong> relation. If you use composition, you have to add methods in container class to expose contained class API</li>
     </ol>
     <p>e.g. If <em>Car</em> contains <em>Vehicle</em> and if you have to get price of the <em>Car</em>, which has been defined in <em>Vehicle</em>, your code will be like this</p>
     <pre><code>class Vehicle{
     protected double getPrice(){
          // return price
     }
} 

class Car{
     Vehicle vehicle;
     protected double getPrice(){
          return vehicle.getPrice();
     }
} 
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>I think it doesn't answer the question</span> <span> - </span> <span class="display-name">almanegra</span> <span> </span> <span class="date">15 Mar 2017 at 14:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>You can have re-look at OP question. I have addressed : What trade-offs are there for each approach?</span> <span> - </span> <span class="display-name">Ravindra babu</span> <span> </span> <span class="date">15 Mar 2017 at 14:34</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>As you mentioned, you talk only about "pros of Inheritance and cons of Composition", and not the tradeoffs for EACH approach or the cases where you should use one over another</span> <span> - </span> <span class="display-name">almanegra</span> <span> </span> <span class="date">15 Mar 2017 at 15:08</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>pros and cons provides trade-off since pros of inheritance is cons of composition and cons of composition is pros of inheritance.</span> <span> - </span> <span class="display-name">Ravindra babu</span> <span> </span> <span class="date">15 Mar 2017 at 15:17</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>i am late to the party but; since cons of composition is pros of inheritence, you didnt talk about cons of inheritance. you only talked about pros of inheritance, twice.</span> <span> - </span> <span class="display-name">numan</span> <span> </span> <span class="date">3 Feb 2022 at 13:03</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_28"><span>Answer 28</span> <span class="arrow"> <a href="#answer_27">↑</a> </span> <span class="arrow"> <a href="#answer_29">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Evrhet Milam</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Sep 2008 at 02:14</span>
     </div>
    </div>
    <div>
     <p>A rule of thumb I have heard is inheritance should be used when its a "is-a" relationship and composition when its a "has-a". Even with that I feel that you should always lean towards composition because it eliminates a lot of complexity.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_29"><span>Answer 29</span> <span class="arrow"> <a href="#answer_28">↑</a> </span> <span class="arrow"> <a href="#answer_30">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>LCJ</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Aug 2012 at 11:15</span>
     </div>
    </div>
    <div>
     <p>As many people told, I will first start with the check - whether there exists an "is-a" relationship. If it exists I usually check the following:</p>
     <blockquote>
      <p>Whether the base class can be instantiated. That is, whether the base class can be non-abstract. If it can be non-abstract I usually prefer composition</p>
     </blockquote>
     <p>E.g 1. Accountant <strong>is an</strong> Employee. But I will <strong>not</strong> use inheritance because a Employee object can be instantiated.</p>
     <p>E.g 2. Book <strong>is a</strong> SellingItem. A SellingItem cannot be instantiated - it is abstract concept. Hence I will use inheritacne. The SellingItem is an <strong>abstract base class (or interface</strong> in C#)</p>
     <p>What do you think about this approach?</p>
     <p>Also, I support @anon answer in <a href="https://stackoverflow.com/questions/3351666/why-use-inheritance-at-all?lq=1">Why use inheritance at all?</a></p>
     <blockquote>
      <p>The main reason for using inheritance is not as a form of composition - it is so you can get polymorphic behaviour. If you don't need polymorphism, you probably should not be using inheritance.</p>
     </blockquote>
     <p>@MatthieuM. says in <a href="https://softwareengineering.stackexchange.com/questions/12439/code-smell-inheritance-abuse/12448#comment303759_12448">https://softwareengineering.stackexchange.com/questions/12439/code-smell-inheritance-abuse/12448#comment303759_12448</a></p>
     <blockquote>
      <p>The issue with inheritance is that it can be used for two orthogonal purposes:</p>
      <p>interface (for polymorphism)</p>
      <p>implementation (for code reuse)</p>
     </blockquote>
     <p><strong>REFERENCE</strong></p>
     <ol>
      <li><a href="https://stackoverflow.com/questions/38820/which-class-design-is-better?lq=1">Which class design is better?</a></li>
      <li><a href="https://stackoverflow.com/questions/269496/inheritance-vs-aggregation/269553#comment15610225_269553">Inheritance vs. Aggregation</a></li>
     </ol>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>I'm not sure why 'the base class is abstract?' figures into the discussion.. the LSP: will all functions that operate on Dogs work if Poodle objects are passed in ? If yes, then Poodle is can be substituted for Dog and hence can inherit from Dog.</span> <span> - </span> <span class="display-name">Gishu</span> <span> </span> <span class="date">1 Aug 2012 at 12:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Gishu Thanks. I will definitely look into LSP. But before that, can you please provide an "example where inheritance is proper in which base class cannot be abstract". What I think is, inheritance is applicable only if base class is abstract. If base class need to be instantiated separately, do not go for inheritance. That is, even though Accountant is an Employee, do not use inheritance.</span> <span> - </span> <span class="display-name">LCJ</span> <span> </span> <span class="date">2 Aug 2012 at 07:11</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>been reading WCF lately. An example in the .net framework is SynchronizationContext (base + can be instantiated) which queues work onto a ThreadPool thread. Derivations include WinFormsSyncContext (queue onto UI Thread) and DispatcherSyncContext (queue onto WPF Dispatcher)</span> <span> - </span> <span class="display-name">Gishu</span> <span> </span> <span class="date">2 Aug 2012 at 09:05</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Gishu Thanks. However, it would be more helpful if you can provide a scenario based on Bank domain, HR domain, Retail domain or any other popular domain.</span> <span> - </span> <span class="display-name">LCJ</span> <span> </span> <span class="date">2 Aug 2012 at 09:08</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Sorry. I'm not familiar with those domains.. Another example if the previous one was too obtuse is the Control class in Winforms/WPF. The base/generic control can be instantiated. Derivations include Listboxes, Textboxes, etc. Now that I think of it, the Decorator Design pattern is a good example IMHO and useful too. The decorator derives from the non-abstract object that it wants to wrap/decorate.</span> <span> - </span> <span class="display-name">Gishu</span> <span> </span> <span class="date">2 Aug 2012 at 09:28</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_30"><span>Answer 30</span> <span class="arrow"> <a href="#answer_29">↑</a> </span> <span class="arrow"> <a href="#answer_31">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Shami Qureshi</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Mar 2014 at 09:39</span>
     </div>
    </div>
    <div>
     <p>Composition v/s Inheritance is a wide subject. There is no real answer for what is better as I think it all depends on the design of the system.</p>
     <p>Generally type of relationship between object provide better information to choose one of them.</p>
     <p>If relation type is "IS-A" relation then Inheritance is better approach. otherwise relation type is "HAS-A" relation then composition will better approach.</p>
     <p>Its totally depend on entity relationship.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_31"><span>Answer 31</span> <span class="arrow"> <a href="#answer_30">↑</a> </span> <span class="arrow"> <a href="#answer_32">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Veverke</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Apr 2015 at 12:41</span>
     </div>
    </div>
    <div>
     <p>I see no one mentioned the <a href="http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem" rel="nofollow"><strong>diamond problem</strong></a>, which might arise with inheritance.</p>
     <p>In a glance, if classes B and C inherit A and both override method X, and a fourth class D, inherits from both B and C, and does not override X, which implementation of X D is supposed to use?</p>
     <p><a href="http://en.wikipedia.org/wiki/Composition_over_inheritance" rel="nofollow">Wikipedia</a> offers a nice overview of the topic being discussed in this question.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>D inherits B and C not A. If so, then it'd use the implementation of X that is in class A.</span> <span> - </span> <span class="display-name">fabricio</span> <span> </span> <span class="date">13 May 2015 at 11:46</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@fabricio: thanks, I edited the text. By the way, such scenario cannot occur in languages that do not allow multiple class inheritance, am I right ?</span> <span> - </span> <span class="display-name">Veverke</span> <span> </span> <span class="date">14 May 2015 at 08:59</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>yes you are right.. and I've never worked with one that allows multiple inheritance (as per the example in the diamond problem)..</span> <span> - </span> <span class="display-name">fabricio</span> <span> </span> <span class="date">14 May 2015 at 15:11</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>It is not the problem at all as this is the basic way of scaling systems or reserving facilities and functionality for load balancing. Both the implementations are present, and it is up to the user or load balancing algorithm/rules to decide which one and when to apply. On the language level it is not a problem because even in your question all implementations of the method <code>X</code>are identified with different qualified names.</span> <span> - </span> <span class="display-name">Aleksey F.</span> <span> </span> <span class="date">7 Oct 2021 at 00:31</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_32"><span>Answer 32</span> <span class="arrow"> <a href="#answer_31">↑</a> </span> <span class="arrow"> <a href="#answer_33">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>luke1985</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Jan 2014 at 13:57</span>
     </div>
    </div>
    <div>
     <p>This rule is a complete nonsense. Why?</p>
     <p>The reason is that in every case it is possible to tell whether to use composition or inheritance. This is determined by the answer to a question: "IS something A something else" or "HAS something A something else".</p>
     <p>You cannot "prefer" to make something to be something else or to have something else. Strict logical rules apply.</p>
     <p>Also there are no "contrived examples" because in every situation an answer to this question can be given.</p>
     <p>If you cannot answer this question there is something else wrong. This includes overlapping responsibilities of classess which are usually the result of <a href="http://devmatrix.wordpress.com/wp-admin/post.php?post=115&amp;action=edit&amp;message=6&amp;postpost=v2" rel="nofollow">wrong use of interfaces</a>, less often by rewriting same code in different classess.</p>
     <p>To avoid this situations I also recommend to use good names for classes , that fully resemble their responsibilities.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span>Your point is a good one, though I think it should be phrased somewhat better; also, there <i>are</i> some borderline cases (you suggest there are none whatsoever). The key point is that in most cases, the decision is actually very straightforward and should not be considered a judgment call. The real question to answer in asking whether a Foo should <i>be</i> a Bar or <i>contain</i> one, will be whether it will be necessary to have any code operate on the <code>Foo</code> within a <code>Bar</code> *while retaining its identity as a <code>Bar</code>. If not, simply encapsulate a <code>Foo</code> and expose it as a member.</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">5 Jan 2014 at 22:26</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>No there are no borderline cases. Every case can be solved by factors that are not obvious at first. The matter requires a deep analysis, otherwise - arbitrary decision will cause problems leading to bad code.</span> <span> - </span> <span class="display-name">luke1985</span> <span> </span> <span class="date">6 Jan 2014 at 14:13</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>And only semantics can determine this. If you are in situation when you need any code to operate on the Foo within a Bar while retaining its identity as Bar - you shouldn't make decision upon this. You, as a designer of the class API should know whether to use delegates or expose that member.</span> <span> - </span> <span class="display-name">luke1985</span> <span> </span> <span class="date">6 Jan 2014 at 14:26</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>An object-oriented model of the universe should be regarded as a tool which is often useful to facilitate the solving of many real-world problems. Not all real-world problems are a good fit for an object-oriented model, however. Sometimes even when inheritance isn't a perfect fit for an object-oriented model, it may allow existing code to be used without modification in cases that would otherwise require more rework. Such usage may incur some "technical debt", but if the program is expected to be obsolete before that poses a problem, such obsolescence would essentially vacate any such debt.</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">6 Jan 2014 at 18:22</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>All real world problems can be solved using an object oriented model, because everything fits into a definition of object. Inheritance is the only fit for an object-oriented model. I know cases, where people search refugee in interfaces, traits or multiple inheritance because they are simply not capable of figuring out the correct inheritance. It's their code that represents technical debt, which actually means a negligence and ignorance. While algorithmic correctness comes from iterative process of trial and error - OOP doesn't allow any mistakes which instantly take their toll. . . .</span> <span> - </span> <span class="display-name">luke1985</span> <span> </span> <span class="date">6 Jan 2014 at 21:07</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>. . . And that is a reason why there is a lot of bad code around, a lot of bad practices are being taught (like SOLID, and AGILE). This approaches are presented as solution to programming pains. But there are no solutions, no golden rule. The pains will last forever because God cursed the earth, doing this things that those "technigques" have to "offer" actually add to these pains more and more, not mentioning that less good things come out of this. The software this days, as everybody can see is shallow, uninteresting, superficial and cheap. Unexciting and uncolorfull.</span> <span> - </span> <span class="display-name">luke1985</span> <span> </span> <span class="date">6 Jan 2014 at 21:21</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>In the real world, systems are periodically replaced. Well-designed systems have room for at least one layer of "kludge" changes to be implemented reliably <i>if no further changes are ever required</i>. If a new system will be coming on line in a month and the old system will have no usefulness past that time, but people need to add a new function to the old system ASAP, a kludge which can be implemented reliably in 48 hours may be preferable to a better-engineered solution which would take a week. If it turns out the new system never comes on-line, the kludge might cause pain later, but...</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">6 Jan 2014 at 21:31</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>...if the new system is installed on schedule, the extra effort required for a clean solution may be essentially wasted.</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">6 Jan 2014 at 21:33</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>They are replaced because they are all not perfect and they are not perfect because they are created with money in mind and not their users. That's the ultimate answer why they fail. This involves both sides: the producer which want to minimize costs and the consumer which doesn't want to spend enough time to analyse his real needs in order to maximize his profits by getting involved in other activities.</span> <span> - </span> <span class="display-name">luke1985</span> <span> </span> <span class="date">6 Jan 2014 at 21:39</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>"All real world problems can be solved using an object oriented model, because everything fits into a definition of object." All real world problems can also be solved by a Turing Machine, because everything fits into a definition of Turing Machine. That doesn't make it a good idea though.</span> <span> - </span> <span class="display-name">Warbo</span> <span> </span> <span class="date">30 May 2014 at 11:39</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>leading in with "This rule is a complete nonsense" is a little obtuse, try making the points the strong statement.</span> <span> - </span> <span class="display-name">Catalyst</span> <span> </span> <span class="date">24 Jun 2016 at 22:36</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>It's not a rule, it's a principle. If it was a rule then one could logically interpret it as, "Never, ever inherit. Compose instead." A less experienced programmer needs that guidance. They're not going to intuitively going to know which is better, and they're likely to lean toward inheritance because learning materials emphasize it. And experienced programmers make bad choices too, so it's good for all of us.</span> <span> - </span> <span class="display-name">Scott Hannen</span> <span> </span> <span class="date">29 Jul 2016 at 13:26</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Indeed, the question of the OP is rather pointless. It's like asking: "Which is better, train or boat?". If you're on an island with no bridges, the boat is better. If you are far away from the coast and the destination is connected to you by land, the train is better. In some situations, inheritance involves less work, in other situations, composition involves less work.</span> <span> - </span> <span class="display-name">iPherian</span> <span> </span> <span class="date">19 Apr 2017 at 22:35</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_33"><span>Answer 33</span> <span class="arrow"> <a href="#answer_32">↑</a> </span> <span class="arrow"> <a href="#answer_34">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Alexey Nikitenko</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Oct 2022 at 23:17</span>
     </div>
    </div>
    <div>
     <p>Just opinion, inheritance should only be used when:</p>
     <ul>
      <li>Both classes are in the same logical domain</li>
      <li>The subclass is a proper subtype of the superclass</li>
      <li>The superclass’s implementation is necessary or appropriate for the subclass</li>
      <li>The enhancements made by the subclass are primarily additive.</li>
     </ul>
     <p>There are times when all of these things converge:</p>
     <ul>
      <li>Higher-level domain modeling</li>
      <li>Frameworks and framework extensions</li>
      <li>Differential programming</li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_34"><span>Answer 34</span> <span class="arrow"> <a href="#answer_33">↑</a> </span> <span class="arrow"> <a href="#answer_35">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user125959</span>
     </div>
     <div>
      <span> Answered: </span> <span>20 Jun 2009 at 04:41</span>
     </div>
    </div>
    <div>
     <p>What do you want to force yourself (or another programmer) to adhere to and when do you want to allow yourself (or another programmer) more freedom. It has been argued that inheritance is helpful when you want to force someone into a way of dealing with/solving a particular problem so they can't head off in the wrong direction.</p>
     <p><code>Is-a</code> and <code>Has-a</code> is a helpful rule of thumb.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_35"><span>Answer 35</span> <span class="arrow"> <a href="#answer_34">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mohamed Reda</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 May 2022 at 13:41</span>
     </div>
    </div>
    <div>
     <p>Simply, implementation is like rules you (the class) should follow</p>
     <p>But extend is like using common code for a lot of classes, and maybe just one of them that you need to override.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>