<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Why is "asdf".replace(/.*/g, "x") == "xx"?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>Why is "asdf".replace(/.*/g, "x") == "xx"?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>153</span>
    </div>
    <div>
     <span>Asker: </span> <span>recursive</span>
    </div>
    <div>
     <span>Asked: </span> <span>17 Apr 2020 at 02:25</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/61263151/why-is-asdf-replace-g-x-xx">source</a>
    </div>
   </div>
   <div>
    <p>I stumbled across a surprising (to me) fact.</p>
    <p></p>
    <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
     <div class="snippet-code">
      <pre class="snippet-code-js lang-js prettyprint-override"><code>console.log("asdf".replace(/.*/g, "x"));</code></pre>
     </div>
    </div>
    <p></p>
    <p>Why <em>two</em> replacements? It seems any non-empty string without newlines will produce exactly two replacements for this pattern. Using a replacement function, I can see that the first replacement is for the entire string, and the second is for an empty string.</p>
   </div>
   <div class="tags">
    <span class="tag">javascript</span><span class="tag">regex</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td></td>
       <td><span></span> <span> - </span> <span class="display-name">recursive</span> <span> </span> <span class="date">17 Apr 2020 at 02:36</span></td>
      </tr>
      <tr>
       <td>10</td>
       <td><span></span> <span> - </span> <span class="display-name">Narro</span> <span> </span> <span class="date">17 Apr 2020 at 02:51</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span></span> <span> - </span> <span class="display-name">Celsiuss</span> <span> </span> <span class="date">17 Apr 2020 at 02:57</span></td>
      </tr>
      <tr>
       <td>35</td>
       <td><span></span> <span> - </span> <span class="display-name">Celsiuss</span> <span> </span> <span class="date">17 Apr 2020 at 03:13</span></td>
      </tr>
      <tr>
       <td>6</td>
       <td><span></span> <span> - </span> <span class="display-name">Lux</span> <span> </span> <span class="date">17 Apr 2020 at 03:17</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span></span> <span> - </span> <span class="display-name">user10678532</span> <span> </span> <span class="date">17 Apr 2020 at 12:01</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span></span> <span> - </span> <span class="display-name">Joshua</span> <span> </span> <span class="date">17 Apr 2020 at 22:34</span></td>
      </tr>
      <tr>
       <td>4</td>
       <td><span></span> <span> - </span> <span class="display-name">user10678532</span> <span> </span> <span class="date">18 Apr 2020 at 06:32</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span></span> <span> - </span> <span class="display-name">recursive</span> <span> </span> <span class="date">18 Apr 2020 at 14:16</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span></span> <span> - </span> <span class="display-name">T.J. Crowder</span> <span> </span> <span class="date">18 Apr 2020 at 14:29</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span></span> <span> - </span> <span class="display-name">T.J. Crowder</span> <span> </span> <span class="date">18 Apr 2020 at 14:31</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span></span> <span> - </span> <span class="display-name">Eric Duminil</span> <span> </span> <span class="date">18 Apr 2020 at 14:47</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span></span> <span> - </span> <span class="display-name">Eric Duminil</span> <span> </span> <span class="date">19 Apr 2020 at 19:33</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>110</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Alan Liang</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Apr 2020 at 04:00</span>
     </div>
    </div>
    <div>
     <p>As per the <a href="https://tc39.es/ecma262/" rel="noreferrer">ECMA-262</a> standard, <a href="https://tc39.es/ecma262/#sec-string.prototype.replace" rel="noreferrer">String.prototype.replace</a> calls <a href="https://tc39.es/ecma262/#sec-regexp.prototype-@@replace" rel="noreferrer">RegExp.prototype[@@replace]</a>, which says:</p>
     <pre class="lang-none prettyprint-override"><code>11. Repeat, while done is false
  a. Let result be ? RegExpExec(rx, S).
  b. If result is null, set done to true.
  c. Else result is not null,
    i. Append result to the end of results.
    ii. If global is false, set done to true.
    iii. Else,
      1. Let matchStr be ? ToString(? Get(result, "0")).
      2. If matchStr is the empty String, then
        a. Let thisIndex be ? ToLength(? Get(rx, "lastIndex")).
        b. Let nextIndex be AdvanceStringIndex(S, thisIndex, fullUnicode).
        c. Perform ? Set(rx, "lastIndex", nextIndex, true).
</code></pre>
     <p>where <code>rx</code> is <code>/.*/g</code> and <code>S</code> is <code>'asdf'</code>.</p>
     <p>See 11.c.iii.2.b:</p>
     <blockquote>
      <p>b. Let nextIndex be AdvanceStringIndex(S, thisIndex, fullUnicode).</p>
     </blockquote>
     <p>Therefore in <code>'asdf'.replace(/.*/g, 'x')</code> it is actually:</p>
     <ol>
      <li>result (undefined), results = <code>[]</code>, lastIndex = <code>0</code></li>
      <li>result = <code>'asdf'</code>, results = <code>[ 'asdf' ]</code>, lastIndex = <code>4</code></li>
      <li>result = <code>''</code>, results = <code>[ 'asdf', '' ]</code>, lastIndex = <code>4</code>, <code>AdvanceStringIndex</code>, set lastIndex to <code>5</code></li>
      <li>result = <code>null</code>, results = <code>[ 'asdf', '' ]</code>, return</li>
     </ol>
     <p>Therefore there are 2 matches.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>47</td>
        <td><span></span> <span> - </span> <span class="display-name">Felipe</span> <span> </span> <span class="date">18 Apr 2020 at 07:23</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">jimh</span> <span> </span> <span class="date">24 Apr 2020 at 06:01</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>39</span>
     </div>
     <div>
      <span>Answerer: </span> <span>ComFreek</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Apr 2020 at 11:30</span>
     </div>
    </div>
    <div>
     <p>Together in an offline chat with <a href="https://stackoverflow.com/users/1116343/yawkat">yawkat</a>, we found an <strong>intuitive way</strong> of seeing why <code>"abcd".replace(/.*/g, "x")</code> exactly produces two matches. Note that we haven't checked whether it completely equals the semantics imposed by the ECMAScript standard, hence just take it as a rule of thumb.</p>
     <h3>Rules of Thumb</h3>
     <ul>
      <li>Consider the matches as a list of tuples <code>(matchStr, matchIndex)</code> in chronological order that indicate which string parts and indices of the input string have already been eaten up.</li>
      <li>This list is continuously built up starting from the left of the input string for the regex.</li>
      <li>Parts already eaten up cannot be matched anymore</li>
      <li>Replacement is done at indices given by <code>matchIndex</code> overwriting the substring <code>matchStr</code> at that position. If <code>matchStr = ""</code>, then the "replacement" is effectively insertion.</li>
     </ul>
     <p>Formally, the act of matching and replacement is described as a loop as seen <a href="https://stackoverflow.com/a/61263944/603003">in the other answer</a>.</p>
     <h3>Easy Examples</h3>
     <ol>
      <li>
       <p><code>"abcd".replace(/.*/g, "x")</code> outputs <code>"xx"</code>:</p>
       <ul>
        <li>
         <p>The match list is <code>[("abcd", 0), ("", 4)]</code></p>
         <p>Notably, it does <em>not</em> include the following matches one could have thought of for the following reasons:</p>
         <ul>
          <li><code>("a", 0)</code>, <code>("ab", 0)</code>: the quantifier <code>*</code> is greedy</li>
          <li><code>("b", 1)</code>, <code>("bc", 1)</code>: due to the previous match <code>("abcd", 0)</code>, the strings <code>"b"</code> and <code>"bc"</code> are already eaten up</li>
          <li><code>("", 4), ("", 4)</code> (i.e. twice): the index position 4 is already eaten up by the first apparent match</li>
         </ul></li>
        <li>
         <p>Hence, the replacement string <code>"x"</code> replaces the found match strings exactly at those positions: at position 0 it replaces the string <code>"abcd"</code> and at position 4 it replaces <code>""</code>.</p>
         <p>Here you can see that replacement can act as true replacement of a previous string or just as insertion of a new string.</p></li>
       </ul></li>
      <li>
       <p><code>"abcd".replace(/.*?/g, "x")</code> with a <a href="https://www.regular-expressions.info/repeat.html#lazy" rel="noreferrer">lazy quantifier <code>*?</code></a> outputs <code>"xaxbxcxdx"</code></p>
       <ul>
        <li>
         <p>The match list is <code>[("", 0), ("", 1), ("", 2), ("", 3), ("", 4)]</code></p>
         <p>In contrast to the previous example, here <code>("a", 0)</code>, <code>("ab", 0)</code>, <code>("abc", 0)</code>, or even <code>("abcd", 0)</code> are not included due to the quantifier's laziness that strictly limits it to find the shortest possible match.</p></li>
        <li>
         <p>Since all match strings are empty, no actual replacement occurs, but instead insertions of <code>x</code> at positions 0, 1, 2, 3, and 4.</p></li>
       </ul></li>
      <li>
       <p><code>"abcd".replace(/.+?/g, "x")</code> with a <a href="https://www.regular-expressions.info/repeat.html#lazy" rel="noreferrer">lazy quantifier <code>+?</code></a> outputs <code>"xxxx"</code></p>
       <ul>
        <li>The match list is <code>[("a", 0), ("b", 1), ("c", 2), ("d", 3)]</code></li>
       </ul></li>
      <li>
       <p><code>"abcd".replace(/.{2,}?/g, "x")</code> with a <a href="https://www.regular-expressions.info/repeat.html#lazy" rel="noreferrer">lazy quantifier <code>[2,}?</code></a> outputs <code>"xx"</code></p>
       <ul>
        <li>The match list is <code>[("ab", 0), ("cd", 2)]</code></li>
       </ul></li>
      <li>
       <p><code>"abcd".replace(/.{0}/g, "x")</code> outputs <code>"xaxbxcxdx"</code> by the same logic as in example 2.</p></li>
     </ol>
     <h3>Harder Examples</h3>
     <p>We can consistently exploit the idea of <em>insertion instead of replacement</em> if we just always match an empty string and control the position where such matches happen to our advantage. For example, we can create regular expressions matching the empty string at every even position to insert a character there:</p>
     <ol>
      <li>
       <p><code>"abcdefgh".replace(/(?&lt;=^(..)*)/g, "_"))</code> with a <a href="https://www.regular-expressions.info/lookaround.html" rel="noreferrer">positive lookbehind <code>(?&lt;=...)</code></a> outputs <code>"_ab_cd_ef_gh_"</code> (only supported in Chrome so far)</p>
       <ul>
        <li>The match list is <code>[("", 0), ("", 2), ("", 4), ("", 6), ("", 8)]</code></li>
       </ul></li>
      <li>
       <p><code>"abcdefgh".replace(/(?=(..)*$)/g, "_"))</code> with a <a href="https://www.regular-expressions.info/lookaround.html" rel="noreferrer">positive lookahead <code>(?=...)</code></a> outputs <code>"_ab_cd_ef_gh_"</code></p>
       <ul>
        <li>The match list is <code>[("", 0), ("", 2), ("", 4), ("", 6), ("", 8)]</code></li>
       </ul></li>
     </ol>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span></span> <span> - </span> <span class="display-name">Eric Duminil</span> <span> </span> <span class="date">18 Apr 2020 at 12:16</span></td>
       </tr>
       <tr>
        <td>8</td>
        <td><span></span> <span> - </span> <span class="display-name">ComFreek</span> <span> </span> <span class="date">18 Apr 2020 at 12:58</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span></span> <span> - </span> <span class="display-name">Anders Kaseorg</span> <span> </span> <span class="date">20 Apr 2020 at 09:35</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span></span> <span> - </span> <span class="display-name">ComFreek</span> <span> </span> <span class="date">20 Apr 2020 at 10:43</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">Anders Kaseorg</span> <span> </span> <span class="date">20 Apr 2020 at 11:20</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>31</span>
     </div>
     <div>
      <span>Answerer: </span> <span>David SK</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Apr 2020 at 03:25</span>
     </div>
    </div>
    <div>
     <p>The first match is obviously <code>"asdf"</code> (Position [0,4]). Because the global flag (<code>g</code>) is set, it continues searching. At this point (Position 4), it finds a second match, an empty string (Position [4,4]).</p>
     <p>Remember that <code>*</code> matches zero or more elements.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span></span> <span> - </span> <span class="display-name">recursive</span> <span> </span> <span class="date">17 Apr 2020 at 03:32</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span></span> <span> - </span> <span class="display-name">David SK</span> <span> </span> <span class="date">17 Apr 2020 at 03:46</span></td>
       </tr>
       <tr>
        <td>16</td>
        <td><span></span> <span> - </span> <span class="display-name">Jörg W Mittag</span> <span> </span> <span class="date">17 Apr 2020 at 16:15</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span></span> <span> - </span> <span class="display-name">user10678532</span> <span> </span> <span class="date">17 Apr 2020 at 18:01</span></td>
       </tr>
       <tr>
        <td>9</td>
        <td><span></span> <span> - </span> <span class="display-name">hobbs</span> <span> </span> <span class="date">18 Apr 2020 at 01:13</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Nilanka Manoj</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 May 2020 at 02:38</span>
     </div>
    </div>
    <div>
     <p>simply, the first <code>x</code> is for the replacement of matching <code>asdf</code>.</p>
     <p>second <code>x</code> for the empty string after <code>asdf</code>. Search terminates when empty.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>