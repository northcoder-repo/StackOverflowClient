<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>The case against checked exceptions</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>The case against checked exceptions</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>527</span>
    </div>
    <div>
     <span>Asker: </span> <span>TofuBeer</span>
    </div>
    <div>
     <span>Asked: </span> <span>5 Mar 2009 at 08:18</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/613954/the-case-against-checked-exceptions">source</a>
    </div>
   </div>
   <div>
    <p>For a number of years now I have been unable to get a decent answer to the following question: why are some developers so against checked exceptions? I have had numerous conversations, read things on blogs, read what Bruce Eckel had to say (the first person I saw speak out against them).</p>
    <p>I am currently writing some new code and paying very careful attention to how I deal with exceptions. I am trying to see the point of view of the "we don't like checked exceptions" crowd and I still cannot see it.</p>
    <p>Every conversation I have ends with the same question going unanswered... let me set it up:</p>
    <p>In general (from how Java was designed),</p>
    <ul>
     <li><code>Error</code> is for things that should never be caught (VM has a peanut allergy and someone dropped a jar of peanuts on it)</li>
     <li><code>RuntimeException</code> is for things that the programmer did wrong (programmer walked off the end of an array)</li>
     <li><code>Exception</code> (except <code>RuntimeException</code>) is for things that are out of the programmer's control (disk fills up while writing to the file system, file handle limit for the process has been reached and you cannot open any more files)</li>
     <li><code>Throwable</code> is simply the parent of all of the exception types.</li>
    </ul>
    <p>A common argument I hear is that if an exception happens then all the developer is going to do is exit the program.</p>
    <p>Another common argument I hear is that checked exceptions make it harder to refactor code.</p>
    <p>For the "all I am going to do is exit" argument I say that even if you are exiting you need to display a reasonable error message. If you are just punting on handling errors then your users won't be overly happy when the program exits without a clear indication of why.</p>
    <p>For the "it makes it hard to refactor" crowd, that indicates that the proper level of abstraction wasn't chosen. Rather than declare a method throws an <code>IOException</code>, the <code>IOException</code> should be transformed into an exception that is more suited for what is going on.</p>
    <p>I don't have an issue with wrapping Main with <code>catch(Exception)</code> (or in some cases <code>catch(Throwable)</code> to ensure that the program can exit gracefully - but I always catch the specific exceptions I need to. Doing that allows me to, at the very least, display an appropriate error message.</p>
    <p>The question that people never reply to is this:</p>
    <blockquote>
     <p>If you throw <code>RuntimeException</code> subclasses instead of <code>Exception</code> subclasses then how do you know what you are supposed to catch?</p>
    </blockquote>
    <p>If the answer is catch <code>Exception</code> then you are also dealing with programmer errors the same way as system exceptions. That seems wrong to me.</p>
    <p>If you catch <code>Throwable</code> then you are treating system exceptions and VM errors (and the like) the same way. That seems wrong to me.</p>
    <p>If the answer is that you catch only the exceptions you know are thrown then how do you know what ones are thrown? What happens when programmer X throws a new exception and forgot to catch it? That seems very dangerous to me.</p>
    <p>I would say that a program that displays a stack trace is wrong. Do people who don't like checked exceptions not feel that way?</p>
    <p>So, if you don't like checked exceptions can you explain why not AND answer the question that doesn't get answered please?</p>
    <p>I am not looking for advice on when to use either model, what I am looking for is <em>why</em> people extend from <code>RuntimeException</code> because they don't like extending from <code>Exception</code> and/or why they catch an exception and then rethrow a <code>RuntimeException</code> rather than add throws to their method. I want to understand the motivation for disliking checked exceptions.</p>
   </div>
   <div class="tags">
    <span class="tag">java</span><span class="tag">exception</span><span class="tag">checked-exceptions</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>49</td>
       <td><span>I don't think it's completely subjective - it's a language feature that was designed to have a specific use, rather than for everyone to decide what it's for for themselves. And it's not especially argumentative, it addresses in advance specific rebuttals which people could easily have come up with.</span> <span> - </span> <span class="display-name">Gareth</span> <span> </span> <span class="date">5 Mar 2009 at 08:49</span></td>
      </tr>
      <tr>
       <td>8</td>
       <td><span>Come on. Viewed as a language feature, this topic has been and can be approached in an objective way.</span> <span> - </span> <span class="display-name">Kurt Schelfthout</span> <span> </span> <span class="date">5 Mar 2009 at 12:30</span></td>
      </tr>
      <tr>
       <td>6</td>
       <td><span>@cletus "answering your own question" if I had the answer I wouldn't have asked the question!</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">5 Mar 2009 at 15:32</span></td>
      </tr>
      <tr>
       <td>2</td>
       <td><span>I agree that it should be CW. There is no "right" answer; it's about methodology and practices. I don't agree that it should be closed, however. It's an important debate, and the more opinions can be seen on the subject, the better, IMO.</span> <span> - </span> <span class="display-name">Randolpho</span> <span> </span> <span class="date">5 Mar 2009 at 16:48</span></td>
      </tr>
      <tr>
       <td>2</td>
       <td><span>I am not asking for the "right answer about methodology and practices" I am asking for the rationale for people who choose this particular methodology. I did not ask for the relative merits between different ways of dealing with exceptions. Also not CW IMO, that is for a comparison between the two</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">5 Mar 2009 at 17:01</span></td>
      </tr>
      <tr>
       <td>9</td>
       <td><span>Great question. In C++ there are no checked exceptions at all, and in my opinion it renders the exception feature unusable. You end up in a situation where you have to put a catch around every single function call you make, because you just don't know whether it might throw something.</span> <span> - </span> <span class="display-name">Dimitri C.</span> <span> </span> <span class="date">24 Jun 2009 at 10:15</span></td>
      </tr>
      <tr>
       <td>2</td>
       <td><span>@TofuBeer: you are <i>way</i> overthinking this: ask yourself the following question: where do checked exception come into play at the OOA/OOD level and how comes, what, 95% of the languages out there are perfectly happy without the broken concept of checked exceptions? Checked exceptions are a Java idiosynchrasy that people have to deal with because there are broken API that have been written around that broken concept. 200KLOC codebase here. We defined <i>zero</i> checked exception and we're throwing <i>zero</i> checked exception. And our OOP is close to our OOA/OOD. That's why we don't like them.</span> <span> - </span> <span class="display-name">SyntaxT3rr0r</span> <span> </span> <span class="date">18 Mar 2010 at 18:32</span></td>
      </tr>
      <tr>
       <td>3</td>
       <td><span>C++ is broken without checked exceptions IMO - how often do you see catch(...) just to make sure things do not crash. So, since you have a large code base, please answer the simple question - how do you make sure that you do not miss any exceptions? Say you add in a new "FooException" - how do you ensure that your program doesn't crash if you fail to catch it? How do you catch it in all of the correct places?</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">18 Mar 2010 at 20:19</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>usign TDD and rutime exceptions resolves the problem with checked exception (if one afraids that he can miss something). but unfortunately java core libs themself force you to catch those exception, that makes your code bigger, often without reason. I think using AOP/spring can handle some problem as well - kind of something on top on java.</span> <span> - </span> <span class="display-name">ses</span> <span> </span> <span class="date">10 May 2013 at 14:16</span></td>
      </tr>
      <tr>
       <td>2</td>
       <td><span>@ses TDD doesn't solve the problem unless one looks at all of the source code to to know what to test for. It works for the person writing the code that throws the RuntimeException, but not for the person writing the code that calls the code that throws it. Start with the premise that your program cannot crash, ever, now how attractive are RuntimeExceptions?</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">10 May 2013 at 14:20</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@TofuBeer The person who writes the code, does not know for sure that person(client) who would use this code should check this exception. because it depends on the case what client thinks about it. The client itself can decide, reading the definition of method that throws RuntimeException where he want to catch it or not. That's fair. That's respect of client's time and clinet's code. Especially I do not see the reason to use CheckedExceptions in interface methods, when 1000 of classes implement it, in 500 of them don't throw this exception at all, but the client still must catch it.</span> <span> - </span> <span class="display-name">ses</span> <span> </span> <span class="date">10 May 2013 at 14:36</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@TofuBeer if client of code uses TDD, it helps him to avoid bad cases.</span> <span> - </span> <span class="display-name">ses</span> <span> </span> <span class="date">10 May 2013 at 14:36</span></td>
      </tr>
      <tr>
       <td>2</td>
       <td><span>@ses the client won't necessarily know about the runtime exception, there is no requirement that runtime exceptions be documented. If the client doesn't know how can the client make an informed decision? Also, my premise is that the program can never crash. runtime exceptions do not lend themselves to that.</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">10 May 2013 at 14:42</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@TofuBeer also Client might not to know how to handle it. This is what happened all the time. The client just swallows it until he has a problem. So client <i>should</i> know about exception / and about what he is going to use - and about what the method does. As soon as he knows about it he could decide what to do with that.</span> <span> - </span> <span class="display-name">ses</span> <span> </span> <span class="date">10 May 2013 at 15:27</span></td>
      </tr>
      <tr>
       <td>2</td>
       <td><span>And the client will know about the exception how exactly? Follow it through to the logical conclusion. I give you library X, you call method y from class Z. What runtime exceptions should you catch?</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">10 May 2013 at 16:16</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>I personally like checked exceptions very much, these help me to recognize potential problems in my code very early. But one thing I hate about it is that the throws declaration is also a part of function signatures. This can really get you in a problem with no solution at all. Thats the thing I think most programmers don't like.</span> <span> - </span> <span class="display-name">Aqeel Ashiq</span> <span> </span> <span class="date">23 Sep 2013 at 09:06</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>By reading its contract? Exceptions are part of a methods contract, checked or not. You catch the exceptions you can actually do something about.</span> <span> - </span> <span class="display-name">Kevin</span> <span> </span> <span class="date">5 Aug 2015 at 00:41</span></td>
      </tr>
      <tr>
       <td>2</td>
       <td><span>That is the issue @Kevin, if you add a 3rd party library that doesn't document the exceptions then what? The whole point of checked exceptions is to avoid programmer mistakes... using unchecked exceptions for things that should be dealt with (things that are not programmer errors) negates that.</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">6 Aug 2015 at 07:12</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@TofuBeer Even if you are using checked exceptions, if you don't document exceptions (outside of the method header itself) and under what specific conditions they occur, they wouldn't know how to deal with your exceptions either. The problem isn't checked vs unchecked exceptions, but one of documentation.</span> <span> - </span> <span class="display-name">Kevin</span> <span> </span> <span class="date">6 Aug 2015 at 13:07</span></td>
      </tr>
      <tr>
       <td>3</td>
       <td><span>Checked exceptions encourage documentation, and, in the event they are not documented they are still known about. Unchecked exceptions can more easily not be documented and, worse, not be known about until they happen in a production environment.</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">13 Aug 2015 at 02:55</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@DimitriC. That is how I feel as a C# developer now!</span> <span> - </span> <span class="display-name">Honinbo Shusaku</span> <span> </span> <span class="date">29 Mar 2017 at 19:42</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>"VM has a peanut allergy and someone dropped a jar of peanuts on it" - Yup, you definitely want your machine to die without the possibility of recovery at the most critical moments... I don't see anything wrong with that.. NEVER USE ERROR</span> <span> - </span> <span class="display-name">B T</span> <span> </span> <span class="date">7 Jun 2017 at 00:29</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>It seems nobody noticed the problem with interfaces. If you implement an interface, you can only throw the exceptions that are declared in the interface. Making it impossible to react to an error with checked exception in many different cases. See my answer.</span> <span> - </span> <span class="display-name">Vlasec</span> <span> </span> <span class="date">9 Oct 2017 at 14:44</span></td>
      </tr>
      <tr>
       <td>6</td>
       <td><span>The strongest argument I know <i>for</i> checked exceptions is that they weren't originally there in Java, and that when they were introduced they discovered hundreds of bugs in the JDK. This is somewhat prior to Java 1.0. I personally would not be without them, and disagree violently with Bruce Eckel and others on this.</span> <span> - </span> <span class="display-name">user207421</span> <span> </span> <span class="date">12 Apr 2019 at 02:16</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>@user207421 in my experience, most anything Bruce Eckel says is wrong when it comes to Java...</span> <span> - </span> <span class="display-name">jwenting</span> <span> </span> <span class="date">8 Jan 2020 at 11:02</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>This is the question. Many libraries don't throw checked exceptions, so the programmer is not aware of everything that can go wrong and prepare for it. Unless he/she reads the source code, but who reads any kind of documentation? Unless they test really carefully, but who crafts tests like they are a very important thing? To both questions I guess the answer is only a few.</span> <span> - </span> <span class="display-name">Jorge Viana</span> <span> </span> <span class="date">23 May 2020 at 14:33</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>There are some methods I have to call that throw certain exceptions that I <b>KNOW</b> will <b>NEVER</b> happen because of the params I pass. Those are okay to catch and ignore.</span> <span> - </span> <span class="display-name">Captain Jack Sparrow</span> <span> </span> <span class="date">3 Mar 2022 at 17:04</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Language and library authors "assume" that programmer will "always" want to handle a particular type of error, and that too "immediately". Totally wrong assumptions given the infinite ways real world programmers actually use exceptions.</span> <span> - </span> <span class="display-name">S.D.</span> <span> </span> <span class="date">2 Jun 2023 at 16:10</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>324</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Rhubarb</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Mar 2009 at 12:03</span>
     </div>
    </div>
    <div>
     <p>I think I read the same Bruce Eckel interview that you did - and it's always bugged me. In fact, the argument was made by the interviewee (if this is indeed the post you're talking about) Anders Hejlsberg, the MS genius behind .NET and C#.</p>
     <blockquote>
      <p><a href="http://www.artima.com/intv/handcuffs.html" rel="noreferrer">http://www.artima.com/intv/handcuffs.html</a></p>
     </blockquote>
     <p>Fan though I am of Hejlsberg and his work, this argument has always struck me as bogus. It basically boils down to:</p>
     <blockquote>
      <p>"Checked exceptions are bad because programmers just abuse them by always catching them and dismissing them which leads to problems being hidden and ignored that would otherwise be presented to the user".</p>
     </blockquote>
     <p>By <em>"otherwise presented to the user"</em> I mean if you use a runtime exception the lazy programmer will just ignore it (versus catching it with an empty catch block) and the user will see it.</p>
     <p>The summary of the argument is that <em>"Programmers won't use them properly and not using them properly is worse than not having them"</em>.</p>
     <p>There is some truth to this argument and in fact, I suspect Goslings motivation for not putting operator overrides in Java comes from a similar argument - they confuse the programmer because they are often abused.</p>
     <p>But in the end, I find it a bogus argument of Hejlsberg's and possibly a post-hoc one created to explain the lack rather than a well thought out decision.</p>
     <p>I would argue that while the over-use of checked exceptions is a bad thing and tends to lead to sloppy handling by users, but the proper use of them allows the API programmer to give great benefit to the API client programmer.</p>
     <p>Now the API programmer has to be careful not to throw checked exceptions all over the place, or they will simply annoy the client programmer. The very lazy client programmer will resort to catch <code>(Exception) {}</code> as Hejlsberg warns and all benefit will be lost and hell will ensue. But in some circumstances, there's just no substitute for a good checked exception.</p>
     <p>For me, the classic example is the file-open API. Every programming language in the history of languages (on file systems at least) has an API somewhere that lets you open a file. And every client programmer using this API knows that they have to deal with the case that the file they are trying to open doesn't exist. Let me rephrase that: Every client programmer using this API <em>should know</em> that they have to deal with this case. And there's the rub: can the API programmer help them know they should deal with it through commenting alone or can they indeed <em>insist</em> the client deal with it.</p>
     <p>In C the idiom goes something like</p>
     <pre><code>  if (f = fopen("goodluckfindingthisfile")) { ... } 
  else { // file not found ...
</code></pre>
     <p>where <code>fopen</code> indicates failure by returning 0 and C (foolishly) lets you treat 0 as a boolean and... Basically, you learn this idiom and you're okay. But what if you're a noob and you didn't learn the idiom. Then, of course, you start out with</p>
     <pre><code>   f = fopen("goodluckfindingthisfile");
   f.read(); // BANG! 
</code></pre>
     <p>and learn the hard way.</p>
     <p>Note that we're only talking about strongly typed languages here: There's a clear idea of what an API is in a strongly typed language: It's a smorgasbord of functionality (methods) for you to use with a clearly defined protocol for each one.</p>
     <p>That clearly defined protocol is typically defined by a method signature. Here fopen requires that you pass it a string (or a char* in the case of C). If you give it something else you get a compile-time error. You didn't follow the protocol - you're not using the API properly.</p>
     <p>In some (obscure) languages the return type is part of the protocol too. If you try to call the equivalent of <code>fopen()</code> in some languages without assigning it to a variable you'll also get a compile-time error (you can only do that with void functions).</p>
     <p>The point I'm trying to make is that: <em>In a statically typed language the API programmer encourages the client to use the API properly by preventing their client code from compiling if it makes any obvious mistakes.</em></p>
     <p>(In a dynamically typed language, like Ruby, you can pass anything, say a float, as the file name - and it will compile. Why hassle the user with checked exceptions if you're not even going to control the method arguments. The arguments made here apply to statically-typed languages only.)</p>
     <p>So, what about checked exceptions?</p>
     <p>Well here's one of the Java APIs you can use for opening a file.</p>
     <pre><code>try {
  f = new FileInputStream("goodluckfindingthisfile");
}
catch (FileNotFoundException e) {
  // deal with it. No really, deal with it!
  ... // this is me dealing with it
}
</code></pre>
     <p>See that catch? Here's the signature for that API method:</p>
     <pre><code>public FileInputStream(String name)
                throws FileNotFoundException
</code></pre>
     <p>Note that <code>FileNotFoundException</code> is a <em>checked</em> exception.</p>
     <p>The API programmer is saying this to you: "You may use this constructor to create a new FileInputStream but you</p>
     <p>a) <em>must</em> pass in the file name as a String<br>
       b) <em>must</em> accept the possibility that the file might not be found at runtime"</p>
     <p>And that's the whole point as far as I'm concerned.</p>
     <p>The key is basically what the question states as "Things that are out of the programmer's control". My first thought was that he/she means things that are out of the <em>API</em> programmers control. But in fact, checked exceptions when used properly should really be for things that are out of both the client programmer's and the API programmer's control. I think this is the key to not abusing checked exceptions.</p>
     <p>I think the file-open illustrates the point nicely. The API programmer knows you might give them a file name that turns out to be nonexistent at the time the API is called, and that they won't be able to return you what you wanted, but will have to throw an exception. They also know that this will happen pretty regularly and that the client programmer might expect the file name to be correct at the time they wrote the call, but it might be wrong at runtime for reasons beyond their control too.</p>
     <p>So the API makes it explicit: There will be cases where this file doesn't exist at the time you call me and you had damn well better deal with it.</p>
     <p>This would be clearer with a counter-case. Imagine I'm writing a table API. I have the table model somewhere with an API including this method:</p>
     <pre><code>public RowData getRowData(int row) 
</code></pre>
     <p>Now as an API programmer I know there will be cases where some client passes in a negative value for the row or a row value outside of the table. So I might be tempted to throw a checked exception and force the client to deal with it:</p>
     <pre><code>public RowData getRowData(int row) throws CheckedInvalidRowNumberException
</code></pre>
     <p>(I wouldn't really call it "Checked" of course.)</p>
     <p>This is bad use of checked exceptions. The client code is going to be full of calls to fetch row data, every one of which is going to have to use a try/catch, and for what? Are they going to report to the user that the wrong row was sought? Probably not - because whatever the UI surrounding my table view is, it shouldn't let the user get into a state where an illegal row is being requested. So it's a bug on the part of the client programmer.</p>
     <p>The API programmer can still predict that the client will code such bugs and should handle it with a runtime exception like an <code>IllegalArgumentException</code>.</p>
     <p>With a checked exception in <code>getRowData</code>, this is clearly a case that's going to lead to Hejlsberg's lazy programmer simply adding empty catches. When that happens, the illegal row values will not be obvious even to the tester or the client developer debugging, rather they'll lead to knock-on errors that are hard to pinpoint the source of. Arianne rockets will blow up after launch.</p>
     <p>Okay, so here's the problem: I'm saying that the checked exception <code>FileNotFoundException</code> is not just a good thing but an essential tool in the API programmers toolbox for defining the API in the most useful way for the client programmer. But the <code>CheckedInvalidRowNumberException</code> is a big inconvenience, leading to bad programming and should be avoided. But how to tell the difference.</p>
     <p>I guess it's not an exact science and I guess that underlies and perhaps justifies to a certain extent Hejlsberg's argument. But I'm not happy throwing the baby out with the bathwater here, so allow me to extract some rules here to distinguish good checked exceptions from bad:</p>
     <ol>
      <li>
       <p>Out of client's control or Closed vs Open:</p>
       <p>Checked exceptions should only be used where the error case is out of control of both the API <em>and</em> the client programmer. This has to do with how <em>open</em> or <em>closed</em> the system is. In a <em>constrained</em> UI where the client programmer has control, say, over all of the buttons, keyboard commands etc that add and delete rows from the table view (a closed system), it is a client programming bug if it attempts to fetch data from a nonexistent row. In a file-based operating system where any number of users/applications can add and delete files (an open system), it is conceivable that the file the client is requesting has been deleted without their knowledge so they should be expected to deal with it.</p></li>
      <li>
       <p>Ubiquity:</p>
       <p>Checked exceptions should not be used on an API call that is made frequently by the client. By frequently I mean from a lot of places in the client code - not frequently in time. So a client code doesn't tend to try to open the same file a lot, but my table view gets <code>RowData</code> all over the place from different methods. In particular, I'm going to be writing a lot of code like</p>
       <pre><code>if (model.getRowData().getCell(0).isEmpty())
</code></pre></li>
     </ol>
     <p>and it will be painful to have to wrap in try/catch every time.</p>
     <ol start="3">
      <li>
       <p>Informing the User:</p>
       <p>Checked exceptions should be used in cases where you can imagine a useful error message being presented to the end user. This is the <em>"and what will you do when it happens?"</em> question I raised above. It also relates to item 1. Since you can predict that something outside of your client-API system might cause the file to not be there, you can reasonably tell the user about it:</p>
       <pre><code>"Error: could not find the file 'goodluckfindingthisfile'"
</code></pre>
       <p>Since your illegal row number was caused by an internal bug and through no fault of the user, there's really no useful information you can give them. If your app doesn't let runtime exceptions fall through to the console it will probably end up giving them some ugly message like:</p>
       <pre><code>"Internal error occured: IllegalArgumentException in ...."
</code></pre>
       <p>In short, if you don't think your client programmer can explain your exception in a way that helps the user, then you should probably not be using a checked exception.</p></li>
     </ol>
     <p>So those are my rules. Somewhat contrived, and there will doubtless be exceptions (please help me refine them if you will). But my main argument is that there are cases like <code>FileNotFoundException</code> where the checked exception is as important and useful a part of the API contract as the parameter types. So we should not dispense with it just because it is misused.</p>
     <p>Sorry, didn't mean to make this so long and waffly. Let me finish with two suggestions:</p>
     <p>A: API programmers: use checked exceptions sparingly to preserve their usefulness. When in doubt use an unchecked exception.</p>
     <p>B: Client programmers: get in the habit of creating a wrapped exception (google it) early on in your development. JDK 1.4 and later provide a constructor in <code>RuntimeException</code> for this, but you can easily create your own too. Here's the constructor:</p>
     <pre><code>public RuntimeException(Throwable cause)
</code></pre>
     <p>Then get in the habit of whenever you have to handle a checked exception and you're feeling lazy (or you think the API programmer was overzealous in using the checked exception in the first place), don't just swallow the exception, wrap it and rethrow it.</p>
     <pre><code>try {
  overzealousAPI(thisArgumentWontWork);
}
catch (OverzealousCheckedException exception) {
  throw new RuntimeException(exception);  
}
</code></pre>
     <p>Put this in one of your IDE's little code templates and use it when you're feeling lazy. This way if you really need to handle the checked exception you'll be forced to come back and deal with it after seeing the problem at runtime. Because, believe me (and Anders Hejlsberg), you're never going to come back to that TODO in your</p>
     <pre><code>catch (Exception e) { /* TODO deal with this at some point (yeah right) */}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Comments are not for extended discussion; this conversation has been <a href="https://chat.stackoverflow.com/rooms/238813/discussion-on-answer-by-rhubarb-the-case-against-checked-exceptions">moved to chat</a>.</span> <span> - </span> <span class="display-name">Jean-François Fabre</span> <span> </span> <span class="date">2 Nov 2021 at 19:53</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>219</span>
     </div>
     <div>
      <span>Answerer: </span> <span>bobince</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Mar 2009 at 10:59</span>
     </div>
    </div>
    <div>
     <p>The thing about checked exceptions is that they are not really exceptions by the usual understanding of the concept. Instead, they are API alternative return values.</p>
     <p>The whole idea of exceptions is that an error thrown somewhere way down the call chain can bubble up and be handled by code somewhere further up, without the intervening code having to worry about it. Checked exceptions, on the other hand, require every level of code between the thrower and the catcher to declare they know about all forms of exception that can go through them. This is really little different in practice to if checked exceptions were simply special return values which the caller had to check for. eg.[pseudocode]:</p>
     <pre><code>public [int or IOException] writeToStream(OutputStream stream) {
    [void or IOException] a= stream.write(mybytes);
    if (a instanceof IOException)
        return a;
    return mybytes.length;
}
</code></pre>
     <p>Since Java can't do alternative return values, or simple inline tuples as return values, checked exceptions are are a reasonable response.</p>
     <p>The problem is that a lot of code, including great swathes of the standard library, misuse checked exceptions for real exceptional conditions that you might very well want to catch several levels up. Why is IOException not a RuntimeException? In every other language I can let an IO exception happen, and if I do nothing to handle it, my application will stop and I'll get a handy stack trace to look at. This is the best thing that can happen.</p>
     <p>Maybe two methods up from the example you want to catch all IOExceptions from the whole writing-to-stream process, abort the process and jump into the error reporting code; in Java you can't do that without adding ‘throws IOException’ at every call level, even levels that themselves do no IO. Such methods should not need to know about the exception handling; having to add exceptions to their signatures:</p>
     <ol>
      <li>unnecessarily increases coupling;</li>
      <li>makes interface signatures very brittle to change;</li>
      <li>makes the code less readable;</li>
      <li>is so annoying that it the common programmer reaction is to defeat the system by doing something horrible like ‘throws Exception’, ‘catch (Exception e) {}’, or wrapping everything in a RuntimeException (which makes debugging harder).</li>
     </ol>
     <p>And then there's plenty of just ridiculous library exceptions like:</p>
     <pre><code>try {
    httpconn.setRequestMethod("POST");
} catch (ProtocolException e) {
    throw new CanNeverHappenException("oh dear!");
}
</code></pre>
     <p>When you have to clutter up your code with ludicrous crud like this, it is no wonder checked exceptions receive a bunch of hate, even though really this is just simple poor API design.</p>
     <p>Another particular bad effect is on Inversion of Control, where component A supplies a callback to generic component B. Component A wants to be able to let an exception throw from its callback back to the place where it called component B, but it can't because that would change the callback interface which is fixed by B. A can only do it by wrapping the real exception in a RuntimeException, which is yet more exception-handling boilerplate to write.</p>
     <p>Checked exceptions as implemented in Java and its standard library mean boilerplate, boilerplate, boilerplate. In an already verbose language this is not a win.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>15</td>
        <td><span>In your code example, it would be best to chain the exceptions so that the original cause can be found when reading the logs: throw CanNeverHappenException(e);</span> <span> - </span> <span class="display-name">Esko Luontola</span> <span> </span> <span class="date">6 Mar 2009 at 11:25</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>I disagree. Exceptions, checked or not, are exceptional conditions. Example: a method that retrieves an object via HTTP. The return value is else the object or nothing, all the things that can go bad are exceptional. Treating them as return values as it is done in C only leads to confusion and poor design.</span> <span> - </span> <span class="display-name">Mister Smith</span> <span> </span> <span class="date">22 Aug 2011 at 11:33</span></td>
       </tr>
       <tr>
        <td>19</td>
        <td><span>@Mister: What I'm saying is that checked exceptions as implemented in Java behave, in practice, more like return values as in C than they do the traditional ‘exceptions’ we might recognise from C++ and other pre-Java languages. And that IMO this does indeed lead to confusion and poor design.</span> <span> - </span> <span class="display-name">bobince</span> <span> </span> <span class="date">22 Aug 2011 at 13:23</span></td>
       </tr>
       <tr>
        <td>10</td>
        <td><span>Agree that the standard libraries misuse of checked exceptions definitely added to the confusion and bad catching behavior. And, often it's just from poor documentation, e.g. a tear down method like disconnect() that throws IOException when "some other I/O error occurs". Well, I was disconnecting! Am I'm leaking a handle or other resource? Do I need to retry? Without knowing <i>why</i> it happened, I can't derive the action I should take and so I have to guess whether I should just swallow it, retry, or bail.</span> <span> - </span> <span class="display-name">charstar</span> <span> </span> <span class="date">3 Dec 2011 at 09:26</span></td>
       </tr>
       <tr>
        <td>32</td>
        <td><span>+1 for "API alternative return values". Interesting way of looking at checked exceptions.</span> <span> - </span> <span class="display-name">Zsolt Török</span> <span> </span> <span class="date">20 Dec 2011 at 12:38</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>I like the "alternative return values" notion. Some exception types aren't likely going to be useful to anyone but the immediate caller, and even if the caller can't handle the exception, the caller should wrap it in such a way that its caller will know it was thrown from a nested routine). I think the big problem with checked exception ties in with a bigger problem of exceptions in general: way too many different things are all wrapped up in an exception's type. The fact that Java distinguishes "checked versus unchecked" exceptions based upon the exception type makes things worse, but...</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">26 Mar 2012 at 19:01</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>...is not the root problem. What might have been helpful would have been to have a reliable means for a "catch" statement to indicate that it only wants to catch exceptions for which the immediate called routine wants to "take credit", and a convenient means for routines to indicate when they want to take credit for exceptions thrown by nested routines (or even their own, for that matter). Checked exceptions could provide that, sort of, if there were a convenient way of indicating declaratively that exceptions should be wrapped, without having to write imperative code to do it.</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">26 Mar 2012 at 19:08</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>In many ways, though, what's needed is a standard "aggregate exception" type, with distinct "catch" and "resolve" statements; a "catch" statement should run code if any of its conditions matches an aggregate exception, but an aggregate exception should continue up the call stack until all parts are "resolved". No such feature exists in Java or .net, but I would think such a feature should be a part of new frameworks that are developed.</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">26 Mar 2012 at 19:12</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@MisterSmith In programming, "exceptional conditions" do not mean conditions that we can ignore. It means conditions that we know, despite our best efforts, will eventually happen one day, but we don't have a good way of addressing them. Open Office cannot reasonably do anything about a disk being unplugged in the middle of saving a file. An API can't help it if your code has a bug and passes in an illegal <code>null</code>. It makes very little sense to impose strict requirements on handling situations our code cannot effectively handle; the "best way" will be <i>very</i> context dependent.</span> <span> - </span> <span class="display-name">jpmc26</span> <span> </span> <span class="date">27 Sep 2017 at 23:20</span></td>
       </tr>
       <tr>
        <td>10</td>
        <td><span>I think conceptually the idea of exceptions as an alternative return value makes sense, but I'd take it even further. It's an alternative <b>return mechanism</b>. Exceptions can pass the same value through <b>multiple entries in the function call stack</b>, silently bypassing swaths of code in the process. This is not something the normal <code>return</code> mechanism can do, and it is the reason that exceptions allow us to achieve decoupling. Bottom line, exceptions are <i>flow control</i>, contrary to the platitude. They are a more limited, more manageable (because of greater guarantees about state) GOTO.</span> <span> - </span> <span class="display-name">jpmc26</span> <span> </span> <span class="date">27 Sep 2017 at 23:29</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Unlike error return values, exceptions don’t have to be checked after every function call. The <code>try-catch</code> block can group functions so that error handling is not interleaved with the algorithm. Thus it’s not correct to equate checked exceptions with return values.</span> <span> - </span> <span class="display-name">Shelby Moore III</span> <span> </span> <span class="date">21 May 2018 at 10:25</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>89</span>
     </div>
     <div>
      <span>Answerer: </span> <span>cletus</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Mar 2009 at 11:44</span>
     </div>
    </div>
    <div>
     <p>Rather than rehash all the (many) reasons against checked exceptions, I'll pick just one. I've lost count of the number of times I've written this block of code:</p>
     <pre><code>try {
  // do stuff
} catch (AnnoyingcheckedException e) {
  throw new RuntimeException(e);
}
</code></pre>
     <p>99% of the time I can't do anything about it. Finally blocks do any necessary cleanup (or at least they should).</p>
     <p>I've also lost count of the number of times I've seen this:</p>
     <pre><code>try {
  // do stuff
} catch (AnnoyingCheckedException e) {
  // do nothing
}
</code></pre>
     <p>Why? Because someone had to deal with it and was lazy. Was it wrong? Sure. Does it happen? Absolutely. What if this were an unchecked exception instead? The app would've just died (which is preferable to swallowing an exception).</p>
     <p>And then we have infuriating code that uses exceptions as a form of flow control, like <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/text/Format.html#parseObject(java.lang.String)" rel="noreferrer">java.text.Format</a> does. Bzzzt. Wrong. A user putting "abc" into a number field on a form is not an exception.</p>
     <p>Ok, i guess that was three reasons.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>But if an exception is properly catched, you can inform the user, do other tasks (log?) and exit the application in a controlled way. I agree that some API parts could have been designed better. And for the lazy programmer reason, well, I think as a programmer you are 100% responsible of your code.</span> <span> - </span> <span class="display-name">Mister Smith</span> <span> </span> <span class="date">23 Aug 2011 at 06:22</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>note that the try-catch-rethrow allows you to specify a message - I usually use it to add information about the contents of state variables. A frequent example is for IOExceptions to add the absolutePathName() of the file in question.</span> <span> - </span> <span class="display-name">Thorbjørn Ravn Andersen</span> <span> </span> <span class="date">29 Oct 2012 at 22:34</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I think you identified the biggest problem with checked exceptions; if <code>foo</code> calls <code>bar</code>, and <code>bar</code> might unexpectedly throw a <code>wazooException</code> <code>foo</code> isn't prepared to handle, there should be an easy way for <code>foo</code> to simply declare that it isn't prepared to handle a <code>wazooException</code> from <code>bar</code>. Passing it up via <code>throws</code> is the <i>wrong</i> approach, since the caller won't be able to distinguish between a <code>wazooException</code> thrown by <code>foo</code>, for reasons <code>foo</code> was anticipating, and a <code>wazooException</code> thrown by <code>bar</code> for reasons <code>foo</code> was not expecting.</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">24 Jan 2013 at 23:34</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I like your third reason(was it a reason against checked exceptions really? anyways I liked it). But to the lazy programmer reason, I'l definitely kick out such a programmer from my team.</span> <span> - </span> <span class="display-name">Aqeel Ashiq</span> <span> </span> <span class="date">24 Sep 2013 at 08:37</span></td>
       </tr>
       <tr>
        <td>20</td>
        <td><span>I think IDEs such as Eclipse have a lot to blame for the number of times you've seen the empty catch block. Really, they should rethrow by default.</span> <span> - </span> <span class="display-name">artbristol</span> <span> </span> <span class="date">8 Nov 2013 at 11:10</span></td>
       </tr>
       <tr>
        <td>18</td>
        <td><span>"99% of the time I can't do anything about it" -- wrong, you can show the user a message saying "Could not connect to the server" or "The IO device failed", instead of just letting the app crash due to a little network hiccup. Both of your examples are arts of work from bad programmers. You should be attacking the bad programmers and not checked exceptions themselves. It's like me attacking insulin for not helping with my diabetes when I use it as salad dressing.</span> <span> - </span> <span class="display-name">AxiomaticNexus</span> <span> </span> <span class="date">25 Jun 2014 at 21:56</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>@YasmaniLlanes You cannot always do these things. Sometimes you have an interface to adhere to. And this is especially true when you design good maintainable APIs because you can't just start throwing side-effects all over the place. Both that, and the complexity it will introduce, will bite you severely on a large scale. So yes, 99% of the time, there's nothing to be done about it.</span> <span> - </span> <span class="display-name">MasterMastic</span> <span> </span> <span class="date">25 Aug 2015 at 20:07</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@MasterMastic Why would the simple act of implementing an interface prevent you from alerting the user when a network connection is lost or a file failed to load?</span> <span> - </span> <span class="display-name">AxiomaticNexus</span> <span> </span> <span class="date">25 Aug 2015 at 20:57</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@YasmaniLlanes Well, forgive and correct me if I'm wrong please (I'm not very familiar with Java), but if the interface doesn't expect the exception, well, what am I to do as an implementer? &amp; how will I alert the user? do I have to carry my error-logging interface with me to every object that could fail? &amp; what then? how do I exit the procedure? or maybe I should just exit like others said? well those are <i>all</i> horrible practices, aren't they? modularity is dead, complexity is sad, and if I just quit the application what happens to all my acquired resources (that aren't managed by the OS)?.</span> <span> - </span> <span class="display-name">MasterMastic</span> <span> </span> <span class="date">25 Aug 2015 at 21:53</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@MasterMastic You're correct that if an interface does not declare a method to throw a checked exception, its implementation cannot either. In the rare situation that a specific implementation of an interface runs into a checked exception, then it is the responsibility of that specific implementation to handle it, after all, the calling code to the interface is not expecting this exception, it doesn't make sense to slap them in the face with one. Ideally you would return an appropriate result, or you can always wrap the checked exception in a non-checked one and throw that instead.</span> <span> - </span> <span class="display-name">AxiomaticNexus</span> <span> </span> <span class="date">25 Aug 2015 at 23:44</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@YasmaniLlanes I haven't found this to be rare at all. And I don't think the interface should predict all exceptions. If you interface a service that gets a arbitrary string, an implementer can do so by reading from static memory, or get it from a local file, or network, or remote database, and endless possibilities exist. I'm sure you don't think the interface should predict all possible (infinite) exceptions. So I don't think it would be unreasonable to slap on exceptions. It's far from ideal, definitely, but ugh, it's not news that exceptions are a <i>horrible</i> mechanism.</span> <span> - </span> <span class="display-name">MasterMastic</span> <span> </span> <span class="date">26 Aug 2015 at 00:32</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>And yes, I really do end up throwing a RuntimeException to get around checked exceptions (which I argue are bad here). You say "appropriate result" but in my experience it's usually impossible (at least to us who believe null is by no means appropriate). Thank you very much for your response.</span> <span> - </span> <span class="display-name">MasterMastic</span> <span> </span> <span class="date">26 Aug 2015 at 00:32</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@MasterMastic It depends on what the interface is declaring. If the interface is declaring something like "loadStageFile()" then an IOException is a given; the interface should declare it. If the interface is declaring something like "calculatePiDigit()" any exception that may happen in there is the implementation's problem. If your implementation for whatever reason calculates Pi from a file, then it is your job to catch IOExceptions, in which case you would probably want to wrap it in a RuntimeException.</span> <span> - </span> <span class="display-name">AxiomaticNexus</span> <span> </span> <span class="date">26 Aug 2015 at 02:52</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@MasterMastic Keep in mind that these cases with interfaces are not even a show stopper. Checked exceptions are not taking anything away from you feature-wise. You are always free to use RuntimeExceptions if you want, but the common wisdom that this IOException should always be handled is still there, Java just makes sure that you stick to that common wisdom.</span> <span> - </span> <span class="display-name">AxiomaticNexus</span> <span> </span> <span class="date">26 Aug 2015 at 02:57</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@AxiomaticNexus "a message ... instead of just letting the app crash". That's always an option, but this happens typically some 10-20 stack frames higher, which all get polluted by the checked exception. And usually, writing just <code>catch Exception</code> somewhere close to top frame is much better as this way you can be sure you miss nothing. Obviously, you can and usually should differentiate according to the exact exception class, but that's nothing you'd need checked exceptions for. Actually, they make things worse as you're oftentimes forced to wrap them and then inspect the cause instead.</span> <span> - </span> <span class="display-name">maaartinus</span> <span> </span> <span class="date">2 Dec 2017 at 14:22</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@maaartinus I would hardly call pollution adding two words: "throws XyzException" to the signature of any method up the stack that, you know... throws XyzException. The benefits (ensuring you handle exceptions properly) far outweigh the costs (adding two words to the method signature).</span> <span> - </span> <span class="display-name">AxiomaticNexus</span> <span> </span> <span class="date">4 Dec 2017 at 18:23</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@cletus What do you think java.text.Format ought to do instead of throwing an Exception?</span> <span> - </span> <span class="display-name">Mohan</span> <span> </span> <span class="date">21 Dec 2017 at 04:20</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Mohan: the <code>Format</code> example is hilarious, as directly above the throwing method, there is the method <a href="https://docs.oracle.com/javase/1.5.0/docs/api/java/text/Format.html#parseObject(java.lang.String,%20java.text.ParsePosition)" rel="nofollow noreferrer"><code>parseObject(String source, ParsePosition pos)</code></a> which does not throw but return <code>null</code> on wrong input and updates the position object accordingly. The programmer has the choice.</span> <span> - </span> <span class="display-name">Holger</span> <span> </span> <span class="date">25 Jan 2018 at 14:54</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This is not an argument. Allowing a lazy default programmer action to become the lazy language default has nothing to recommend it.</span> <span> - </span> <span class="display-name">user207421</span> <span> </span> <span class="date">21 Mar 2021 at 09:25</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>65</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Boann</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Nov 2013 at 02:03</span>
     </div>
    </div>
    <div>
     <p>I know this is an old question but I've spent a while wrestling with checked exceptions and I've something to add. Please forgive me for the length of it!</p>
     <p>My main beef with checked exceptions is that they ruin polymorphism. It's impossible to make them play nicely with polymorphic interfaces.</p>
     <p>Take the good ol' Java <a href="http://docs.oracle.com/javase/8/docs/api/java/util/List.html" rel="noreferrer"><code>List</code></a> interface. We have common in-memory implementations like <code>ArrayList</code> and <code>LinkedList</code>. We also have the the skeletal class <a href="http://docs.oracle.com/javase/8/docs/api/java/util/AbstractList.html" rel="noreferrer"><code>AbstractList</code></a> which makes it easy to design new types of list. For a read-only list we need to implement only two methods: <code>size()</code> and <code>get(int index)</code>.</p>
     <p>This example <code>WidgetList</code> class reads some fixed-size objects of type <code>Widget</code> (not shown) from a file:</p>
     <pre><code>class WidgetList extends AbstractList&lt;Widget&gt; {
    private static final int SIZE_OF_WIDGET = 100;
    private final RandomAccessFile file;

    public WidgetList(RandomAccessFile file) {
        this.file = file;
    }

    @Override
    public int size() {
        return (int)(file.length() / SIZE_OF_WIDGET);
    }

    @Override
    public Widget get(int index) {
        file.seek((long)index * SIZE_OF_WIDGET);
        byte[] data = new byte[SIZE_OF_WIDGET];
        file.read(data);
        return new Widget(data);
    }
}
</code></pre>
     <p>By exposing the Widgets using the familiar <code>List</code> interface, you can retrieve items (<code>list.get(123)</code>) or iterate a list (<code>for (Widget w : list) ...</code>) without needing to know about <code>WidgetList</code> itself. One can pass this list to any standard methods that use generic lists, or wrap it in a <code>Collections.synchronizedList</code>. Code that uses it need neither know nor care whether the "Widgets" are made up on the spot, come from an array, or are read from a file, or a database, or from across the network, or from a future subspace relay. It will still work correctly because the <code>List</code> interface is correctly implemented.</p>
     <p>Except it isn't. The above class doesn't compile because the file access methods may throw an <code>IOException</code>, a checked exception which you have to "catch or specify". You <strong><em>can't specify it as thrown</em></strong> -- the compiler won't let you because that would violate the contract of the <code>List</code> interface. And there is no useful way that <code>WidgetList</code> itself can handle the exception (as I'll expound on later).</p>
     <p>Apparently the only thing to do is catch and rethrow checked exceptions as some unchecked exception:</p>
     <pre><code>@Override
public int size() {
    try {
        return (int)(file.length() / SIZE_OF_WIDGET);
    } catch (IOException e) {
        throw new WidgetListException(e);
    }
}

public static class WidgetListException extends RuntimeException {
    public WidgetListException(Throwable cause) {
        super(cause);
    }
}
</code></pre>
     <p>((Edit: Java 8 has added an <a href="http://docs.oracle.com/javase/8/docs/api/java/io/UncheckedIOException.html" rel="noreferrer"><code>UncheckedIOException</code></a> class for exactly this case: for catching and rethrowing <code>IOException</code>s across polymorphic method boundaries. Kind of proves my point!))</p>
     <p>So checked exceptions <strong><em>simply don't work</em></strong> in cases like this. You can't throw them. Ditto for a clever <code>Map</code> backed by a database, or an implementation of <code>java.util.Random</code> connected to a quantum entropy source via a COM port. As soon as you try to do anything novel with the implementation of a polymorphic interface, the concept of checked exceptions fails. But checked exceptions are so insidious that they still won't leave you in peace, because you still have to catch and rethrow any from lower-level methods, cluttering the code and cluttering the stack trace.</p>
     <p>I find that the ubiquitous <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html" rel="noreferrer"><code>Runnable</code></a> interface is often backed into this corner, if it calls something which throws checked exceptions. It can't throw the exception as is, so all it can do is clutter the code by catching and rethrowing as a <code>RuntimeException</code>.</p>
     <p>Actually, you <em>can</em> throw undeclared checked exceptions if you resort to hacks. The JVM, at run time, doesn't care about checked exception rules, so we need to fool only the compiler. The easiest way to do this is to abuse generics. This is my method for it (class name shown because (before Java 8) it's required in the calling syntax for the generic method):</p>
     <pre><code>class Util {
    /**
     * Throws any {@link Throwable} without needing to declare it in the
     * method's {@code throws} clause.
     * 
     * &lt;p&gt;When calling, it is suggested to prepend this method by the
     * {@code throw} keyword. This tells the compiler about the control flow,
     * about reachable and unreachable code. (For example, you don't need to
     * specify a method return value when throwing an exception.) To support
     * this, this method has a return type of {@link RuntimeException},
     * although it never returns anything.
     * 
     * @param t the {@code Throwable} to throw
     * @return nothing; this method never returns normally
     * @throws Throwable that was provided to the method
     * @throws NullPointerException if {@code t} is {@code null}
     */
    public static RuntimeException sneakyThrow(Throwable t) {
        return Util.&lt;RuntimeException&gt;sneakyThrow1(t);
    }

    @SuppressWarnings("unchecked")
    private static &lt;T extends Throwable&gt; RuntimeException sneakyThrow1(
            Throwable t) throws T {
        throw (T)t;
    }
}
</code></pre>
     <p>Hurray! Using this we can throw a checked exception any depth up the stack without declaring it, without wrapping it in a <code>RuntimeException</code>, and without cluttering the stack trace! Using the "WidgetList" example again:</p>
     <pre><code>@Override
public int size() {
    try {
        return (int)(file.length() / SIZE_OF_WIDGET);
    } catch (IOException e) {
        throw sneakyThrow(e);
    }
}
</code></pre>
     <p>Unfortunately, the final insult of checked exceptions is that the compiler refuses to allow you to <strong>catch</strong> a checked exception if, in its flawed opinion, it could not have been thrown. (Unchecked exceptions do not have this rule.) To catch the sneakily thrown exception we have to do this:</p>
     <pre><code>try {
    ...
} catch (Throwable t) { // catch everything
    if (t instanceof IOException) {
        // handle it
        ...
    } else {
        // didn't want to catch this one; let it go
        throw t;
    }
}
</code></pre>
     <p>That is a bit awkward, but on the plus side, it is still slightly simpler than the code for extracting a checked exception that was wrapped in a <code>RuntimeException</code>.</p>
     <p>Happily, the <code>throw t;</code> statement is legal here, even though the type of <code>t</code> is checked, thanks to a rule added in Java 7 about rethrowing caught exceptions.</p>
     <hr>
     <p>When checked exceptions meet polymorphism, the opposite case is also a problem: when a method is spec'd as potentially throwing a checked exception, but an overridden implementation doesn't. For example, the abstract class <a href="http://docs.oracle.com/javase/8/docs/api/java/io/OutputStream.html" rel="noreferrer"><code>OutputStream</code></a>'s <code>write</code> methods all specify <code>throws IOException</code>. <a href="http://docs.oracle.com/javase/8/docs/api/java/io/ByteArrayOutputStream.html" rel="noreferrer"><code>ByteArrayOutputStream</code></a> is a subclass that writes to an in-memory array instead of a true I/O source. Its overridden <code>write</code> methods cannot cause <code>IOException</code>s, so they have no <code>throws</code> clause, and you can call them without worrying about the catch-or-specify requirement.</p>
     <p>Except not always. Suppose that <code>Widget</code> has a method for saving it out to a stream:</p>
     <pre><code>public void writeTo(OutputStream out) throws IOException;
</code></pre>
     <p>Declaring this method to accept a plain <code>OutputStream</code> is the right thing to do, so it can be used polymorphically with all kinds of outputs: files, databases, the network, and so on. And in-memory arrays. With an in-memory array, however, there is a spurious requirement to handle an exception that can't actually happen:</p>
     <pre><code>ByteArrayOutputStream out = new ByteArrayOutputStream();
try {
    someWidget.writeTo(out);
} catch (IOException e) {
    // can't happen (although we shouldn't ignore it if it does)
    throw new RuntimeException(e);
}
</code></pre>
     <p>As usual, checked exceptions get in the way. If your variables are declared as a base type that has more open-ended exception requirements, you have to add handlers for those exceptions even if you <em>know</em> they won't occur in your application.</p>
     <p>But wait, checked exceptions are actually <em>so</em> annoying, that <em>they won't even let you do the reverse!</em> Imagine you currently catch any <code>IOException</code> thrown by <code>write</code> calls on an <code>OutputStream</code>, but you want to change the variable's declared type to a <code>ByteArrayOutputStream</code>, the compiler will berate you for trying to catch a checked exception that it says cannot be thrown.</p>
     <p>That rule causes some absurd problems. For example, one of the three <code>write</code> methods of <code>OutputStream</code> is <em>not</em> overridden by <code>ByteArrayOutputStream</code>. Specifically, <code>write(byte[] data)</code> is a convenience method that writes the full array by calling <code>write(byte[] data, int offset, int length)</code> with an offset of 0 and the length of the array. <code>ByteArrayOutputStream</code> overrides the three-argument method but inherits the one-argument convenience method as-is. The inherited method does exactly the right thing, but it includes an unwanted <code>throws</code> clause. That was perhaps an oversight in the design of <code>ByteArrayOutputStream</code>, but they can never fix it because it would break source compatibility with any code that does catch the exception -- the exception that has never, is never, and never will be thrown!</p>
     <p>That rule is annoying during editing and debugging too. E.g., sometimes I'll comment out a method call temporarily, and if it could have thrown a checked exception, the compiler will now complain about the existence of the local <code>try</code> and <code>catch</code> blocks. So I have to comment those out too, and now when editing the code within, the IDE will indent to the wrong level because the <code>{</code> and <code>}</code> are commented out. Gah! It's a small complaint but it seems like the only thing checked exceptions ever do is cause trouble.</p>
     <hr>
     <p>I'm nearly done. My final frustration with checked exceptions is that <em>at most call sites</em>, there's nothing useful you can do with them. Ideally when something goes wrong we'd have a competent application-specific handler that can inform the user of the problem and/or end or retry the operation as appropriate. Only a handler high up the stack can do this because it's the only one that knows the overall goal.</p>
     <p>Instead we get the following idiom, which is rampant as a way to shut the compiler up:</p>
     <pre><code>try {
    ...
} catch (SomeStupidExceptionOmgWhoCares e) {
    e.printStackTrace();
}
</code></pre>
     <p>In a GUI or automated program the printed message won't be seen. Worse, it plows on with the rest of the code after the exception. Is the exception not actually an error? Then don't print it. Otherwise, something else is going to blow up in a moment, by which time the original exception object will be gone. This idiom is no better than BASIC's <code>On Error Resume Next</code> or PHP's <code>error_reporting(0);</code>.</p>
     <p>Calling some kind of logger class is not much better:</p>
     <pre><code>try {
    ...
} catch (SomethingWeird e) {
    logger.log(e);
}
</code></pre>
     <p>That is just as lazy as <code>e.printStackTrace();</code> and still plows on with code in an indeterminate state. Plus, the choice of a particular logging system or other handler is application-specific, so this hurts code reuse.</p>
     <p>But wait! There is an easy and universal way to find the application-specific handler. It's higher up the call stack (or it is set as the Thread's <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setUncaughtExceptionHandler-java.lang.Thread.UncaughtExceptionHandler-" rel="noreferrer">uncaught exception handler</a>). So in most places, <strong><em>all you need to do is throw the exception higher up the stack</em></strong>. E.g., <code>throw e;</code>. Checked exceptions just get in the way.</p>
     <p>I'm sure checked exceptions sounded like a good idea when the language was designed, but in practice I've found them to be all bother and no benefit.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>For your size method with the WidgetList, I would cache the size in a variable and set it in the constructor. The constructor is free to throw an exception. This won't work if the file changes while using the WidgetList though, which would probably be bad if it did.</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">27 Nov 2013 at 03:20</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>SomeStupidExceptionOmgWhoCares well someone cared enough to throw it. So either it never should have been thrown (bad design) or you should really handle it. The same is true of the bad implementation of a pre-1.0 class (the byte array output stream) where the design was, unfortunately bad.</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">27 Nov 2013 at 03:22</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>The proper idiom would have been a directive that would catch any specified exceptions thrown by nested subroutine calls and rethrow them wrapped in a <code>RuntimeException</code>. Note that a routine could simultaneously be declared as <code>throws IOException</code> and yet also specify that any <code>IOException</code> thrown from a nested call should be considered unexpected and wrapped.</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">26 Dec 2013 at 03:13</span></td>
       </tr>
       <tr>
        <td>21</td>
        <td><span>I'm a professional C# developer with some Java experience who stumbled on this post. I'm baffled as to why anyone would support this bizarre behavior. In .NET if I want to catch a specific type of exception, I can catch that. If I want to just let it get thrown up the stack, there's nothing to do. I wish Java wasn't so quirky. :)</span> <span> - </span> <span class="display-name">aikeru</span> <span> </span> <span class="date">15 Mar 2014 at 04:38</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Concerning "sometimes I'll comment out a method call temporarily" - I learnt to use <code>if (false)</code> for this. It avoids the throw clause problem and the warning helps me to navigate back faster. +++ That said, I agree with everything you wrote. Checked exceptions have some value, but this value is negligible when compared to their cost. Nearly always they just get in the way.</span> <span> - </span> <span class="display-name">maaartinus</span> <span> </span> <span class="date">25 May 2017 at 04:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>A bit late to the party, but it gets even worse with lambdas (that appeared as a way to reduce boilerplate!). That said, regarding API calls with errors, you can wrap checked exceptions (where they occur) in a <code>RuntimeException</code> and have every API endpoint wrapped to a generic error handler that gets the <b>cause</b> of the exception and handle it, or return an appropriate error message to the user that accessed the API, possibly logging the error too. This is the most practical way I found to handle checked exceptions, but still annoying because I have to rethrow them.</span> <span> - </span> <span class="display-name">Lucas Basquerotto</span> <span> </span> <span class="date">30 Jun 2021 at 19:00</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Your WidgetList example is perhaps one good argument against the belief that the correct handler is always somewhere up the call stack. You would probably have one place where you configure your list to use a particular file. That's a pretty good place to handle an exception, e.g. pick a fallback file (Consider adding a configurable exception handler to the list itself). But after you pass that list all over the place, I doubt you will remember to or could reasonably handle exceptions everywhere. So your application will crash instead of picking a fallback set of slightly ugglier widgets.</span> <span> - </span> <span class="display-name">Boyan Hristov</span> <span> </span> <span class="date">20 Oct 2021 at 22:01</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>48</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Richard Levasseur</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Mar 2009 at 09:40</span>
     </div>
    </div>
    <div>
     <p>Well, it's not about displaying a stacktrace or silently crashing. It's about being able to communicate errors between layers.</p>
     <p>The problem with checked exceptions is they encourage people to swallow important details (namely, the exception class). If you choose not to swallow that detail, then you have to keep adding throws declarations across your whole app. This means 1) that a new exception type will affect lots of function signatures, and 2) you can miss a specific instance of the exception you actually -want- to catch (say you open a secondary file for a function that writes data to a file. The secondary file is optional, so you can ignore its errors, but because the signature <code>throws IOException</code>, it's easy to overlook this).</p>
     <p>I'm actually dealing with this situation now in an application. We repackaged almost exceptions as AppSpecificException. This made signatures really clean and we didn't have to worry about exploding <code>throws</code> in signatures.</p>
     <p>Of course, now we need to specialize the error handling at the higher levels, implementing retry logic and such. Everything is AppSpecificException, though, so we can't say "If an IOException is thrown, retry" or "If ClassNotFound is thrown, abort completely". We don't have a reliable way of getting to the <em>real</em> exception because things get repackaged again and again as they pass between our code and third-party code.</p>
     <p>This is why I'm a big fan of the exception handling in python. You can catch only the things you want and/or can handle. Everything else bubbles up as if you rethrew it yourself (which you have done anyways).</p>
     <p>I've found, time and time again, and throughout the project I mentioned, that exception handling falls into 3 categories:</p>
     <ol>
      <li>Catch and handle a <em>specific</em> exception. This is to implement retry logic, for example.</li>
      <li>Catch and rethrow <em>other</em> exceptions. All that happens here is usually logging, and its usually a trite message like "Unable to open $filename". These are errors you can't do anything about; only a higher levels knows enough to handle it.</li>
      <li>Catch everything and display an error message. This is usually at the very root of a dispatcher, and all it does it make sure it can communicate the error to the caller via a non-Exception mechanism (popup dialogue, marshaling an RPC Error object, etc).</li>
     </ol>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>6</td>
        <td><span>You could have made specific subclasses of AppSpecificException to allow separation while keeping the plain method signatures.</span> <span> - </span> <span class="display-name">Thorbjørn Ravn Andersen</span> <span> </span> <span class="date">1 Nov 2009 at 08:21</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Also a very important addition to item 2, is that it allows you to ADD INFORMATION to the exception caught (e.g. by nesting in a RuntimeException). It is much, much better to have the name of the file not found in the stack trace, than hidden deep down in a log file.</span> <span> - </span> <span class="display-name">Thorbjørn Ravn Andersen</span> <span> </span> <span class="date">1 Nov 2009 at 08:25</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Basically your argument is "Managing exceptions is tiring so I'd rather not deal with it". As the exception bubbles up it looses meaning and context making is practically useless. As designer of an API you should make is contractually clear as to what can be expected when things go wrong, if my program crashes because I was not informed that this or that exception can "bubbles up" then you, as designer, failed and as a result of your failure my system is not as stable as it can be.</span> <span> - </span> <span class="display-name">Newtopian</span> <span> </span> <span class="date">8 Nov 2009 at 04:07</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>Thats not what I'm saying at all. Your last sentence actually agrees with me. If everything is wrapped in AppSpecificException, then it doesn't bubble up (and meaning/context is lost), and, yes, the API client is not being informed - this is exactly what happens with checked exceptions (as they are in java), because people don't want to deal with functions with lots of <code>throws</code> declarations.</span> <span> - </span> <span class="display-name">Richard Levasseur</span> <span> </span> <span class="date">8 Nov 2009 at 06:33</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span>@Newtopian -- exceptions can largely only be handled at the "business" or "request" level. It makes sense to fail or retry at large granularity, not for every tiny potential failure. For this reason, exception-handling best practice is summarized as "throw early, catch late". Checked exceptions make it <i>harder</i> to manage reliability at the correct level, and encourage vast numbers of mis-coded catch blocks. <a href="http://literatejava.com/exceptions/checked-exceptions-javas-biggest-mistake/" rel="nofollow noreferrer">literatejava.com/exceptions/…</a></span> <span> - </span> <span class="display-name">Thomas W</span> <span> </span> <span class="date">2 Jun 2014 at 02:09</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>You could add a method like <code>hasCause(Class&lt;? extends Exception&gt;... causeClasses)</code> (searching the whole chain) to your <code>AppSpecificException</code> and use it as easily as multiple catch clauses.</span> <span> - </span> <span class="display-name">maaartinus</span> <span> </span> <span class="date">25 May 2017 at 03:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@maaartinus or just use a factory method for <code>AppSpecificException</code> that doesn’t create a new instance but returns a cause of the same type, if one exists.</span> <span> - </span> <span class="display-name">Holger</span> <span> </span> <span class="date">25 Jan 2018 at 15:02</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Your python example is functionally equivalent to unchecked exceptions (If you don't wish to handle them they bubble up to where they can be handled well or at least displayed) and I completely agree--being forced to handle exceptions right at the call point is not preferable which is an excellent answer to the question.</span> <span> - </span> <span class="display-name">Bill K</span> <span> </span> <span class="date">21 Nov 2018 at 00:41</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>The counter point by James Gosling in literatejava.com link (via @thomas-w comment) is so convoluted. His argument is essentially that c-programmers do not check FILE_NOT_FOUND error code during fopen() so we force this behavior using checked exceptions to make programs robust. Even a FATFS lib for tiny microcontrollers lists 18 return codes. <a href="http://elm-chan.org/fsw/ff/doc/open.html" rel="nofollow noreferrer">elm-chan.org/fsw/ff/doc/open.html</a>. Good C programmers would check and print right error messages and Bad Java programmers would swallow the checked exception whole. What a load of cr*p!</span> <span> - </span> <span class="display-name">rjha94</span> <span> </span> <span class="date">9 Jun 2022 at 10:06</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>26</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Luke Quinane</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Apr 2009 at 03:25</span>
     </div>
    </div>
    <div>
     <h2>SNR</h2>
     <p>Firstly, checked exceptions decrease the "signal-to-noise ratio" for the code. Anders Hejlsberg also talks about imperative vs declarative programming which is a similar concept. Anyway consider the following code snippets:</p>
     <p>Update UI from non UI-thread in Java:</p>
     <pre><code>try {  
    // Run the update code on the Swing thread  
    SwingUtilities.invokeAndWait(() -&gt; {  
        try {
            // Update UI value from the file system data  
            FileUtility f = new FileUtility();  
            uiComponent.setValue(f.readSomething());
        } catch (IOException e) {  
            throw new UncheckedIOException(e);
        }
    });
} catch (InterruptedException ex) {  
    throw new IllegalStateException("Interrupted updating UI", ex);  
} catch (InvocationTargetException ex) {
    throw new IllegalStateException("Invocation target exception updating UI", ex);
}
</code></pre>
     <p>Update UI from non UI-thread in C#:</p>
     <pre><code>private void UpdateValue()  
{  
   // Ensure the update happens on the UI thread  
   if (InvokeRequired)  
   {  
       Invoke(new MethodInvoker(UpdateValue));  
   }  
   else  
   {  
       // Update UI value from the file system data  
       FileUtility f = new FileUtility();  
       uiComponent.Value = f.ReadSomething();  
   }  
}  
</code></pre>
     <p>Which seems a lot clearer to me. When you start to do more and more UI work in Swing checked exceptions start to become really annoying and useless.</p>
     <h2>Jail Break</h2>
     <p>To implement even the most basic of implementations, such as Java's List interface, checked exceptions as a tool for design by contract fall down. Consider a list that is backed by a database or a filesystem or any other implementation that throws a checked exception. The only possible implementation is to catch the checked exception and rethrow it as an unchecked exception:</p>
     <pre><code>@Override
public void clear()  
{  
   try  
   {  
       backingImplementation.clear();  
   }  
   catch (CheckedBackingImplException ex)  
   {  
       throw new IllegalStateException("Error clearing underlying list.", ex);  
   }  
}  
</code></pre>
     <p>And now you have to ask what is the point of all that code? The checked exceptions just add noise, the exception has been caught but not handled and design by contract (in terms of checked exceptions) has broken down.</p>
     <h2>Conclusion</h2>
     <ul>
      <li>Catching exceptions is different to handling them.</li>
      <li>Checked exceptions add noise to the code.</li>
      <li>Exception handling works well in C# without them.</li>
     </ul>
     <p>I blogged about this <a href="http://lukequinane.blogspot.com/2009/03/java-exceptions.html" rel="noreferrer">previously</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Update UI from non UI-thread in C#: - what if an exception occurs?</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">1 Apr 2009 at 03:46</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>In the example both Java and C# are just letting the exceptions propagate up without handling them (Java via IllegalStateException). The difference is that you may want to handle a FileNotFoundException but its unlikely that handling InvocationTargetException or InterruptedException will be useful.</span> <span> - </span> <span class="display-name">Luke Quinane</span> <span> </span> <span class="date">1 Apr 2009 at 04:25</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>And in the C# way how do I know that the I/O exception can occur? Also I would never throw an exception from run... I consider that abusing exception handling. Sorry but for that part of your code I just can see your side of it yet.</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">1 Apr 2009 at 15:36</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>The known exceptions are put into the C# "Javadoc"; good APIs will define all known exceptions this way. You may be able to catch a FileNotFound inside run() but some exceptions can't be handled there. Catching them inside run() but not properly handling isn't good. Perhaps I'm misunderstanding.</span> <span> - </span> <span class="display-name">Luke Quinane</span> <span> </span> <span class="date">1 Apr 2009 at 23:58</span></td>
       </tr>
       <tr>
        <td>8</td>
        <td><span>We are getting there :-) So with each new release of an API you have to comb through all your calls and look for any new exceptions that might happen? The can easily happen with internal to a company APIs since they don't have to worry about backwards compatibility.</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">2 Apr 2009 at 16:38</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>Did you mean <i>decrease</i> the signal-to-noise ratio?</span> <span> - </span> <span class="display-name">neo2862</span> <span> </span> <span class="date">15 Nov 2009 at 09:53</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>You are mixing things here. C# is more recent than Java and has a simpler design for the every day tasks. You can achieve the same clean design in Java, adding your own libraries or utilities.</span> <span> - </span> <span class="display-name">Mister Smith</span> <span> </span> <span class="date">23 Aug 2011 at 06:36</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@TofuBeer Isn't being forced to update your code after the interface of an underlaying API changed a good thing? If you had had only unchecked exceptions there, you'd have ended up with a broken/incomplete program without knowing it.</span> <span> - </span> <span class="display-name">Francois Bourgeois</span> <span> </span> <span class="date">4 Apr 2013 at 10:52</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I think this answer hits the head on the nail. "Look how crufty the Java code becomes. Java is already verbose!" A few remarks though: Just rethrowing the IOExceptions and InterruptedExceptions and crash and burn like that is a bad idea. In 9 cases out of 10, there's a more responsible way of dealing with the situation than to sweep it under the carpet. Where to deal with it? You're doing UI stuff here, so here's the right place to do it! If you do this improvement in both snippets, the C# version starts to approach the Java version. ...</span> <span> - </span> <span class="display-name">aioobe</span> <span> </span> <span class="date">11 Jul 2017 at 04:39</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>... So, in this case I'd actually claim that the checked exceptions in fact helped you write more responsible code. The <code>InvocationTargetException</code> is nothing but unfortunate. It should clearly have been a <code>RuntimeException</code>. It's from the early days of Java, and no one had experienced the annoyance checked exceptions had brought us today. I would however like to emphasize that this is an API design issue, rather than an issue with checked exceptions as a language feature. Is it hard to get right? Sure, sometimes. But not so hard that a good feature like this should be tossed out the window.</span> <span> - </span> <span class="display-name">aioobe</span> <span> </span> <span class="date">11 Jul 2017 at 04:44</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>23</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Le Dude</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Mar 2009 at 10:34</span>
     </div>
    </div>
    <div>
     <p>Artima <a href="http://www.artima.com/intv/handcuffs.html" rel="noreferrer">published an interview</a> with one of the architects of .NET, Anders Hejlsberg, which acutely covers the arguments against checked exceptions. A short taster:</p>
     <blockquote>
      <p>The throws clause, at least the way it's implemented in Java, doesn't necessarily force you to handle the exceptions, but if you don't handle them, it forces you to acknowledge precisely which exceptions might pass through. It requires you to either catch declared exceptions or put them in your own throws clause. To work around this requirement, people do ridiculous things. For example, they decorate every method with, "throws Exception." That just completely defeats the feature, and you just made the programmer write more gobbledy gunk. That doesn't help anybody.</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>In fact, the chief architect.</span> <span> - </span> <span class="display-name">Trap</span> <span> </span> <span class="date">5 Mar 2009 at 12:11</span></td>
       </tr>
       <tr>
        <td>19</td>
        <td><span>I have read that, to me his argument boils down to "there are bad programmers out there".</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">5 Mar 2009 at 15:11</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span>TofuBeer, not at all. The whole point is that many times you don't know what to do with the Exception that the called method throws, and the case you're really interested in isn't even mentioned. You open a file, you get an IO Exception, for instance... that's not my problem, so I throw it up. But the top-level calling method will just want to stop processing and inform the user that there's an unknown problem. The checked Exception didn't help at all. It was one of a million strange things that can happen.</span> <span> - </span> <span class="display-name">Dan Rosenstark</span> <span> </span> <span class="date">27 May 2009 at 12:19</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>@yar, if you don't like the checked exception, then do a "throw new RuntimeException("we did not expect this when doing Foo.bar()", e)" and be done with it.</span> <span> - </span> <span class="display-name">Thorbjørn Ravn Andersen</span> <span> </span> <span class="date">1 Nov 2009 at 09:32</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>TofuBeer, I think his real argument is that there are humans out there. And that on the whole, it's not convincing that the pain incurred using checked exceptions is less than the pain incurred without them.</span> <span> - </span> <span class="display-name">Phil</span> <span> </span> <span class="date">3 May 2010 at 00:23</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@ThorbjørnRavnAndersen: That would be the right approach, but I would posit that such wrapping should occur implicitly if a method neither catches a checked exception nor indicates somehow that it should percolate up the stack as-is (even if <code>Foo</code>, which has a <code>throws WizzleException</code> clause calls <code>Bar</code> which has a matching clause, that should not suffice, since likely as not, <code>Bar</code>'s exception won't mean the same thing as <code>Foo</code>'s. Boilerplate code to do the thing that should be done in 90% of cases is just noise.</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">29 Oct 2012 at 20:35</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@supercat in my experience, checked exceptions mean that you think about error handling <i>much</i> earlier in the development process. This result in higher quality code (given that errors may be recoverable).</span> <span> - </span> <span class="display-name">Thorbjørn Ravn Andersen</span> <span> </span> <span class="date">29 Oct 2012 at 22:05</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>@ThorbjørnRavnAndersen: A fundamental design weakness in Java, which .net unfortunately copied, is that it uses the type of an exception as both the primary means for deciding whether it should be acted upon, and the primary means of indicating the general type of thing that went wrong, when in fact the two issues are largely orthogonal. What matters is not what went wrong, but what state objects are in. Further, both .net and Java assume by default that acting upon and resolving an exception are generally the same thing, when in fact they're often different.</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">29 Oct 2012 at 22:20</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@supercat interesting. Is this elaborated somewhere?</span> <span> - </span> <span class="display-name">Thorbjørn Ravn Andersen</span> <span> </span> <span class="date">29 Oct 2012 at 22:28</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@ThorbjørnRavnAndersen: Not that I know of; it's just my opinion. If one has a method like <code>LoadDocument()</code> and it throws any exception, the caller has to deal with the fact that the document didn't load. If the caller can survive without the document, the next thing the caller needs to know is whether the attempt to load the document had any dangerous side effects that weren't rolled back. And the exception type says <i>nothing</i> about that. If a failed attempt to load a document had no side-effects, informing the user that it couldn't load may be sufficient to handle the exception.</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">29 Oct 2012 at 22:35</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@ThorbjørnRavnAndersen: If the attempt to load the document corrupted a data structure which is shared with other open documents, informing the user of the problem may be appropriate, but the problem should <i>not</i> be considered resolved. Unfortunately, both Java and .net assume that a <code>catch</code> block will resolve just about any exception unless the code manually rethrows it.</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">29 Oct 2012 at 22:37</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@supercat in that case the <code>loadDocument()</code> method has too many responsibilities. The exception should be handled at a <i>much</i> lower level instead of being allowed to interrupt the manipulation of shared data structures. What you describe is simply bad design and not the fault of the exception mechanism.</span> <span> - </span> <span class="display-name">Thorbjørn Ravn Andersen</span> <span> </span> <span class="date">30 Oct 2012 at 00:05</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>So he's arguing against bad programmers, not checked exceptions themselves. Not having checked exceptions only makes those bad programmers even worse.</span> <span> - </span> <span class="display-name">AxiomaticNexus</span> <span> </span> <span class="date">25 Jun 2014 at 21:45</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>22</span>
     </div>
     <div>
      <span>Answerer: </span> <span>tsimon</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Mar 2009 at 09:07</span>
     </div>
    </div>
    <div>
     <p>I initially agreed with you, as I've always been in favour of checked exceptions, and began to think about why I don't like not having checked exceptions in .Net. But then I realised that I don't infact like checked exceptions.</p>
     <p>To answer you question, yes, I like my programs to show stack traces, preferably really ugly ones. I want the application to explode into a horrible heap of the ugliest error messages you could ever want to see.</p>
     <p>And the reason is because, if it does that, I have to fix it, and I have to fix it right away. I want to know immediately that there is a problem.</p>
     <p>How many times do you actually handle exceptions? I'm not talking about catching exceptions -- I'm talking about handling them? It's too easy to write the following:</p>
     <pre><code>try {
  thirdPartyMethod();
} catch(TPException e) {
  // this should never happen
}
</code></pre>
     <p>And I know you can say that it's bad practice, and that 'the answer' is to do something with the exception (let me guess, log it?), but in the Real World (tm), most programmers just don't do it.</p>
     <p>So yes, I don't want to catch exceptions if I don't have to do so, and I want my program to blow up spectacularly when I screw up. Silently failing is the worst possible outcome.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Java encourages you to do this sort of thing, so that you don't have to add every type of exception to every method signature.</span> <span> - </span> <span class="display-name">yfeldblum</span> <span> </span> <span class="date">5 Mar 2009 at 12:00</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I handle the exception, with code inside of the catch 100% of the time. The code is more than simply logging the fact that the exception is not too often. Most often the code is throwing a different exception type.</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">5 Mar 2009 at 15:31</span></td>
       </tr>
       <tr>
        <td>19</td>
        <td><span>Funny.. ever since I embraced checked exceptions correctly and used them appropriately my programs stopped blowing up in huge steaming pile of in your face customer dissatisfaction. If while developing you have big ugly bad stack trace then the customer is bound to get them as well. D'love to see his face when he sees ArrayIndexOutOfBoundsException with a mile high stack trace on his crashed system instead of a little tray notification saying that the color config for button XYZ could not be parsed so the default was used instead with the software happily humming along</span> <span> - </span> <span class="display-name">Newtopian</span> <span> </span> <span class="date">7 Aug 2009 at 16:46</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Perhaps what Java needs is a "cantHandle" declaration which would specify that a method or try/catch block of code isn't prepared to handle a particular exception that occurs within it, and that any such exception that occurs via means other than an explicit throw within that method (as opposed to a called method) should be automatically wrapped and rethrown in a RuntimeException. IMHO, checked exceptions should <i>rarely</i> propagate up the call stack without being wrapped.</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">24 Jan 2013 at 23:52</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>@Newtopian -- I write server &amp; high-reliability software &amp; have been doing so for 25 years. My programs have <i>never</i> blown up, and I work with high-availability, retry &amp; reconnect, integration-based financial &amp; military systems. I have an absolute objective basis to prefer runtime exceptions. Checked exceptions make it more difficult to follow correct "throw early, catch late" best practice. Correct reliability &amp; error-handling are at the "business", "connection" or "request" level. (Or occasionally when parsing data). Checked exceptions get in the way of doing it right.</span> <span> - </span> <span class="display-name">Thomas W</span> <span> </span> <span class="date">2 Jun 2014 at 02:39</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>The exceptions you're talking about here are <code>RuntimeExceptions</code> which indeed you don't have to catch, and I agree you should let the program blow up from. The exceptions you should always catch and handle are the checked exceptions like <code>IOException</code>. If you get an <code>IOException</code>, there's nothing to fix in your code; your program should not blow up just because there was a network hiccup.</span> <span> - </span> <span class="display-name">AxiomaticNexus</span> <span> </span> <span class="date">25 Jun 2014 at 21:25</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Is there a static analysis tool out there which can find empty exception handlers and warn programmers, or do some IDEs already do it?</span> <span> - </span> <span class="display-name">MauganRa</span> <span> </span> <span class="date">31 Aug 2016 at 10:10</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>22</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Esko Luontola</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Mar 2009 at 12:56</span>
     </div>
    </div>
    <div>
     <p>The article <a href="http://www.oracle.com/technetwork/articles/entarch/effective-exceptions-092345.html" rel="noreferrer">Effective Java Exceptions</a> explains nicely when to use unchecked and when to use checked exceptions. Here are some quotes from that article to highlight the main points:</p>
     <blockquote>
      <p><strong>Contingency:</strong> An expected condition demanding an alternative response from a method that can be expressed in terms of the method's intended purpose. The caller of the method expects these kinds of conditions and has a strategy for coping with them.</p>
      <p><strong>Fault:</strong> An unplanned condition that prevents a method from achieving its intended purpose that cannot be described without reference to the method's internal implementation.</p>
     </blockquote>
     <p>(SO doesn't allow tables, so you might want to read the following from the <a href="http://www.oracle.com/technetwork/articles/entarch/effective-exceptions2-097044.html" rel="noreferrer">original page</a>...)</p>
     <blockquote>
      <p><strong>Contingency</strong></p>
      <ul>
       <li>Is considered to be: A part of the design</li>
       <li>Is expected to happen: Regularly but rarely</li>
       <li>Who cares about it: The upstream code that invokes the method</li>
       <li>Examples: Alternative return modes</li>
       <li>Best Mapping: A checked exception</li>
      </ul>
      <p><strong>Fault</strong></p>
      <ul>
       <li>Is considered to be: A nasty surprise</li>
       <li>Is expected to happen: Never</li>
       <li>Who cares about it: The people who need to fix the problem</li>
       <li>Examples: Programming bugs, hardware malfunctions, configuration mistakes, missing files, unavailable servers</li>
       <li>Best Mapping: An unchecked exception</li>
      </ul>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>I know when to use them, I want to know why people who don't follow that advice... don't follow that advice :-)</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">5 Mar 2009 at 15:45</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>What are <i>programming bugs</i> and how to distinguish them from <i>usage bugs</i>? Is it a programming bug if the user passes the wrong arguments to the program? From the Java point of view it might be no programming bug but from the shell script point of view it is a programming bug. So what are invalid arguments in <code>args[]</code>? Are they a Contingency or a Fault?</span> <span> - </span> <span class="display-name">ceving</span> <span> </span> <span class="date">12 Mar 2013 at 14:50</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>@TofuBeer -- Because the Java library designers, chose to put all kinds of unrecoverable low-level failures as <i>checked exceptions</i> when they clearly should have been <i>unchecked</i>. FileNotFound is the only IOException which should be checked, for example. With regard to JDBC -- only connecting to the database, can reasonably be considered a <i>contingency</i>. All other SQLExceptions should have been <i>failures</i> and unchecked. Error handling should correctly be at the "business" or "request" level -- see the "throw early, catch late" best practice. Checked exceptions are a barrier to that.</span> <span> - </span> <span class="display-name">Thomas W</span> <span> </span> <span class="date">2 Jun 2014 at 02:21</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>There is a single huge flaw in your argument. "Contingency" must NOT be handled through exceptions, but through business code and method return values. Exceptions are for, as the word says, EXCEPTIONAL situations, therefore Faults.</span> <span> - </span> <span class="display-name">Matteo Mosca</span> <span> </span> <span class="date">16 Dec 2014 at 16:15</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@MatteoMosca Error return codes tend to get ignored and that's enough to disqualify them. Actually, anything unusual can oftentimes be only handled somewhere up in the stack and that's a use case for exceptions. I could imagine something like <code>File#openInputStream</code> returning <code>Either&lt;InputStream, Problem&gt;</code> - if that's what you mean, then we may agree.</span> <span> - </span> <span class="display-name">maaartinus</span> <span> </span> <span class="date">2 Dec 2017 at 15:12</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@maaartinus That's exactly what I meant.</span> <span> - </span> <span class="display-name">Matteo Mosca</span> <span> </span> <span class="date">3 Dec 2017 at 15:27</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>20</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mario Ortegón</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Mar 2009 at 09:40</span>
     </div>
    </div>
    <div>
     <p>I have been working with several developers in the last three years in relatively complex applications. We have a code base that uses Checked Exceptions quite often with proper error handling, and some other that doesn't.</p>
     <p>So far, I have it found easier to work with the code base with Checked Exceptions. When I am using someone else's API, it is nice that I can see exactly what kind of error conditions I can expect when I call the code and handle them properly, either by logging, displaying or ignoring (Yes, there is valid cases for ignoring exceptions, such as a ClassLoader implementation). That gives the code I am writing an opportunity to recover. All runtime exceptions I propagate up until they are cached and handled with some generic error handling code. When I find a checked exception that I don't really want to handle at a specific level, or that I consider a programming logic error, then I wrap it into a RuntimeException and let it bubble up. Never, ever swallow an exception without a good reason (and good reasons for doing this are rather scarce)</p>
     <p>When I work with the codebase that does not have checked exceptions, it makes it to me a little bit harder to know before hand what can I expect when calling the function, which can break some stuff terribly.</p>
     <p>This is all of course a matter of preference and developer skill. Both ways of programming and error handling can be equally effective (or noneffective), so I wouldn't say that there is The One Way.</p>
     <p>All in all, I find it easier to work with Checked Exceptions, specially in large projects with lot of developers.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>7</td>
        <td><span>I do to. For me they are an essential part of a contract. Without having to get to detailed in the API documentation, I can quickly know the likeliest of error scenarios.</span> <span> - </span> <span class="display-name">Wayne Hartman</span> <span> </span> <span class="date">18 May 2009 at 03:47</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>Agree. I experienced the necessity of checked exceptions in .Net once when I tried to make network calls. Knowing that a network hiccup could happen at any moment, I had to read through the entire documentation of the API's to find out what exception is it that I needed to catch specifically for that scenario. If C# had checked exceptions, I would have known immediately. Other C# developers would probably just let the app crash from a simple network error.</span> <span> - </span> <span class="display-name">AxiomaticNexus</span> <span> </span> <span class="date">25 Jun 2014 at 21:35</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>20</span>
     </div>
     <div>
      <span>Answerer: </span> <span>David Lichteblau</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Mar 2009 at 10:40</span>
     </div>
    </div>
    <div>
     <p>In short:</p>
     <p><em>Exceptions are an API design question.</em> -- No more, no less.</p>
     <p><strong>The argument for checked exceptions:</strong></p>
     <p>To understand why checked exceptions might not be good thing, let's turn the question around and ask: When or why are checked exceptions attractive, i.e. why would you want the compiler to enforce declaration of exceptions?</p>
     <p>The answer is obvious: Sometimes you <em>need</em> to catch an exception, and that is only possible if the code being called offers a specific exception class for the error that you are interested in.</p>
     <p>Hence, the argument <strong>for</strong> checked exceptions is that the compiler forces programmers to declare which exceptions are thrown, and <strong>hopefully</strong> the programmer will then also document specific exception classes and the errors that cause them.</p>
     <p>In reality though, ever too often a package <code>com.acme</code> only throws an <code>AcmeException</code> rather than specific subclasses. Callers then need to handle, declare, or re-signal <code>AcmeExceptions</code>, but still cannot be certain whether an <code>AcmeFileNotFoundError</code> happened or an <code>AcmePermissionDeniedError</code>.</p>
     <p>So if you're only interested in an <code>AcmeFileNotFoundError</code>, the solution is to file a feature request with the ACME programmers and tell them to implement, declare, and document that subclass of <code>AcmeException</code>.</p>
     <p><strong>So why bother?</strong></p>
     <p>Hence, even with checked exceptions, the compiler cannot force programmers to throw <strong>useful</strong> exceptions. It is still just a question of the API's quality.</p>
     <p>As a result, languages without checked exceptions usually do not fare much worse. Programmers might be tempted to throw unspecific instances of a general <code>Error</code> class rather than an <code>AcmeException</code>, but if they care at all about their API quality, they will learn to introduce an <code>AcmeFileNotFoundError</code> after all.</p>
     <p>Overall, the specification and documentation of exceptions is not much different from the specification and documentation of, say, ordinary methods. Those, too, are an API design question, and if a programmer forgot to implement or export a useful feature, the API needs to be improved so that you can work with it usefully.</p>
     <p>If you follow this line of reasoning, it should be obvious that the "hassle" of declaring, catching, and re-throwing of exceptions that is so common in languages like Java often adds little value.</p>
     <p>It is also worth noting that the Java VM does <em>not</em> have checked exceptions -- only the Java compiler checks them, and class files with changed exception declarations are compatible at run time. Java VM security is not improved by checked exceptions, only coding style.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>Your argument argues against itself. If "sometimes you need to catch an exception" and API quality is often poor, without checked exceptions you won't know whether the designer neglected to document that a certain method throws an exception that needs to be caught. Couple that with throwing <code>AcmeException</code> rather than <code>AcmeFileNotFoundError</code> and good luck figuring out what you did wrong and where you need to catch it. Checked exceptions provide programmers a modicum of protection against bad API design.</span> <span> - </span> <span class="display-name">Eva</span> <span> </span> <span class="date">28 Feb 2013 at 16:27</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Java library design made serious mistakes. 'Checked exceptions' were for predictable &amp; recoverable contingencies -- such as file not found, failure to connect. They were never meant or suited for low-level systemic failure. It would have been fine to force opening a file to be checked, but there is no sensible retry or recovery for failure to write a single byte/ execute a SQL query etc. Retry or recovery are correctly handled at the "business" or "request" level, which checked exceptions make pointlessly difficult. <a href="http://literatejava.com/exceptions/checked-exceptions-javas-biggest-mistake/" rel="nofollow noreferrer">literatejava.com/exceptions/…</a></span> <span> - </span> <span class="display-name">Thomas W</span> <span> </span> <span class="date">2 Jun 2014 at 02:14</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>18</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Daniel A.A. Pelsmaeker</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 May 2013 at 00:49</span>
     </div>
    </div>
    <div>
     <h2>Exception categories</h2>
     <p>When talking about exceptions I always refer back to <a href="https://blogs.msdn.com/b/ericlippert/archive/2008/09/10/vexing-exceptions.aspx" rel="noreferrer">Eric Lippert's Vexing exceptions</a> blog article. He places exceptions into these categories:</p>
     <ul>
      <li><strong>Fatal</strong> - These exceptions are <em>not your fault</em>: you cannot prevent then, and you cannot sensibly handle them. For example, <code>OutOfMemoryError</code> or <code>ThreadAbortException</code>.</li>
      <li><strong>Boneheaded</strong> - These exceptions <em>are your fault</em>: you should have prevented them, and they represent bugs in your code. For example, <code>ArrayIndexOutOfBoundsException</code>, <code>NullPointerException</code> or any <code>IllegalArgumentException</code>.</li>
      <li><strong>Vexing</strong> - These exceptions are <em>not exceptional</em>, not your fault, you cannot prevent them, but you'll have to deal with them. They are often the result of an unfortunate design decision, such as throwing <code>NumberFormatException</code> from <code>Integer.parseInt</code> instead of providing an <code>Integer.tryParseInt</code> method that returns a boolean false on parse failure.</li>
      <li><strong>Exogenous</strong> - These exceptions <em>are usually exceptional</em>, not your fault, you cannot (reasonably) prevent them, but <em>you must handle them</em>. For example, <code>FileNotFoundException</code>.</li>
     </ul>
     <p>An API user:</p>
     <ul>
      <li><em>must not</em> handle <em>fatal</em> or <em>boneheaded</em> exceptions.</li>
      <li><em>should</em> handle <em>vexing</em> exceptions, but they should not occur in an ideal API.</li>
      <li><em>must</em> handle <em>exogenous</em> exceptions.</li>
     </ul>
     <h2>Checked exceptions</h2>
     <p>The fact that the API user <em>must</em> handle a particular exception is part of the method's contract between the caller and the callee. The contract specifies, among other things: the number and types of arguments the callee expects, the type of return value the caller can expect, and <em>the exceptions the caller is expected to handle</em>.</p>
     <p>Since <em>vexing</em> exceptions should not exist in an API, only these <em>exogenous</em> exceptions must be <em>checked exceptions</em> to be part of the method's contract. Relatively few exceptions are <em>exogenous</em>, so any API should have relatively few checked exceptions.</p>
     <p>A checked exception is an exception that <em>must be handled</em>. Handling an exception can be as simple as swallowing it. There! The exception is handled. Period. If the developer wants to handle it that way, fine. But he can't ignore the exception, and has been warned.</p>
     <h2>API problems</h2>
     <p>But any API that has checked <em>vexing</em> and <em>fatal</em> exceptions (e.g. the JCL) will put unnecessary strain on the API users. Such exceptions <em>have</em> to be handled, but either the exception is so common that it should not have been an exception in the first place, or nothing can be done when handling it. And <em>this</em> causes Java developers to hate checked exceptions.</p>
     <p>Also, many APIs don't have a proper exception class hierarchy, causing all kinds of non-exogenous exception causes to be represented by a single checked exception class (e.g. <code>IOException</code>). And this also causes Java developers to hate checked exceptions.</p>
     <h2>Conclusion</h2>
     <p><em>Exogenous</em> exceptions are those that are not your fault, could not have been prevented, and which should be handled. These form a small subset of all the exceptions that can get thrown. APIs should only have <strong>checked <em>exogenous</em> exceptions</strong>, and all other exceptions unchecked. This will make better APIs, put less strain on the API user, and therefore reduce the need to catch all, swallow or rethrow unchecked exceptions.</p>
     <p>So don't hate Java and its checked exceptions. Instead, hate the APIs that overuse checked exceptions.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>And misuse them by not having a hierarchy.</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">12 May 2013 at 17:02</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>FileNotFound and establishing a JDBC/network connection are <i>contingencies</i> and correct to be checked exceptions, as these are predictable and (possible) recoverable. Most other IOExceptions, SQLExceptions, RemoteException etc are unpredictable &amp; unrecoverable <i>failures</i>, and should have been <b>runtime exceptions.</b> Due to mistaken Java library design, we have all been lumped with this mistake &amp; are now mostly using Spring &amp; Hibernate (who got their design right).</span> <span> - </span> <span class="display-name">Thomas W</span> <span> </span> <span class="date">2 Jun 2014 at 02:45</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>You usually should handle boneheaded exceptions, though you may not want to call it "handling". For example, in a web server, I log them and show 500 to the user. As the exception is unexpected, there's about all I can do before the bug fix.</span> <span> - </span> <span class="display-name">maaartinus</span> <span> </span> <span class="date">2 Dec 2017 at 15:19</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Newtopian</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Aug 2009 at 17:34</span>
     </div>
    </div>
    <div>
     <p>Ok... Checked exceptions are not ideal and have some caveat but they do serve a purpose. When creating an API there are specific cases of failures that are contractual of this API. When in the context of a strongly statically typed language such as Java if one does not use checked exceptions then one must rely on ad-hoc documentation and convention to convey the possibility of error. Doing so removes all benefit that the compiler can bring in handling error and you are left completely to the good will of programmers.</p>
     <p>So, one removes Checked exception, such as was done in C#, how then can one programmatically and structurally convey the possibility of error ? How to inform the client code that such and such errors can occur and must be dealt with ?</p>
     <p>I hear all sorts of horrors when dealing with checked exceptions, they are misused this is certain but so are unchecked exceptions. I say wait a few years when APIs are stacked many layers deep and you will be begging for the return of some kind of structured mean to convey failures.</p>
     <p>Take the case when the exception was thrown somewhere at the bottom of the API layers and just bubbled up because nobody knew it was even possible for this error to occur, this even though it was a type of error that was very plausible when the calling code threw it (FileNotFoundException for example as opposed to VogonsTrashingEarthExcept... in which case it would not matter if we handle it or not since there is nothing left to handle it with).</p>
     <p>Many have argued that not being able to load the file was almost always the end of the world for the process and it must die a horrible and painful death. So yeah.. sure ... ok.. you build an API for something and it loads file at some point... I as the user of said API can only respond... "Who the hell are you to decide when my program should crash !" Sure Given the choice where exceptions are gobbled up and leave no trace or the EletroFlabbingChunkFluxManifoldChuggingException with a stack trace deeper than the Marianna trench I would take the latter without a cinch of hesitation, but does this mean that it is the desirable way to deal with exception ? Can we not be somewhere in the middle, where the exception would be recast and wrapped each time it traversed into a new level of abstraction so that it actually means something ?</p>
     <p>Lastly, most of the argument I see is "I don't want to deal with exceptions, many people do not want to deal with exceptions. Checked exceptions force me to deal with them thus I hate checked exception" To eliminate such mechanism altogether and relegate it to the chasm of goto hell is just silly and lacks jugement and vision.</p>
     <p>If we eliminate checked exception we could also eliminate the return type for functions and always return a "anytype" variable... That would make life so much simpler now would it not ?</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>Checked exceptions would be useful if there were a declarative means of saying none of the method calls within a block are expected to throw some (or any) checked exceptions, and any such exceptions should automatically be wrapped and rethrown. They could be even more useful if calls to methods which were declared as throwing checked exceptions traded off call speed/return for exception-handling speed (so that expected exceptions could be handled almost as fast as normal program flow). Neither situation presently applies, though.</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">14 Mar 2014 at 00:20</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span> <span class="arrow"> <a href="#answer_15">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Boann</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Apr 2016 at 15:09</span>
     </div>
    </div>
    <div>
     <p>This isn't an argument against the pure concept of checked exceptions, but the class hierarchy Java uses for them is a freak show. We always call the things simply "exceptions" – which is correct, because the language specification <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-11.html" rel="noreferrer">calls them that too</a> – but how is an exception named and represented in the type system?</p>
     <p>By the class <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Exception.html" rel="noreferrer"><code>Exception</code></a> one imagines? Well no, because <code>Exception</code>s are exceptions, and likewise exceptions are <code>Exception</code>s, except for those exceptions that are <strong><em>not</em></strong> <code>Exception</code>s, because other exceptions are actually <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Error.html" rel="noreferrer"><code>Error</code></a>s, which are the other kind of exception, a kind of extra-exceptional exception that should never happen except when it does, and which you should never catch except sometimes you have to. Except that's not all because you can also define other exceptions that are neither <code>Exception</code>s nor <code>Error</code>s but merely <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html" rel="noreferrer"><code>Throwable</code></a> exceptions.</p>
     <p>Which of these are the "checked" exceptions? <code>Throwable</code>s are checked exceptions, except if they're also <code>Error</code>s, which are unchecked exceptions, and then there's the <code>Exception</code>s, which are also <code>Throwable</code>s and are the main type of checked exception, except there's one exception to that too, which is that if they are also <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html" rel="noreferrer"><code>RuntimeException</code></a>s, because that's the other kind of unchecked exception.</p>
     <p>What are <code>RuntimeException</code>s for? Well just like the name implies, they're exceptions, like all <code>Exception</code>s, and they happen at run-time, like all exceptions actually, except that <code>RuntimeException</code>s are exceptional compared to other run-time <code>Exception</code>s because they aren't supposed to happen except when you make some silly error, although <code>RuntimeException</code>s are never <code>Error</code>s, so they're for things that are exceptionally erroneous but which aren't actually <code>Error</code>s. Except for <a href="https://docs.oracle.com/javase/8/docs/api/javax/management/RuntimeErrorException.html" rel="noreferrer"><code>RuntimeErrorException</code></a>, which really is a <code>RuntimeException</code> for <code>Error</code>s. But aren't all exceptions supposed to represent erroneous circumstances anyway? Yes, all of them. Except for <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadDeath.html" rel="noreferrer"><code>ThreadDeath</code></a>, an exceptionally unexceptional exception, as the documentation explains that it's a "normal occurrence" and that that's why they made it a type of <code>Error</code>.</p>
     <p>Anyway, since we're dividing all exceptions down the middle into <code>Error</code>s (which are for exceptional execution exceptions, so unchecked) and <code>Exception</code>s (which are for less exceptional execution errors, so checked except when they're not), we now need two different kinds of each of several exceptions. So we need <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalAccessError.html" rel="noreferrer"><code>IllegalAccessError</code></a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalAccessException.html" rel="noreferrer"><code>IllegalAccessException</code></a>, and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/InstantiationError.html" rel="noreferrer"><code>InstantiationError</code></a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/InstantiationException.html" rel="noreferrer"><code>InstantiationException</code></a>, and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/NoSuchFieldError.html" rel="noreferrer"><code>NoSuchFieldError</code></a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/NoSuchFieldException.html" rel="noreferrer"><code>NoSuchFieldException</code></a>, and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/NoSuchMethodError.html" rel="noreferrer"><code>NoSuchMethodError</code></a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/NoSuchMethodException.html" rel="noreferrer"><code>NoSuchMethodException</code></a>, and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/zip/ZipError.html" rel="noreferrer"><code>ZipError</code></a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/zip/ZipException.html" rel="noreferrer"><code>ZipException</code></a>.</p>
     <p>Except that even when an exception is checked, there are always (fairly easy) ways to cheat the compiler and throw it without it being checked. If you do you that you may get an <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/UndeclaredThrowableException.html" rel="noreferrer"><code>UndeclaredThrowableException</code></a>, except in other cases, where it could throw up as an <a href="https://docs.oracle.com/javase/8/docs/api/java/rmi/UnexpectedException.html" rel="noreferrer"><code>UnexpectedException</code></a>, or an <a href="https://docs.oracle.com/javase/8/docs/api/org/omg/CORBA/portable/UnknownException.html" rel="noreferrer"><code>UnknownException</code></a> (which is unrelated to <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/UnknownError.html" rel="noreferrer"><code>UnknownError</code></a>, which is only for "serious exceptions"), or an <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutionException.html" rel="noreferrer"><code>ExecutionException</code></a>, or an <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/InvocationTargetException.html" rel="noreferrer"><code>InvocationTargetException</code></a>, or an <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ExceptionInInitializerError.html" rel="noreferrer"><code>ExceptionInInitializerError</code></a>.</p>
     <p>Oh, and we mustn't forget Java 8's snazzy new <a href="https://docs.oracle.com/javase/8/docs/api/java/io/UncheckedIOException.html" rel="noreferrer"><code>UncheckedIOException</code></a>, which is a <code>RuntimeException</code> exception designed to let you throw the exception checking concept out the window by wrapping checked <a href="https://docs.oracle.com/javase/8/docs/api/java/io/IOException.html" rel="noreferrer"><code>IOException</code></a> exceptions caused by I/O errors (which don't cause <a href="https://docs.oracle.com/javase/8/docs/api/java/io/IOError.html" rel="noreferrer"><code>IOError</code></a> exceptions, although that exists too) that are exceptionally difficult to handle and so you need them to not be checked.</p>
     <p>Thanks Java!</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span>As far as I can say, this answer only says "Java's exceptions are a mess" in a full of irony, arguably funny way. What it seems not to do is explain why programmers tend to avoid trying to understand how these things are supposed to work. Also, in real-life cases (at least the ones I had a chance to deal with), if the programmers don't deliberately try to make their lives harder, the exceptions are nowhere near as complicated as you've described.</span> <span> - </span> <span class="display-name">CptBartender</span> <span> </span> <span class="date">28 Jun 2016 at 07:26</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_15"><span>Answer 15</span> <span class="arrow"> <a href="#answer_14">↑</a> </span> <span class="arrow"> <a href="#answer_16">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Kurt Schelfthout</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Mar 2009 at 12:23</span>
     </div>
    </div>
    <div>
     <p>Indeed, checked exceptions on the one hand increase robustness and correctness of your program (you're forced to make correct declarations of your interfaces -the exceptions a method throws are basically a special return type). On the other hand you face the problem that, since exceptions "bubble up", very often you need to change a whole lot of methods (all the callers, and the callers of the callers, and so on) when you change the exceptions one method throws.</p>
     <p>Checked exceptions in Java do not solve the latter problem; C# and VB.NET throw out the baby with the bathwater.</p>
     <p>A nice approach that takes the middle road is described in <a href="https://dl.acm.org/citation.cfm?id=1094847" rel="nofollow noreferrer">this OOPSLA 2005 paper</a> (or the <a href="http://www.cs.kuleuven.be/publicaties/rapporten/cw/CW407.pdf" rel="nofollow noreferrer">related technical report</a>.)</p>
     <p>In short, it allows you to say: <code>method g(x) throws like f(x)</code>, which means that g throws all the exceptions f throws. Voila, checked exceptions without the cascading changes problem.</p>
     <p>Although it is an academic paper, I'd encourage you to read (parts of) it, as it does a good job of explaining what the benefits and downsides of checked exceptions are.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_16"><span>Answer 16</span> <span class="arrow"> <a href="#answer_15">↑</a> </span> <span class="arrow"> <a href="#answer_17">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Piotr Sobczyk</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Oct 2011 at 22:01</span>
     </div>
    </div>
    <div>
     <h2>The problem</h2>
     <p>The worst problem I see with exception handling mechanism is that <strong>it introduces code duplication in a big scale</strong>! Let's be honest: In most of projects in 95% of the time all that developers really need to do with exception is to communicate it somehow to the user (and, in some cases, to the development team as well, e.g. by sending an e-mail with the stack trace). So usually the same line/block of code is used in every place the exception is handled.</p>
     <p>Let's assume that we do simple logging in each catch block for some type of checked exception:</p>
     <pre><code>try{
   methodDeclaringCheckedException();
}catch(CheckedException e){
   logger.error(e);
}
</code></pre>
     <p>If it's a common exception there may be even several hundreds of such try-catch blocks in a larger codebase. Now let's assume that we need to introduce popup dialog based exception handling instead of console logging or start to additionally send an e-mail to the development team.</p>
     <p>Wait a moment... are we really going to edit all of that several hundreds of locations in the code?! You get my point :-).</p>
     <h2>The solution</h2>
     <p>What we did to adress that issue was introducing the concept of <em>exception handlers</em> (to which I'll further refer as EH's) to <em>centralize</em> exception handling. To every class that needs to hande exceptions an instance of exception handler is injected by our <a href="http://en.wikipedia.org/wiki/Dependency_injection" rel="nofollow noreferrer">Dependency Injection</a> framework. So the typical pattern of exception handling now looks like this:</p>
     <pre><code>try{
    methodDeclaringCheckedException();
}catch(CheckedException e){
    exceptionHandler.handleError(e);
}
</code></pre>
     <p>Now to customize our exception handling we only need to change the code in a single place (EH code).</p>
     <p>Of course for more complex cases we can implement several subclasses of EHs and leverage features that our DI framework provides us. By changing our DI framework configuration we can easily switch EH implementation globally or provide specific implementations of EH to classes with special exception handling needs (for example using Guice @Named annotation).</p>
     <p>That way we can differentiate exception handling behaviour in development and release version of application (eg. development - logging the error and halting the application, prod - logging the error with more details and letting the application continue its execution) with no effort.</p>
     <h2>Last one thing</h2>
     <p>Last but not least, it may seem that the same kind of centralisation can be obtained by just passing our exceptions "up" until they arrive to some top level exception handling class. But that leads to cluttering of code and signatures of our methods and introduces maintenance problems mentioned by others in this thread.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>7</td>
        <td><span>Exceptions are invented to do something useful with them. Writing them into a log file or rendering a pretty window is not useful, because the original problem does not get solved by this. Doing something useful requires trying a different solution strategy. Examples: If I am not able to get my data from server A I try it on server B. Or if algorithm A produces a heap overflow I try algorithm B which is much slower but might succeed.</span> <span> - </span> <span class="display-name">ceving</span> <span> </span> <span class="date">12 Mar 2013 at 15:12</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>@ceving Yeah, it's all good and true in theory. But now let's get back to practice word. Please answer really honestly how often you do it in your real-word project? What part of <code>catch</code> blocks in this real project do something really "useful" with exceptins? 10% would be good. Usual problems that generate exceptions are like trying to read configuration from file that doesn't exist, OutOfMemoryErrors, NullPointerExceptions, database constraint integrity errors etc, etc. Are you really trying to gracefully recover from all of them? I don't believe you :). Often there is just no way to recover.</span> <span> - </span> <span class="display-name">Piotr Sobczyk</span> <span> </span> <span class="date">13 Mar 2013 at 18:51</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@PiotrSobczyk: If a program takes some action as a result of a suer request, and the operation fails in some fashion which hasn't damaged anything in the system state, notifying the user that the operation couldn't be completed is a perfectly useful way of handling the situation. The biggest failing of exceptions in C# and .net is that there's no consistent way to ascertain whether anything in the system state might have gotten damaged.</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">15 Mar 2013 at 19:58</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>Correct, @PiotrSobczyk. Most often, the only correct action to take in response to an exception is to rollback the transaction &amp; return an error response. Ideas of "solving exception" imply knowledge &amp; authority we don't (and shouldn't) have, and violate encapsulation. If our application is not a DB, we shouldn't try to <i>fix</i> the DB. Failing cleanly &amp; avoiding writing erroneous data, ceving, is <i>useful enough</i>.</span> <span> - </span> <span class="display-name">Thomas W</span> <span> </span> <span class="date">2 Jun 2014 at 02:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@PiotrSobczyk Yesterday, I dealt with a "could not read object" exception (which will only come about because the underlying database has been updated before the software - which should never happen but is a possibility due to human error) by failing over to a historical version of the database guaranteed to point to an old version of the object.</span> <span> - </span> <span class="display-name">Eponymous</span> <span> </span> <span class="date">10 Oct 2014 at 13:23</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_17"><span>Answer 17</span> <span class="arrow"> <a href="#answer_16">↑</a> </span> <span class="arrow"> <a href="#answer_18">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Piotr Sobczyk</span>
     </div>
     <div>
      <span> Answered: </span> <span>31 Dec 2011 at 09:48</span>
     </div>
    </div>
    <div>
     <p><a href="http://articles.vconst.com/2009/08/error-handling-and-exceptions-in-java.html" rel="noreferrer">This article</a> is the best piece of text on exception handling in Java I have ever read.</p>
     <p>It favours unchecked over checked exceptions but this choice is explained very thouroughly and based on strong arguments.</p>
     <p>I don't want to cite too much of the article content here (it's best to read it as a whole) but it covers most of arguments of unchecked exceptions advocates from this thread. Especially this argument (which seems to be quite popular) is covered:</p>
     <blockquote>
      <p>Take the case when the exception was thrown somewhere at the bottom of the API layers and just bubbled up because nobody knew it was even possible for this error to occur, this even though it was a type of error that was very plausible when the calling code threw it (FileNotFoundException for example as opposed to VogonsTrashingEarthExcept... in which case it would not matter if we handle it or not since there is nothing left to handle it with).</p>
     </blockquote>
     <p>The author "responses":</p>
     <blockquote>
      <p>It is absolutely incorrect to assume that all runtime exceptions should not be caught and allowed to propagate to the very "top" of the application. (...) For every exceptional condition that is required to be handled distinctly - by the system/business requirements - programmers must decide where to catch it and what to do once the condition is caught. This must be done strictly according to the actual needs of the application, not based on a compiler alert. All other errors must be allowed to freely propagate to the topmost handler where they would be logged and a graceful (perhaps, termination) action will be taken.</p>
     </blockquote>
     <p>And the main thought or article is:</p>
     <blockquote>
      <p>When it comes to error handling in software, the only safe and correct assumption that may ever be made is that a failure may occur in absolutely every subroutine or module that exists!</p>
     </blockquote>
     <p>So if "<em>nobody knew it was even possible for this error to occur</em>" there is something wrong with that project. Such exception should be handled by at least the most generic exception handler (e.g. the one that handles all Exceptions not handled by more specific handlers) as author suggests.</p>
     <p>So sad not many poeple seems to discover this great article :-(. I recommend wholeheartly everyone who hesitates which approach is better to take some time and read it.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_18"><span>Answer 18</span> <span class="arrow"> <a href="#answer_17">↑</a> </span> <span class="arrow"> <a href="#answer_19">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Vlasec</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Oct 2017 at 14:39</span>
     </div>
    </div>
    <div>
     <p>One important thing nobody mentioned is how it interferes with interfaces and lambda expressions.</p>
     <p>Let's say you define a <code>MyAppException extends Exception</code>. It is the top level exception inherited by all exceptions thrown by your application. In some places you don't want to react to the particular exceptions, you want the caller to resolve it, so you declare <code>throws MyAppException</code>.</p>
     <p>All looks OK until you want to use someone else's interface. Obviously they don't declare intention to throw <code>MyAppException</code>, so compiler doesn't allow you to even call your methods that declare <code>throws MyAppException</code> in there. This is especially painful with <code>java.util.function</code>.</p>
     <p>However, if your exception extends <code>RuntimeException</code>, there will be no problem with interfaces. You can mention the exception in JavaDoc if you wish. But other than that it just silently bubbless through anything. Of course that means it can terminate your application. But in lots of enterprise software you have exception handling layer and unchecked exceptions save lots of trouble.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>But this is exactly the point of the checked exceptions. If the interface does not specify checked exceptions, then the user of this interface may be sure, that no exceptions will be thrown. This basically means, that the implementation of the operation is not allowed to fail. And if your implementation cannot guarantee it, then you should not implement it. Or you should consider carefully, what to do with a failure because interface does not allow you to report it explicitly to the caller.</span> <span> - </span> <span class="display-name">Dmitrii Semikin</span> <span> </span> <span class="date">25 Nov 2020 at 16:46</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@DmitriiSemikin The point is, there is some interesting syntax sugar coming in Java 8, with <code>Predicate</code>s, <code>Function</code>s etc. that gets cumbersome to use if there are checked exceptions. One would prefer to handle the exception outside the lambda, but the way checked exceptions are made doesn't allow for that. If <code>Predicate</code> threw <code>Exception</code> in its <code>test</code> method, then it would work with any checked exception, but it would always need to be nested in a try/catch-all, even if the lambda throws no exception at all, which would be worse than what we have currently.</span> <span> - </span> <span class="display-name">Vlasec</span> <span> </span> <span class="date">8 May 2021 at 11:58</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>If the lambdas were an integral part of the language from the start rather than some kind of syntax sugar over anonymous classes, maybe they would have some special interfaces where the checked exceptions thrown inside them would be automatically added to their <code>throws</code> declaration, and the obligation to declare or catch the checked exception would be transitioned to the class that uses the lambda. But since it is not the case, libraries generally prefer unchecked exceptions even for situations where checked exceptions would otherwise be a better idea, to protect the syntax sugar.</span> <span> - </span> <span class="display-name">Vlasec</span> <span> </span> <span class="date">8 May 2021 at 12:27</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>I would say, I agree, that lambdas and checked exceptions do not play nicely together. But probably it is also for reason. I find that having Lambdas throwing exceptions (either checked or unchecked) is not a good idea in general. Because you never know, where this lambda will be used (and consequently, where you need to catch the exception... it can be even other thread). So in case of Lambdas I personally would just give up on using exceptions(if it were possible)and would use other ways of reporting errors. The fact, that checked exceptions do not work well with lambdas just highlights it.</span> <span> - </span> <span class="display-name">Dmitrii Semikin</span> <span> </span> <span class="date">10 May 2021 at 14:51</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I agree that checked exceptions are not a good idea in functional interfaces, in general. However, if you want to go for a different approach to reporting errors, then perhaps you should try Scala instead. In Java 8, if you are a bit pragmatic, you just throw an unchecked exception and catch it where appropriate. Otherwise you'll probably end up with much more boilerplate than you'd end up in Scala with its great pattern matching. I know newer Java has some pattern matching as well, but if it's as comfortable to use as Java 8 Optional, then I'd rather stay away from that.</span> <span> - </span> <span class="display-name">Vlasec</span> <span> </span> <span class="date">24 May 2021 at 13:34</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>The problem is with API's accepting only lambda's that throw no checked exceptions. The Stream API is the biggest culprit. It is however perfectly possible to write the Stream API in such a way that checked exceptions are possible, albeit a bit cumbersome because of lack of language support. See here: <a href="https://github.com/hjohn/MediaSystem-v2/blob/master/mediasystem-util/src/test/java/hs/mediasystem/util/checked/FlowTest.java" rel="nofollow noreferrer">github.com/hjohn/MediaSystem-v2/blob/master/mediasystem-util‌​/…</a></span> <span> - </span> <span class="display-name">john16384</span> <span> </span> <span class="date">30 Oct 2021 at 09:51</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The example is nice. With a bit of factory method support, there could be methods that create <code>Flow</code> with <code>0..N</code> thrown exception types, where <code>N &gt; 2</code> wouldn't hurt as much. While I don't know of any way to completely avoid throws clause once it is parametrized this way, you could just add an unchecked exception called e.g. NoException and use it when no checked exceptions are provided.</span> <span> - </span> <span class="display-name">Vlasec</span> <span> </span> <span class="date">14 Nov 2021 at 00:01</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>As for language support, I wouldn't expect that. Functional languages tend to add the error state to the response itself, e.g. if you were writing your own implementation of integer arithmetic in Scala, you would use <code>def / (a: Int, b: Int): Either[ArithmeticError, Int]</code> as the output of division, and return <code>Right(3)</code> as a result of <code>10 / 3</code>, and <code>Left(ArithmeticError(...))</code> when someone tries <code>5 / 0</code>. Checked exceptions would be superficial there.</span> <span> - </span> <span class="display-name">Vlasec</span> <span> </span> <span class="date">14 Nov 2021 at 00:20</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_19"><span>Answer 19</span> <span class="arrow"> <a href="#answer_18">↑</a> </span> <span class="arrow"> <a href="#answer_20">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Martin</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 May 2009 at 20:15</span>
     </div>
    </div>
    <div>
     <p>As folks have already stated, checked exceptions don't exist in Java bytecode. They are simply a compiler mechanism, not unlike other syntax checks. I see checked exceptions a lot like I see the compiler complaining about a redundant conditional: <code>if(true) { a; } b;</code>. That's helpful but I might have done this on purpose, so let me ignore your warnings.</p>
     <p>The fact of the matter is, you aren't going to be able to force every programmer to "do the right thing" if you enforce checked exceptions and everyone else is now collateral damage who just hates you for the rule you made.</p>
     <p>Fix the bad programs out there! Don't try to fix the language to not allow them! For most folks, "doing something about an exception" is really just telling the user about it. I can tell the user about an unchecked exception just as well, so keep your checked exception classes out of my API.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Right, I just wanted to emphasize the difference between unreachable code (that generates an error) and conditionals with a predictable outcome. I’ll remove this comment later.</span> <span> - </span> <span class="display-name">Holger</span> <span> </span> <span class="date">29 Jan 2018 at 08:14</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_20"><span>Answer 20</span> <span class="arrow"> <a href="#answer_19">↑</a> </span> <span class="arrow"> <a href="#answer_21">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Dave Elton</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Jul 2012 at 13:21</span>
     </div>
    </div>
    <div>
     <p>To attempt to address just the unanswered question:</p>
     <blockquote>
      <p>If you throw RuntimeException subclasses instead of Exception subclasses then how do you know what you are supposed to catch?</p>
     </blockquote>
     <p>The question contains specious reasoning IMHO. Just because the API tells you what it throws doesn't mean you deal with it in the same way in all cases. To put it another way, the exceptions you need to catch vary depending on the context in which you use the component throwing the exception.</p>
     <p>For example:</p>
     <p>If I'm writing a connection tester for a database, or something to check the validity of a user entered XPath, then I'd probably want to catch and report on all checked and unchecked exceptions that are thrown by the operation.</p>
     <p>If, however, I am writing a processing engine, I will likely treat an XPathException (checked) in the same way as an NPE: I would let it run up to the top of the worker thread, skip the rest of that batch, log the issue (or send it to a support department for diagnosis) and leave feedback for the user to contact support.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span>Exactly. Easy and straightforward, the way exception-handling be. As Dave says, correct exception-handling is normally done at a <i>high level</i>. "Throw early, catch late" is the principle. Checked exceptions make that difficult.</span> <span> - </span> <span class="display-name">Thomas W</span> <span> </span> <span class="date">2 Jun 2014 at 03:05</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_21"><span>Answer 21</span> <span class="arrow"> <a href="#answer_20">↑</a> </span> <span class="arrow"> <a href="#answer_22">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Chuck Conway</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Mar 2009 at 10:02</span>
     </div>
    </div>
    <div>
     <p>Anders speaks about the pitfalls of checked exceptions and why he left them out of C# in <a href="http://www.se-radio.net/podcast/2008-05/episode-97-interview-anders-hejlsberg" rel="nofollow noreferrer">episode 97</a> of Software Engineering radio.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_22"><span>Answer 22</span> <span class="arrow"> <a href="#answer_21">↑</a> </span> <span class="arrow"> <a href="#answer_23">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Joshua</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Nov 2009 at 20:34</span>
     </div>
    </div>
    <div>
     <p>My writeup on c2.com is still mostly unchanged from its original form: <a href="http://c2.com/cgi/wiki?CheckedExceptionsAreIncompatibleWithVisitorPattern" rel="nofollow noreferrer">CheckedExceptionsAreIncompatibleWithVisitorPattern</a></p>
     <p>In summary:</p>
     <p>Visitor Pattern and its relatives are a class of interfaces where the indirect caller and interface implementation both know about an exception but the interface and direct caller form a library that cannot know.</p>
     <p>The fundamental assumption of CheckedExceptions is all declared exceptions can be thrown from any point that calls a method with that declaration. The VisitorPattern reveals this assumption to be faulty.</p>
     <p>The final result of checked exceptions in cases like these is a lot of otherwise useless code that essentially removes the compiler's checked exception constraint at runtime.</p>
     <p>As for the underlying problem:</p>
     <p>My general idea is the top-level handler needs to interpret the exception and display an appropriate error message. I almost always see either IO exceptions, communication exceptions (for some reason APIs distinguish), or task-fatal errors (program bugs or severe problem on backing server), so this should not be too hard if we allow a stack trace for a severe server problem.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>You should have something like DAGNodeException in the interface, then catch the IOException and convert it to a DAGNodeException: public void call(DAGNode arg) throws DAGNodeException;</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">7 Nov 2009 at 20:46</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@TofuBeer, that 's exactly my point. I find that constantly wrapping and unwrapping exceptions is worse than removing checked exceptions.</span> <span> - </span> <span class="display-name">Joshua</span> <span> </span> <span class="date">7 Nov 2009 at 22:48</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Well we disagree completely then... but your article still does not answer the real underlying question of how you stop your application from displaying a stack trace to the user when a runtime exception is thrown.</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">8 Nov 2009 at 01:54</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@TofuBeer -- When it fails, telling the user it failed is correct! What's your alternative, other than to "paper over" the failure with 'null' or incomplete/incorrect data? Pretending it succeeded is a lie, that just makes things worse. With 25 years experience in high-reliability systems, retry logic should only be used carefully &amp; where appropriate. I would also expect a Visitor to likely fail again, no matter how many times you retry it. Unless you're flying a plane, swapping to a second version of the same algorithm is impractical &amp; implausible (and may fail anyway).</span> <span> - </span> <span class="display-name">Thomas W</span> <span> </span> <span class="date">2 Jun 2014 at 03:01</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_23"><span>Answer 23</span> <span class="arrow"> <a href="#answer_22">↑</a> </span> <span class="arrow"> <a href="#answer_24">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Thomas W</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Jun 2014 at 03:34</span>
     </div>
    </div>
    <div>
     <p>Checked exceptions were, in their original form, an attempt to handle contingencies rather than failures. The laudable goal was to highlight specific predictable points (unable to connect, file not found, etc) &amp; ensure developers handled these.</p>
     <p>What was never included in the original concept, was to force a vast range of systemic &amp; unrecoverable failures to be declared. These failures were never correct to be declared as checked exceptions.</p>
     <p>Failures are generally possible in code, and EJB, web &amp; Swing/AWT containers already cater for this by providing an outermost “failed request” exception-handler. The most basic correct strategy is to rollback the transaction &amp; return an error.</p>
     <p>One crucial point, is that <strong>runtime &amp; checked exceptions are functionally equivalent.</strong> There is no handling or recovery which checked exceptions can do, that runtime exceptions can’t.</p>
     <p>The biggest argument against “checked” exceptions is that most exceptions can’t be fixed. The simple fact is, we don’t own the code/ subsystem that broke. We can’t see the implementation, we’re not responsible for it, and can’t fix it.</p>
     <p>If our application is not a DB.. we shouldn't try and fix the DB. That would violate the <em>principle of encapsulation</em>.</p>
     <p>Particularly problematic have been the areas of JDBC (SQLException) and RMI for EJB (RemoteException). Rather than identifying fixable contingencies as per the original “checked exception” concept, these forced pervasive systemic reliability issues, not actually fixable, to be widely declared.</p>
     <p>The other severe flaw in the Java design, was that exception-handling should correctly placed at the highest possible "business" or "request" level. The principle here is "throw early, catch late". Checked exceptions do little but get in the way of this.</p>
     <p>We have an obvious issue in Java of requiring thousands of do-nothing try-catch blocks, with a significant proportion (40%+) being miscoded. Almost none of these implement any genuine handling or reliability, but impose major coding overhead.</p>
     <p>Lastly, "checked exceptions" are pretty much incompatible with FP functional programming.</p>
     <p>Their insistence on "handle immediately" is at odds with both "catch late" exception-handling best practice, and any FP structure which abstracts loops/ or flow of control.</p>
     <p>Many people talk about "handling" checked exceptions, but are talking through their hats. Continuing after a failure with null, incomplete or incorrect data to <em>pretend</em> success is not handling anything. It's engineering/ reliability malpractice of the lowest form.</p>
     <p>Failing cleanly, is the most basic correct strategy for handling an exception. Rolling back the transaction, logging the error &amp; reporting a "failure" response to the user are sound practice -- and most importantly, prevent incorrect business data being committed to the database.</p>
     <p>Other strategies for exception-handling are "retry", "reconnect" or "skip", at the business, subsystem, or request level. All of these are general reliability strategies, and work well/ better with runtime exceptions.</p>
     <p>Lastly, it is far preferable to fail, than to run with incorrect data. Continuing will either cause secondary errors, distant from the original cause &amp; harder to debug; or will eventually result in erroneous data being committed. People get fired for that.</p>
     <p>See:<br>
       - <a href="http://literatejava.com/exceptions/checked-exceptions-javas-biggest-mistake/" rel="nofollow">http://literatejava.com/exceptions/checked-exceptions-javas-biggest-mistake/</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>That was a nice answer, but it doesn't address the core of my question: How do you know to catch an exception and roll back? Or are you simply saying people should catch RuntimeException at the top level of everything to ensure code doesn't crash?</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">29 Jun 2014 at 16:49</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@TofuBeer Your request (web) or event/action (GUI) handler essentially processes business operations, and always has a possibility of internal/infrastructure failure. Failures should be handled at the business level by rolling back -- as you say, with a comprehensible error message. Such 'reliability handler' catch clauses should generally catch 'Exception' to catch any runtime/or checked exceptions. Modality/type of failure is largely irrelevant to handling, except in the rare cases where a specific known contingency occurs &amp; logic exists to recover from it.</span> <span> - </span> <span class="display-name">Thomas W</span> <span> </span> <span class="date">30 Jun 2014 at 02:24</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>You should not catch Exception that leads to particularly horrendous code that can hide legitimate failures (such as ArrayIndexOutOfBounds) where the code things it is something else. In essense you can easily hide bugs by doing what you are suggesting.</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">30 Jun 2014 at 08:11</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>My point is to <i>fail properly</i> as the general strategy. Unchecked exceptions help that as they do not force catch blocks to be interposed. Catching &amp; error-logging can then be left to a few outermost handlers, rather than miscoded thousands of times throughout the codebase <i>(which is actually what hides bugs)</i>. For arbitrary failures, unchecked exceptions are absolutely most correct. <i>Contingencies</i> -- predictable outcomes such as insufficient funds -- are the only exceptions legitimately are worth making checked.</span> <span> - </span> <span class="display-name">Thomas W</span> <span> </span> <span class="date">11 Jun 2015 at 23:56</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Thomas W, that still doesn't address the issue of how the outer layer knows what to catch though, which is the fundamental issue.That still doesn't address the issue of how the outer layer knows what to catch though, which is the fundamental issue.</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">14 Jun 2015 at 01:26</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span><b>My answer already above addresses this.</b> First and foremost, <i>1) Outermost failure handler should catch everything.</i> Beyond that, for specific identified sites only, <i>2) Specific expected contingencies can be caught and handled -- at the immediate site they are thrown.</i> That means file not found, insufficient funds etc at the point these could be recovered from -- no higher. Principle of encapsulation means that outer layers cannot/ should not be responsible to understand/ recover from failures deep inside. Third, <i>3) Everything else should be thrown outwards -- unchecked if possible.</i></span> <span> - </span> <span class="display-name">Thomas W</span> <span> </span> <span class="date">15 Jun 2015 at 01:27</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span><b>Outermost handler catches Exception,</b> logs it, and returns a "failed" response or shows an error dialog. Very simple, not hard to define at all. The point is that every exception not immediately &amp; locally recoverable, is an <i>unrecoverable failure</i> due to principle of encapsulation. If the code that's meant to know about can't recover it, then the request overall fails cleanly &amp; properly. This is the right way to do it properly.</span> <span> - </span> <span class="display-name">Thomas W</span> <span> </span> <span class="date">15 Jun 2015 at 01:34</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>very simple and very dangerous - you wind up catching things that are genuine bugs that way. Exception catches RuntimeException and RuntimeException indicates a programmer error.</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">17 Jun 2015 at 06:00</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span><b>Incorrect.</b> Outermost handler's job is to <i>fail cleanly &amp; log errors</i> on the 'request' boundary. Broken request fails properly, exception is reported, thread is able to continue to service next request. Such an outermost handler is a standard feature in Tomcat, AWT, Spring, EJB containers &amp; the Java 'main' thread.</span> <span> - </span> <span class="display-name">Thomas W</span> <span> </span> <span class="date">17 Jun 2015 at 23:23</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>How am I wrong? Exception catches RuntimeException. The purpose of RuntimeException is to indicate programmer errors.</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">19 Jun 2015 at 04:09</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Why is it dangerous to report "genuine bugs" at the request boundary or outermost handler??? I frequently work in systems integration &amp; reliability, where correct reliability engineering is actually important, and use "unchecked exception" approaches to do so. I'm not really sure what you're actually debating -- seems like you might want to actually spend 3 months in the unchecked exception way, get a feel for it, and then perhaps we can discuss further. Thanks.</span> <span> - </span> <span class="display-name">Thomas W</span> <span> </span> <span class="date">25 Jun 2015 at 04:23</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>An ArrayIndexOutOfBounds exception is an example of something that should not be caught. In terms of System integration and dealing with unknown 3rd party code then, yes, you do have to deal with unforeseen thing, but this question is about throwing them not catching them.</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">25 Jun 2015 at 18:01</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@TofuBeer I for sure want to catch all exceptions including AIOOBE <i>somewhere</i>. It's a programming error and must be reported to be fixed, but there absolutely no reason to ignore it completely. There's no danger in catching <code>RuntimeException</code>; on the opposite: It must be done somewhere in order to present 500 to the user and an error report to the developers. So there's an outer block like <code>try {...} catch (RuntimeException e) {...} catch (Exception e) {...} </code> in my code (and surely also in Spring and other frameworks).</span> <span> - </span> <span class="display-name">maaartinus</span> <span> </span> <span class="date">2 Dec 2017 at 15:48</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_24"><span>Answer 24</span> <span class="arrow"> <a href="#answer_23">↑</a> </span> <span class="arrow"> <a href="#answer_25">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>oxbow_lakes</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Mar 2009 at 10:00</span>
     </div>
    </div>
    <div>
     <p>I think that this is an excellent question and not at all argumentative. I think that 3rd party libraries should (in general) throw <em>unchecked</em> exceptions. This means that you can isolate your dependencies on the library (i.e. you don't have to either re-throw their exceptions or throw <code>Exception</code> - usually bad practice). Spring's <a href="http://static.springframework.org/spring/docs/2.0.x/reference/jdbc.html" rel="nofollow noreferrer">DAO layer</a> is an excellent example of this.</p>
     <p>On the other hand, exceptions from the core Java API should in general be checked if they could <strong>ever</strong> be handled. Take <code>FileNotFoundException</code> or (my favourite) <code>InterruptedException</code>. These conditions should <em>almost always</em> be handled specifically (i.e. your reaction to an <code>InterruptedException</code> is not the same as your reaction to an <code>IllegalArgumentException</code>). The fact that your exceptions are checked forces developers to think about whether a condition is handle-able or not. (That said, I've rarely seen <code>InterruptedException</code> handled properly!)</p>
     <p>One more thing - a <code>RuntimeException</code> is not always "where a developer got something wrong". An illegal argument exception is thrown when you try and create an <code>enum</code> using <code>valueOf</code> and there's no <code>enum</code> of that name. This is not necessarily a mistake by the developer!</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>Yes, it is a mistake by the developer. They clearly didn't use the right name, so they have to go back and fix their code.</span> <span> - </span> <span class="display-name">AxiomaticNexus</span> <span> </span> <span class="date">25 Jun 2014 at 21:41</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@AxiomaticNexus No sane developer uses <code>enum</code> member names, simply because they use <code>enum</code> objects instead. So a wrong name only can come from the outside, be it an import file or whatever. One possible way to dealing with such names is calling <code>MyEnum#valueOf</code> and catching the IAE. Another way is to use a pre-filled <code>Map&lt;String, MyEnum&gt;</code>, but these are implementation details.</span> <span> - </span> <span class="display-name">maaartinus</span> <span> </span> <span class="date">2 Dec 2017 at 15:54</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@maaartinus There are cases where enum member names are used without the string coming from outside. For example, when you want to loop through all the members dynamically to do something with each. Furthermore, whether the string comes from outside or not is irrelevant. The developer has all the information they need, to know whether passing x string to "MyEnum#valueOf" will result in an error before passing it. Passing x string to "MyEnum#valueOf" anyway when it would have caused error, would clearly be a mistake on the developer's part.</span> <span> - </span> <span class="display-name">AxiomaticNexus</span> <span> </span> <span class="date">4 Dec 2017 at 18:52</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_25"><span>Answer 25</span> <span class="arrow"> <a href="#answer_24">↑</a> </span> <span class="arrow"> <a href="#answer_26">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Powerlord</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Mar 2009 at 17:14</span>
     </div>
    </div>
    <div>
     <p>A problem with checked exceptions is that exceptions are often attached to methods of an interface if even one implementation of that interface uses it.</p>
     <p>Another problem with checked exceptions is that they tend to be misused. The perfect example of this is in <a href="http://java.sun.com/javase/6/docs/api/java/sql/Connection.html" rel="nofollow noreferrer"><code>java.sql.Connection</code></a>'s <a href="http://java.sun.com/javase/6/docs/api/java/sql/Connection.html#close()" rel="nofollow noreferrer"><code>close()</code></a> method. It can throw a <a href="http://java.sun.com/javase/6/docs/api/java/sql/SQLException.html" rel="nofollow noreferrer"><code>SQLException</code></a>, even though you've already <strong>explicitly stated</strong> that you're done with the Connection. What information could close() possibly convey that you'd care about?</p>
     <p>Usually, when I close() a connection<code>*</code>, it looks something like this:</p>
     <pre><code>try {
    conn.close();
} catch (SQLException ex) {
    // Do nothing
}
</code></pre>
     <p>Also, don't get me started on the various parse methods and NumberFormatException... .NET's TryParse, which doesn't throw exceptions, is so much easier to use it's painful to have to go back to Java (we use both Java and C# where I work).</p>
     <p><code>*</code>As an additional comment, a PooledConnection's Connection.close() doesn't even <em>close</em> a connection, but you still have to catch the SQLException due to it being a checked exception.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>Right, any of the drivers can... the question is rather "why should the programmer care?" as he's done accessing the database anyway. The docs even warn you that you should always commit() or rollback() the current transaction before calling close().</span> <span> - </span> <span class="display-name">Powerlord</span> <span> </span> <span class="date">5 Mar 2009 at 17:52</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Many people think that close on a file cannot throw an exception... <a href="http://stackoverflow.com/questions/588546/does-close-ever-throw-an-ioexception" title="does close ever throw an ioexception">stackoverflow.com/questions/588546/…</a> are you 100% certain that there are no cases that it would matter?</span> <span> - </span> <span class="display-name">TofuBeer</span> <span> </span> <span class="date">5 Mar 2009 at 21:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I'm 100% certain that there are no cases that it <i>would</i> matter and that the caller <i>wouldn't</i> put in a try/catch.</span> <span> - </span> <span class="display-name">Martin</span> <span> </span> <span class="date">17 May 2009 at 20:06</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Excellent example with closing connections, Martin! I can only rephrase you: If we just explicitly stated that we're done with a connection why should be bother what's going on when we're closig it. There more cases like this that programmer doesn't really care if exception occurs and he is absolutely right about it.</span> <span> - </span> <span class="display-name">Piotr Sobczyk</span> <span> </span> <span class="date">29 Oct 2011 at 09:33</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@PiotrSobczyk: Some SQL drivers will squawk if one closes a connection after starting a transaction but neither confirming it nor rolling it back. IMHO, squawking is better than silently ignoring the problem, at least in cases where squawking won't cause other exceptions to get lost.</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">14 Mar 2014 at 00:21</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_26"><span>Answer 26</span> <span class="arrow"> <a href="#answer_25">↑</a> </span> <span class="arrow"> <a href="#answer_27">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Aleksandr Dubinsky</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Jul 2015 at 02:03</span>
     </div>
    </div>
    <div>
     <p>The programmer needs to know <strong>all</strong> of the exceptions that a method may throw, in order to use it correctly. So, beating him over the head with just some of the exceptions does not necessarily help a careless programmer avoid errors.</p>
     <p>The slim benefit is outweighed by the burdensome cost (especially in larger, less flexible code bases where constantly modifying the interface signatures is not practical).</p>
     <p>Static analysis can be nice, but truly reliable static analysis often inflexibly demands strict work from the programmer. There is a cost-benefit calculation, and the bar needs to be set high for a check that leads to a compile time error. It would be more helpful if the IDE took on the role of communicating which exceptions a method may throw (including which are unavoidable). Although perhaps it would not be as reliable without forced exception declarations, most exceptions would still be declared in documentation, and the reliability of an IDE warning is not so crucial.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_27"><span>Answer 27</span> <span class="arrow"> <a href="#answer_26">↑</a> </span> <span class="arrow"> <a href="#answer_28">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>ses</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 May 2013 at 15:16</span>
     </div>
    </div>
    <div>
     <p>The good proves that Checked Exception are not needed are:</p>
     <ol>
      <li>A lot of framework that does some work for Java. Like Spring that wraps JDBC exception to unchecked exceptions, throwing messages to the log</li>
      <li>Lot of languages that came after java, even on top on java platform - they do not use them</li>
      <li>Checked exceptions, it is kind prediction about how the client would use the code that throws an exception. But a developer who writes this code would never know about the system and business that client of code is working in. As an example Interfcace methods that force to throw checked exception. There are 100 implementation over the system, 50 or even 90 of implementations do not throw this exception, but the client still must to catch this exception if he user reference to that interface. Those 50 or 90 implementations tend to handle those exceptions inside themself, putting exception to the log (and this is good behavior for them). What we should do with that? I would better have some background logic that would do all that job - sending message to the log. And If I, as a client of code, would feel I need handle the exception - I will do it. I may forget about it, right - but if I use TDD, all my steps are covered and I know what I want.</li>
      <li>Another example when I'm working with I/O in java, it forces me to check all exception, if file does not exists? what I should do with that? If it does not exists, the system would not go to the next step. The client of this method, would not get expected content from that file - he can handle Runtime Exception, otherwise I should first check Checked Exception, put a message to log, then throw exception up out form the method. No...no - I would better do it automatically with RuntimeEception, that does it / lits up automatically. There is no any sense to handle it manually - I would be happy I saw an error message in the log (AOP can help with that.. something that fixes java). If, eventually, I deice that system should shows pop-up message to the end user - I will show it, not a problem.</li>
     </ol>
     <p>I was happy if java would provide me with a <strong>choice</strong> what to use, when working with core libs, like I/O. Like provides two copies of same classes - one wrapped with RuntimeEception. <strong>Then we can compare what people would use</strong>. For now, though, many people would better go for some framework on top on java, or different language. Like Scala, JRuby whatever. Many just believe that SUN was right.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>Rather than having two versions of classes, there should be a concise way of specifying none of the method calls made by a block of code are not expected to throw exceptions of certain types, and that any such exceptions should be wrapped via some specified means and rethrown (by default, create a new <code>RuntimeException</code> with an appropriate inner exception). It is unfortunate that it's more concise to have the outer method <code>throws</code> an exception from the inner method, than to have it wrap exceptions from the inner method, when the latter course of action would more often be correct.</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">13 May 2013 at 19:03</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_28"><span>Answer 28</span> <span class="arrow"> <a href="#answer_27">↑</a> </span> <span class="arrow"> <a href="#answer_29">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Zrom</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Jul 2022 at 14:01</span>
     </div>
    </div>
    <div>
     <p><strong>Robert C. Martin</strong> also does not recommend using checked exception in his book <strong>Clean Code</strong> and considers that checked exception is an <strong>Open-Closed Principle</strong> violation:</p>
     <blockquote>
      <p>What price? The price of checked exceptions is an Open/Closed Principle1 violation. If you throw a checked exception from a method in your code and the catch is three levels above, you must declare that exception in the signature of each method between you and the catch. This means that a change at a low level of the software can force signature changes on many higher levels. The changed modules must be rebuilt and redeployed, even though nothing they care about changed.</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_29"><span>Answer 29</span> <span class="arrow"> <a href="#answer_28">↑</a> </span> <span class="arrow"> <a href="#answer_30">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mister Smith</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Aug 2011 at 06:52</span>
     </div>
    </div>
    <div>
     <p>Despite having read the whole page, I still can't find a single reasonable argument against checked exceptions. Most people are instead talking about poor API design, either at some Java classes or at their own classes.</p>
     <p>The only scenario where this feature may be annoying is prototiping. This could be solved by adding some mechanism to the language (for instance, some @supresscheckedexceptions annotation). But for regular programming, I think checked exceptions are a good thing.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>Best-practice "throw early, catch late" is incompatible with checked exception's insistence that they be handled <i>immediately</i>. It also prevents FP functional programming approaches. See: <a href="http://literatejava.com/exceptions/checked-exceptions-javas-biggest-mistake/" rel="nofollow noreferrer">literatejava.com/exceptions/…</a></span> <span> - </span> <span class="display-name">Thomas W</span> <span> </span> <span class="date">2 Jun 2014 at 03:02</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>There's no insistence on being handled immediately, only on being handled. You can declare that your method throws some exceptions and catch them as late as you want. And you can throw as early as you want as well.</span> <span> - </span> <span class="display-name">Mister Smith</span> <span> </span> <span class="date">2 Jun 2014 at 15:15</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>Exponential expansion through the call tree is effectively an insistence on being handled immediately. This could have been could worthwhile if applied solely to <i>contingencies</i>, which are predictable &amp; potentially recoverable, but 'checked' behavior was erroneously widened to a broad range of unpredictable &amp; unrecoverable <i>failures</i>. 'File open' or 'connect JDBC' are reasonable to require checked -- most other IOException, SQLException, RemoteException not so. This was a major error in Java library design. See my answer &amp; a basic primer on exception-handling.</span> <span> - </span> <span class="display-name">Thomas W</span> <span> </span> <span class="date">2 Jun 2014 at 21:59</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@ThomasW I've read your link and your answer, and I still I disagree. Checked exceptions are not bad in general, although I agree in that some particular exceptions in the API should have been made unchecked.</span> <span> - </span> <span class="display-name">Mister Smith</span> <span> </span> <span class="date">3 Jun 2014 at 15:31</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@ThomasW And the principle of "throw early, catch late" is highly debatable. The throw early part is ok, but you can't default to catching late always. It depends. For instance, if I'm coding a class that interfaces with a WS, I might run into, lest say, <code>IOException</code>, <code>ParsingException</code>, <code>RemoteException</code>, <code>PermissionException</code> and so on. Here we can catch early to handle them in this layer and either return null/false/-1/whatever or envelope them in a custom WSException (of course checked, otherwise client classes might forget to handle them).</span> <span> - </span> <span class="display-name">Mister Smith</span> <span> </span> <span class="date">3 Jun 2014 at 15:32</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>"Catch late" is based on the level at which failure can be isolated -- most times, those are the business/ request or outbound connection/ request level. Simple &amp; correct.</span> <span> - </span> <span class="display-name">Thomas W</span> <span> </span> <span class="date">4 Jun 2014 at 02:23</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Returning null/false/-1 is <b>incorrect practice</b> as it mis-represents success to your client! This is a strict no-no, as it enables execution to continue with incomplete/invalid/incorrect data to either fail later (bad) or commit to the DB (worse). If parts of the business logic are <b>genuinely optional</b>, which you haven't stated, then a try/catch allow those to continue with a warning. Non-valid values and spreading bad data around the application are neither good nor necessary.</span> <span> - </span> <span class="display-name">Thomas W</span> <span> </span> <span class="date">4 Jun 2014 at 02:32</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>Best-practice exception handling is based on <i>actually</i> how exceptions/errors can best be correctly handled (logging, reporting, sometimes recovered). This a science, not an art.. Getting it 100% optimal &amp; correct is actually simple &amp; easy -- so long as we are not pushed (by mistaken library design) to "handle early". As we can see, that mainly just encourages mistaken practice.</span> <span> - </span> <span class="display-name">Thomas W</span> <span> </span> <span class="date">4 Jun 2014 at 02:36</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@MisterSmith You can't ever forget to handle a <code>WSException</code> or any other if you <code>catch (Exception e)</code> on some close-to-top level. You may or may not want some special handling, but the basic principle is to handle everything. For special handling you can use <code>try {...} catch (WSException) {...} catch (Exception e) {...}</code>, but it's only needed if you can do something special about it (you may want to retry it, but that holds for <code>TransactionLockTimeExceeded</code>, too).</span> <span> - </span> <span class="display-name">maaartinus</span> <span> </span> <span class="date">2 Dec 2017 at 16:05</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_30"><span>Answer 30</span> <span class="arrow"> <a href="#answer_29">↑</a> </span> <span class="arrow"> <a href="#answer_31">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Jacob Toronto</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Aug 2012 at 16:54</span>
     </div>
    </div>
    <div>
     <p>We've seen some references to C#'s chief architect.</p>
     <p>Here's an alternate point of view from a Java guy about when to use checked exceptions. He acknowledges many of the negatives others have mentioned: <a href="http://www.oracle.com/technetwork/articles/entarch/effective-exceptions2-097044.html" rel="nofollow">Effective Exceptions</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>The problem with checked exceptions in Java stems from a deeper problem, which is that way too much information is encapsulated in the TYPE of the exception, rather than in properties of an instance. It would be useful to have checked exceptions, if being "checked" was an attribute of throw/catch sites, and if one could declaratively specify whether a checked exception which escapes a block of code should be remain as a checked exception, or be seen by any enclosing block as an unchecked exception; likewise catch blocks should be able to specify that they only want checked exceptions.</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">2 Aug 2012 at 18:33</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Suppose a dictionary-lookup routine is specified to throw some particular type of exception if an attempt is made to access a non-existent key. It may be reasonable for client code to catch such an exception. If, however, some method used by the lookup routine happens to throw that same type of exception in a manner the lookup routine doesn't expect, the client code probably shouldn't catch it. Having checked-ness be a property of exception <i>instances</i>, throw sites, and catch sites, would avoid such issues. The client would catch 'checked' exceptions of that type, dodging unexpected ones.</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">2 Aug 2012 at 18:38</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_31"><span>Answer 31</span> <span class="arrow"> <a href="#answer_30">↑</a> </span> <span class="arrow"> <a href="#answer_32">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>finnw</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Mar 2009 at 09:12</span>
     </div>
    </div>
    <div>
     <p><a href="http://www.joelonsoftware.com/items/2003/10/13.html" rel="nofollow noreferrer">Here</a>'s one argument against checked exceptions (from joelonsoftware.com):</p>
     <blockquote>
      <p>The reasoning is that I consider exceptions to be no better than "goto's", considered harmful since the 1960s, in that they create an abrupt jump from one point of code to another. In fact they are significantly worse than goto's:</p>
      <ul>
       <li>They are invisible in the source code. Looking at a block of code, including functions which may or may not throw exceptions, there is no way to see which exceptions might be thrown and from where. This means that even careful code inspection doesn't reveal potential bugs.</li>
       <li>They create too many possible exit points for a function. To write correct code, you really have to think about every possible code path through your function. Every time you call a function that can raise an exception and don't catch it on the spot, you create opportunities for surprise bugs caused by functions that terminated abruptly, leaving data in an inconsistent state, or other code paths that you didn't think about.</li>
      </ul>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span>+1 You might want to summarize the argument in your answer though? They are like invisible gotos and early exits for your routines, scattered throughout the program.</span> <span> - </span> <span class="display-name">MarkJ</span> <span> </span> <span class="date">5 Mar 2009 at 09:20</span></td>
       </tr>
       <tr>
        <td>18</td>
        <td><span>That's more an argument against Exceptions in general.</span> <span> - </span> <span class="display-name">Ionuț G. Stan</span> <span> </span> <span class="date">5 Mar 2009 at 09:36</span></td>
       </tr>
       <tr>
        <td>14</td>
        <td><span>have you actually read the article !! Firstly he talks about exceptions in general, secondly the section "They are invisible in the source code" applies specifically to UNCHECKED exception. This is the whole point of checked exception... so that you KNOW what code throws what where</span> <span> - </span> <span class="display-name">Newtopian</span> <span> </span> <span class="date">7 Aug 2009 at 16:55</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Part of the argument against checked exceptions is that actually you <i>don't</i> know what is thrown where. Yes, you know that a method <i>might</i> throw its declared checked exceptions (although there are many annoying cases where an exception is declared even though you know that particular implementation can never throw that exception)... and, it could throw <i>any</i> unchecked exception. Focusing on the former tends to make developers neglect the latter.</span> <span> - </span> <span class="display-name">DNA</span> <span> </span> <span class="date">1 Aug 2012 at 08:33</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Would people quit with the "this feature is a goto in disguise"! If statements are a form of goto, loops are a form of goto. The problem with gotos is that they're too powerful and not specific enough. You can use goto everywhere, which makes it difficult to know when to stop. When you have a "goto" construct like exceptions, break statements, continue, etc., you can tell exactly what it's being used for.</span> <span> - </span> <span class="display-name">Eva</span> <span> </span> <span class="date">6 Mar 2013 at 18:24</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@Eva They are not the same. With a goto statement you can see the <code>goto</code> keyword. With a loop you can see the closing brace or the <code>break</code> or <code>continue</code> keyword. All of them jump to a point in the current method. But you cannot always see the <code>throw</code>, because often it is not in the current method but in another method that it calls (possibly indirectly.)</span> <span> - </span> <span class="display-name">finnw</span> <span> </span> <span class="date">7 Mar 2013 at 00:45</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>@finnw Functions are themselves a form of goto. You usually don't know what functions the functions you're calling are calling. If you programmed without functions, you wouldn't have a problem with invisible exceptions. Which means that the problem is not specifically tied to exceptions, and is not a valid argument against exceptions in general. You could say error codes are faster, you could say monads are cleaner, but the goto argument is silly.</span> <span> - </span> <span class="display-name">Eva</span> <span> </span> <span class="date">7 Mar 2013 at 01:15</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Eva actually, error codes are <i>slower</i>, as they need repeated checks after each operation that could fail, including all levels of delegation, whereas an exception can skip over these call chains directly to the handler, while the ordinary code flow is not cluttered with conditionals. In languages where exceptions record stack traces, they are usually slower, but only <i>when</i> an exception is created.</span> <span> - </span> <span class="display-name">Holger</span> <span> </span> <span class="date">25 Jan 2018 at 15:25</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Holger... or create them without stacktraces at all?</span> <span> - </span> <span class="display-name">Eugene</span> <span> </span> <span class="date">25 Jan 2018 at 20:06</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Eugene well, when you disable stack traces, exceptions indeed become really fast, but I would still recommend a coding style where exceptions stay the exception, hence, their creation costs are irrelevant anyway.</span> <span> - </span> <span class="display-name">Holger</span> <span> </span> <span class="date">26 Jan 2018 at 08:35</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Holger right, but my understating is that the context is goto vs exceptions here, if so why would I need stack traces?</span> <span> - </span> <span class="display-name">Eugene</span> <span> </span> <span class="date">26 Jan 2018 at 09:22</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Eugene not exactly. I was just referring to the “error codes vs exceptions” performance comparison. So in both cases we have a normal code flow, in which using exceptions is faster and the erroneous case, in which case exceptions are slower when they record stack traces, which shouldn’t be a problem. If you want to abuse exceptions as some kind of goto, disabling traces would help the performance; I once hotfixed some code of this kind by disabling stack trace for that particular exception, but at some later time I rewrote the entire code to not abuse exceptions, which is even better (to me)…</span> <span> - </span> <span class="display-name">Holger</span> <span> </span> <span class="date">26 Jan 2018 at 09:36</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_32"><span>Answer 32</span> <span class="arrow"> <a href="#answer_31">↑</a> </span> <span class="arrow"> <a href="#answer_33">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>adrian.tarau</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 May 2009 at 03:36</span>
     </div>
    </div>
    <div>
     <p>I've read a lot about exception handling, even if (most of the time) I cannot really say I'm happy or sad about the existence of checked exceptions this is my take : checked exceptions in low-level code(IO, networking, OS, etc) and unchecked exceptions in high-level APIs/application level.</p>
     <p>Even if there is not so easy to draw a line between them, I find that it is really annoying/difficult to integrate several APIs/libraries under the same roof without wrapping all the time lots of checked exceptions but on the other hand, sometime it is useful/better to be forced to catch some exception and provide a different one which makes more sense in the current context.</p>
     <p>The project I'm working on takes lots of libraries and integrates them under the same API, API which is completely based on unchecked exceptions.This frameworks provides a high-level API which in the beginning was full of checked exceptions and had only several unchecked exceptions(Initialization Exception, ConfigurationException, etc) and I must say was not very <em>friendly</em>. Most of the time you had to catch or re-throw exceptions which you don't know how to handle, or you don't even care(not to be confused with you should ignore exceptions), especially on the client side where a single click could throw 10 possible (checked) exceptions.</p>
     <p>The current version(3rd one) uses only unchecked exceptions, and it has a global exception handler which is responsible to handle anything uncaught. The API provides a way to register exception handlers, which will decide if an exception is considered an error(most of the time this is the case) which means log &amp; notify somebody, or it can mean something else - like this exception, AbortException, which means break the current execution thread and don't log any error 'cause it is desired not to. Of course, in order to work out all custom thread must handle the run() method with a try {...} catch(all).</p>
     <p>public void run() {</p>
     <pre><code>try {
     ... do something ...
} catch (Throwable throwable) {
     ApplicationContext.getExceptionService().handleException("Handle this exception", throwable);
}
</code></pre>
     <p>}</p>
     <p>This is not necessary if you use the WorkerService to schedule jobs(Runnable, Callable, Worker), which handles everything for you.</p>
     <p>Of course this is just my opinion, and it might not be the right one, but it looks like a good approach to me. I will see after I will release the project if what I think it is good for me, it is good for others too... :)</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_33"><span>Answer 33</span> <span class="arrow"> <a href="#answer_32">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Rudi</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Aug 2013 at 22:11</span>
     </div>
    </div>
    <div>
     <p>In my opinion the checked exceptions are a very fine concept. Unfortunately the most programmers who have worked together we me have another opinion so that the projects have a lot of wrong used exception handling. I have seen that the most programmers create one (only one) exception class, a subclass of RuntimeException. That contains a message, sometimes a multi language key. I have no chance to argument against this. I have the impression that I talk to a wall when I explain them what anti patterns are, what a contracts of a methods are... I'm a little bit disappointed.</p>
     <p>But today it has become obvious that the concept to have a general runtime exception for everything is an anti pattern. They have used it for a check of a user input. The exception is thrown so that a user dialogue can make an error message out of it. But not every caller of the method is a dialogue! By throwing the runtime exception the contract of the method was changed but not declared, because it was not a checked exception.</p>
     <p>Hopefully they have learned something today and will make their checks (which are useful and necessary) at another place. Using only checked exception couldn't solve the problem but the checked exception would signal to the programmer that he implements something wrong.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>