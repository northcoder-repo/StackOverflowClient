<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>How to handle very large numbers in Java without using java.math.BigInteger</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>How to handle very large numbers in Java without using java.math.BigInteger</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>72</span>
    </div>
    <div>
     <span>Asker: </span> <span>frodosamoa</span>
    </div>
    <div>
     <span>Asked: </span> <span>15 Mar 2011 at 21:06</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/5318068/how-to-handle-very-large-numbers-in-java-without-using-java-math-biginteger">source</a>
    </div>
   </div>
   <div>
    <p>How would I go about doing arithmetic, + - / * % !, with arbitrarily large integers without using <code>java.math.BigInteger</code>?</p>
    <p>For instance, the factorial of 90 returns 0 in Java. I would like to be able to solve that.</p>
   </div>
   <div class="tags">
    <span class="tag">java</span><span class="tag">math</span><span class="tag">biginteger</span><span class="tag">integer</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>3</td>
       <td><span></span> <span> - </span> <span class="display-name">Lotfi</span> <span> </span> <span class="date">15 Mar 2011 at 21:09</span></td>
      </tr>
      <tr>
       <td>28</td>
       <td><span></span> <span> - </span> <span class="display-name">Mark Peters</span> <span> </span> <span class="date">15 Mar 2011 at 21:09</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span></span> <span> - </span> <span class="display-name">frodosamoa</span> <span> </span> <span class="date">15 Mar 2011 at 21:11</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span></span> <span> - </span> <span class="display-name">John</span> <span> </span> <span class="date">15 Mar 2011 at 21:12</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span></span> <span> - </span> <span class="display-name">frodosamoa</span> <span> </span> <span class="date">15 Mar 2011 at 21:13</span></td>
      </tr>
      <tr>
       <td>3</td>
       <td><span></span> <span> - </span> <span class="display-name">John</span> <span> </span> <span class="date">15 Mar 2011 at 21:14</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span></span> <span> - </span> <span class="display-name">Peter Lawrey</span> <span> </span> <span class="date">15 Mar 2011 at 21:15</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span></span> <span> - </span> <span class="display-name">josefx</span> <span> </span> <span class="date">15 Mar 2011 at 21:15</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span></span> <span> - </span> <span class="display-name">lukastymo</span> <span> </span> <span class="date">15 Mar 2011 at 21:16</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span></span> <span> - </span> <span class="display-name">frodosamoa</span> <span> </span> <span class="date">15 Mar 2011 at 21:18</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span></span> <span> - </span> <span class="display-name">Peter Lawrey</span> <span> </span> <span class="date">15 Mar 2011 at 21:22</span></td>
      </tr>
      <tr>
       <td>4</td>
       <td><span></span> <span> - </span> <span class="display-name">Peter Lawrey</span> <span> </span> <span class="date">15 Mar 2011 at 21:39</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>263</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Paŭlo Ebermann</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Mar 2011 at 22:34</span>
     </div>
    </div>
    <div>
     <p>I think a programmer should have implemented his own bignum-library once, so welcome here.</p>
     <p>(Of course, later you'll get that BigInteger is better, and use this, but it is a valuable learning experience.)</p>
     <p>(You can follow the source code of this course life <a href="https://github.com/ePaul/stackoverflow-examples/blob/master/src/de/fencing_game/paul/examples/DecimalBigInt.java" rel="noreferrer">on github</a>. Also, I remade this (a bit polished) into a <a href="http://paul-ebermann-blog.tumblr.com/post/6277562800/big-numbers-self-made-part-0-14-introduction" rel="noreferrer">14-part blog series</a>.)</p>
     <h1>Creating a simple Big number class in Java</h1>
     <p>So, what do we need?</p>
     <h2>First, a representation of the number,</h2>
     <p>based on the datatypes which Java gives us.</p>
     <p>As you think the decimal conversion is the most complicated part, let's stay in a decimal based mode. For efficiency, we'll store not real decimal digits, but work in base <code>1 000 000 000 = 10^9 &lt; 2^30</code>. This fits in a Java <code>int</code> (up to <code>2^31</code> or <code>2^32</code>), and the product of two such <em>digits</em> fits nicely in a Java <code>long</code>.</p>
     <pre><code>final static int BASE = 1000000000;
final static int BASE_DECIMAL_DIGITS = 9;
</code></pre>
     <p>Then the digits-array:</p>
     <pre><code>private int[] digits;
</code></pre>
     <p>Do we store the digits in little- or big endian, i.e. the bigger parts first or last? It does not really matter, so we decide on big-endian since this is how humans want to read it. (For now we concentrate on non-negative values - later we'll add a sign bit for negative numbers.)</p>
     <p>For testing purposes, we add a constructor which allows initializing from such a int[].</p>
     <pre><code>/**
 * creates a DecimalBigInt based on an array of digits.
 * @param digits a list of digits, each between 0 (inclusive)
 *    and {@link BASE} (exclusive).
 * @throws IllegalArgumentException if any digit is out of range.
 */
public DecimalBigInt(int... digits) {
    for(int digit : digits) {
        if(digit &lt; 0 ||  BASE &lt;= digit) {
            throw new IllegalArgumentException("digit " + digit +
                                               " out of range!");
        }
    }
    this.digits = digits.clone();
}
</code></pre>
     <p>As a added bonus, this constructor is also usable for a single <code>int</code> (if smaller than <code>BASE</code>), and even for no <code>int</code> (which we'll interpret as 0). So, we now can do this:</p>
     <pre><code>DecimalBigInt d = new DecimalBigInt(7, 5, 2, 12345);
System.out.println(d);
</code></pre>
     <p>This gives us <code>de.fencing_game.paul.examples.DecimalBigInt@6af62373</code>, not so useful. So, we add a <code>toString()</code> method:</p>
     <pre><code>/**
 * A simple string view for debugging purposes.
 * (Will be replaced later with a real decimal conversion.)
 */
public String toString() {
    return "Big" + Arrays.toString(digits);
}
</code></pre>
     <p>The output is now <code>Big[7, 5, 2, 12345]</code>, which is more useful for testing, isn't it?</p>
     <h2>Second, conversion from decimal format.</h2>
     <p>We are lucky here: our base (10^9) is a power of the base we want to convert from (10). Thus, we always have the same number (9) of decimal digits representing one "our format" digit. (Of course, in the beginning there may be some digits less.) In the following code, <code>decimal</code> is a String of decimal digits.</p>
     <pre><code> int decLen = decimal.length();
 int bigLen = (decLen-1) / BASE_DECIMAL_DIGITS + 1;
</code></pre>
     <p>This strange formula is a Java int way of writing <code>bigLen = ceil(decLen/BASE_DECIMAL_DIGITS)</code>. (I hope it is correct, we'll later test it.)</p>
     <pre><code> int firstSome = decLen - (bigLen-1) * BASE_DECIMAL_DIGITS;
</code></pre>
     <p>This is the length of the first block of decimal digits, should be between 1 and 9 (inclusive).</p>
     <p>We create our array:</p>
     <pre><code> int[] digits = new int[bigLen];
</code></pre>
     <p>Looping through the digits to be created:</p>
     <pre><code> for(int i = 0; i &lt; bigLen; i++) {
</code></pre>
     <p>Each of <em>our</em> digits is represented by a block of digits in the original number:</p>
     <pre><code>    String block =
        decimal.substring(Math.max(firstSome + (i-1)*BASE_DECIMAL_DIGITS, 0),
                          firstSome +   i  *BASE_DECIMAL_DIGITS);
</code></pre>
     <p>(The <code>Math.max</code> is needed here for the first shorter block.) We now use the usual Integer parsing function, and put the result into the array:</p>
     <pre><code>    digits[i] = Integer.parseInt(block);
}
</code></pre>
     <p>From the array now created we create our DecimalBigInt object:</p>
     <pre><code>return new DecimalBigInt(digits);
</code></pre>
     <p>Let's see if this works:</p>
     <pre><code>DecimalBigInt d2 = DecimalBigInt.valueOf("12345678901234567890");
System.out.println(d2);
</code></pre>
     <p>Output:</p>
     <pre><code>Big[12, 345678901, 234567890]
</code></pre>
     <p>Looks right :-) We should test it with some other numbers (of different length) too.</p>
     <p>Next part will be decimal formatting, this should be even easier.</p>
     <h2>Third, conversion to decimal format.</h2>
     <p>We need to output our individual digits as 9 decimal digits each. For this we can use the <code>Formatter</code> class, which supports printf-like format strings.</p>
     <p>A simple variant would be this:</p>
     <pre><code>public String toDecimalString() {
    Formatter f = new Formatter();
    for(int digit : digits) {
        f.format("%09d", digit);
    }
    return f.toString();
}
</code></pre>
     <p>This returns <code>000000007000000005000000002000012345</code> and <code>000000012345678901234567890</code> for our two numbers. This works for a round-trip (i.e. feeding it to the <code>valueOf</code> method gives an equivalent object), but the leading zeros are not really nice to look at (and could create confusion with octal numbers). So we need to break apart our beautiful for-each loop and use a different formatting string for the first and the following digits.</p>
     <pre><code>public String toDecimalString() {
    Formatter f = new Formatter();
    f.format("%d", digits[0]);
    for(int i = 1; i &lt; digits.length; i++) {
        f.format("%09d", digits[i]);
    }
    return f.toString();
}
</code></pre>
     <h2>Addition.</h2>
     <p>Let's start with addition, as this is simple (and we can use parts of it for the multiplication later).</p>
     <pre><code>/**
 * calculates the sum of this and that.
 */
public DecimalBigInt plus(DecimalBigInt that) {
    ...
}
</code></pre>
     <p>I want method names that you can read like you would read the formula, thus <code>plus</code>, <code>minus</code>, <code>times</code> instead of <code>add</code>, <code>subtract</code>, <code>multiply</code>.</p>
     <p>So, how does addition work? It works the same as we learned it in school for decimal numbers higher than 9: add the corresponding digits, and if for some of then the result is bigger than 10 (or <code>BASE</code> in our case), carry one to the next digit. This can cause the resulting number to have one digit more than the original ones.</p>
     <p>First we look at the simple case that both numbers have same number of digits. Then it looks simply like this:</p>
     <pre><code>int[] result = new int[this.digits.length];
int carry = 0;
for(int i = this.digits.length-1; i &gt; 0; i--) {
    int digSum = carry + this.digits[i] + that.digits[i];
    result[i] = digSum % BASE;
    carry = digSum / BASE;
}
if(carry &gt; 0) {
    int[] temp = new int[result.length + 1];
    System.arraycopy(result, 0, temp, 1, result.length);
    temp[0] = carry;
    result = temp;
}
return new DecimalBigInt(result);
</code></pre>
     <p>(We go from right to left, so we can carry any overflows to the next digit. This would be a bit prettier if we had decided using Little Endian format.)</p>
     <p>If both numbers do not have the same number of digits, it gets a bit more complicated.</p>
     <p>To let it as simple as possible, we split it to several methods:</p>
     <p>This method adds one digit to an element in the array (which may already contain some non-zero value), and stores the result back in the array. If there was overflow, we carry it to the next digit (which has index one less, not one more) by means of a recursive call. This way we make sure our digits stay always in the valid range.</p>
     <pre><code>/**
 * adds one digit from the addend to the corresponding digit
 * of the result.
 * If there is carry, it is recursively added to the next digit
 * of the result.
 */
private void addDigit(int[] result, int resultIndex,
                      int addendDigit)
{
    int sum = result[resultIndex] + addendDigit;
    result[resultIndex] = sum % BASE;
    int carry = sum / BASE;
    if(carry &gt; 0) {
        addDigit(result, resultIndex - 1, carry);
    }
}
</code></pre>
     <p>The next does the same for a whole array of digits to add:</p>
     <pre><code>/**
 * adds all the digits from the addend array to the result array.
 */
private void addDigits(int[] result, int resultIndex,
                       int... addend)
{
    int addendIndex = addend.length - 1;
    while(addendIndex &gt;= 0) {
        addDigit(result, resultIndex,
                 addend[addendIndex]);
        addendIndex--;
        resultIndex--;
    }
}
</code></pre>
     <p>Now we can implement our <code>plus</code> method:</p>
     <pre><code>/**
 * calculates the sum of this and that.
 */
public DecimalBigInt plus(DecimalBigInt that) {
    int[] result = new int[Math.max(this.digits.length,
                                    that.digits.length)+ 1];

    addDigits(result, result.length-1, this.digits);
    addDigits(result, result.length-1, that.digits);

    // cut of leading zero, if any
    if(result[0] == 0) {
        result = Arrays.copyOfRange(result, 1, result.length);
    }
    return new DecimalBigInt(result);
}
</code></pre>
     <p>We could do a bit better here if we would look before if overflow is at all possible and only then create the array one bigger than necessary.</p>
     <p>Ah, one test: <code>d2.plus(d2)</code> gives <code>Big[24, 691357802, 469135780]</code>, which looks right.</p>
     <h2>Multiplication.</h2>
     <p>Let's remember back to school, how did we multiply bigger numbers on paper?</p>
     <pre><code>123 * 123
----------
      369   &lt;== 123 * 3
     246    &lt;== 123 * 2
    123     &lt;== 123 * 1
  --------
    15129
</code></pre>
     <p>So, we have to multiply each digit[i] of the first number with each digit[j] of the second number, and add the product in digit[i+j] of the result (and pay attention to carry). Of course, here the indexes are counted from right, not from left. <em>(Now i really wish I had used little-endian numbers.)</em></p>
     <p>Since the product of two of our digits can get outside of the range of <code>int</code>, we use <code>long</code> for multiplication.</p>
     <pre><code>/**
 * multiplies two digits and adds the product to the result array
 * at the right digit-position.
 */
private void multiplyDigit(int[] result, int resultIndex,
                           int firstFactor, int secondFactor) {
    long prod = (long)firstFactor * (long)secondFactor;
    int prodDigit = (int)(prod % BASE);
    int carry = (int)(prod / BASE);
    addDigits(result, resultIndex, carry, prodDigit);
}
</code></pre>
     <p>Now we can see why I declared my <code>addDigits</code> method to take a <code>resultIndex</code> parameter. (And I just changed the last argument to a varargs parameter, to be able to write this here better.)</p>
     <p>So, here the cross-multiplying method:</p>
     <pre><code>private void multiplyDigits(int[] result, int resultIndex,
                            int[] leftFactor, int[] rightFactor) {
    for(int i = 0; i &lt; leftFactor.length; i++) {
        for(int j = 0; j &lt; rightFactor.length; j++) {

            multiplyDigit(result, resultIndex - (i + j),
                          leftFactor[leftFactor.length-i-1],
                          rightFactor[rightFactor.length-j-1]);
        }
    }
}
</code></pre>
     <p>I hope I have the index-calculations right. With a little-endian representation, it would have been <code>multiplyDigit(result, resultIndex + i + j, leftFactor[i], rightFactor[j])</code> - quite clearer, isn't it?</p>
     <p>Our <code>times</code> method now has only to allocate the result array, invoke <code>multiplyDigits</code> and wrap the result.</p>
     <pre><code>/**
 * returns the product {@code this × that}.
 */
public DecimalBigInt times(DecimalBigInt that) {
    int[] result = new int[this.digits.length + that.digits.length];
    multiplyDigits(result, result.length-1, 
                   this.digits, that.digits);

    // cut off leading zero, if any
    if(result[0] == 0) {
        result = Arrays.copyOfRange(result, 1, result.length);
    }
    return new DecimalBigInt(result);
}
</code></pre>
     <p>For testing, <code>d2.times(d2)</code> gives <code>Big[152, 415787532, 388367501, 905199875, 19052100]</code>, which is the same what my Emacs calc calculates here.</p>
     <h2>Comparison</h2>
     <p>We want to be able to compare two of our objects. So, we implement <code>Comparable&lt;DecimalBigInt&gt;</code> and its compareTo method.</p>
     <pre><code>public int compareTo(DecimalBigInt that) {
</code></pre>
     <p>How to know if one of our numbers is bigger than another? First, we compare the length of the arrays. As we took care not to induce any leading zeros (did we?), the longer array should have the bigger number.</p>
     <pre><code>    if(this.digits.length &lt; that.digits.length) {
        return -1;
    }
    if (that.digits.length &lt; this.digits.length) {
        return 1;
    }
</code></pre>
     <p>If the length are same, we can compare elementwise. Since we use big endian (i.e. <em>the big end comes first</em>), we start at the beginning.</p>
     <pre><code>    for(int i = 0; i &lt; this.digits.length; i++) {
        if(this.digits[i] &lt; that.digits[i]) {
            return -1;
        }
        if(that.digits[i] &lt; this.digits[i]) {
            return 1;
        }
    }
</code></pre>
     <p>If everything was same, obviously our numbers are identical, and we can return <code>0</code>.</p>
     <pre><code>    return 0;
}
</code></pre>
     <h2><code>equals</code> + <code>hashCode()</code></h2>
     <p>Every good immutable class should implement <code>equals()</code> and <code>hashCode()</code> in a suitable (and compatible) way.</p>
     <p>For our <code>hashCode()</code>, we simply sum up the digits, multiplying them with a small prime to make sure digit-switching does not result in same hash code:</p>
     <pre><code>/**
 * calculates a hashCode for this object.
 */
public int hashCode() {
    int hash = 0;
    for(int digit : digits) {
        hash = hash * 13 + digit;
    }
    return hash;
}
</code></pre>
     <p>In the <code>equals()</code> method we simply can delegate to the compareTo method, instead of implementing the same algorithm again:</p>
     <pre><code>/**
 * compares this object with another object for equality.
 * A DecimalBigInt is equal to another object only if this other
 * object is also a DecimalBigInt and both represent the same
 * natural number.
 */
public boolean equals(Object o) {
    return o instanceof DecimalBigInt &amp;&amp;
        this.compareTo((DecimalBigInt)o) == 0;
}
</code></pre>
     <hr>
     <p>So, enough for today. Subtraction (and maybe negative numbers) and division are more complicated, so I'm omitting them for now. <strong>For calculating the factorial of 90 this should be enough.</strong></p>
     <h2>Calculating big factorials:</h2>
     <p>Here the factorial function:</p>
     <pre><code>/**
 * calculates the factorial of an int number.
 * This uses a simple iterative loop.
 */
public static DecimalBigInt factorial(int n) {
    DecimalBigInt fac = new DecimalBigInt(1);
    for(int i = 2; i &lt;= n; i++) {
        fac = fac.times(new DecimalBigInt(i));
    }
    return fac;
}
</code></pre>
     <p>This gives us</p>
     <pre><code>fac(90) = 1485715964481761497309522733620825737885569961284688766942216863704985393094065876545992131370884059645617234469978112000000000000000000000
</code></pre>
     <h2>Converting from arbitrary-radix representations</h2>
     <p>Prompted by the next question of frodosamoa, I wrote <a href="https://stackoverflow.com/questions/5372279/how-can-i-convert-very-large-decimal-numbers-to-binary-in-java/5372316#5372316">my answer about how to convert from arbitrary (positional) number systems in the one in which we can (or want to) calculate</a>. (In the example there, I converted from trinary to decimal, while the question was about decimal to binary.)</p>
     <p>Here we want to convert from an arbitrary number system (okay, with radix between 2 and 36, so we can use <a href="http://download.oracle.com/javase/6/docs/api/java/lang/Character.html#digit%28char,%20int%29" rel="noreferrer"><code>Character.digit()</code></a> to convert single digits to ints) to our system with radix <code>BASE</code> (= 1.000.000.000, but this is not really important here).</p>
     <p>Basically we use <a href="http://en.wikipedia.org/wiki/Horner_scheme" rel="noreferrer">Horner scheme</a> to calculate the value of polynomial with the digits as coefficients at the point given by the radix.</p>
     <pre><code>sum[i=0..n] digit[i] * radix^i
</code></pre>
     <p>can be calculated with this loop:</p>
     <pre><code>value = 0;
for  i = n .. 0
  value = value * radix + digit[i]
return value
</code></pre>
     <p>Since our input strings are big-endian, we don't have to count down, but can use a simple enhanced for loop. (It looks more ugly in Java, since we have no operator overloading, and no autoboxing from int to our DecimalBigInt type.)</p>
     <pre><code>public static DecimalBigInt valueOf(String text, int radix) {
    DecimalBigInt bigRadix = new DecimalBigInt(radix);
    DecimalBigInt value = new DecimalBigInt(); // 0
    for(char digit : text.toCharArray()) {
       DecimalBigInt bigDigit =
           new DecimalBigInt(Character.digit(digit, radix));
       value = value.times(bigRadix).plus(bigDigit);
    }
    return value;
}
</code></pre>
     <p>In <a href="https://github.com/ePaul/stackoverflow-examples/commit/2a029557f8b2ea6e2970c673e2d7451eac7ffb0e" rel="noreferrer">my actual implementation</a> I added some error checking (and exception throwing) to ensure that we really have a valid number, and of course a documentation comment.</p>
     <hr>
     <p>Converting <strong>to</strong> an arbitrary positional system is more complicated, as it involves remainder and division (by the arbitrary radix), which we did not implement yet - so not for now. It will be done when I have a good idea on how to do division. (We need only division by small (one-digit) numbers here, which may be easier than a general division.)</p>
     <h2>Division by small numbers</h2>
     <p>In school, I learned <a href="http://en.wikipedia.org/wiki/Long_division" rel="noreferrer">long division</a>. Here is an example for a small (one-digit) divisor, in the notation we use here in Germany (with annotations about the background calculations, which we normally would not write), in decimal system:</p>
     <pre><code> 12345 : 6 = 02057     1 / 6 =  0
-0┊┊┊┊                 0 * 6 =  0
──┊┊┊┊
 12┊┊┊                12 / 6 =  2
-12┊┊┊                 2 * 6 = 12
 ──┊┊┊
  03┊┊                 3 / 6 =  0
 - 0┊┊                 0 * 6 =  0
  ──┊┊
   34┊                34 / 6 =  5
  -30┊                 5 * 6 = 30
   ──┊
    45                45 / 6 =  7
   -42                 7 * 6 = 42
    ──
     3     ==&gt; quotient 2057, remainder 3.
</code></pre>
     <p>Of couse, we don't need to calculate these products (0, 12, 0, 30, 42) and subtract them if we have a native remainder operation. Then it looks like this (of course, we here would not need to write the operations):</p>
     <pre><code> 12345 : 6 = 02057     1 / 6 =  0,   1 % 6 = 1
 12┊┊┊                12 / 6 =  2,  12 % 6 = 0
  03┊┊                 3 / 6 =  0,   3 % 6 = 3
   34┊                34 / 6 =  5,  34 % 6 = 4
    45                45 / 6 =  7,  45 % 6 = 3
     3
           ==&gt; quotient 2057, remainder 3.
</code></pre>
     <p>This already looks quite like <a href="http://en.wikipedia.org/wiki/Short_division" rel="noreferrer">short division</a>, if we write it in another format.</p>
     <p>We can observe (and prove) the following:</p>
     <p>If we have a two-digit number x with first digit smaller than our divisor d, than <code>x / d</code> is a one-digit number, and <code>x % d</code> is also a one-digit number, smaller than d. This, together with induction, shows that we only ever need to divide (with remainder) two-digit numbers by our divisor.</p>
     <p>Coming back to our big numbers with radix BASE: all two-digit numbers are representable as a Java <code>long</code>, and there we have native <code>/</code> and <code>%</code>.</p>
     <pre><code>/**
 * does one step in the short division algorithm, i.e. divides
 *  a two-digit number by a one-digit one.
 *
 * @param result the array to put the quotient digit in.
 * @param resultIndex the index in the result array where
 *             the quotient digit should be put.
 * @param divident the last digit of the divident.
 * @param lastRemainder the first digit of the divident (being the
 *           remainder of the operation one digit to the left).
 *           This must be &lt; divisor.
 * @param divisor the divisor.
 * @returns the remainder of the division operation.
 */
private int divideDigit(int[] result, int resultIndex,
                        int divident, int lastRemainder,
                        int divisor) {
    assert divisor &lt; BASE;
    assert lastRemainder &lt; divisor;

    long ent = divident + (long)BASE * lastRemainder;
    
    long quot = ent / divisor;
    long rem = ent % divisor;
    
    assert quot &lt; BASE;
    assert rem &lt; divisor;

    result[resultIndex] = (int)quot;
    return (int)rem;
}
</code></pre>
     <p>We will now call this method in a loop, always feeding the result from the previous call back as <code>lastRemainder</code>.</p>
     <pre><code>/**
 * The short division algorithm, like described in
 * &lt;a href="http://en.wikipedia.org/wiki/Short_division"&gt;Wikipedia's
 *   article &lt;em&gt;Short division&lt;/em&gt;&lt;/a&gt;.
 * @param result an array where we should put the quotient digits in.
 * @param resultIndex the index in the array where the highest order digit
 *     should be put, the next digits will follow.
 * @param divident the array with the divident's digits. (These will only
 *          be read, not written to.)
 * @param dividentIndex the index in the divident array where we should
 *         start dividing. We will continue until the end of the array.
 * @param divisor the divisor. This must be a number smaller than
 *        {@link #BASE}.
 * @return the remainder, which will be a number smaller than
 *     {@code divisor}.
 */
private int divideDigits(int[] result, int resultIndex,
                         int[] divident, int dividentIndex,
                         int divisor) {
    int remainder = 0;
    for(; dividentIndex &lt; divident.length; dividentIndex++, resultIndex++) {
        remainder = divideDigit(result, resultIndex,
                                divident[dividentIndex],
                                remainder, divisor);
    }
    return remainder;
}
</code></pre>
     <p>This method still returns an int, the remainder.</p>
     <p>Now we want to have a public method returning a DecimalBigInt, so we create one. It has the task to check the arguments, create an array for the working method, discard the remainder, and create a DecimalBigInt from the result. (The constructor removes a leading zero which may be there.)</p>
     <pre><code>/**
 * Divides this number by a small number.
 * @param divisor an integer with {@code 0 &lt; divisor &lt; BASE}.
 * @return the integer part of the quotient, ignoring the remainder.
 * @throws IllegalArgumentException if the divisor is &lt;= 0 or &gt;= BASE.
 */
public DecimalBigInt divideBy(int divisor)
{
    if(divisor &lt;= 0 || BASE &lt;= divisor) {
        throw new IllegalArgumentException("divisor " + divisor +
                                           " out of range!");
    }

    int[] result = new int[digits.length];
    divideDigits(result, 0,
                 digits, 0,
                 divisor);
    return new DecimalBigInt(result);
}
</code></pre>
     <p>We also have a similar method, which returns the remainder instead:</p>
     <pre><code>/**
 * Divides this number by a small number, returning the remainder.
 * @param divisor an integer with {@code 0 &lt; divisor &lt; BASE}.
 * @return the remainder from the division {@code this / divisor}.
 * @throws IllegalArgumentException if the divisor is &lt;= 0 or &gt;= BASE.
 */
public int modulo(int divisor) {
    if(divisor &lt;= 0 || BASE &lt;= divisor) {
        throw new IllegalArgumentException("divisor " + divisor +
                                           " out of range!");
    }
    int[] result = new int[digits.length];
    return divideDigits(result, 0,
                        digits, 0,
                        divisor);
}
</code></pre>
     <p>These methods can be invoked like this:</p>
     <pre><code>    DecimalBigInt d3_by_100 = d3.divideBy(100);
    System.out.println("d3/100 = " + d3_by_100);
    System.out.println("d3%100 = " + d3.modulo(100));
</code></pre>
     <h2>Conversion to arbitrary radix</h2>
     <p>Now we have the basics to convert to an arbitrary radix. Of course, not really arbitrary, only radixes smaller than <code>BASE</code> are allowed, but this should not be a too big problem.</p>
     <p>As already answered in another answer about converting numbers, we have to do "division, remainder, multiply, add. The "multiply-add" part is in fact only putting together the individual digits, so we can replace it by a simple array-access.</p>
     <p>As we always need both the quotient and the remainder, we won't use the public methods <code>modulo</code> and <code>divideBy</code>, but instead repeatedly call the <code>divideDigits</code> method.</p>
     <pre><code>/**
 * converts this number to an arbitrary radix.
 * @param radix the target radix, {@code 1 &lt; radix &lt; BASE}.
 * @return the digits of this number in the base-radix system,
 *     in big-endian order.
 */
public int[] convertTo(int radix)
{
    if(radix &lt;= 1 || BASE &lt;= radix) {
        throw new IllegalArgumentException("radix " + radix +
                                           " out of range!");
    }
</code></pre>
     <p>First, a special-case handling for 0.</p>
     <pre><code>    // zero has no digits.
    if(digits.length == 0)
        return new int[0];
</code></pre>
     <p>Then, we create an array for the result digits (long enough), and some other variables.</p>
     <pre><code>    // raw estimation how many output digits we will need.
    // This is just enough in cases like BASE-1, and up to
    // 30 digits (for base 2) too much for something like (1,0,0).
    int len = (int) (Math.log(BASE) / Math.log(radix) * digits.length)+1;
    int[] rDigits = new int[len];
    int rIndex = len-1;
    int[] current = digits;
    int quotLen = digits.length;
</code></pre>
     <p><code>quotLen</code> is the number of digits (excluding leading zeroes) in the last quotient. If this is 0, we are done.</p>
     <pre><code>    while(quotLen &gt; 0)  {
</code></pre>
     <p>A new array for the next quotient.</p>
     <pre><code>        int[] quot = new int[quotLen];
</code></pre>
     <p>The quotient-and-remainder operation. The quotient is now in <code>quot</code>, the remainder in <code>rem</code>.</p>
     <pre><code>        int rem = divideDigits(quot, 0,
                               current, current.length - quotLen,
                               radix);
</code></pre>
     <p>We put the remainder in the output array (filling it from the last digit).</p>
     <pre><code>        rDigits[rIndex] = rem;
        rIndex --;
</code></pre>
     <p>Then we swap the arrays for the next round.</p>
     <pre><code>        current = quot;
</code></pre>
     <p>If there are leading zeros in the quotient (there will be at most one, since radix is smaller than BASE), we shrink the quotient size by one. The next array will be smaller.</p>
     <pre><code>        if(current[0] == 0) {
            // omit leading zeros in next round.
            quotLen--;
        }
    }
</code></pre>
     <p>After the loop there may be leading zeros in the rDigits array, and we cut them off.</p>
     <pre><code>    // cut of leading zeros in rDigits:
    while(rIndex &lt; 0 || rDigits[rIndex] == 0) {
        rIndex++;
    }
    return Arrays.copyOfRange(rDigits, rIndex, rDigits.length);
}
</code></pre>
     <p>That's it. It looks a bit complicated, though. Here is an example of how to use it:</p>
     <pre><code>    System.out.println("d4 in base 11: " +
                       Arrays.toString(d4.convertTo(11)));
    System.out.println("d5 in base 7: " +
                       Arrays.toString(d5.convertTo(7)));
</code></pre>
     <p>These print <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0]</code> and <code>[1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0]</code>, just the same numbers as we parsed before (from a String, though).</p>
     <p>Based on this we can also format as a string:</p>
     <pre><code>/**
 * Converts the number to a String in a given radix.
 * This uses {@link Character.digit} to convert each digit
 * to one character.
 * @param radix the radix to use, between {@link Character.MIN_RADIX}
 *   and {@link Character.MAX_RADIX}.
 * @return a String containing the digits of this number in the
 *   specified radix, using '0' .. '9' and 'a' .. 'z' (as much as needed).
 */
public String toString(int radix) {
    if(radix &lt; Character.MIN_RADIX || Character.MAX_RADIX &lt; radix) {
        throw new IllegalArgumentException("radix out of range: " + radix);
    }
    if(digits.length == 0)
        return "0";
    int[] rdigits = convertTo(radix);
    StringBuilder b = new StringBuilder(rdigits.length);
    for(int dig : rdigits) {
        b.append(Character.forDigit(dig, radix));
    }
    return b.toString();
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>WhiteFang34</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Mar 2011 at 22:34</span>
     </div>
    </div>
    <div>
     <p>You might want to implement or research a library for <a href="http://en.wikipedia.org/wiki/Binary-coded_decimal" rel="nofollow">binary-coded decimal</a> if you're trying to avoid <code>BigInteger</code>. You can accomplish factorial of 90 with <code>BigInteger</code> if you want to use it though:</p>
     <pre><code>public static BigInteger factorial(BigInteger value) {
    BigInteger total = BigInteger.ONE;
    for (int i = 0; value.compareTo(BigInteger.ONE) == 1; i++) {
        total = total.multiply(value);
        value = value.subtract(BigInteger.ONE);
    }
    return total;
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Paŭlo Ebermann</span> <span> </span> <span class="date">16 Mar 2011 at 02:11</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user2130532</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Mar 2013 at 05:12</span>
     </div>
    </div>
    <div>
     <p>Use the code below to multiply numbers of any length:-</p>
     <pre><code>public class BigNumberMultiplication {


private static int[] firstBigNumber = null;
private static int[] secondBigNumber = null;

public static int[] baseMul(int[] baseMultiple, int base) {

    System.out.println("baseMultiple" + Arrays.toString(baseMultiple) + base);
    for (int i = 0; i &lt; baseMultiple.length; i++) {
        baseMultiple[i] *= base;
    }
    System.out.println("basemultipleresultwithoutcarryforward" + baseMultiple);
    return carryForward(baseMultiple);
}

public static int[] basePowerMul(int[] basePowerMultiple, int base, int power) {

    int basePowerMultipleTemp[] = baseMul(basePowerMultiple, base);
    System.out.println("basePowerMultipleTemp" + Arrays.toString(basePowerMultipleTemp) + "power" + power);
    int basePowerMultipleResult[] = new int[basePowerMultipleTemp.length + (power - 1)];
    for(int i = 0; i &lt; basePowerMultipleTemp.length; i++)
        basePowerMultipleResult[i] = basePowerMultipleTemp[i];
    if(power &gt; 1){
    for(int i = 0; i &lt; (power - 1); i++)
        basePowerMultipleResult[basePowerMultipleTemp.length + i] = 0;
    }
    System.out.println("basepowermulresult" + Arrays.toString(basePowerMultipleResult));
    return basePowerMultipleResult;
}
public static int[] addBigNumber(int[] finalNumberInArray, int[] finalNumberInArrayTemp){
    System.out.println("final number in array" + Arrays.toString(finalNumberInArray) + "finalNumberInTemp" + Arrays.toString(finalNumberInArrayTemp));
    int n = finalNumberInArray.length;
    for(int i = (finalNumberInArrayTemp.length - 1); i &gt;= 0; i--){
        finalNumberInArray[n - 1] += finalNumberInArrayTemp[i];
        n--;
    }

    return carryForward(finalNumberInArray);

}

public static int[] carryForward(int[] arrayWithoutCarryForward){

    int[] arrayWithCarryForward = null;
    System.out.println("array without carry forward" + Arrays.toString(arrayWithoutCarryForward));
    for (int i = arrayWithoutCarryForward.length - 1; i &gt; 0; i--) {
        if (arrayWithoutCarryForward[i] &gt;= 10) {
            int firstDigit = arrayWithoutCarryForward[i] % 10;
            int secondDigit = arrayWithoutCarryForward[i] / 10;
            arrayWithoutCarryForward[i] = firstDigit;
            arrayWithoutCarryForward[i - 1] += secondDigit;
        } 
    }

    if(arrayWithoutCarryForward[0] &gt;= 10){
        arrayWithCarryForward = new int[arrayWithoutCarryForward.length + 1];
        arrayWithCarryForward[0] = arrayWithoutCarryForward[0] / 10;
        arrayWithCarryForward[1] = arrayWithoutCarryForward[0] % 10;
    for(int i = 1; i &lt; arrayWithoutCarryForward.length; i++)
        arrayWithCarryForward[i + 1] = arrayWithoutCarryForward[i];
    }
    else{
        arrayWithCarryForward = arrayWithoutCarryForward;
    }
    System.out.println("array with carry forward" + Arrays.toString(arrayWithCarryForward));
    return arrayWithCarryForward;
}
public static int[] twoMuscularNumberMul(){
    int finalNumberInArray[] = null;
    for(int i = 0; i &lt; secondBigNumber.length; i++){
        if(secondBigNumber[i] == 0){}
        else {

             int[] finalNumberInArrayTemp = basePowerMul(Arrays.copyOf(firstBigNumber, firstBigNumber.length), secondBigNumber[i], secondBigNumber.length - i);
             if(finalNumberInArray == null){
                 finalNumberInArray = finalNumberInArrayTemp;
                 System.out.println("finalNumberInArray" + Arrays.toString(finalNumberInArray));
             }
             else{
                 finalNumberInArray = addBigNumber(finalNumberInArray, finalNumberInArrayTemp);
             System.out.println("finalNumberInArray" + Arrays.toString(finalNumberInArray));
             }
        }
    }
    return finalNumberInArray;
}

public static int [] readNumsFromCommandLine() {

    Scanner s = new Scanner(System.in);
    System.out.println("Please enter the number of digit");
    int count = s.nextInt();
    System.out.println("please enter the nuumber separated by space");
    s.nextLine();

    int [] numbers = new int[count];
    Scanner numScanner = new Scanner(s.nextLine());
    for (int i = 0; i &lt; count; i++) {
        if (numScanner.hasNextInt()) {
            numbers[i] = numScanner.nextInt();
        } else {
            System.out.println("You didn't provide enough numbers");
            break;
        }
    }

    return numbers;
}
public static void main(String[] args) {

    firstBigNumber = readNumsFromCommandLine();
    secondBigNumber = readNumsFromCommandLine();
    System.out.println("1st number" + Arrays.toString(firstBigNumber) + "2nd number" + Arrays.toString(secondBigNumber));
    int[] finalArray = twoMuscularNumberMul();
    System.out.println(Arrays.toString(finalArray));

    }

}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">user2130532</span> <span> </span> <span class="date">4 Mar 2013 at 05:15</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span></span> <span> - </span> <span class="display-name">Sebastian</span> <span> </span> <span class="date">4 Mar 2013 at 05:30</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>maerics</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Mar 2011 at 21:24</span>
     </div>
    </div>
    <div>
     <p>Arithmetic operations in Java using the operators <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and <code>%</code> are bound by the constraints of the <a href="http://download.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html" rel="nofollow">Java primitive data types</a>.</p>
     <p>This means that if you can't fit your desired numbers into the range of, say a <code>double</code> or <code>long</code> then you'll have to use a "big number" library, such as the one built-in to Java (<a href="http://download.oracle.com/javase/1.5.0/docs/api/java/math/BigDecimal.html" rel="nofollow">BigDecimal</a>, <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/math/BigInteger.html" rel="nofollow">BigInteger</a>), or a third-party library, or write your own. This also means that you cannot use the arithmetic operators since Java does not support operator overloading.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Adhyyan Sekhsaria</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Jun 2016 at 17:41</span>
     </div>
    </div>
    <div>
     <p>When I want to do 90! or some other massive calculation, I try and use an int[] array, each element holding one of the digits. Then I apply the traditional multiplication we using pen and paper to get the answer in another int[] array.</p>
     <p>This is the code I wrote in Java which calculates 100! rather quickly. Feel free to use this however you like.</p>
     <pre><code>public int factoial(int num) {
    int sum = 0;
    int[][] dig = new int[3][160];
    dig[0][0] = 0;
    dig[0][1] = 0;
    dig[0][2] = 1;

    for (int i = 99; i &gt; 1; i--) {
        int len = length(i);
        for (int k = 1; k &lt;= len; k++) { // Sets up multiplication
            int pos = len - k;
            dig[1][pos] = ((i / (int) (Math.pow(10, pos))) % 10);
        }
        int temp;
        for (int k = 0; k &lt; len; k++) { // multiplication
            for (int j = 0; j &lt; 159; j++) {
                dig[2][k + j] += (dig[1][k] * dig[0][j]);
                if (dig[2][k + j] &gt;= 10) {
                    dig[2][k + j + 1] += dig[2][k + j] / 10;
                    dig[2][k + j] = dig[2][k + j] % 10;
                }
            }
        }
        sum = 0;
        for (int k = 159; k &gt;= 0; k--) {
            System.out.print(dig[2][k]);
            dig[0][k] = dig[2][k];
            dig[1][k] = 0;
            sum += dig[2][k];
            dig[2][k] = 0;
        }
        System.out.println();
    }
    return sum;
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>BBsal</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Sep 2015 at 03:47</span>
     </div>
    </div>
    <div>
     <p><strong>strong text</strong> public class BigInteger {</p>
     <pre><code>     public static String checkSignWithRelational(int bigInt1, int bigInt2){
            if( bigInt1 &lt; 0){
                return "negative";
            }else {
                return "positive";
            }
     }
     BigInteger( long init)
     {
         Long.parseLong(bigInt1);
     }
     BigInteger String (String init){
        return null; 
     }

    private static int intLenght(int bigInt) {

        return Integer.toString(bigInt).length();
    }

    private static int[] intToArray(int bigInt, int bigIntLength, int arrayLength) {

        int array[] = new int[arrayLength ]; 
        for (int i = 0; i &lt; arrayLength ; i++) {
            array[i] = ( i&lt;bigIntLength ?
                             getDigitAtIndex(bigInt, bigIntLength - i -1) :0 ); 
        }
        return array;
}
    static String add(int bigInt1, int bigInt2) {
        //Find array length
        int length1 = intLenght(bigInt1);
        int length2 = intLenght(bigInt2);
        int arrayLength = Math.max(length1, length2);


        int array1[] = intToArray(bigInt1, length1, arrayLength);
        int array2[] = intToArray(bigInt2, length2, arrayLength);


        return add(array1, array2);
    }


    private static String add(int[] array1, int[] array2) {
        int carry=0;
        int addArray[] = new int[array1.length + 1];


        for (int i = 0; i &lt; array1.length; i++) {
            addArray[i] = (array1[i] + array2[i] + carry) % 10 ; 
            carry = (array1[i] + array2[i] + carry) / 10; 
        }
        addArray[array1.length] = carry;
        return arrayToString(addArray);
    }

    private static int getDigitAtIndex(int longint,int index){        
        return Integer.parseInt(Integer.toString(longint).substring(index, index+1)); 
    }
    private static String arrayToString(int[] addArray) {
        String add = "";
        boolean firstNonZero = false; 
        for (int i = addArray.length-1; i &gt;= 0 ; i--) {  

            if(!firstNonZero &amp;&amp; (addArray[i]==0)){ 
                continue;
            } else{
                firstNonZero=true;
            }
            add += addArray[i];
            if((i%3 ==0)&amp;&amp;i!=0){ add +=",";}  //formatting
        }
        String sumStr = add.length()==0?"0":add; 
        return sumStr;
    }
    public static String sub(int bigInt1, int bigInt2) {


        int length1 = intLenght(bigInt1);
        int length2 = intLenght(bigInt2);
        int arrayLength = Math.max(length1, length2);


        int array1[] = intToArray(bigInt1, length1, arrayLength);
        int array2[] = intToArray(bigInt2, length2, arrayLength);


        return sub(array1, array2);
    }
    private static String sub(int[] array1, int[] array2) {
        int carry=0;
        int sub[] = new int[array1.length + 1];


        for (int i = 0; i &lt; array1.length; i++) {
            sub[i] = (array1[i] - array2[i] + carry) % 10 ; //sum digits + carry; then extract last digit
            carry = (array1[i] - array2[i] + carry) / 10; //Compute carry
        }
        sub[array1.length] = carry;
        return arrayToString(sub);
    }
    public static String mul(int bigInt1, int bigInt2) {
        int length1 = intLenght(bigInt1), length2 = intLenght(bigInt2), length = Math.max(length1, length2);        
        int array1[] = intToArray(bigInt1, length1, length); int array2[] = intToArray(bigInt2, length2, length);
        return mul(array1, array2);
    }
    private static String mul(int[] array1, int[] array2) {
        int product[] = new int[array1.length + array2.length];
        for(int i=0; i&lt;array1.length; i++){        
            for(int j=0; j&lt;array2.length; j++){ 

                int prod = array1[i] * array2[j];       
                int prodLength = intLenght(prod);
                int prodAsArray[] =  intToArray(prod, prodLength, prodLength); 


                for (int k =0; k &lt; prodAsArray.length; k++) {
                    product[i+j+k] += prodAsArray[k];


                    int currentValue = product[i+j+k];
                    if(currentValue&gt;9){
                        product[i+j+k] = 0;                
                        int curValueLength = intLenght(currentValue);
                        int curValueAsArray[] = intToArray(currentValue, curValueLength, curValueLength);
                        for (int l = 0; l &lt; curValueAsArray.length; l++) {
                            product[i+j+k+l] += curValueAsArray[l];
                        }
                    }
                }      
            }
        }
        return arrayToString(product);
    }

   public static int div(int bigInt1, int bigInt2) {
       if ( bigInt2 == 0){
           throw new ArithmeticException("Division by 0 is undefined:" + bigInt1+ "/" + bigInt2);
       }
       int sign = 1;
       if(bigInt1 &lt; 0) {
           bigInt1 = -bigInt1;
           sign = -sign;
       }
       if (bigInt2 &lt; 0){
           bigInt2 = -bigInt2;
           sign = -sign;

       }
       int result  =0;
       while (bigInt1 &gt;= 0){
           bigInt1 -= bigInt2;
           result++;
       }
       return (result - 1) * sign;
   }

    public static String check(String bigInt1, String bigInt2){
        int difference;
        StringBuilder first = new StringBuilder(bigInt1);
        StringBuilder second = new StringBuilder(bigInt2);

        if(bigInt1.length()&gt; bigInt2.length()){
            difference = bigInt1.length() - bigInt2.length();
            for(int x = difference; x &gt; 0; x--){
                second.insert(0,"0");

            }
        bigInt2 = second.toString();
        return bigInt2;

        }else {
            difference = bigInt2.length() - bigInt1.length();
            for (int x = difference; x&gt; 0; x--)
            {
                first.insert(0, "0");
            }
            bigInt1 = first.toString();
            return bigInt1;
        }
    }
    public static int mod(int bigInt1, int bigInt2){
        int res = bigInt1 % bigInt2;
        return (res);

    }

    public static void main(String[] args) {

        int bigInt1 = Integer.parseInt("987888787");
        int bigInt2 = Integer.parseInt("444234343");
        System.out.println(bigInt1+" + "+bigInt2+" = "+add(bigInt1, bigInt2));
        System.out.println(bigInt1+" - "+bigInt2+" = "+sub(bigInt1, bigInt2));
        System.out.println(bigInt1+" * "+bigInt2+" = "+mul(bigInt1, bigInt2));
        System.out.println(bigInt1+" / "+bigInt2+" = "+div(bigInt1, bigInt2));
        System.out.println(bigInt1+" % "+bigInt2+" = "+mod(bigInt1, bigInt2));
    }
</code></pre>
     <p>}</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span></span> <span> - </span> <span class="display-name">Mephy</span> <span> </span> <span class="date">11 Sep 2015 at 03:52</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Teepeemm</span> <span> </span> <span class="date">12 Sep 2015 at 12:36</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Shubhdeep Singh</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Apr 2018 at 05:59</span>
     </div>
    </div>
    <div>
     <p>If we have really big numbers on which we want to perform arithmetic operations than they must be in some object form such as Strings.</p>
     <p>Let their be strings with the character length greater than the range of BigInteger.</p>
     <p>In this case I'll perform arithmetic operation the way we do it on a notebook. For Example - Let's assume we have to do the addition. Start with comparing the two strings for length. Make three new Strings. The First String is the smaller one. The Second String is the rightmost substring of the longer string with length equal to the smaller string. The third string is the leftover long string from the left side. Now add the first and second string from the end converting characters to integers, one character at a time and keeping the carry in an int variable. Immediately after each addition, append the sum in a StringBuffer. After the two strings are added, do the same operation for the third string and keep on adding the carry. In the end reverse the StringBuffer and return the String.</p>
     <p>Here is the code I used for Addition</p>
     <pre><code>public String addNumber(String input1,String input2){
int n=0;String tempStr;
String one="";
String two="";
if(input1.length()&gt;input2.length()){
    n=input1.length()-input2.length();
    tempStr=new String(input1);
    one=new String(input1.substring(n,input1.length()));
    two=new String(input2);
}else{
    n=input2.length()-input1.length();
    tempStr=new String(input2);
    one=new String(input2.substring(n,input2.length()));
    two=new String(input1);
}
StringBuffer temp=new StringBuffer();
for(int i=0;i&lt;n;i++){
    temp.append(tempStr.charAt(i));
}
StringBuffer newBuf=new StringBuffer();
int carry=0;
int c;
for(int i=one.length()-1;i&gt;=0;i--){
    int a=Character.getNumericValue(one.charAt(i));
    int b=Character.getNumericValue(two.charAt(i));
    c=a+b+carry;

    newBuf.append(""+(c%10));
    c=c/10;
    carry=c%10;
}
String news=new String(temp);
for(int i=news.length()-1;i&gt;=0;i--){
c=(Character.getNumericValue(news.charAt(i)))+carry;
newBuf.append(""+(c%10));
c=c/10;
carry=c%10;
}
if(carry==1){
    newBuf.append(""+carry);
}
String newisis=new String(newBuf.reverse());
return newisis;
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>