<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>What is the difference between "let" and "var"?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>What is the difference between "let" and "var"?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>6134</span>
    </div>
    <div>
     <span>Asker: </span> <span>TM.</span>
    </div>
    <div>
     <span>Asked: </span> <span>17 Apr 2009 at 20:09</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/762011">source</a>
    </div>
   </div>
   <div>
    <p>ECMAScript 6 introduced <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" rel="noreferrer">the <code>let</code> statement</a>.</p>
    <p>I've heard that it's described as a local variable, but I'm still not quite sure how it behaves differently than the var keyword.</p>
    <p>What are the differences? When should <code>let</code> be used instead of <code>var</code>?</p>
   </div>
   <div class="tags">
    <span class="tag">javascript</span><span class="tag">scope</span><span class="tag">ecmascript-6</span><span class="tag">var</span><span class="tag">let</span>
   </div>
   <hr>
   <div class="comment">
    <table>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8060</span>
     </div>
     <div>
      <span>Answerer: </span> <span>ThinkingStiff</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Jul 2012 at 02:53</span>
     </div>
    </div>
    <div>
     <h1>Scoping rules</h1>
     <p>The main difference is scoping rules. Variables declared by <code>var</code> keyword are scoped to the immediate function body (hence the function scope) while <code>let</code> variables are scoped to the immediate <em>enclosing</em> block denoted by <code>{ }</code> (hence the block scope).</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function run() {
  var foo = "Foo";
  let bar = "Bar";

  console.log(foo, bar); // Foo Bar

  {
    var moo = "Mooo"
    let baz = "Bazz";
    console.log(moo, baz); // Mooo Bazz
  }

  console.log(moo); // Mooo
  console.log(baz); // ReferenceError
}

run();</code></pre>
      </div>
     </div>
     <p></p>
     <p>The reason why <code>let</code> keyword was introduced to the language was function scope is confusing and was one of the main sources of bugs in JavaScript.</p>
     <p>Take a look at this example from <a href="https://stackoverflow.com/questions/750486/javascript-closure-inside-loops-simple-practical-example">another Stack Overflow question</a>:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>var funcs = [];
// let's create 3 functions
for (var i = 0; i &lt; 3; i++) {
  // and store them in funcs
  funcs[i] = function() {
    // each should log its value.
    console.log("My value: " + i);
  };
}
for (var j = 0; j &lt; 3; j++) {
  // and now let's run each one to see
  funcs[j]();
}</code></pre>
      </div>
     </div>
     <p></p>
     <p><code>My value: 3</code> was output to console each time <code>funcs[j]();</code> was invoked since anonymous functions were bound to the same variable.</p>
     <p>People had to create immediately invoked functions to capture correct values from the loops but that was also hairy.</p>
     <h1>Hoisting</h1>
     <p>While variables declared with <code>var</code> keyword are <a href="https://dev.to/godcrampy/the-secret-of-hoisting-in-javascript-egi" rel="noreferrer">hoisted</a> (initialized with <code>undefined</code> before the code is run) which means they are accessible in their enclosing scope even before they are declared:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function run() {
  console.log(foo); // undefined
  var foo = "Foo";
  console.log(foo); // Foo
}

run();</code></pre>
      </div>
     </div>
     <p></p>
     <p><code>let</code> variables are not initialized until their definition is evaluated. Accessing them before the initialization results in a <code>ReferenceError</code>. The variable is said to be in "temporal dead zone" from the start of the block until the initialization is processed.</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function checkHoisting() {
  console.log(foo); // ReferenceError
  let foo = "Foo";
  console.log(foo); // Foo
}

checkHoisting();</code></pre>
      </div>
     </div>
     <p></p>
     <h1>Creating global object property</h1>
     <p>At the top level, <code>let</code>, unlike <code>var</code>, does not create a property on the global object:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>var foo = "Foo";  // globally scoped
let bar = "Bar"; // not allowed to be globally scoped

console.log(window.foo); // Foo
console.log(window.bar); // undefined</code></pre>
      </div>
     </div>
     <p></p>
     <h1>Redeclaration</h1>
     <p>In strict mode, <code>var</code> will let you re-declare the same variable in the same scope while <code>let</code> raises a SyntaxError.</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>'use strict';
var foo = "foo1";
var foo = "foo2"; // No problem, 'foo1' is replaced with 'foo2'.

let bar = "bar1"; 
let bar = "bar2"; // SyntaxError: Identifier 'bar' has already been declared</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>70</td>
        <td><span>Remember you can create block whenever you want. function() { code;{ let inBlock = 5; } code; };</span> <span> - </span> <span class="display-name">average Joe</span> <span> </span> <span class="date">14 Dec 2012 at 10:14</span></td>
       </tr>
       <tr>
        <td>251</td>
        <td><span>So is the purpose of let statements only to free up memory when not needed in a certain block?</span> <span> - </span> <span class="display-name">NoBugs</span> <span> </span> <span class="date">7 Jun 2013 at 05:18</span></td>
       </tr>
       <tr>
        <td>292</td>
        <td><span>@NoBugs, Yes, and it is encouraged that variables are existent only where they are needed.</span> <span> - </span> <span class="display-name">batman</span> <span> </span> <span class="date">7 Jun 2013 at 15:02</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>let is not hoisted like its counterpart 'var' Hoisting behaves differently around a function block and any other block</span> <span> - </span> <span class="display-name">Anvesh Checka</span> <span> </span> <span class="date">26 Sep 2014 at 03:19</span></td>
       </tr>
       <tr>
        <td>73</td>
        <td><span><code>let</code> block expression <code>let (variable declaration) statement</code> is non-standard and will be removed in future, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1023609" rel="nofollow noreferrer">bugzilla.mozilla.org/show_bug.cgi?id=1023609</a>.</span> <span> - </span> <span class="display-name">Gajus</span> <span> </span> <span class="date">17 Dec 2014 at 14:51</span></td>
       </tr>
       <tr>
        <td>10</td>
        <td><span>Although a let enclosing block is deprecated you can do the same thing by creating an explicit block with braces. { let bar = foo; let foo = bar; <code>code</code>; <code>more code</code>; console.log(bar + foo); } and simply have your lets at the top of your block of code wrapped in braces.</span> <span> - </span> <span class="display-name">Eric Bishard</span> <span> </span> <span class="date">7 May 2015 at 14:12</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Just found this repo that allows you to use let blocks in your code. Because let blocks are pretty nice IMHO. <a href="https://github.com/getify/let-er" rel="nofollow noreferrer">github.com/getify/let-er</a> which <code>Transpiles non-ES6 let-blocks into ES6 (or ES3)</code></span> <span> - </span> <span class="display-name">Eric Bishard</span> <span> </span> <span class="date">7 May 2015 at 14:16</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span><b>Note:</b> As @EricB said, you can use <code>let a = 1; { let a = 2; console.log(a === 2) } console.log(a === 1)</code> in the place of <code>let a = 1; let (a = 2) { console.log(a === 2) } console.log(a === 1)</code>. It does exactly the same.</span> <span> - </span> <span class="display-name">Toothbrush</span> <span> </span> <span class="date">22 Oct 2015 at 22:32</span></td>
       </tr>
       <tr>
        <td>13</td>
        <td><span><code>let</code> at the top level scope is <i>not</i> identical to <code>var</code> -- <code>let</code> explicitly will not create globally-scoped references: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Scoping_rules" rel="nofollow noreferrer">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/…</a></span> <span> - </span> <span class="display-name">Dave Newton</span> <span> </span> <span class="date">31 Mar 2016 at 21:28</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Unfortunately browsers still (as of May 2017) do not optimize all corner cases for this nice feature and there are possible some loop slowdowns due to that <a href="http://stackoverflow.com/questions/43153889/javascript-var-vs-let-deoptimization-slowdown-issue-in-v8-and-spidermonkey" title="javascript var vs let deoptimization slowdown issue in v8 and spidermonkey">stackoverflow.com/questions/43153889/…</a></span> <span> - </span> <span class="display-name">Chajnik-U</span> <span> </span> <span class="date">8 May 2017 at 07:29</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>This answer does not address part of the question: "When should <code>let</code> be used over <code>var</code>?". I've attempted to answer that along with collecting a lot of the useful material in other answers <a href="/questions/762011/#44103318">below</a>. If some kind soul is willing to see this put into the community wiki, I will not object to copy-paste in whole or in part.</span> <span> - </span> <span class="display-name">mormegil</span> <span> </span> <span class="date">22 May 2017 at 01:27</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>I'm observing that redeclaration behavior remains same even without <code>'use strict';</code> mode. So it seems redeclaring a variable with same name using <code>let</code> keyword will <i>always</i> result in error no matter whether we are using strict mode or not. I'm using chrome version 58.</span> <span> - </span> <span class="display-name">RBT</span> <span> </span> <span class="date">1 Jun 2017 at 01:08</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>I would like to correct that let me = 'go' is not truly under global scope like var me = 'go' if you try this.me with let, you will get undefined. If you try this.me with var, you will get me's value, in this case 'go'.</span> <span> - </span> <span class="display-name">Tim Hong</span> <span> </span> <span class="date">23 Apr 2018 at 02:29</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>I think "immediate" would be better term than nearest in "nearest function block".</span> <span> - </span> <span class="display-name">snnsnn</span> <span> </span> <span class="date">11 Sep 2019 at 11:36</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>JetBrains (at least PHPStorm) typically recommends let in it's IDE help.</span> <span> - </span> <span class="display-name">S. Dre</span> <span> </span> <span class="date">4 Aug 2022 at 07:06</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>818</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Gurpreet Singh</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 May 2015 at 10:16</span>
     </div>
    </div>
    <div>
     <p><code>let</code> can also be used to avoid problems with closures. It binds fresh value rather than keeping an old reference as shown in examples below.</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>for(var i=1; i&lt;6; i++) {
  $("#div" + i).click(function () { console.log(i); });
}</code></pre>
       <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt;
&lt;p&gt;Clicking on each number will log to console:&lt;/p&gt; 
&lt;div id="div1"&gt;1&lt;/div&gt;
&lt;div id="div2"&gt;2&lt;/div&gt;
&lt;div id="div3"&gt;3&lt;/div&gt;
&lt;div id="div4"&gt;4&lt;/div&gt;
&lt;div id="div5"&gt;5&lt;/div&gt;</code></pre>
      </div>
     </div>
     <p></p>
     <p>Code above demonstrates a classic JavaScript closure problem. Reference to the <code>i</code> variable is being stored in the click handler closure, rather than the actual value of <code>i</code>.</p>
     <p>Every single click handler will refer to the same object because there’s only one counter object which holds 6 so you get six on each click.</p>
     <p>A general workaround is to wrap this in an anonymous function and pass <code>i</code> as an argument. Such issues can also be avoided now by using <code>let</code> instead <code>var</code> as shown in the code below.</p>
     <p><sub>(Tested in Chrome and Firefox 50)</sub></p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>for(let i=1; i&lt;6; i++) {
  $("#div" + i).click(function () { console.log(i); });
}</code></pre>
       <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt;
&lt;p&gt;Clicking on each number will log to console:&lt;/p&gt; 
&lt;div id="div1"&gt;1&lt;/div&gt;
&lt;div id="div2"&gt;2&lt;/div&gt;
&lt;div id="div3"&gt;3&lt;/div&gt;
&lt;div id="div4"&gt;4&lt;/div&gt;
&lt;div id="div5"&gt;5&lt;/div&gt;</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>78</td>
        <td><span>That is actually cool. I would expect "i" to be defined outside the loop body contains within brackets and to NOT form a "closure" around "i".Of course your example proves otherwise. I think it is a bit confusing from the syntax point of view but this scenario is so common it makes sense to support it in that way. Many thanks for bringing this up.</span> <span> - </span> <span class="display-name">Karol Kolenda</span> <span> </span> <span class="date">27 Jul 2015 at 12:49</span></td>
       </tr>
       <tr>
        <td>12</td>
        <td><span>IE 11 supports <code>let</code>, but it alerts "6" for all the buttons. Do you have any source saying how <code>let</code> is supposed to behave?</span> <span> - </span> <span class="display-name">Jim Hunziker</span> <span> </span> <span class="date">22 Oct 2015 at 13:29</span></td>
       </tr>
       <tr>
        <td>13</td>
        <td><span>Looks like your answer is the correct behavior: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" rel="nofollow noreferrer">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/…</a></span> <span> - </span> <span class="display-name">Jim Hunziker</span> <span> </span> <span class="date">22 Oct 2015 at 13:32</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>While reading the link in @Jim s comment I noticed a note that mentioned let working in Firefox 44.</span> <span> - </span> <span class="display-name">Marie</span> <span> </span> <span class="date">28 Jan 2016 at 14:25</span></td>
       </tr>
       <tr>
        <td>17</td>
        <td><span>Indeed this is a common pitfall in Javascript and now I can see why <code>let</code> would be really useful. Setting event listeners in a loop no longer requires an immediatelly invoked function expression for locally scoping <code>i</code> at each iteration.</span> <span> - </span> <span class="display-name">Adrian Moisa</span> <span> </span> <span class="date">21 Feb 2016 at 08:12</span></td>
       </tr>
       <tr>
        <td>25</td>
        <td><span>The use of "let" just defers this problem. So each iteration creates a private independent block scope, but the "i" variable can still be corrupted by subsequent changes within the block, (granted the iterator variable is not <i>usually</i> changed within the block, but other declared let variables within the block may well be) and any function declared within the block can, when invoked, corrupt the value of "i" for other functions declared within the block because they <i>do</i> share the same private block scope hence the same reference to "i".</span> <span> - </span> <span class="display-name">gary</span> <span> </span> <span class="date">7 Sep 2016 at 23:10</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>@gary According to MDN + changing the above demo to <code>i++</code> each function has its own block scope and doesn't interfere with the other instances: <a href="http://jsfiddle.net/rmXcF/474/" rel="nofollow noreferrer">jsfiddle.net/rmXcF/474</a></span> <span> - </span> <span class="display-name">krulik</span> <span> </span> <span class="date">20 Mar 2017 at 11:57</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>@krulik This is what I meant: <a href="http://jsfiddle.net/k7nmhoed/" rel="nofollow noreferrer">jsfiddle.net/k7nmhoed</a> two functions declared in the same block modify the shared loop variable i.</span> <span> - </span> <span class="display-name">gary</span> <span> </span> <span class="date">31 Mar 2017 at 16:32</span></td>
       </tr>
       <tr>
        <td>9</td>
        <td><span><code>for(let i = 1; i &lt; 6; i++)</code> I personally find this notation misleading: <code>i++</code> suggests that <code>i</code> is increased by <code>1</code>. Instead, a new variable named <code>i</code> is passed to the next iteration and initialized the the value of <code>i</code> in the previous iteration increased by <code>1</code>. I think they should have chosen another notation.</span> <span> - </span> <span class="display-name">giorgio-b</span> <span> </span> <span class="date">8 Mar 2018 at 13:52</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>For readers of "Javascript: The Good Parts", note that using <code>let</code> instead of <code>var</code> in the for loop (as in the second code block in this answer) prevents the code from showing an alert containing only the number of nodes; <a href="https://resources.oreilly.com/examples/9780596517748/blob/master/example_code/ch04.txt#L335" rel="nofollow noreferrer">here's a link to the example code</a>.</span> <span> - </span> <span class="display-name">jrh</span> <span> </span> <span class="date">26 Dec 2018 at 15:14</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@gary - that's exactly what <i>should</i> happen. <code>i</code> is available to all nested code. Without this, there is no easy way to refer to variables in outer scopes. If those two functions want <i>independent</i> <code>i</code>s, then they each declare <i>their own</i>, using <code>let</code>. OTOH I see your point - there is no way to ensure <code>i</code> is "frozen" (constant) within the loop. Could assign it to a const: <code>const j = i;</code>, but still have to manually verify that <code>i</code> isn't referenced anywhere.</span> <span> - </span> <span class="display-name">ToolmakerSteve</span> <span> </span> <span class="date">15 Oct 2019 at 12:11</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Has something changed in Javascript since this answer was posted? Both the "var" and "let" version produce the same results.</span> <span> - </span> <span class="display-name">KWallace</span> <span> </span> <span class="date">23 Oct 2019 at 17:56</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@KirbyL.Wallace and others confused about the same result for both examples: I believe the difference is in what happens when you click each number, not in what gets outputted. Both examples should show 1,2,3,4,5 on the screen, but in the console, they should result in different values appearing when each one is clicked, compared to the other.</span> <span> - </span> <span class="display-name">TylerH</span> <span> </span> <span class="date">13 Apr 2021 at 18:47</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>331</span>
     </div>
     <div>
      <span>Answerer: </span> <span>John Slegers</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Feb 2016 at 18:35</span>
     </div>
    </div>
    <div>
     <h3>What's the difference between <code>let</code> and <code>var</code>?</h3>
     <ul>
      <li>A variable defined using a <code>var</code> statement is known throughout <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function" rel="noreferrer"><strong>the function</strong></a> it is defined in, from the start of the function. <em>(*)</em></li>
      <li>A variable defined using a <code>let</code> statement is only known in <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/block" rel="noreferrer"><strong>the block</strong></a> it is defined in, from the moment it is defined onward. <em>(**)</em></li>
     </ul>
     <p>To understand the difference, consider the following code:</p>
     <pre><code>// i IS NOT known here
// j IS NOT known here
// k IS known here, but undefined
// l IS NOT known here

function loop(arr) {
    // i IS known here, but undefined
    // j IS NOT known here
    // k IS known here, but has a value only the second time loop is called
    // l IS NOT known here

    for( var i = 0; i &lt; arr.length; i++ ) {
        // i IS known here, and has a value
        // j IS NOT known here
        // k IS known here, but has a value only the second time loop is called
        // l IS NOT known here
    };

    // i IS known here, and has a value
    // j IS NOT known here
    // k IS known here, but has a value only the second time loop is called
    // l IS NOT known here

    for( let j = 0; j &lt; arr.length; j++ ) {
        // i IS known here, and has a value
        // j IS known here, and has a value
        // k IS known here, but has a value only the second time loop is called
        // l IS NOT known here
    };

    // i IS known here, and has a value
    // j IS NOT known here
    // k IS known here, but has a value only the second time loop is called
    // l IS NOT known here
}

loop([1,2,3,4]);

for( var k = 0; k &lt; arr.length; k++ ) {
    // i IS NOT known here
    // j IS NOT known here
    // k IS known here, and has a value
    // l IS NOT known here
};

for( let l = 0; l &lt; arr.length; l++ ) {
    // i IS NOT known here
    // j IS NOT known here
    // k IS known here, and has a value
    // l IS known here, and has a value
};

loop([1,2,3,4]);

// i IS NOT known here
// j IS NOT known here
// k IS known here, and has a value
// l IS NOT known here
</code></pre>
     <p>Here, we can see that our variable <code>j</code> is only known in the first for loop, but not before and after. Yet, our variable <code>i</code> is known in the entire function.</p>
     <p>Also, consider that block scoped variables are not known before they are declared because they are not hoisted. You're also not allowed to redeclare the same block scoped variable within the same block. This makes block scoped variables less error prone than globally or functionally scoped variables, which are hoisted and which do not produce any errors in case of multiple declarations.</p>
     <hr>
     <h3>Is it safe to use <code>let</code> today?</h3>
     <p>Some people would argue that in the future we'll ONLY use let statements and that var statements will become obsolete. JavaScript guru <a href="https://twitter.com/getify" rel="noreferrer"><strong>Kyle Simpson</strong></a> wrote <a href="https://davidwalsh.name/for-and-against-let" rel="noreferrer"><strong>a very elaborate article on why he believes that won't be the case</strong></a>.</p>
     <p>Today, however, that is definitely not the case. In fact, we need actually to ask ourselves whether it's safe to use the <code>let</code> statement. The answer to that question depends on your environment:</p>
     <ul>
      <li>
       <p>If you're writing server-side JavaScript code (<a href="https://nodejs.org/en/" rel="noreferrer"><strong>Node.js</strong></a>), you can safely use the <code>let</code> statement.</p></li>
      <li>
       <p>If you're writing client-side JavaScript code and use a browser based transpiler (like <a href="https://github.com/google/traceur-compiler" rel="noreferrer"><strong>Traceur</strong></a> or <a href="https://github.com/babel/babel-standalone" rel="noreferrer"><strong>babel-standalone</strong></a>), you can safely use the <code>let</code> statement, however your code is likely to be anything but optimal with respect to performance.</p></li>
      <li>
       <p>If you're writing client-side JavaScript code and use a Node based transpiler (like the <a href="https://github.com/google/traceur-compiler/wiki/Compiling-Offline" rel="noreferrer"><strong>traceur shell script</strong></a> or <a href="https://babeljs.io/" rel="noreferrer"><strong>Babel</strong></a>), you can safely use the <code>let</code> statement. And, because your browser will only know about the transpiled code, performance drawbacks should be limited.</p></li>
      <li>
       <p>If you're writing client-side JavaScript code and don't use a transpiler, you need to consider browser support.</p>
       <p>There are still some browsers that don't support <code>let</code> at all :</p></li>
     </ul>
     <p><a href="https://i.stack.imgur.com/J9kEC.png" rel="noreferrer"><img src="/question/stackoverflow/762011/J9kEC.png" alt="enter image description here"></a></p>
     <hr>
     <h3>How to keep track of browser support</h3>
     <p>For an up-to-date overview of which browsers support the <code>let</code> statement at the time of your reading this answer, see <a href="http://caniuse.com/#search=let" rel="noreferrer"><strong>this <code>Can I Use</code> page</strong></a>.</p>
     <hr>
     <p><em>(*) Globally and functionally scoped variables can be initialized and used before they are declared because JavaScript variables are <a href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting" rel="noreferrer"><strong>hoisted</strong></a>.</em> This means that declarations are always moved to the top of the scope.</p>
     <p><em>(**) Block scoped variables are not hoisted</em></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>22</td>
        <td><span>regarding answer v4: <code>i</code> IS known everywhere in the function-block! It starts as <code>undefined</code> (due to hoisting) until you assign a value! ps: <code>let</code> is also hoisted (to the top of it's containing block), but will give a <code>ReferenceError</code> when referenced in the block before first assignment. (ps2: I'm a pro-semicolon kinda guy but you really don't need a semicolon after a block ). That being said, thanks for adding the reality-check regarding support!</span> <span> - </span> <span class="display-name">GitaarLAB</span> <span> </span> <span class="date">21 May 2016 at 04:41</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@GitaarLAB : According to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" rel="nofollow noreferrer">Mozilla Developer Network</a> : "In ECMAScript 2015, let bindings are not subject to Variable Hoisting, which means that let declarations do not move to the top of the current execution context." - Anyway, I made a few improvements to my answer that should clarify the difference in hoisting behavior between <code>let</code> and <code>var</code>!</span> <span> - </span> <span class="display-name">John Slegers</span> <span> </span> <span class="date">26 Feb 2018 at 23:37</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Your answer improved a lot (I thoroughly checked). Note that same link you referenced in your comment also says: "The (let) variable is in a "temporal dead zone" from the <i>start of the block</i> until the initialization is processed." That means that the 'identifier' (the text-string 'reserved' to point to 'something') <i>is already</i> reserved in the relevant scope, otherwise it would become part of the root/host/window scope. To me personally, 'hoisting' means nothing more than reserving/linking declared 'identifiers' to their relevant scope; excluding their initialization/assignment/modifyability!</span> <span> - </span> <span class="display-name">GitaarLAB</span> <span> </span> <span class="date">1 Mar 2018 at 18:16</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>And..+1. That Kyle Simpson article you linked is an <i>excellent</i> read, thank you for that! It is also clear about the "temporal dead zone" aka "TDZ". One interesting thing I'd like to add: I've read on MDN that <code>let</code> and <code>const</code> were <i>recommended to only use when you actually need their additional functionality</i>, because enforcing/checking these extra features (like write-only const) result in 'more work' (and additional scope-nodes in the scope-tree) for the (current)engine(s) to enforce/check/verify/setup.</span> <span> - </span> <span class="display-name">GitaarLAB</span> <span> </span> <span class="date">1 Mar 2018 at 18:17</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Note that MDN says that IE DOES interpret let correctly. Which is it? <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" rel="nofollow noreferrer">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/…</a></span> <span> - </span> <span class="display-name">Katinka Hesselink</span> <span> </span> <span class="date">6 Feb 2019 at 12:42</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@KatinkaHesselink : I don't see the MDN saying any like that. As far as I can tell, they merely left out a quirk in IE11 that others have correctly documented. See also <a href="https://stackoverflow.com/questions/2356830/what-browsers-currently-support-javascripts-let-keyword" title="what browsers currently support javascripts let keyword">stackoverflow.com/questions/2356830/…</a>.</span> <span> - </span> <span class="display-name">John Slegers</span> <span> </span> <span class="date">5 Apr 2019 at 09:49</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>184</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ben S</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Apr 2009 at 20:11</span>
     </div>
    </div>
    <div>
     <p>Here's an <a href="https://developer.mozilla.org/en/New_in_JavaScript_1.7#Block_scope_with_let" rel="noreferrer">explanation of the <code>let</code> keyword</a> with some examples.</p>
     <blockquote>
      <p><code>let</code> works very much like <code>var</code>. The main difference is that the scope of a <code>var</code> variable is the entire enclosing function</p>
     </blockquote>
     <p><a href="http://en.wikipedia.org/wiki/JavaScript#Version_history" rel="noreferrer">This table</a> on Wikipedia shows which browsers support Javascript 1.7.</p>
     <p>Note that only Mozilla and Chrome browsers support it. IE, Safari, and potentially others don't.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>7</td>
        <td><span>The key bit of text from the linked document seems to be, "let works very much like var. The main difference is that the scope of a var variable is the entire enclosing function".</span> <span> - </span> <span class="display-name">Michael Burr</span> <span> </span> <span class="date">17 Apr 2009 at 20:25</span></td>
       </tr>
       <tr>
        <td>59</td>
        <td><span>@olliej, actually Mozilla is just ahead of the game. See page 19 of <a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf" rel="nofollow noreferrer">ecma-international.org/publications/files/ECMA-ST/Ecma-262.p‌​df</a></span> <span> - </span> <span class="display-name">Tyler Crompton</span> <span> </span> <span class="date">18 Jun 2012 at 20:16</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@TylerCrompton that's just the set of words that have been reserved for years. When mozilla added let it was purely a mozilla extension, with no related spec. ES6 should define behaviour for let statements, but that came after mozilla introduced the syntax. Remember moz also has E4X, which is entirely dead and moz only.</span> <span> - </span> <span class="display-name">olliej</span> <span> </span> <span class="date">11 Jul 2012 at 18:49</span></td>
       </tr>
       <tr>
        <td>11</td>
        <td><span>IE11 added support for <code>let</code> <a href="http://msdn.microsoft.com/en-us/library/ie/dn342892%28v=vs.85%29.aspx" rel="nofollow noreferrer">msdn.microsoft.com/en-us/library/ie/dn342892%28v=vs.85%29.as‌​px</a></span> <span> - </span> <span class="display-name">eloyesp</span> <span> </span> <span class="date">24 Dec 2013 at 12:59</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Now <code>let</code> support all latest browser today except Opera, Blackberry &amp; QQ Browsers.</span> <span> - </span> <span class="display-name">Shapon Pal</span> <span> </span> <span class="date">8 Jan 2019 at 05:11</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>150</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Michał Perłakowski</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Nov 2016 at 22:52</span>
     </div>
    </div>
    <div>
     <h1><code>let</code></h1>
     <h2>Block scope</h2>
     <p>Variables declared using the <code>let</code> keyword are block-scoped, which means that they are available only in the <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/block" rel="noreferrer">block</a> in which they were declared.</p>
     <h3>At the top level (outside of a function)</h3>
     <p>At the top level, variables declared using <code>let</code> don't create properties on the global object.</p>
     <pre><code>var globalVariable = 42;
let blockScopedVariable = 43;

console.log(globalVariable); // 42
console.log(blockScopedVariable); // 43

console.log(this.globalVariable); // 42
console.log(this.blockScopedVariable); // undefined
</code></pre>
     <h3>Inside a function</h3>
     <p>Inside a function (but outside of a block), <code>let</code> has the same scope as <code>var</code>.</p>
     <pre><code>(() =&gt; {
  var functionScopedVariable = 42;
  let blockScopedVariable = 43;

  console.log(functionScopedVariable); // 42
  console.log(blockScopedVariable); // 43
})();

console.log(functionScopedVariable); // ReferenceError: functionScopedVariable is not defined
console.log(blockScopedVariable); // ReferenceError: blockScopedVariable is not defined
</code></pre>
     <h3>Inside a block</h3>
     <p>Variables declared using <code>let</code> inside a block can't be accessed outside that block.</p>
     <pre><code>{
  var globalVariable = 42;
  let blockScopedVariable = 43;
  console.log(globalVariable); // 42
  console.log(blockScopedVariable); // 43
}

console.log(globalVariable); // 42
console.log(blockScopedVariable); // ReferenceError: blockScopedVariable is not defined
</code></pre>
     <h3>Inside a loop</h3>
     <p>Variables declared with <code>let</code> in loops can be referenced only inside that loop.</p>
     <pre><code>for (var i = 0; i &lt; 3; i++) {
  var j = i * 2;
}
console.log(i); // 3
console.log(j); // 4

for (let k = 0; k &lt; 3; k++) {
  let l = k * 2;
}
console.log(typeof k); // undefined
console.log(typeof l); // undefined
// Trying to do console.log(k) or console.log(l) here would throw a ReferenceError.
</code></pre>
     <h3>Loops with closures</h3>
     <p>If you use <code>let</code> instead of <code>var</code> in a loop, with each iteration you get a new variable. That means that you can safely use a closure inside a loop.</p>
     <pre><code>// Logs 3 thrice, not what we meant.
for (var i = 0; i &lt; 3; i++) {
  setTimeout(() =&gt; console.log(i), 0);
}

// Logs 0, 1 and 2, as expected.
for (let j = 0; j &lt; 3; j++) {
  setTimeout(() =&gt; console.log(j), 0);
}
</code></pre>
     <h2>Temporal dead zone</h2>
     <p>Because of <a href="https://stackoverflow.com/q/33198849/3853934">the temporal dead zone</a>, variables declared using <code>let</code> can't be accessed before they are declared. Attempting to do so throws an error.</p>
     <pre><code>console.log(noTDZ); // undefined
var noTDZ = 43;
console.log(hasTDZ); // ReferenceError: hasTDZ is not defined
let hasTDZ = 42;
</code></pre>
     <h2>No re-declaring</h2>
     <p>You can't declare the same variable multiple times using <code>let</code>. You also can't declare a variable using <code>let</code> with the same identifier as another variable which was declared using <code>var</code>.</p>
     <pre><code>var a;
var a; // Works fine.

let b;
let b; // SyntaxError: Identifier 'b' has already been declared

var c;
let c; // SyntaxError: Identifier 'c' has already been declared
</code></pre>
     <h1><code>const</code></h1>
     <p><code>const</code> is quite similar to <code>let</code>—it's block-scoped and has TDZ. There are, however, two things which are different.</p>
     <h2>No re-assigning</h2>
     <p>Variable declared using <code>const</code> can't be re-assigned.</p>
     <pre><code>const a = 42;
a = 43; // TypeError: Assignment to constant variable.
</code></pre>
     <p>Note that it doesn't mean that the value is immutable. Its properties still can be changed.</p>
     <pre><code>const obj = {};
obj.a = 42;
console.log(obj.a); // 42
</code></pre>
     <p>If you want to have an immutable object, you should use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" rel="noreferrer"><code>Object.freeze()</code></a>.</p>
     <pre><code>const obj = Object.freeze({a: 40});
obj.a = 42;
console.log(obj.a); // 40
console.log(obj.b); // undefined
</code></pre>
     <h2>Initializer is required</h2>
     <p>You always must specify a value when declaring a variable using <code>const</code>.</p>
     <pre><code>const a; // SyntaxError: Missing initializer in const declaration
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>143</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Lcf.vs</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Jun 2015 at 20:59</span>
     </div>
    </div>
    <div>
     <p>The accepted answer is missing a point:</p>
     <pre><code>{
  let a = 123;
};

console.log(a); // ReferenceError: a is not defined
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>21</td>
        <td><span>The accepted answer does NOT explain this point in its example. The accepted answer only demonstrated it in a <code>for</code> loop initializer, dramatically narrowing the scope of application of the limitations of <code>let</code>. Upvoted.</span> <span> - </span> <span class="display-name">Jon Davis</span> <span> </span> <span class="date">22 Sep 2015 at 06:55</span></td>
       </tr>
       <tr>
        <td>45</td>
        <td><span>@stimpy77 It explicitly states "let is scoped to the nearest enclosing block"; does every way that manifests need to be included?</span> <span> - </span> <span class="display-name">Dave Newton</span> <span> </span> <span class="date">31 Mar 2016 at 21:32</span></td>
       </tr>
       <tr>
        <td>9</td>
        <td><span>there were a lot of examples and none of them properly demonstrated the matter .. I might've upvoted both the accepted answer and this one?</span> <span> - </span> <span class="display-name">Jon Davis</span> <span> </span> <span class="date">31 Mar 2016 at 21:38</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>This contribution demonstrates that a "block" can simply be a set of lines enclosed in brackets; i.e. it doesn't need to be associated with any sort of control flow, loop, etc.</span> <span> - </span> <span class="display-name">webelo</span> <span> </span> <span class="date">22 Nov 2017 at 14:37</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>110</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Hasan Sefa Ozalp</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 May 2020 at 17:04</span>
     </div>
    </div>
    <div>
     <h2>In most basic terms,</h2>
     <pre><code>for (let i = 0; i &lt; 5; i++) {
  // i accessible ✔️
}
// i not accessible ❌
</code></pre>
     <hr>
     <pre><code>for (var i = 0; i &lt; 5; i++) {
  // i accessible ✔️
}
// i accessible ✔️
</code></pre>
     <hr>
     <p>⚡️ Sandbox to play around ↓</p>
     <p><a href="https://codesandbox.io/s/let-vs-var-emzh5?fontsize=14&amp;hidenavigation=1&amp;theme=dark" rel="noreferrer"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="Edit let vs var"></a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>67</span>
     </div>
     <div>
      <span>Answerer: </span> <span>vlio20</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Mar 2015 at 10:41</span>
     </div>
    </div>
    <div>
     <p>Here is an example of the difference between the two:<br><img src="/question/stackoverflow/762011/dqNYW.png" alt="enter image description here"></p>
     <p>As you can see, the <code>var j</code> variable still has a value outside the for loop scope (Block Scope), but the <code>let i</code> variable is undefined outside of the for loop scope.</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>"use strict";
console.log("var:");
for (var j = 0; j &lt; 2; j++) {
  console.log(j);
}

console.log(j);

console.log("let:");
for (let i = 0; i &lt; 2; i++) {
  console.log(i);
}

console.log(i);</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>66</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Alireza</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Mar 2017 at 14:39</span>
     </div>
    </div>
    <div>
     <p>The main difference is the <strong>scope</strong> difference, while <strong>let</strong> can be only available inside the <strong>scope</strong> it's declared, like in for loop, <strong>var</strong> can be accessed outside the loop for example. From the documentation in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" rel="noreferrer">MDN</a> (examples also from MDN):</p>
     <blockquote>
      <p><strong>let</strong> allows you to declare variables that are limited in scope to the block, statement, or expression on which it is used. This is unlike the <strong>var</strong> keyword, which defines a variable globally, or locally to an entire function regardless of block scope.</p>
      <p>Variables declared by <strong>let</strong> have as their scope the block in which they are defined, as well as in any contained sub-blocks. In this way, <strong>let</strong> works very much like <strong>var</strong>. The main difference is that the scope of a <strong>var</strong> variable is the entire enclosing function:</p>
     </blockquote>
     <pre><code>function varTest() {
  var x = 1;
  if (true) {
    var x = 2;  // same variable!
    console.log(x);  // 2
  }
  console.log(x);  // 2
}

function letTest() {
  let x = 1;
  if (true) {
    let x = 2;  // different variable
    console.log(x);  // 2
  }
  console.log(x);  // 1
}`
</code></pre>
     <blockquote>
      <p>At the top level of programs and functions, <strong>let</strong>, unlike <strong>var</strong>, does not create a property on the global object. For example:</p>
     </blockquote>
     <pre><code>var x = 'global';
let y = 'global';
console.log(this.x); // "global"
console.log(this.y); // undefined
</code></pre>
     <blockquote>
      <p>When used inside a block, let limits the variable's scope to that block. Note the difference between <strong>var</strong> whose scope is inside the function where it is declared.</p>
     </blockquote>
     <pre><code>var a = 1;
var b = 2;

if (a === 1) {
  var a = 11; // the scope is global
  let b = 22; // the scope is inside the if-block

  console.log(a);  // 11
  console.log(b);  // 22
} 

console.log(a); // 11
console.log(b); // 2
</code></pre>
     <p>Also don't forget it's ECMA6 feature, so it's not fully supported yet, so it's better always transpiles it to ECMA5 using Babel etc... for more info about visit <a href="https://babeljs.io" rel="noreferrer">babel website</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>I don't know if that last example is accurate. Because by calling it not from a function but a direct command line its still considered part of the same function. So, if you called it from outside of a function, it shouldn't behave in the same way.</span> <span> - </span> <span class="display-name">ACopeLan</span> <span> </span> <span class="date">28 Aug 2020 at 18:20</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>64</span>
     </div>
     <div>
      <span>Answerer: </span> <span>olliej</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Apr 2009 at 21:38</span>
     </div>
    </div>
    <div>
     <p>There are some subtle differences — <code>let</code> scoping behaves more like variable scoping does in more or less any other languages.</p>
     <p>e.g. It scopes to the enclosing block, They don't exist before they're declared, etc.</p>
     <p>However it's worth noting that <code>let</code> is only a part of newer Javascript implementations and has varying degrees of <a href="http://caniuse.com/#search=let" rel="noreferrer">browser support</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>14</td>
        <td><span>It's also worth noting that ECMAScript is the standard and <code>let</code> is included in the <a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-12.2.1" rel="nofollow noreferrer">6th edition draft</a> and will most likely be in the final specification.</span> <span> - </span> <span class="display-name">Richard Ayotte</span> <span> </span> <span class="date">31 Mar 2012 at 15:09</span></td>
       </tr>
       <tr>
        <td>8</td>
        <td><span>Just stubled across this question and in 2012 it is still the case that only Mozilla browsers support <code>let</code>. Safari, IE, and Chome all don't.</span> <span> - </span> <span class="display-name">pseudosavant</span> <span> </span> <span class="date">13 Jul 2012 at 17:38</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>The idea of accidentally creating partial block scope on accident is a good point, beware, <code>let</code> does not hoist, to use a variable defined by a <code>let</code> defined at the top of your block. If you have an <code>if</code> statement that is more than just a few lines of code, you may forget that you cannot use that variable until after it is defined. GREAT POINT!!!</span> <span> - </span> <span class="display-name">Eric Bishard</span> <span> </span> <span class="date">7 May 2015 at 14:01</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>This is one of the most important distinctions between let and var and it's not in the accepted answer haha. Especially considering the numerous bugs that can occur thanks to hoisting and scoping. I feel like there aren't many differences between let and var if you don't mention hoisting.</span> <span> - </span> <span class="display-name">Jay</span> <span> </span> <span class="date">21 Jun 2015 at 16:12</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>@EricB: yes and no: "In ECMAScript 2015, <code>let</code> <b>will hoist</b> the variable to the top of the block. However, referencing the variable in the block before the variable declaration results in a <i>ReferenceError</i> (my note: instead of good old <code>undefined</code>). The variable is in a 'temporal dead zone' from the start of the block until the declaration is processed." Same goes for "switch statements because there is only one underlying block". Source: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" rel="nofollow noreferrer">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/…</a></span> <span> - </span> <span class="display-name">GitaarLAB</span> <span> </span> <span class="date">21 May 2016 at 04:15</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>34</span>
     </div>
     <div>
      <span>Answerer: </span> <span>zangw</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Jan 2016 at 15:11</span>
     </div>
    </div>
    <div>
     <ul>
      <li>
       <p>
        <del><strong>Variable Not Hoisting</strong></del></p>
       <p>
        <del><code>let</code> will <strong>not hoist</strong> to the entire scope of the block they appear in. By contrast, <code>var</code> could hoist as below.</del></p>
       <pre><code>{
   console.log(cc); // undefined. Caused by hoisting
   var cc = 23;
}

{
   console.log(bb); // ReferenceError: bb is not defined
   let bb = 23;
}
</code></pre>
       <p>Actually, Per @Bergi, <a href="https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6">Both <code>var</code> and <code>let</code> are hoisted</a>.</p></li>
      <li>
       <p><strong>Garbage Collection</strong></p>
       <p>Block scope of <code>let</code> is useful relates to closures and garbage collection to reclaim memory. Consider,</p>
       <pre><code>function process(data) {
    //...
}

var hugeData = { .. };

process(hugeData);

var btn = document.getElementById("mybutton");
btn.addEventListener( "click", function click(evt){
    //....
});
</code></pre>
       <p>The <code>click</code> handler callback does not need the <code>hugeData</code> variable at all. Theoretically, after <code>process(..)</code> runs, the huge data structure <code>hugeData</code> could be garbage collected. However, it's possible that some JS engine will still have to keep this huge structure, since the <code>click</code> function has a closure over the entire scope.</p>
       <p>However, the block scope can make this huge data structure to garbage collected.</p>
       <pre><code>function process(data) {
    //...
}

{ // anything declared inside this block can be garbage collected
    let hugeData = { .. };
    process(hugeData);
}

var btn = document.getElementById("mybutton");
btn.addEventListener( "click", function click(evt){
    //....
});
</code></pre></li>
      <li>
       <p><strong><code>let</code> loops</strong></p>
       <p><code>let</code> in the loop can <strong>re-binds it</strong> to each iteration of the loop, making sure to re-assign it the value from the end of the previous loop iteration. Consider,</p>
       <pre><code>// print '5' 5 times
for (var i = 0; i &lt; 5; ++i) {
    setTimeout(function () {
        console.log(i);
    }, 1000);  
}
</code></pre>
       <p>However, replace <code>var</code> with <code>let</code></p>
       <pre><code>// print 1, 2, 3, 4, 5. now
for (let i = 0; i &lt; 5; ++i) {
    setTimeout(function () {
        console.log(i);
    }, 1000);  
}
</code></pre>
       <p>Because <code>let</code> create a new lexical environment with those names for a) the initialiser expression b) each iteration (previosly to evaluating the increment expression), more details are <a href="https://stackoverflow.com/a/30900289/3011380">here</a>.</p></li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>6</td>
        <td><span>Yip they are hoisted, but behave as if not hoisted because of the (drum roll) Temporal Dead Zone - a very dramatic name for an identifier not being accessible until it's declared:-)</span> <span> - </span> <span class="display-name">Drenai</span> <span> </span> <span class="date">31 Dec 2016 at 15:42</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>33</span>
     </div>
     <div>
      <span>Answerer: </span> <span>mormegil</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 May 2017 at 01:09</span>
     </div>
    </div>
    <div>
     <p>The difference is in the <a href="https://en.wikipedia.org/wiki/Variable_(computer_science)#Scope_and_extent" rel="noreferrer">scope</a> of the variables declared with each.</p>
     <p>In practice, there are a number of useful consequences of the difference in scope:</p>
     <ol>
      <li><code>let</code> variables are only visible in their <em>nearest enclosing</em> block (<code>{ ... }</code>).</li>
      <li><code>let</code> variables are only usable in lines of code that occur <em>after</em> the variable is declared (even though <a href="/questions/33198849">they are hoisted</a>!).</li>
      <li><code>let</code> variables may not be redeclared by a subsequent <code>var</code> or <code>let</code>.</li>
      <li>Global <code>let</code> variables are not added to the global <code>window</code> object.</li>
      <li><code>let</code> variables are <em>easy to use</em> with closures (they do not cause <a href="https://en.wikipedia.org/wiki/Race_condition#Software" rel="noreferrer">race conditions</a>).</li>
     </ol>
     <p>The restrictions imposed by <code>let</code> reduce the visibility of the variables and increase the likelihood that unexpected name collisions will be found early. This makes it easier to track and reason about variables, including their <a href="https://en.wikipedia.org/wiki/Unreachable_memory" rel="noreferrer">reachability</a>(helping with reclaiming unused memory).</p>
     <p>Consequently, <code>let</code> variables are less likely to cause problems when used in large programs or when independently-developed frameworks are combined in new and unexpected ways.</p>
     <p><code>var</code> may still be useful if you are sure you want the single-binding effect when using a closure in a loop (#5) or for declaring externally-visible global variables in your code (#4). Use of <code>var</code> for exports may be supplanted if <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export" rel="noreferrer"><code>export</code></a> migrates out of transpiler space and into the core language.</p>
     <h1>Examples</h1>
     <p><strong>1. No use outside nearest enclosing block:</strong> This block of code will throw a reference error because the second use of <code>x</code> occurs outside of the block where it is declared with <code>let</code>:</p>
     <pre><code>{
    let x = 1;
}
console.log(`x is ${x}`);  // ReferenceError during parsing: "x is not defined".
</code></pre>
     <p>In contrast, the same example with <code>var</code> works.</p>
     <p><strong>2. No use before declaration:</strong><br>
       This block of code will throw a <code>ReferenceError</code> before the code can be run because <code>x</code> is used before it is declared:</p>
     <pre><code>{
    x = x + 1;  // ReferenceError during parsing: "x is not defined".
    let x;
    console.log(`x is ${x}`);  // Never runs.
}
</code></pre>
     <p>In contrast, the same example with <code>var</code> parses and runs without throwing any exceptions.</p>
     <p><strong>3. No redeclaration:</strong> The following code demonstrates that a variable declared with <code>let</code> may not be redeclared later:</p>
     <pre><code>let x = 1;
let x = 2;  // SyntaxError: Identifier 'x' has already been declared
</code></pre>
     <p><strong>4. Globals not attached to <code>window</code>:</strong></p>
     <pre><code>var button = "I cause accidents because my name is too common.";
let link = "Though my name is common, I am harder to access from other JS files.";
console.log(link);  // OK
console.log(window.link);  // undefined (GOOD!)
console.log(window.button);  // OK
</code></pre>
     <p><strong>5. Easy use with closures:</strong> Variables declared with <code>var</code> do not work well with closures inside loops. Here is a simple loop that outputs the sequence of values that the variable <code>i</code> has at different points in time:</p>
     <pre><code>for (let i = 0; i &lt; 5; i++) {
    console.log(`i is ${i}`), 125/*ms*/);
}
</code></pre>
     <p>Specifically, this outputs:</p>
     <pre><code>i is 0
i is 1
i is 2
i is 3
i is 4
</code></pre>
     <p>In JavaScript we often use variables at a significantly later time than when they are created. When we demonstrate this by delaying the output with a closure passed to <code>setTimeout</code>:</p>
     <pre><code>for (let i = 0; i &lt; 5; i++) {
    setTimeout(_ =&gt; console.log(`i is ${i}`), 125/*ms*/);
}
</code></pre>
     <p>... the output remains unchanged as long as we stick with <code>let</code>. In contrast, if we had used <code>var i</code> instead:</p>
     <pre><code>for (var i = 0; i &lt; 5; i++) {
    setTimeout(_ =&gt; console.log(`i is ${i}`), 125/*ms*/);
}
</code></pre>
     <p>... the loop unexpectedly outputs "i is 5" five times:</p>
     <pre><code>i is 5
i is 5
i is 5
i is 5
i is 5
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>11</td>
        <td><span>#5 is not caused by a race condition. By using <code>var</code> instead of <code>let</code>, the code is equivalent to: <code>var i = 0; while (i &lt; 5) { doSomethingLater(); i++; }</code> <code>i</code> is outside the closure, and by the time that <code>doSomethingLater()</code> is executed, <code>i</code> has already been incremented 5 times, hence the output is <code>i is 5</code> five times. By using <code>let</code>, the variable <code>i</code> is within the closure, so each async call gets its own copy of <code>i</code> instead of using the 'global' one that's created with <code>var</code>.</span> <span> - </span> <span class="display-name">Daniel T.</span> <span> </span> <span class="date">2 Jun 2017 at 01:12</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@DanielT.: I don't think the transformation of lifting the variable definition out of the loop initializer explains anything. That is simply the normal definition of the semantics of <code>for</code>. A more accurate transformation, though more complicated, is the classical <code>for (var i = 0; i &lt; 5; i++) { (function(j) { setTimeout(_ =&gt; console.log(</code>i is ${j}<code>), 125/*ms*/); })(i); }</code> which introduces a "function-activation record" to save each value of <code>i</code> with the name of <code>j</code> inside the function.</span> <span> - </span> <span class="display-name">mormegil</span> <span> </span> <span class="date">25 Jul 2017 at 07:13</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>27</span>
     </div>
     <div>
      <span>Answerer: </span> <span>abroz</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Aug 2014 at 00:58</span>
     </div>
    </div>
    <div>
     <p>Here's an example to add on to what others have already written. Suppose you want to make an array of functions, <code>adderFunctions</code>, where each function takes a single Number argument and returns the sum of the argument and the function's index in the array. Trying to generate <code>adderFunctions</code> with a loop using the <code>var</code> keyword won't work the way someone might naïvely expect:</p>
     <pre><code>// An array of adder functions.
var adderFunctions = [];

for (var i = 0; i &lt; 1000; i++) {
  // We want the function at index i to add the index to its argument.
  adderFunctions[i] = function(x) {
    // What is i bound to here?
    return x + i;
  };
}

var add12 = adderFunctions[12];

// Uh oh. The function is bound to i in the outer scope, which is currently 1000.
console.log(add12(8) === 20); // =&gt; false
console.log(add12(8) === 1008); // =&gt; true
console.log(i); // =&gt; 1000

// It gets worse.
i = -8;
console.log(add12(8) === 0); // =&gt; true
</code></pre>
     <p>The process above doesn't generate the desired array of functions because <code>i</code>'s scope extends beyond the iteration of the <code>for</code> block in which each function was created. Instead, at the end of the loop, the <code>i</code> in each function's closure refers to <code>i</code>'s value at the end of the loop (1000) for every anonymous function in <code>adderFunctions</code>. This isn't what we wanted at all: we now have an array of 1000 different functions in memory with exactly the same behavior. And if we subsequently update the value of <code>i</code>, the mutation will affect all the <code>adderFunctions</code>.</p>
     <p>However, we can try again using the <code>let</code> keyword:</p>
     <pre><code>// Let's try this again.
// NOTE: We're using another ES6 keyword, const, for values that won't
// be reassigned. const and let have similar scoping behavior.
const adderFunctions = [];

for (let i = 0; i &lt; 1000; i++) {
  // NOTE: We're using the newer arrow function syntax this time, but 
  // using the "function(x) { ..." syntax from the previous example 
  // here would not change the behavior shown.
  adderFunctions[i] = x =&gt; x + i;
}

const add12 = adderFunctions[12];

// Yay! The behavior is as expected. 
console.log(add12(8) === 20); // =&gt; true

// i's scope doesn't extend outside the for loop.
console.log(i); // =&gt; ReferenceError: i is not defined
</code></pre>
     <p>This time, <code>i</code> is rebound on each iteration of the <code>for</code> loop. Each function now keeps the value of <code>i</code> at the time of the function's creation, and <code>adderFunctions</code> behaves as expected.</p>
     <p>Now, image mixing the two behaviors and you'll probably see why it's not recommended to mix the newer <code>let</code> and <code>const</code> with the older <code>var</code> in the same script. Doing so can result is some spectacularly confusing code.</p>
     <pre><code>const doubleAdderFunctions = [];

for (var i = 0; i &lt; 1000; i++) {
    const j = i;
    doubleAdderFunctions[i] = x =&gt; x + i + j;
}

const add18 = doubleAdderFunctions[9];
const add24 = doubleAdderFunctions[12];

// It's not fun debugging situations like this, especially when the
// code is more complex than in this example.
console.log(add18(24) === 42); // =&gt; false
console.log(add24(18) === 42); // =&gt; false
console.log(add18(24) === add24(18)); // =&gt; false
console.log(add18(24) === 2018); // =&gt; false
console.log(add24(18) === 2018); // =&gt; false
console.log(add18(24) === 1033); // =&gt; true
console.log(add24(18) === 1030); // =&gt; true
</code></pre>
     <p>Don't let this happen to you. Use a linter.</p>
     <blockquote>
      <p><strong>NOTE:</strong> This is a teaching example intended to demonstrate the <code>var</code>/<code>let</code> behavior in loops and with function closures that would also be easy to understand. This would be a terrible way to add numbers. But the general technique of capturing data in anonymous function closures might be encountered in the real world in other contexts. YMMV.</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>@aborz: Also very cool anonymous function syntax in the second example. It's just what I'm used to in C#. I've learned something today.</span> <span> - </span> <span class="display-name">Barton</span> <span> </span> <span class="date">20 Feb 2015 at 08:59</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Correction: Technically, Arrow function syntax described here =&gt; <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="nofollow noreferrer">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/…</a></span> <span> - </span> <span class="display-name">Barton</span> <span> </span> <span class="date">16 Mar 2015 at 06:58</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>Actually, you don't need <code>let value = i;</code>. The <code>for</code> statement creates a lexical block.</span> <span> - </span> <span class="display-name">Toothbrush</span> <span> </span> <span class="date">22 Oct 2015 at 22:38</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span> <span class="arrow"> <a href="#answer_15">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>24</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Abdennour TOUMI</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Dec 2015 at 03:22</span>
     </div>
    </div>
    <div>
     <p>May the following two functions show the difference:</p>
     <pre><code>function varTest() {
    var x = 31;
    if (true) {
        var x = 71;  // Same variable!
        console.log(x);  // 71
    }
    console.log(x);  // 71
}

function letTest() {
    let x = 31;
    if (true) {
        let x = 71;  // Different variable
        console.log(x);  // 71
    }
    console.log(x);  // 31
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_15"><span>Answer 15</span> <span class="arrow"> <a href="#answer_14">↑</a> </span> <span class="arrow"> <a href="#answer_16">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>20</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Srikrushna</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Jan 2020 at 11:39</span>
     </div>
    </div>
    <div>
     <p>ES6 introduced two new keyword(<strong>let</strong> and <strong>const</strong>) alternate to <strong>var</strong>.</p>
     <p>When you need a block level deceleration you can go with let and const instead of var.</p>
     <p>The below table summarize the difference between var, let and const</p>
     <p><a href="https://i.stack.imgur.com/GBn5a.jpg" rel="noreferrer"><img src="/question/stackoverflow/762011/GBn5a.jpg" alt="enter image description here"></a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>9</td>
        <td><span>The hoisted column is incorrect. They all hoist variable. The difference with <code>var</code> is that they hoist but do not initialize to the <code>undefined</code> value. If they did not hoist, they would not mask variables of the same name in enclosing blocks: <a href="https://stackoverflow.com/q/63337235/2326961">stackoverflow.com/q/63337235/2326961</a></span> <span> - </span> <span class="display-name">Géry Ogam</span> <span> </span> <span class="date">11 Aug 2020 at 09:43</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_16"><span>Answer 16</span> <span class="arrow"> <a href="#answer_15">↑</a> </span> <span class="arrow"> <a href="#answer_17">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>19</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Willem van der Veen</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Sep 2018 at 13:08</span>
     </div>
    </div>
    <div>
     <h2>Function VS block scope:</h2>
     <p>The main difference between <code>var</code> and <code>let</code> is that variables declared with <code>var</code> are <strong>function scoped</strong>. Whereas functions declared with <code>let</code> are <strong>block scoped</strong>. For example:</p>
     <pre><code>function testVar () {
  if(true) {
    var foo = 'foo';
  }

  console.log(foo);
}

testVar();  
// logs 'foo'


function testLet () {
  if(true) {
    let bar = 'bar';
  }

  console.log(bar);
}

testLet(); 
// reference error
// bar is scoped to the block of the if statement 
</code></pre>
     <p><strong>variables with <code>var</code>:</strong></p>
     <p>When the first function <code>testVar</code> gets called the variable foo, declared with <code>var</code>, is still accessible outside the <code>if</code> statement. This variable <code>foo</code> would be available <strong>everywhere</strong> within the scope of the <code>testVar</code> <strong>function</strong>.</p>
     <p><strong>variables with <code>let</code>:</strong></p>
     <p>When the second function <code>testLet</code> gets called the variable bar, declared with <code>let</code>, is only accessible inside the <code>if</code> statement. Because variables declared with <code>let</code> are <strong>block scoped</strong> (where a block is the code between curly brackets e.g <code>if{}</code> , <code>for{}</code>, <code>function{}</code>).</p>
     <h2><code>let</code> variables don't get hoisted:</h2>
     <p>Another difference between <code>var</code> and <code>let</code> is variables with declared with <code>let</code> <strong>don't get hoisted</strong>. An example is the best way to illustrate this behavior:</p>
     <p>variables with <code>let</code> <strong>don't</strong> get hoisted:</p>
     <pre><code>console.log(letVar);

let letVar = 10;
// referenceError, the variable doesn't get hoisted
</code></pre>
     <p>variables with <code>var</code> <strong>do</strong> get hoisted:</p>
     <pre><code>console.log(varVar);

var varVar = 10;
// logs undefined, the variable gets hoisted
</code></pre>
     <h2>Global <code>let</code> doesn't get attached to <code>window</code>:</h2>
     <p>A variable declared with <code>let</code> in the global scope (which is code that is not in a function) doesn't get added as a property on the global <code>window</code> object. For example (this code is in global scope):</p>
     <pre><code>var bar = 5;
let foo  = 10;

console.log(bar); // logs 5
console.log(foo); // logs 10

console.log(window.bar);  
// logs 5, variable added to window object

console.log(window.foo);
// logs undefined, variable not added to window object
</code></pre>
     <p><br></p>
     <blockquote>
      <p><strong>When should <code>let</code> be used over <code>var</code>?</strong></p>
     </blockquote>
     <p>Use <code>let</code> over <code>var</code> whenever you can because it is simply scoped more specific. This reduces potential naming conflicts which can occur when dealing with a large number of variables. <code>var</code> can be used when you want a global variable explicitly to be on the <code>window</code> object (always consider carefully if this is really necessary).</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_17"><span>Answer 17</span> <span class="arrow"> <a href="#answer_16">↑</a> </span> <span class="arrow"> <a href="#answer_18">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>18</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ran Turner</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Jan 2022 at 18:20</span>
     </div>
    </div>
    <div>
     <p>This explanation is taken from an article I wrote at <a href="https://blog.devgenius.io/how-does-hoisting-in-javascript-works-80614300cb98" rel="nofollow noreferrer">Medium</a>:</p>
     <blockquote>
      <p>Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their scope by the parser which reads the source code into an intermediate representation before the actual code execution starts by the JavaScript interpreter. So, it actually doesn’t matter where variables or functions are declared, they will be moved to the top of their scope regardless of whether their scope is global or local. This means that</p>
      <pre><code>console.log (hi);     
var hi = "say hi";
</code></pre>
      <p>is actually interpreted to</p>
      <pre><code>var hi = undefined;
console.log (hi);
hi = "say hi";
</code></pre>
      <p>So, as we saw just now, <code>var</code> variables are being hoisted to the top of their scope and are being initialized with the value of undefined which means that we can actually assign their value before actually declaring them in the code like so:</p>
      <pre><code>hi = “say hi”
console.log (hi); // say hi
var hi;
</code></pre>
      <p>Regarding function declarations, we can invoke them before actually declaring them like so:</p>
      <pre><code>sayHi(); // Hi

function sayHi() {
   console.log('Hi');
};
</code></pre>
      <p>Function expressions, on the other hand, are not hoisted, so we’ll get the following error:</p>
      <pre><code>sayHi(); //Output: "TypeError: sayHi is not a function

var sayHi = function() {
  console.log('Hi');
}; 
</code></pre>
      <p>ES6 introduced JavaScript developers the <code>let</code> and <code>const</code> keywords. While <code>let</code> and <code>const</code> are block-scoped and not function scoped as <code>var</code> it shouldn’t make a difference while discussing their hoisting behavior. We’ll start from the end, JavaScript hoists <code>let</code> and <code>const</code>.</p>
      <pre><code>console.log(hi); // Output: Cannot access 'hi' before initialization 
let hi = 'Hi';
</code></pre>
      <p>As we can see above, <code>let</code> doesn’t allow us to use undeclared variables, hence the interpreter explicitly output a reference error indicating that the <code>hi</code> variable cannot be accessed before initialization. The same error will occur if we change the above <code>let</code> to <code>const</code></p>
      <pre><code>console.log(hi); // Output: Cannot access 'hi' before initialization
const hi = 'Hi';
</code></pre>
      <p>So, bottom line, the JavaScript parser searches for variable declarations and functions and hoists them to the top of their scope before code execution and assign values to them in the memory so in case the interpreter will encounter them while executing the code he will recognize them and will be able to execute the code with their assigned values. Variables declared with <code>let</code> or <code>const</code> remain uninitialized at the beginning of execution while that variables declared with <code>var</code> are being initialized with a value of <code>undefined</code>.</p>
      <p>I added this visual illustration to better help understanding of how are the hoisted variables and function are being saved in the memory <a href="https://i.stack.imgur.com/7aRxL.png" rel="nofollow noreferrer"><img src="/question/stackoverflow/762011/7aRxL.png" alt="enter image
description here"></a></p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Proper attribution for quoted content is required on Stack Overflow. This includes explicit disclosure of affiliation and clearly displaying when content is copied from another location... even if you are the author.</span> <span> - </span> <span class="display-name">TylerH</span> <span> </span> <span class="date">11 Feb 2022 at 14:28</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_18"><span>Answer 18</span> <span class="arrow"> <a href="#answer_17">↑</a> </span> <span class="arrow"> <a href="#answer_19">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>17</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Dmytro</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Jul 2016 at 00:21</span>
     </div>
    </div>
    <div>
     <p><code>let</code> is interesting, because it allows us to do something like this:</p>
     <pre><code>(() =&gt; {
    var count = 0;

    for (let i = 0; i &lt; 2; ++i) {
        for (let i = 0; i &lt; 2; ++i) {
            for (let i = 0; i &lt; 2; ++i) {
                console.log(count++);
            }
        }
    }
})();
</code></pre>
     <p>Which results in counting [0, 7].</p>
     <p>Whereas</p>
     <pre><code>(() =&gt; {
    var count = 0;

    for (var i = 0; i &lt; 2; ++i) {
        for (var i = 0; i &lt; 2; ++i) {
            for (var i = 0; i &lt; 2; ++i) {
                console.log(count++);
            }
        }
    }
})();
</code></pre>
     <p>Only counts [0, 1].</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>yes, it adds much more confusion than necessary and where there should be none.</span> <span> - </span> <span class="display-name">Bekim Bacaj</span> <span> </span> <span class="date">4 Oct 2021 at 19:27</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Bekim Bacaj This is a contrived example illustrating a distinction between let and var. That is, at the end of the loop, the variable declared by let goes out of scope, whereas var remains. It is up to the programmer to decide which constructs they opt to incorporate into their code, based on their intent, and prior experience. The intent of this example is not to cause confusion, but to give the reader a starting point to play with the let construct in creative ways to familiarize themselves with it.</span> <span> - </span> <span class="display-name">Dmytro</span> <span> </span> <span class="date">6 Oct 2021 at 02:29</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_19"><span>Answer 19</span> <span class="arrow"> <a href="#answer_18">↑</a> </span> <span class="arrow"> <a href="#answer_20">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>16</span>
     </div>
     <div>
      <span>Answerer: </span> <span>RDoc</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Aug 2015 at 00:35</span>
     </div>
    </div>
    <div>
     <p>It also appears that, at least in Visual Studio 2015, TypeScript 1.5, "var" allows multiple declarations of the same variable name in a block, and "let" doesn't.</p>
     <p>This won't generate a compile error:</p>
     <pre><code>var x = 1;
var x = 2;
</code></pre>
     <p>This will:</p>
     <pre><code>let x = 1;
let x = 2;
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_20"><span>Answer 20</span> <span class="arrow"> <a href="#answer_19">↑</a> </span> <span class="arrow"> <a href="#answer_21">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>14</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Kasun</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Sep 2022 at 10:48</span>
     </div>
    </div>
    <div>
     <pre><code>var   --&gt; Function scope  
let   --&gt; Block scope
const --&gt; Block scope
</code></pre>
     <p><strong>var</strong></p>
     <p>In this code sample, variable <code>i</code> is declared using <code>var</code>. Therefore, it has a <em>function scope</em>. It means you can access <code>i</code> from only inside the <code>function x</code>. You can't read it from outside the <code>function x</code></p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function x(){
  var i = 100;
  console.log(i); // 100
}
 
console.log(i); // Error. You can't do this

x();</code></pre>
      </div>
     </div>
     <p></p>
     <p>In this sample, you can see <code>i</code> is declared inside a <code>if</code> block. But it's declared using <code>var</code>. Therefore, it gets function scope. It means still you can access variable <code>i</code> inside <code>function x</code>. Because <code>var</code> always get scoped to functions. Even though variable <code>i</code> is declared inside <code>if</code> block, because of it's using <code>var</code> it get scoped to parent <code>function x</code>.</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function x(){
  if(true){
    var i = 100;
  }
  console.log(i); 
}

x();</code></pre>
      </div>
     </div>
     <p></p>
     <p>Now variable <code>i</code> is declared inside the <code>function y</code>. Therefore, <code>i</code> scoped to <code>function y</code>. You can access <code>i</code> inside <code>function y</code>. But not from outside <code>function y</code>.</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function x(){
  function y(){
    var i = 100;
    console.log(i);
  }
  
  y();
}

x();</code></pre>
      </div>
     </div>
     <p></p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function x(){
  function y(){
    var i = 100;
  }
  console.log(i); // ERROR
}

x();</code></pre>
      </div>
     </div>
     <p></p>
     <p><strong>let, const</strong></p>
     <p>let and const has block scope.</p>
     <p><code>const</code> and <code>let</code> behave same. But the difference is, when you assign value to <code>const</code> you can't re-assign. But you can re-assign values with <code>let</code>.</p>
     <p>In this example, variable <code>i</code> is declared inside an <code>if</code> block. So it can be only accessed from inside that <code>if</code> block. We can't access it from outside that <code>if</code> block. (here <code>const</code> work same as <code>let</code>)</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>if(true){
  let i = 100;
  console.log(i); // Output: 100
}

console.log(i); // Error</code></pre>
      </div>
     </div>
     <p></p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function x(){
  if(true){
    let i = 100;
    console.log(i); // Output: 100
  }
  console.log(i); // Error
}

x();</code></pre>
      </div>
     </div>
     <p></p>
     <p>Another difference with <code>(let, const)</code> vs <code>var</code> is you can access <code>var</code> defined variable before declaring it. It will give you <code>undefined</code>. But if you do that with <code>let</code> or <code>const</code> defined variable it will give you an error.</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>console.log(x);
var x = 100;</code></pre>
      </div>
     </div>
     <p></p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>console.log(x); // ERROR
let x = 100;</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_21"><span>Answer 21</span> <span class="arrow"> <a href="#answer_20">↑</a> </span> <span class="arrow"> <a href="#answer_22">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>12</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Moslem Shahsavan</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Oct 2017 at 12:42</span>
     </div>
    </div>
    <div>
     <p><code>var</code> is global scope (hoist-able) variable.</p>
     <p><code>let</code> and <code>const</code> is block scope.</p>
     <blockquote>
      <p>test.js</p>
     </blockquote>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>{
    let l = 'let';
    const c = 'const';
    var v = 'var';
    v2 = 'var 2';
}

console.log(v, this.v);
console.log(v2, this.v2);
console.log(l); // ReferenceError: l is not defined
console.log(c); // ReferenceError: c is not defined</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_22"><span>Answer 22</span> <span class="arrow"> <a href="#answer_21">↑</a> </span> <span class="arrow"> <a href="#answer_23">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>11</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Daniel Sokolowski</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Oct 2016 at 05:01</span>
     </div>
    </div>
    <div>
     <p>If I read the specs right then <code>let</code> <strong>thankfully</strong> can also be leveraged to avoid <a href="https://stackoverflow.com/questions/592396/what-is-the-purpose-of-a-self-executing-function-in-javascript#592414">self invoking functions</a> used to simulate private only members - <em>a popular design pattern that decreases code readability, complicates debugging, that adds no real code protection or other benefit - except maybe satisfying someone's desire for semantics, so stop using it. /rant</em></p>
     <pre><code>var SomeConstructor;

{
    let privateScope = {};

    SomeConstructor = function SomeConstructor () {
        this.someProperty = "foo";
        privateScope.hiddenProperty = "bar";
    }

    SomeConstructor.prototype.showPublic = function () {
        console.log(this.someProperty); // foo
    }

    SomeConstructor.prototype.showPrivate = function () {
        console.log(privateScope.hiddenProperty); // bar
    }

}

var myInstance = new SomeConstructor();

myInstance.showPublic();
myInstance.showPrivate();

console.log(privateScope.hiddenProperty); // error
</code></pre>
     <p>See '<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let#Emulating_private_interfaces" rel="noreferrer">Emulating private interfaces</a>'</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Can you elaborate on how Immediately Invoked Function Expressions do not provide “code protection” and <code>let</code> does? (I assume you mean IIFE with “self invoking function”.)</span> <span> - </span> <span class="display-name">Robert Siemer</span> <span> </span> <span class="date">1 Mar 2020 at 03:58</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>And why do you set <code>hiddenProperty</code> in the constructor? There is only one <code>hiddenProperty</code> for all instances in your “class”.</span> <span> - </span> <span class="display-name">Robert Siemer</span> <span> </span> <span class="date">1 Mar 2020 at 12:52</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_23"><span>Answer 23</span> <span class="arrow"> <a href="#answer_22">↑</a> </span> <span class="arrow"> <a href="#answer_24">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>9</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ankur Soni</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 May 2018 at 13:12</span>
     </div>
    </div>
    <div>
     <p><strong>When Using <code>let</code></strong></p>
     <p>The <code>let</code> keyword attaches the variable declaration to the scope of whatever block (commonly a <code>{ .. }</code> pair) it's contained in. In other words,<code>let</code> implicitly hijacks any block's scope for its variable declaration.</p>
     <p><code>let</code> variables cannot be accessed in the <code>window</code> object because they cannot be globally accessed.</p>
     <pre><code>function a(){
    { // this is the Max Scope for let variable
        let x = 12;
    }
    console.log(x);
}
a(); // Uncaught ReferenceError: x is not defined
</code></pre>
     <p><strong>When Using <code>var</code></strong></p>
     <p><code>var</code> and variables in ES5 has scopes in functions meaning the variables are valid within the function and not outside the function itself.</p>
     <p><code>var</code> variables can be accessed in the <code>window</code> object because they cannot be globally accessed.</p>
     <pre><code>function a(){ // this is the Max Scope for var variable
    { 
        var x = 12;
    }
    console.log(x);
}
a(); // 12
</code></pre>
     <p><strong>If you want to know more continue reading below</strong></p>
     <p>one of the most famous interview questions on scope also can suffice the exact use of <code>let</code> and <code>var</code> as below;</p>
     <p><strong>When using <code>let</code></strong></p>
     <pre><code>for (let i = 0; i &lt; 10 ; i++) {
    setTimeout(
        function a() {
            console.log(i); //print 0 to 9, that is literally AWW!!!
        }, 
        100 * i);
}
</code></pre>
     <p>This is because when using <code>let</code>, for every loop iteration the variable is scoped and has its own copy.</p>
     <p><strong>When using <code>var</code></strong></p>
     <pre><code>for (var i = 0; i &lt; 10 ; i++) {
    setTimeout(
        function a() {
            console.log(i); //print 10 times 10
        }, 
        100 * i);
}
</code></pre>
     <p>This is because when using <code>var</code>, for every loop iteration the variable is scoped and has shared copy.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_24"><span>Answer 24</span> <span class="arrow"> <a href="#answer_23">↑</a> </span> <span class="arrow"> <a href="#answer_25">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>zloctb</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Jul 2016 at 17:42</span>
     </div>
    </div>
    <div>
     <p>Some hacks with <code>let</code>:</p>
     <p>1.</p>
     <pre><code>    let statistics = [16, 170, 10];
    let [age, height, grade] = statistics;

    console.log(height)
</code></pre>
     <p>2.</p>
     <pre><code>    let x = 120,
    y = 12;
    [x, y] = [y, x];
    console.log(`x: ${x} y: ${y}`);
</code></pre>
     <p>3.</p>
     <pre><code>    let node = {
                   type: "Identifier",
                   name: "foo"
               };

    let { type, name, value } = node;

    console.log(type);      // "Identifier"
    console.log(name);      // "foo"
    console.log(value);     // undefined

    let node = {
        type: "Identifier"
    };

    let { type: localType, name: localName = "bar" } = node;

    console.log(localType);     // "Identifier"
    console.log(localName);     // "bar"
</code></pre>
     <h3>Getter and setter with <code>let</code>:</h3>
     <pre><code>let jar = {
    numberOfCookies: 10,
    get cookies() {
        return this.numberOfCookies;
    },
    set cookies(value) {
        this.numberOfCookies = value;
    }
};

console.log(jar.cookies)
jar.cookies = 7;

console.log(jar.cookies)
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>please what do this mean <code>let { type, name, value } = node;</code> ? you create a new object with 3 properties type/name/value and initialise them with the properties values from node ?</span> <span> - </span> <span class="display-name">AlainIb</span> <span> </span> <span class="date">15 Jun 2017 at 07:55</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>In example 3 you are re-declaring node which cause exception. These all examples also work perfectly with <code>var</code> too.</span> <span> - </span> <span class="display-name">Rehan Haider</span> <span> </span> <span class="date">9 Jan 2019 at 10:57</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This doesn't answer the question; it could benefit from an explanation as to what each block of code is doing.</span> <span> - </span> <span class="display-name">TylerH</span> <span> </span> <span class="date">13 Apr 2021 at 18:50</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_25"><span>Answer 25</span> <span class="arrow"> <a href="#answer_24">↑</a> </span> <span class="arrow"> <a href="#answer_26">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>daCoda</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Apr 2019 at 00:49</span>
     </div>
    </div>
    <div>
     <p>let vs var. It's all about <strong>scope</strong>.</p>
     <p><strong>var variables are global</strong> and can be accessed basically everywhere, while <strong>let variables are not global</strong> and only exist until a closing parenthesis kills them.</p>
     <p>See my example below, and note how the lion (let) variable acts differently in the two console.logs; it becomes out of scope in the 2nd console.log.</p>
     <pre><code>var cat = "cat";
let dog = "dog";

var animals = () =&gt; {
    var giraffe = "giraffe";
    let lion = "lion";

    console.log(cat);  //will print 'cat'.
    console.log(dog);  //will print 'dog', because dog was declared outside this function (like var cat).

    console.log(giraffe); //will print 'giraffe'.
    console.log(lion); //will print 'lion', as lion is within scope.
}

console.log(giraffe); //will print 'giraffe', as giraffe is a global variable (var).
console.log(lion); //will print UNDEFINED, as lion is a 'let' variable and is now out of scope.
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_26"><span>Answer 26</span> <span class="arrow"> <a href="#answer_25">↑</a> </span> <span class="arrow"> <a href="#answer_27">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Sarvar Nishonboyev</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Oct 2020 at 17:15</span>
     </div>
    </div>
    <div>
     <p>I just came across one use case that I had to use <code>var</code> over <code>let</code> to introduce new variable. Here's a case:</p>
     <p>I want to create a new variable with dynamic variable names.</p>
     <pre><code>let variableName = 'a';
eval("let " + variableName + '= 10;');
console.log(a);   // this doesn't work
</code></pre>
     <pre><code>var variableName = 'a';
eval("var " + variableName + '= 10;');
console.log(a);   // this works
</code></pre>
     <p>The above code doesn't work because <code>eval</code> introduces a new block of code. The declaration using <code>var</code> will declare a variable outside of this block of code since <code>var</code> declares a variable in the function scope.</p>
     <p><code>let</code>, on the other hand, declares a variable in a block scope. So, <code>a</code> variable will only be visible in <code>eval</code> block.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>When will you ever have to create a dynamic variable name, and have to access it later? It is so much better to create an object and assign keys and values to it.</span> <span> - </span> <span class="display-name">user14029620</span> <span> </span> <span class="date">9 Nov 2020 at 19:18</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>In fact, that's because the re-declaration of a JavaScript <code>let</code> <b>proposition</b> is not allowed.</span> <span> - </span> <span class="display-name">Bekim Bacaj</span> <span> </span> <span class="date">4 Oct 2021 at 17:46</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_27"><span>Answer 27</span> <span class="arrow"> <a href="#answer_26">↑</a> </span> <span class="arrow"> <a href="#answer_28">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Piklu Dey</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Sep 2019 at 11:25</span>
     </div>
    </div>
    <div>
     <p>The below shows how 'let' and 'var' are different in the scope:</p>
     <pre><code>let gfoo = 123;
if (true) {
    let gfoo = 456;
}
console.log(gfoo); // 123

var hfoo = 123;
if (true) {
    var hfoo = 456;
}
console.log(hfoo); // 456
</code></pre>
     <p>The <code>gfoo</code>, defined by <code>let</code> initially is in the <strong>global scope</strong>, and when we declare <code>gfoo</code> again inside the <code>if clause</code> its <strong><em>scope changed</em></strong> and when a new value is assigned to the variable inside that scope it <strong>does not affect</strong> the global scope.</p>
     <p>Whereas <code>hfoo</code>, defined by <code>var</code> is initially in the <strong>global scope</strong>, but again when we declare it inside the <code>if clause</code>, it considers the global scope hfoo, although var has been used again to declare it. And when we re-assign its value we see that the global scope hfoo is also affected. This is the primary difference.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_28"><span>Answer 28</span> <span class="arrow"> <a href="#answer_27">↑</a> </span> <span class="arrow"> <a href="#answer_29">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Vipul Jain</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Dec 2017 at 10:47</span>
     </div>
    </div>
    <div>
     <p>let is a part of es6. These functions will explain the difference in easy way.</p>
     <pre><code>function varTest() {
  var x = 1;
  if (true) {
    var x = 2;  // same variable!
    console.log(x);  // 2
  }
  console.log(x);  // 2
}

function letTest() {
  let x = 1;
  if (true) {
    let x = 2;  // different variable
    console.log(x);  // 2
  }
  console.log(x);  // 1
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_29"><span>Answer 29</span> <span class="arrow"> <a href="#answer_28">↑</a> </span> <span class="arrow"> <a href="#answer_30">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>N Randhawa</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Aug 2018 at 10:25</span>
     </div>
    </div>
    <div>
     <p>As mentioned above:</p>
     <blockquote>
      <p>The difference is scoping. <code>var</code> is scoped to the nearest <strong>function block</strong> and <code>let</code> is scoped to the <strong>nearest enclosing block</strong>, which can be smaller than a function block. Both are global if outside any block.Lets see an example:</p>
     </blockquote>
     <p><strong>Example1:</strong></p>
     <p>In my both examples I have a function <code>myfunc</code>. <code>myfunc</code> contains a variable <code>myvar</code> equals to 10. In my first example I check if <code>myvar</code> equals to 10 (<code>myvar==10</code>) . If yes, I agian declare a variable <code>myvar</code> (now I have two myvar variables)using <code>var</code> keyword and assign it a new value (20). In next line I print its value on my console. After the conditional block I again print the value of <code>myvar</code> on my console. If you look at the output of <code>myfunc</code>, <code>myvar</code> has value equals to 20.</p>
     <p><a href="https://i.stack.imgur.com/sWpnR.png" rel="nofollow noreferrer"><img src="/question/stackoverflow/762011/sWpnR.png" alt="let keyword"></a></p>
     <p><strong>Example2:</strong> In my second example instead of using <code>var</code> keyword in my conditional block I declare <code>myvar</code> using <code>let</code> keyword . Now when I call <code>myfunc</code> I get two different outputs: <code>myvar=20</code> and <code>myvar=10</code>.</p>
     <p>So the difference is very simple i.e its scope.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>Please don't post pictures of code, it's considered bad practice on SO as it will not be searchable for future users (as well as accessibility concerns). As well, this answer adds nothing that other answers haven't already addressed.</span> <span> - </span> <span class="display-name">inostia</span> <span> </span> <span class="date">24 Aug 2018 at 17:29</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_30"><span>Answer 30</span> <span class="arrow"> <a href="#answer_29">↑</a> </span> <span class="arrow"> <a href="#answer_31">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>swaraj patil</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Jul 2016 at 08:22</span>
     </div>
    </div>
    <div>
     <p>Now I think there is better scoping of variables to a block of statements using <code>let</code>:</p>
     <pre><code>function printnums()
{
    // i is not accessible here
    for(let i = 0; i &lt;10; i+=)
    {
       console.log(i);
    }
    // i is not accessible here

    // j is accessible here
    for(var j = 0; j &lt;10; j++)
    {
       console.log(j);
    }
    // j is accessible here
}
</code></pre>
     <p>I think people will start using let here after so that they will have similar scoping in JavaScript like other languages, Java, C#, etc.</p>
     <p>People with not a clear understanding about scoping in JavaScript used to make the mistake earlier.</p>
     <p>Hoisting is not supported using <code>let</code>.</p>
     <p>With this approach errors present in JavaScript are getting removed.</p>
     <p>Refer to <em><a href="https://hacks.mozilla.org/2015/07/es6-in-depth-let-and-const/" rel="nofollow noreferrer">ES6 In Depth: let and const</a></em> to understand it better.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_31"><span>Answer 31</span> <span class="arrow"> <a href="#answer_30">↑</a> </span> <span class="arrow"> <a href="#answer_32">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Daniel Viglione</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 Feb 2019 at 16:07</span>
     </div>
    </div>
    <div>
     <p>I want to link these keywords to the Execution Context, because the Execution Context is important in all of this. The Execution Context has two phases: a Creation Phase and Execution Phase. In addition, each Execution Context has a Variable Environment and Outer Environment (its Lexical Environment).</p>
     <p>During the Creation Phase of an Execution Context, var, let and const will still store its variable in memory with an undefined value in the Variable Environment of the given Execution Context. The difference is in the Execution Phase. If you use reference a variable defined with var before it is assigned a value, it will just be undefined. No exception will be raised.</p>
     <p>However, you cannot reference the variable declared with let or const until it is declared. If you try to use it before it is declared, then an exception will be raised during the Execution Phase of the Execution Context. Now the variable will still be in memory, courtesy of the Creation Phase of the Execution Context, but the Engine will not allow you to use it:</p>
     <pre><code>function a(){
    b;
    let b;
}
a();
&gt; Uncaught ReferenceError: b is not defined
</code></pre>
     <p>With a variable defined with var, if the Engine cannot find the variable in the current Execution Context's Variable Environment, then it will go up the scope chain (the Outer Environment) and check the Outer Environment's Variable Environment for the variable. If it cannot find it there, it will continue searching the Scope Chain. This is not the case with let and const.</p>
     <p>The second feature of let is it introduces block scope. Blocks are defined by curly braces. Examples include function blocks, if blocks, for blocks, etc. When you declare a variable with let inside of a block, the variable is only available inside of the block. In fact, each time the block is run, such as within a for loop, it will create a new variable in memory.</p>
     <p>ES6 also introduces the const keyword for declaring variables. const is also block scoped. The difference between let and const is that const variables need to be declared using an initializer, or it will generate an error.</p>
     <p>And, finally, when it comes to the Execution Context, variables defined with var will be attached to the 'this' object. In the global Execution Context, that will be the window object in browsers. This is not the case for let or const.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_32"><span>Answer 32</span> <span class="arrow"> <a href="#answer_31">↑</a> </span> <span class="arrow"> <a href="#answer_33">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Lucian</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Mar 2019 at 16:52</span>
     </div>
    </div>
    <div>
     <p>As I am currently trying to get an in depth understanding of JavaScript I will share my brief research which contains some of the great pieces already discussed plus some other details in a different perspective.</p>
     <p>Understanding the difference between <strong>var</strong> and <strong>let</strong> can be easier if we understand the difference between <em>function</em> and <em>block scope</em>.</p>
     <p>Let's consider the following cases:</p>
     <pre><code>(function timer() {
    for(var i = 0; i &lt;= 5; i++) {
        setTimeout(function notime() { console.log(i); }, i * 1000);
    }
})();


   Stack            VariableEnvironment //one VariablEnvironment for timer();
                                       // when the timer is out - the value will be the same for each iteration
5. [setTimeout, i]  [i=5] 
4. [setTimeout, i]  
3. [setTimeout, i]
2. [setTimeout, i]
1. [setTimeout, i]
0. [setTimeout, i]

####################    

(function timer() {
    for (let i = 0; i &lt;= 5; i++) {
        setTimeout(function notime() { console.log(i); }, i * 1000);
    }
})();

   Stack           LexicalEnvironment - each iteration has a new lexical environment
5. [setTimeout, i]  [i=5]       
                      LexicalEnvironment 
4. [setTimeout, i]    [i=4]     
                        LexicalEnvironment 
3. [setTimeout, i]      [i=3]       
                         LexicalEnvironment 
2. [setTimeout, i]       [i=2]
                           LexicalEnvironment 
1. [setTimeout, i]         [i=1]
                             LexicalEnvironment 
0. [setTimeout, i]           [i=0]
</code></pre>
     <p>when <code>timer()</code> gets called an <strong>ExecutionContext</strong> is created which will contain both the <strong>VariableEnvironment</strong> and all the <strong>LexicalEnvironments</strong> corresponding to each iteration.</p>
     <p>And a simpler example</p>
     <p>Function Scope</p>
     <pre><code>function test() {
    for(var z = 0; z &lt; 69; z++) {
        //todo
    }
    //z is visible outside the loop
}
</code></pre>
     <p>Block Scope</p>
     <pre><code>function test() {
    for(let z = 0; z &lt; 69; z++) {
        //todo
    }
    //z is not defined :(
}
</code></pre>
     <p>Briefly the difference between let and var is that var is function scoped and let is block scoped.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_33"><span>Answer 33</span> <span class="arrow"> <a href="#answer_32">↑</a> </span> <span class="arrow"> <a href="#answer_34">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>anandharshan</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Dec 2016 at 09:44</span>
     </div>
    </div>
    <div>
     <p>This article clearly defines the difference between var, let and const</p>
     <blockquote>
      <p><code>const</code> is a signal that the identifier won’t be reassigned.</p>
      <p><code>let</code>, is a signal that the variable may be reassigned, such as a counter in a loop, or a value swap in an algorithm. It also signals that the variable will be used only in the block it’s defined in, which is not always the entire containing function.</p>
      <p><code>var</code> is now the weakest signal available when you define a variable in JavaScript. The variable may or may not be reassigned, and the variable may or may not be used for an entire function, or just for the purpose of a block or loop.</p>
     </blockquote>
     <p><a href="https://medium.com/javascript-scene/javascript-es6-var-let-or-const-ba58b8dcde75#.esmkpbg9b" rel="nofollow noreferrer">https://medium.com/javascript-scene/javascript-es6-var-let-or-const-ba58b8dcde75#.esmkpbg9b</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_34"><span>Answer 34</span> <span class="arrow"> <a href="#answer_33">↑</a> </span> <span class="arrow"> <a href="#answer_35">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Rafael Herscovici</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Apr 2019 at 02:21</span>
     </div>
    </div>
    <div>
     <p>I think the terms and most of the examples are a bit overwhelming, The main issue i had personally with the difference is understanding what a "Block" is. At some point i realized, a block would be any curly brackets except for <code>IF</code> statement. an opening bracket <code>{</code> of a function or loop will define a new block, anything defined with <code>let</code> within it, will not be available after the closing bracket <code>}</code> of the same thing (function or loop); With that in mind, it was easier to understand:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>let msg = "Hello World";

function doWork() { // msg will be available since it was defined above this opening bracket!
  let friends = 0;
  console.log(msg);

  // with VAR though:
  for (var iCount2 = 0; iCount2 &lt; 5; iCount2++) {} // iCount2 will be available after this closing bracket!
  console.log(iCount2);
  
    for (let iCount1 = 0; iCount1 &lt; 5; iCount1++) {} // iCount1 will not be available behind this closing bracket, it will return undefined
  console.log(iCount1);
  
} // friends will no be available after this closing bracket!
doWork();
console.log(friends);</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_35"><span>Answer 35</span> <span class="arrow"> <a href="#answer_34">↑</a> </span> <span class="arrow"> <a href="#answer_36">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mile Mijatović</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Feb 2019 at 17:17</span>
     </div>
    </div>
    <div>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>const name = 'Max';
let age = 33;
var hasHobbies = true;

name = 'Maximilian';
age = 34;
hasHobbies = false;

const summarizeUser = (userName, userAge, userHasHobby) =&gt; {
    return (
    'Name is ' +
    userName +
    ', age is ' +
    userAge +
    ' and the user has hobbies: ' +
    userHasHobby
    );
}

console.log(summarizeUser(name, age, hasHobbies));</code></pre>
      </div>
     </div>
     <p></p>
     <p>As you can see from running the code above, when you try to change the <code>const</code> variable, you will <a href="https://i.stack.imgur.com/sEh8Y.png" rel="nofollow noreferrer">get an error</a>:</p>
     <blockquote>
      <p>Attempting to override 'name' which is a constant.</p>
     </blockquote>
     <p>or</p>
     <blockquote>
      <p>TypeError: Invalid assignment to const 'name'.</p>
     </blockquote>
     <p>but take a look at the <code>let</code> variable.</p>
     <p>First we declare <code>let age = 33</code>, and later assign some other value <code>age = 34;</code>, which is OK; we don't have any errors when we try to change <code>let</code> variable</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Code should be written out in SO posts, not shared via a screenshot.</span> <span> - </span> <span class="display-name">TylerH</span> <span> </span> <span class="date">13 Apr 2021 at 18:51</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_36"><span>Answer 36</span> <span class="arrow"> <a href="#answer_35">↑</a> </span> <span class="arrow"> <a href="#answer_37">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>paradigm111</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Nov 2022 at 07:19</span>
     </div>
    </div>
    <div>
     <p>"var" is function scoped and "let" is block scoped</p>
     <p>You can use var when you want to use a variable anywhere in a function and let when you want to use a variable only in that block.</p>
     <p>Or you can just use var all the time since you are unlikely to ever get into a scope conflict inside a function and then you don't need to keep track of which variables you defined as let or var.</p>
     <p>Some people recommend to use let all the time but it isn't my preference because in many other programming languages local variables are function scoped and if you use others then you may find it easier to think in that pattern all the time than switch when using JavaScript. If you use let all the time you will need to remember to define variables at a higher scope to be able to use them outside of just that 'if' or 'while' block for example and it takes more work to keep track of the scope of all variables and also transition their scope if you decide you want to use it later at the function level for instance which I think is more likely to cause an issue than having a variable conflict by accidently choosing the same name for a variable twice in the same function.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_37"><span>Answer 37</span> <span class="arrow"> <a href="#answer_36">↑</a> </span> <span class="arrow"> <a href="#answer_38">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Gurucharan M K</span>
     </div>
     <div>
      <span> Answered: </span> <span>19 May 2016 at 11:41</span>
     </div>
    </div>
    <div>
     <p><a href="https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015" rel="nofollow noreferrer">ECMAScript 6</a> added one more keyword to declare variables other the "const" other than "let".</p>
     <p>The primary goal of introduction of "let" and "const" over "var" is to have block scoping instead of traditional lexical scoping. <a href="https://medium.com/@charan4u/ecmascript-6-beginner-guide-part-3-block-level-bindings-2b3cd5c5d408#.ev9gwp2jb" rel="nofollow noreferrer">My article explains very briefly difference between "var" and "let" and it also covers the discussion on "const"</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_38"><span>Answer 38</span> <span class="arrow"> <a href="#answer_37">↑</a> </span> <span class="arrow"> <a href="#answer_39">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Nurlan</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 May 2018 at 07:27</span>
     </div>
    </div>
    <div>
     <p>Check this link in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" rel="nofollow noreferrer">MDN</a></p>
     <pre><code>let x = 1;

if (x === 1) {
let x = 2;

console.log(x);
// expected output: 2
}

console.log(x);
// expected output: 1
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>It would additionally help to explain in words what <code>let</code> is doing, though that would make it a duplicate of another answer here</span> <span> - </span> <span class="display-name">pushkin</span> <span> </span> <span class="date">31 May 2018 at 19:47</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>What he is trying to say is that the <code>let</code> outside the <code>if</code> defines the variable <code>x=1</code>. The <code>if</code>-statement will trigger (since <code>x===1 is true</code>. Now comes the tricky part, which is also the main reason you need to keep track of <code>let</code> vs <code>var</code>. Inside the <code>if</code> he is trying to set <code>x=2</code>, which in the <code>console.log(x)</code> will print 2, HOWEVER, <code>x</code> "on the outside" of the if still has has the value <code>1</code>, so the other <code>console.log(x)</code> gives 1, since the value of <code>x</code> "globally" is still <code>1</code>. The answer does not explain this, so should not be considered a good answer in my opinion.</span> <span> - </span> <span class="display-name">Thomas Darvik</span> <span> </span> <span class="date">27 Sep 2018 at 09:41</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_39"><span>Answer 39</span> <span class="arrow"> <a href="#answer_38">↑</a> </span> <span class="arrow"> <a href="#answer_40">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Taib Islam Dipu</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Dec 2020 at 15:01</span>
     </div>
    </div>
    <div>
     <p>Before 2015, using the <code>var</code> keyword was the only way to <strong>declare</strong> a JavaScript <strong>variable</strong>.</p>
     <p>After <strong>ES6</strong> (a JavaScript version), it allows 2 new keywords <strong>let</strong> &amp; <strong>const</strong>.</p>
     <p><code>let</code> = can be re-assigned <br><code>const</code> = cannot be re-assigned ( const which comes from constant, short-form 'const' )</p>
     <p><strong>Example:</strong></p>
     <ul>
      <li>
       <p>Suppose, declaring a Country Name / Your mother name, <code>const</code> is most suitable here. because there is less chance to change a country name or your mother name soon or later.</p></li>
      <li>
       <p>Your age, weight, salary, speed of a bike and more like these types of data that change often or need to reassign. those situations, <code>let</code> is used.</p></li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_40"><span>Answer 40</span> <span class="arrow"> <a href="#answer_39">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ali Raza</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Mar 2023 at 11:08</span>
     </div>
    </div>
    <div>
     <p>In JavaScript, let and var are both used for variable declaration, but there are some important differences between them:</p>
     <p><strong>Scope</strong>: The main difference between let and var is their scope. var declarations are function-scoped, whereas let declarations are block-scoped.</p>
     <p><strong>Hoisting</strong>: var declarations are hoisted to the top of their scope, while let declarations are not hoisted.</p>
     <p><strong>Re-assignment</strong>: let allows you to re-assign a value to a variable, whereas var can be re-assigned as well but it can also be re-declared.</p>
     <p><strong>Temporal dead zone</strong>: let declarations have a "temporal dead zone" (TDZ), which means that if you try to access a let variable before it has been declared, you will get a ReferenceError.</p>
     <pre><code>function example() {
  var x = 10;
  if (true) {
    var x = 20; // re-declares x in the same scope
    let y = 30; // y is block-scoped to the if statement
    console.log(x); // outputs 20
    console.log(y); // outputs 30
  }
  console.log(x); // outputs 20 (re-assignment)
  console.log(y); // ReferenceError: y is not defined (block-scoped)
}
</code></pre>
     <p>Overall, let is generally preferred over var in modern JavaScript development because of its block-scoping and TDZ behavior, which can help catch errors and make code more predictable.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>