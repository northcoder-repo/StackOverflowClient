<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>How can I validate an email address in JavaScript?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>How can I validate an email address in JavaScript?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>5476</span>
    </div>
    <div>
     <span>Asker: </span> <span>pix0r</span>
    </div>
    <div>
     <span>Asked: </span> <span>5 Sep 2008 at 16:10</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/46155/how-can-i-validate-an-email-address-in-javascript">source</a>
    </div>
   </div>
   <div>
    <p>I'd like to check if the user input is an email address in JavaScript, before sending it to a server or attempting to send an email to it, to prevent the most basic mistyping. How could I achieve this?</p>
   </div>
   <div class="tags">
    <span class="tag">javascript</span><span class="tag">html</span><span class="tag">regex</span><span class="tag">email-validation</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>23</td>
       <td><span>@Alex The reason I added this comment is that the suggested regex in the accepted answer will not allow existing live email addresses which is a bad start for a customer, and the really big problem is that even IF the address was accepted it still does not say if it works. The only way to reliably verify that a supplied email is a working valid email is to send a mail with a verification link. So, if your use case does not demand that you verify the email, just do a minimal test for @, otherwise use a verification email. Regex will only provide bad user experience.</span> <span> - </span> <span class="display-name">David Mårtensson</span> <span> </span> <span class="date">3 May 2021 at 14:56</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@David Mårtensson I added a + on your thoughts. However I do think that a verification email-link thing also can be bad user experience. One that can make you lose a customer.</span> <span> - </span> <span class="display-name">mikael1000</span> <span> </span> <span class="date">3 Jun 2021 at 10:22</span></td>
      </tr>
      <tr>
       <td>7</td>
       <td><span>@mikael1000 Sure, but what is the purpose of a regex validation when you will not know if its a valid email anyway. If you do not want to intrude on the customer with a validation link just do the most simple validation &lt;something&gt; at &lt;something&gt; and leave it at that. It will ensure that the customer at least added something that might be an email, anything more it mostly a waste of code until you get to actually validating. You could possibly check if the domain exists with a dns lookup.</span> <span> - </span> <span class="display-name">David Mårtensson</span> <span> </span> <span class="date">4 Jun 2021 at 14:23</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@DavidMårtensson A customer that mistypes one character in her e-mail will have it regexp validated where it still is wrong. The result will be: <i>no</i> communication possible. To me that is the <b>worst</b> user experience one can imagine. A validation confirmation will engage the user in a conversation which shows respect and genuine interest in customers needs.</span> <span> - </span> <span class="display-name">theking2</span> <span> </span> <span class="date">6 Dec 2021 at 12:39</span></td>
      </tr>
      <tr>
       <td>2</td>
       <td><span>Very similar: <i><a href="https://stackoverflow.com/questions/201323/">How can I validate an email address using a regular expression?</a></i></span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">16 Feb 2022 at 23:18</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>If this question is to stay open it needs to remove "validation", otherwise it should to closed.</span> <span> - </span> <span class="display-name">Braiam</span> <span> </span> <span class="date">4 May 2022 at 13:44</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@theking2 I agree that regex helps only to check the standard email format, but it will not confirm entered email address is valid or reachable. This problem is addressed by a few real-time email validation tools. You might need to check <a href="https://clearout.io/integrations/real-time-javascript-email-validation/" rel="nofollow noreferrer">clearout.io/integrations/real-time-javascript-email-validati‌​on</a>. It even helps to suggest the mistyped email address.</span> <span> - </span> <span class="display-name">GnanaPrakash</span> <span> </span> <span class="date">9 Jul 2022 at 12:49</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Does this answer your question? <a href="https://stackoverflow.com/questions/201323/how-can-i-validate-an-email-address-using-a-regular-expression">How can I validate an email address using a regular expression?</a></span> <span> - </span> <span class="display-name">Karl Knechtel</span> <span> </span> <span class="date">12 Aug 2022 at 04:09</span></td>
      </tr>
      <tr>
       <td>3</td>
       <td><span>I have to admit, I don't understand why there's some much validation going on when you can't predict if the user made a basic type using the valid characters anyway. Just a check for @ and at least one dot is enough at the start.</span> <span> - </span> <span class="display-name">Watts Epherson</span> <span> </span> <span class="date">23 Aug 2022 at 10:56</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6475</span>
     </div>
     <div>
      <span>Answerer: </span> <span>John Rutherford</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Sep 2008 at 16:15</span>
     </div>
    </div>
    <div>
     <p>Using <a href="http://en.wikipedia.org/wiki/Regular_expression" rel="noreferrer">regular expressions</a> is probably the best way of validating an email address in JavaScript. <a href="http://jsfiddle.net/ghvj4gy9/embedded/result.js" rel="noreferrer">View a bunch of tests on JSFiddle</a> taken from <a href="https://cs.chromium.org/chromium/src/third_party/blink/web_tests/fast/forms/resources/ValidityState-typeMismatch-email.js?q=ValidityState-typeMismatch-email.js&amp;sq=package:chromium&amp;dr" rel="noreferrer">Chromium</a>.</p>
     <pre class="lang-js prettyprint-override"><code>const validateEmail = (email) =&gt; {
  return String(email)
    .toLowerCase()
    .match(
      /^(([^&lt;&gt;()[\]\\.,;:\s@"]+(\.[^&lt;&gt;()[\]\\.,;:\s@"]+)*)|.(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
    );
};
</code></pre>
     <p>The following is an example of a regular expression that accepts unicode.</p>
     <pre class="lang-js prettyprint-override"><code>const re =
  /^(([^&lt;&gt;()[\]\.,;:\s@\"]+(\.[^&lt;&gt;()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^&lt;&gt;()[\]\.,;:\s@\"]+\.)+[^&lt;&gt;()[\]\.,;:\s@\"]{2,})$/i;
</code></pre>
     <p>Keep in mind that one should not rely on JavaScript validation alone, as JavaScript can be easily disabled by the client. Furthermore, it is important to validated on the server side.</p>
     <p>The following snippet of code is an example of JavaScript validating an email address on the client side.</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>const validateEmail = (email) =&gt; {
  return email.match(
    /^(([^&lt;&gt;()[\]\\.,;:\s@\"]+(\.[^&lt;&gt;()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
  );
};

const validate = () =&gt; {
  const $result = $('#result');
  const email = $('#email').val();
  $result.text('');

  if(validateEmail(email)){
    $result.text(email + ' is valid.');
    $result.css('color', 'green');
  } else{
    $result.text(email + ' is invalid.');
    $result.css('color', 'red');
  }
  return false;
}

$('#email').on('input', validate);</code></pre>
       <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"&gt;&lt;/script&gt;

&lt;label for="email"&gt;Enter email address&lt;/label&gt;
&lt;input id="email" type="email"&gt;

&lt;p id="result"&gt;&lt;/p&gt;</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>711</td>
        <td><span>This regex eliminates valid, in-use emails. Do not use. Google for "RFC822" or "RFC2822" to get a proper regex.</span> <span> - </span> <span class="display-name">Randal Schwartz</span> <span> </span> <span class="date">8 Sep 2010 at 02:34</span></td>
       </tr>
       <tr>
        <td>71</td>
        <td><span>This doesn't even accept the examples in RFC 822. Some simple cases it doesn't match a\@b@c.com, a(b)@c.com. See the RFC for more. Here's a regex that won't reject any valid addresses [^@]+@[^@]+\.[^@]+ and protects against common errors.</span> <span> - </span> <span class="display-name">Vroo</span> <span> </span> <span class="date">26 Oct 2012 at 06:32</span></td>
       </tr>
       <tr>
        <td>227</td>
        <td><span>You cannot validate email addresses, period. The only one who can validate an email address is the provider of the email address. For example, this answer says these email addresses: <code>%2@gmail.com, "%2"@gmail.com, "a..b"@gmail.com, "a_b"@gmail.com, _@gmail.com, 1@gmail.com , 1_example@something.gmail.com</code> are all valid, but Gmail will never allow any of these email addresses. You should do this by accepting the email address and sending an email message to that email address, with a code/link the user must visit to confirm validity.</span> <span> - </span> <span class="display-name">Kevin Fegan</span> <span> </span> <span class="date">1 Feb 2014 at 08:49</span></td>
       </tr>
       <tr>
        <td>14</td>
        <td><span>@KevinFegan let's be realistic: you would not be using JavaScript to confirm whether an e-mail is authentic. I see this validation as perfectly reasonable when a user signs up. You probably do not want to bother sending verification e-mails to addresses that cannot possibly exist. Some might also have outbound e-mail limits, making it north worth it to send e-mails to <code>email@localhost</code>, <code>i don't have an email</code> or any other funny user inputs.</span> <span> - </span> <span class="display-name">undefined</span> <span> </span> <span class="date">16 Jul 2021 at 23:02</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>gautam+@Gmail.com - showing is valid which should not</span> <span> - </span> <span class="display-name">Gautam Parmar</span> <span> </span> <span class="date">6 Aug 2021 at 06:33</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@KevinFegan You can't <i>validate</i> an email address, but you can recognise obviously invalid ones. Basically anything that will stop your outgoing mail server from even attempting to send the message.</span> <span> - </span> <span class="display-name">Abhi Beckert</span> <span> </span> <span class="date">16 Aug 2021 at 06:35</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This kind of email foo@3.com is not validated by the regex from the answer. I've tested this one and it worked: ^[\w.]+@[a-z]+.\w{2,3}$</span> <span> - </span> <span class="display-name">Iasmini Gomes</span> <span> </span> <span class="date">24 Sep 2021 at 12:26</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@lasmini Gomes this regex is hopelessly naive. brian@li is a valid email address. also brian@my.host.amazon.com is also valid. Also brian+123@gmail.com is also valid. And is use A LOT by testers because the +123 is ignored by gmail.</span> <span> - </span> <span class="display-name">PlexQ</span> <span> </span> <span class="date">17 Oct 2021 at 23:29</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>this is invalid <code>sean.o'leary@cobbcounty.org</code> and your code couldn't verify that, It says valid email.</span> <span> - </span> <span class="display-name">Code Cooker</span> <span> </span> <span class="date">5 Nov 2021 at 09:01</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Invalidates valid emails, such as xxxxxxx@hotmail.com</span> <span> - </span> <span class="display-name">Gabriel Chaves Becchi</span> <span> </span> <span class="date">29 Apr 2022 at 12:47</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1294</span>
     </div>
     <div>
      <span>Answerer: </span> <span>C. Lee</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Feb 2012 at 02:22</span>
     </div>
    </div>
    <div>
     <p>I've slightly modified <a href="https://stackoverflow.com/a/48800/4832311">Jaymon's answer</a> for people who want really simple validation in the form of:</p>
     <pre><code>anystring@anystring.anystring
</code></pre>
     <p>The regular expression:</p>
     <pre><code>/^\S+@\S+\.\S+$/
</code></pre>
     <p>To prevent matching multiple @ signs:</p>
     <pre><code>/^[^\s@]+@[^\s@]+\.[^\s@]+$/
</code></pre>
     <p>The above regexes match the whole string, remove the leading and <code>^</code> and trailing <code>$</code> if you want to match anywhere in the string. The example below matches <em>anywhere</em> in the string.</p>
     <p>If you do want to match the whole sring, you may want to <code>trim()</code> the string first.</p>
     <p>Example JavaScript function:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function validateEmail(email) {
  var re = /\S+@\S+\.\S+/;
  return re.test(email);
}
    
console.log(validateEmail('my email is anystring@anystring.any')); // true
    
console.log(validateEmail('my email is anystring@anystring .any')); // false</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>116</td>
        <td><span>You can implement something 20x as long that might cause problems for a few users and might not be valid in the future, or you can grab ImmortalFirefly's version to make sure they at least put in the effort to make it look real. Depending on your application it may be more likely to come across someone will get mad because you don't accept their unconventional email, rather than someone who causes problems by entering email addresses that don't really exist (which they can do anyways by entering a 100% valid RFC2822 email address but using an unregistered username or domain). Upvoted!</span> <span> - </span> <span class="display-name">user83358</span> <span> </span> <span class="date">30 Jul 2012 at 18:20</span></td>
       </tr>
       <tr>
        <td>131</td>
        <td><span>@ImmortalFirefly, the regex you provided will actually match <code>name@again@example.com</code>. Try pasting your line into a JavaScript console. I believe your intention was to match only the entire text, which would require the beginning of text '^' and end of text '$' operators. The one I'm using is <code>/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test('name@again@example.com')</code></span> <span> - </span> <span class="display-name">OregonTrail</span> <span> </span> <span class="date">9 Aug 2012 at 14:58</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The second regexp does not require a top-level domain, i.e. it accepts <code>user@domain</code>. But AFAIK this is actually a valid e-mail address, although uncommon. The first regexp requires a TLD, so it doesn't cover these types of addresses.</span> <span> - </span> <span class="display-name">waldgeist</span> <span> </span> <span class="date">15 Jul 2021 at 13:00</span></td>
       </tr>
       <tr>
        <td>8</td>
        <td><span>Emails can contain multiple <code>@</code> signs (as comments), also an email doesn't have to contain a period.</span> <span> - </span> <span class="display-name">ruohola</span> <span> </span> <span class="date">6 Oct 2021 at 14:08</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@ruohola is this also the reason why an email will be valid after you input an @ sign without having any periods after?</span> <span> - </span> <span class="display-name">PG20</span> <span> </span> <span class="date">10 Feb 2022 at 09:10</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>@JoseG. Yes. E.g. <code>http://ai</code> is someone's valid domain, so they could use e.g. <code>a@ai</code> as their email.</span> <span> - </span> <span class="display-name">ruohola</span> <span> </span> <span class="date">10 Feb 2022 at 09:42</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>2 issues: Is <code>[^\s@]</code> <code>no string followed by @</code>? Why do you use <code>\s</code> and <code>\S</code>? Is it <a href="https://stackoverflow.com/a/4377521/1705829">related to whitespaces</a>?</span> <span> - </span> <span class="display-name">Timo</span> <span> </span> <span class="date">24 Jul 2022 at 11:35</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Timo <code>[^\s@]</code> means "neither a whitespace character nor <code>@</code>". <code>[xyz]</code> means any one of x, y or z, and <code>[^xyz]</code> means any one character <i>except</i> x, y or z. <code>\s</code> means "any whitespace character". <code>\S</code> means "any character that is not whitespace".</span> <span> - </span> <span class="display-name">Jelaby</span> <span> </span> <span class="date">21 Aug 2022 at 11:03</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>898</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Esteban Küber</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Sep 2009 at 14:26</span>
     </div>
    </div>
    <div>
     <p>Just for completeness, <a href="http://www.regular-expressions.info/email.html" rel="noreferrer">here you have another RFC 2822 compliant regex</a></p>
     <blockquote>
      <p>The official standard is known as <a href="https://www.rfc-editor.org/rfc/rfc2822#section-3.4.1" rel="noreferrer">RFC 2822</a>. It describes the syntax that valid email addresses must adhere to. You can (<strong>but you shouldn't</strong> — <a href="http://www.regular-expressions.info/email.html" rel="noreferrer">read on</a>) implement it with this regular expression:</p>
      <p><code>(?:[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])</code></p>
      <p>(...) We get a more practical implementation of RFC 2822 if we omit the syntax using double quotes and square brackets. <strong>It will still match 99.99% of all email addresses in actual use today.</strong></p>
      <p><code>[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?</code></p>
      <p>A further change you could make is to allow any two-letter country code top level domain, and only specific generic top level domains. <strong>This regex filters dummy email addresses like <code>asdf@adsf.adsf</code></strong>. You <strong>will need to update it as new top-level domains are added</strong>.</p>
      <p><code>[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+(?:[A-Z]{2}|com|org|net|gov|mil|biz|info|mobi|name|aero|jobs|museum)\b</code></p>
      <p>So even when following official standards, there are still trade-offs to be made. <em><strong>Don't blindly copy regular expressions from online libraries or discussion forums. Always test them on your own data and with your own applications.</strong></em></p>
     </blockquote>
     <p><sub>Emphasis mine</sub></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>110</td>
        <td><span>NB: "In actual use <i>today</i>" may have been valid when the code was written, back in 200x. The code <b>will</b> likely remain in use beyond that specific year. (If I had a dime for every "meh, no one will ever use a 4+-letter TLD except those specific ones" I had to fix, I could corner the world's copper and nickel market ;))</span> <span> - </span> <span class="display-name">Piskvor left the building</span> <span> </span> <span class="date">13 Jun 2012 at 15:51</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>Note that this doesn't catch some valid email addresses, like these emoji ones: <a href="https://mailoji.com/" rel="nofollow noreferrer">mailoji.com</a></span> <span> - </span> <span class="display-name">Toastrackenigma</span> <span> </span> <span class="date">6 Oct 2021 at 01:28</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span>@Toastrackenigma if someone is using an emoji email doesn't deserve to subscribe to my website. As easy as that.</span> <span> - </span> <span class="display-name">Christian Vincenzo Traina</span> <span> </span> <span class="date">6 Jun 2022 at 13:24</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@ChristianVincenzoTraina the last one rejects my e-mail address on a .rocks domain. if this stops me from your newsletter then maybe it's good for me that I don't get Ignorant Daily to my inbox, but a list of services stopping me from using this domain includes: country-wide public transport system, an airline, medical services, ...</span> <span> - </span> <span class="display-name">lnl</span> <span> </span> <span class="date">23 Apr 2023 at 13:42</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@lnl the last one is just unmaintainable. The number of top-level domains exploded since 2009</span> <span> - </span> <span class="display-name">Christian Vincenzo Traina</span> <span> </span> <span class="date">23 Apr 2023 at 23:18</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>519</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Jaymon</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Sep 2008 at 21:21</span>
     </div>
    </div>
    <div>
     <p>Wow, there are lots of complexity here. If all you want to do is just catch the most obvious syntax errors, I would do something like this:</p>
     <pre><code>^\S+@\S+$
</code></pre>
     <p>It usually catches the most obvious errors that the user makes and assures that the form is mostly right, which is what JavaScript validation is all about.</p>
     <p>EDIT: We can also check for '.' in the email using</p>
     <pre><code>/^\S+@\S+\.\S+$/
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>115</td>
        <td><span>+1 as sending email and seeing what happens is the only real sure way to validate an email address , theres no need to do more than a simple regex match.</span> <span> - </span> <span class="display-name">kommradHomer</span> <span> </span> <span class="date">19 Jul 2012 at 07:14</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>But it won't accept "Mohit Atray"@gmail.com because it contains space character. Maybe we should just use /^\S.*@\S+$/ regex.</span> <span> - </span> <span class="display-name">Mohit Atray</span> <span> </span> <span class="date">8 Jul 2021 at 19:57</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>That's still not valid. Spaces are permitted in the local-part as long as they are properly escaped (in double quotes).</span> <span> - </span> <span class="display-name">Randal Schwartz</span> <span> </span> <span class="date">21 Jun 2022 at 22:10</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@RandalSchwartz your comment regarding whitespaces before @ is already written by mohit I think.</span> <span> - </span> <span class="display-name">Timo</span> <span> </span> <span class="date">22 Aug 2022 at 19:24</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>375</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Paolo Bergantino</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 May 2009 at 17:18</span>
     </div>
    </div>
    <div>
     <p>There's something you have to understand the second you decide to use a regular expression to validate emails: <a href="http://ex-parrot.com/~pdw/Mail-RFC822-Address.html" rel="noreferrer">It's probably not a good idea</a>. Once you have come to terms with that, there are many implementations out there that can get you halfway there, <a href="http://www.regular-expressions.info/email.html" rel="noreferrer">this article sums them up nicely.</a></p>
     <p>In short, however, the only way to be absolutely, positively sure that what the user entered is in fact an email is to actually send an email and see what happens. Other than that it's all just guesses.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>77</td>
        <td><span>@kommradHomer -- a "regex invalid" address is almost always valid, because whatever regex you use to validate an email address is almost certainly wrong and will exclude valid email addresses. An email address is <code>name_part@domain_part</code> and practically anything, <b>including</b> an <code>@</code>, is valid in the name_part; The address <code>foo@bar@machine.subdomain.example.museum</code> is legal, although it must be escaped as <code>foo\@bar@machine....</code>. Once the email reaches the domain e.g. 'example.com' that domain can route the mail "locally" so "strange" usernames and hostnames can exist.</span> <span> - </span> <span class="display-name">Stephen P</span> <span> </span> <span class="date">7 Mar 2013 at 01:40</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>321</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Anoop</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Oct 2011 at 08:23</span>
     </div>
    </div>
    <div>
     <p>HTML5 itself has email validation. If your browser supports HTML5 then you can use the following code.</p>
     <pre class="lang-html prettyprint-override"><code>&lt;form&gt;
  &lt;label&gt;Email Address
    &lt;input type="email" placeholder="me@example.com" required&gt;
  &lt;/label&gt;
  &lt;input type="submit"&gt;
&lt;/form&gt;
</code></pre>
     <p><a href="http://jsfiddle.net/edwinthomas25/z6wev5L0/" rel="noreferrer">jsFiddle</a> link</p>
     <p>From the <a href="http://www.w3.org/TR/html5/forms.html#valid-e-mail-address" rel="noreferrer">HTML5 spec</a>:</p>
     <blockquote>
      <p>A <strong>valid e-mail address</strong> is a string that matches the <code>email</code> production of the following ABNF, the character set for which is Unicode.</p>
      <pre><code>email   = 1*( atext / "." ) "@" label *( "." label )
label   = let-dig [ [ ldh-str ] let-dig ]  ; limited to a length of 63 characters by RFC 1034 section 3.5
atext   = &lt; as defined in RFC 5322 section 3.2.3 &gt;
let-dig = &lt; as defined in RFC 1034 section 3.5 &gt;
ldh-str = &lt; as defined in RFC 1034 section 3.5 &gt;
</code></pre>
      <p>This requirement is a <a href="http://www.w3.org/TR/html5/introduction.html#willful-violation" rel="noreferrer">willful violation</a> of RFC 5322, which defines a syntax for e-mail addresses that is simultaneously too strict (before the "@" character), too vague (after the "@" character), and too lax (allowing comments, whitespace characters, and quoted strings in manners unfamiliar to most users) to be of practical use here.</p>
      <p>The following JavaScript- and Perl-compatible regular expression is an implementation of the above definition.</p>
      <pre><code>/^[a-zA-Z0-9.!#$%&amp;'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
</code></pre>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>52</td>
        <td><span>this is good, but the problem with this is that it must be inside a <code>form</code> tag and submitted by a <code>submit</code> input, which not everyone has the luxury of doing. Also, you can't really style the error message.</span> <span> - </span> <span class="display-name">Jason</span> <span> </span> <span class="date">12 Nov 2011 at 00:08</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>At first I found this answer useful, but I tried with some invalid email address and the regex said there were valid... by example : <code>bar@domain</code> (extension is missing), <code>A@b@c@example.com</code> (multiple @) and so on (cf <a href="https://en.wikipedia.org/wiki/Email_address#Examples" rel="nofollow noreferrer">en.wikipedia.org/wiki/Email_address#Examples</a>). I found a nice regex here: <a href="https://emailregex.com" rel="nofollow noreferrer">emailregex.com</a></span> <span> - </span> <span class="display-name">Thomas Champion</span> <span> </span> <span class="date">22 Oct 2021 at 15:30</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@ThomasChampion Multiple "@" IS valid. First point is valid though.</span> <span> - </span> <span class="display-name">KNP</span> <span> </span> <span class="date">6 Dec 2021 at 18:26</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@KNP Multiple <code>@</code> is valid only if the extra "@" appear in username part and is wrapped in double quote. It seems that also the second point (missing extension) is not valid anymore since 2013 (<a href="https://www.icann.org/en/announcements/details/new-gtld-dotless-domain-names-prohibited-30-8-2013-en" rel="nofollow noreferrer">icann.org/en/announcements/details/…</a>), but yes it depends, I guess someone could consider extension optional. Finally, I choose the module <code>address</code> from joi: <a href="https://joi.dev/module/address/api/?v=4.1.0#emailisvalidemail-options" rel="nofollow noreferrer">joi.dev/module/address/api/?v=4.1.0#emailisvalidemail-option‌​s</a> to validate email addresss in my app.</span> <span> - </span> <span class="display-name">Thomas Champion</span> <span> </span> <span class="date">7 Dec 2021 at 21:37</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>203</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Andrew</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Sep 2015 at 01:52</span>
     </div>
    </div>
    <div>
     <p>I have found this to be the best solution:</p>
     <pre><code>/^[^\s@]+@[^\s@]+\.[^\s@]+$/
</code></pre>
     <p>It allows the following formats:</p>
     <pre>1.  prettyandsimple@example.com
2.  very.common@example.com
3.  disposable.style.email.with+symbol@example.com
4.  other.email-with-dash@example.com
9.  #!$%&amp;'*+-/=?^_`{}|~@example.org
6.  "()[]:,;@\\\"!#$%&amp;'*+-/=?^_`{}| ~.a"@example.org
7.  " "@example.org (space between the quotes)
8.  üñîçøðé@example.com (Unicode characters in local part)
9.  üñîçøðé@üñîçøðé.com (Unicode characters in domain part)
10. Pelé@example.com (Latin)
11. δοκιμή@παράδειγμα.δοκιμή (Greek)
12. 我買@屋企.香港 (Chinese)
13. 甲斐@黒川.日本 (Japanese)
14. чебурашка@ящик-с-апельсинами.рф (Cyrillic)
</pre>
     <p>It's clearly versatile and allows the all-important international characters, while still enforcing the basic anything@anything.anything format. It will block spaces which are technically allowed by RFC, but they are so rare that I'm happy to do this.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>158</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Boldewyn</span>
     </div>
     <div>
      <span> Answered: </span> <span>20 Dec 2012 at 15:20</span>
     </div>
    </div>
    <div>
     <p>In modern browsers you can build on top of @Sushil's answer with pure JavaScript and the <a href="http://en.wikipedia.org/wiki/Document_Object_Model" rel="noreferrer">DOM</a>:</p>
     <pre><code>function validateEmail(value) {
  var input = document.createElement('input');

  input.type = 'email';
  input.required = true;
  input.value = value;

  return typeof input.checkValidity === 'function' ? input.checkValidity() : /\S+@\S+\.\S+/.test(value);
}
</code></pre>
     <p>I've put together an example in the fiddle <a href="http://jsfiddle.net/boldewyn/2b6d5/" rel="noreferrer">http://jsfiddle.net/boldewyn/2b6d5/</a>. Combined with feature detection and the bare-bones validation from <a href="https://stackoverflow.com/a/9204568/324094">Squirtle's Answer</a>, it frees you from the regular expression massacre and does not bork on old browsers.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>6</td>
        <td><span>This should be the accepted answer by a long shot. Let browser vendors with on staff regex gurus maintain massively complicated regexes for email addresses. Your average frontend dev building a form for collecting email does not often have time to master verbose regex. Yes you have to rely on the regex the vendor provides, but if you need something more complex, do it on the server and or send an actual email and check the response</span> <span> - </span> <span class="display-name">Matt</span> <span> </span> <span class="date">16 Jul 2021 at 11:04</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This is the almost perfect solution. Only little thing that should be added is a check for empty field. HTML5 'email' type accepts an empty string as a valid input.</span> <span> - </span> <span class="display-name">NurShomik</span> <span> </span> <span class="date">31 Dec 2021 at 23:00</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>That’s what the <code>input.required = true;</code> line should take care of ;-)</span> <span> - </span> <span class="display-name">Boldewyn</span> <span> </span> <span class="date">2 Jan 2022 at 17:18</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>HTML5 'email' type accepts an empty string incase the field is not requierd. But if user decide to enter the email, it need to be valide.</span> <span> - </span> <span class="display-name">marcb</span> <span> </span> <span class="date">29 Jan 2022 at 16:49</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>I might repeat myself, but have you noticed the <code>input.required = true;</code> line?</span> <span> - </span> <span class="display-name">Boldewyn</span> <span> </span> <span class="date">30 Jan 2022 at 13:18</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Also worth thinking about: It's robust against future changes, as it doesn't hard-code the actual regex. I like this aspect.</span> <span> - </span> <span class="display-name">oelna</span> <span> </span> <span class="date">10 Apr 2022 at 14:45</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I like this solution, but it sill has some cases where it returns <code>false</code> instead of <code>true</code>. For example: <code>email@[123.123.123.123]</code>, <code>"email"@example.com</code>, <code>much.”more\ unusual”@example.com</code>, <code>very.unusual.”@”.unusual.com@example.com</code>, <code>very.”(),:;&lt;&gt;[]”.VERY.”very@\\ "very”.unusual@strange.example.com</code></span> <span> - </span> <span class="display-name">HauPham</span> <span> </span> <span class="date">23 Jul 2022 at 16:19</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Yes, that’s because the HTML 5 spec hard-codes the regex for e-mail address validation to the 99.9% subset of RFC 2822, that is in actual use. But agreed, if you have special requirements (e.g. intranet or legacy addresses), then this solution might not cut the mustard for you.</span> <span> - </span> <span class="display-name">Boldewyn</span> <span> </span> <span class="date">24 Jul 2022 at 19:24</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I like this solution the most, but I have just noticed that <code>sdf@sd</code> is validated as a correct email...</span> <span> - </span> <span class="display-name">Philipp Mochine</span> <span> </span> <span class="date">17 Aug 2022 at 08:19</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@PhilippMochine : because <code>sdf@sd</code> <i>is</i> a <i>valid</i> email address : dotless domain has some specific uses where you can practically validate who can access devices that can send emails. It's not because the ICANN strongly discourages the continuation of dotless domains that the entire world must upgrade their systems with no exceptions. Like a knive, it's not because it can hurt you will prohibit it everywhere. Again, to validate an email, send one and see what happens, don't use a regex; or use a regex and accept some custommers won't stay. The point is <i>discouraged</i> doesn't mean <i>invalid</i>.</span> <span> - </span> <span class="display-name">Karl Stephen</span> <span> </span> <span class="date">19 Sep 2022 at 18:07</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>What @KarlStephen said. Think of a web app for an intranet application. A browser rejecting e-mail addresses like <code>user@localhost</code> would be worse than useless. It would actively hinder the correct fill-out of the form.</span> <span> - </span> <span class="display-name">Boldewyn</span> <span> </span> <span class="date">19 Sep 2022 at 23:20</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This solution does work <a href="https://stackoverflow.com/questions/73799704/why-checkvalidity-is-returning-true-for-input-field-of-type-email-with-empty" title="why checkvalidity is returning true for input field of type email with empty">stackoverflow.com/questions/73799704/…</a>, checkValidity fails for empty email string as well "a@b" email format</span> <span> - </span> <span class="display-name">vikramvi</span> <span> </span> <span class="date">21 Sep 2022 at 11:26</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>It would only fail, if the field is not required. In my answer I set it to be required, hence <code>checkValidity()</code> catches empty inputs. This was discussed above already. And the <code>a@b</code> case was discussed, too, namely in the very comment above yours. I’m totally unsure, what then the point of your comment is. Sorry.</span> <span> - </span> <span class="display-name">Boldewyn</span> <span> </span> <span class="date">21 Sep 2022 at 11:44</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>96</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ben Scheirman</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Sep 2008 at 16:13</span>
     </div>
    </div>
    <div>
     <p>JavaScript can match a regular expression:</p>
     <pre><code>emailAddress.match( / some_regex /);
</code></pre>
     <p>Here's an <a href="https://www.rfc-editor.org/rfc/rfc22" rel="noreferrer">RFC22</a> regular expression for emails:</p>
     <pre><code>^((?&gt;[a-zA-Z\d!#$%&amp;'*+\-/=?^_`{|}~]+\x20*|"((?=[\x01-\x7f])[^"\\]|\\[\x01-\x7f])*
"\x20*)*(?&lt;angle&gt;&lt;))?((?!\.)(?&gt;\.?[a-zA-Z\d!#$%&amp;'*+\-/=?^_`{|}~]+)+|"((?=[\x01-\x
7f])[^"\\]|\\[\x01-\x7f])*")@(((?!-)[a-zA-Z\d\-]+(?&lt;!-)\.)+[a-zA-Z]{2,}|\[(((?(?&lt;
!\[)\.)(25[0-5]|2[0-4]\d|[01]?\d?\d)){4}|[a-zA-Z\d\-]*[a-zA-Z\d]:((?=[\x01-\x7f])
[^\\\[\]]|\\[\x01-\x7f])+)\])(?(angle)&gt;)$
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span>@Kato: It uses some incompatible extensions, including <code>(?&gt;</code> to stop backtracking and <code>(?&lt;angle&gt;&lt;)…(?(angle)&gt;)</code> to avoid providing a lengthy <code>|</code>.</span> <span> - </span> <span class="display-name">Ry-</span> <span> </span> <span class="date">9 Mar 2014 at 20:05</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The <code>match</code> method returns an array, the <code>test</code> method, which returns a boolean, would be better for this situation.</span> <span> - </span> <span class="display-name">iPzard</span> <span> </span> <span class="date">7 Nov 2020 at 20:43</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>89</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Colonel Panic</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Jul 2013 at 18:15</span>
     </div>
    </div>
    <div>
     <p>All email addresses contain an 'at' (i.e. @) symbol. Test that necessary condition:</p>
     <pre><code>email.includes('@')
</code></pre>
     <p>Or, if you need to support IE/older browsers:</p>
     <pre><code>email.indexOf('@') &gt; 0
</code></pre>
     <p>Don't bother with anything more complicated. Even if you could perfectly determine whether an email is RFC-syntactically valid, that wouldn't tell you whether it belongs to the person who supplied it. That's what really matters.</p>
     <p>To test that, send a validation message.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>22</td>
        <td><span>what if there will be more than one '@' symbol? other restricted symbols? This validation cannot be trusted...</span> <span> - </span> <span class="display-name">iwazovsky</span> <span> </span> <span class="date">26 Apr 2015 at 10:14</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>is a@b valid email ?</span> <span> - </span> <span class="display-name">Aravin</span> <span> </span> <span class="date">20 Dec 2020 at 10:17</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>Its better than most, yes you could have more than one @ with this, but that could also be a valid email like "@"@mydomain.jskd or elldffs(this is @ comment)@mydomain.kjfdij. Both are syntactically valid emails</span> <span> - </span> <span class="display-name">David Mårtensson</span> <span> </span> <span class="date">16 Feb 2021 at 18:37</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@Aravin Yes It is.</span> <span> - </span> <span class="display-name">ruohola</span> <span> </span> <span class="date">29 Sep 2021 at 11:01</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@iwazovsky If you're using string-level validation to determine whether you can "trust" the email entered, you're already doing it wrong. Using it for anything other than catching mistakes is a lost cause, and most mistakes that don't get caught by this are going to be something that no regex can catch anyway because they'll probably still look like a valid email.</span> <span> - </span> <span class="display-name">John Montgomery</span> <span> </span> <span class="date">20 Jan 2022 at 00:38</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>86</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Miloš Rašić</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Mar 2011 at 11:26</span>
     </div>
    </div>
    <div>
     <p>Correct validation of email address in compliance with the RFCs is not something that can be achieved with a one-liner regular expression. An article with the best solution I've found in PHP is <em><a href="http://www.dominicsayers.com/isemail/" rel="noreferrer">What is a valid email address?</a></em>. Obviously, it has been ported to Java. <strike>I think the function is too complex to be ported and used in JavaScript.</strike> JavaScript/node.js port: <a href="https://www.npmjs.com/package/email-addresses" rel="noreferrer">https://www.npmjs.com/package/email-addresses</a>.</p>
     <p>A good practice is to validate your data on the client, but double-check the validation on the server. With this in mind, you can simply check whether a string looks like a valid email address on the client and perform the strict check on the server.</p>
     <p>Here's the JavaScript function I use to check if a string looks like a valid mail address:</p>
     <pre><code>function looksLikeMail(str) {
    var lastAtPos = str.lastIndexOf('@');
    var lastDotPos = str.lastIndexOf('.');
    return (lastAtPos &lt; lastDotPos &amp;&amp; lastAtPos &gt; 0 &amp;&amp; str.indexOf('@@') == -1 &amp;&amp; lastDotPos &gt; 2 &amp;&amp; (str.length - lastDotPos) &gt; 2);
}
</code></pre>
     <p>Explanation:</p>
     <ul>
      <li>
       <p><code>lastAtPos &lt; lastDotPos</code>: Last <code>@</code> should be before last <code>.</code> since <code>@</code> cannot be part of server name (as far as I know).</p></li>
      <li>
       <p><code>lastAtPos &gt; 0</code>: There should be something (the email username) before the last <code>@</code>.</p></li>
      <li>
       <p><code>str.indexOf('@@') == -1</code>: There should be no <code>@@</code> in the address. Even if <code>@</code> appears as the last character in email username, it has to be quoted so <code>"</code> would be between that <code>@</code> and the last <code>@</code> in the address.</p></li>
      <li>
       <p><code>lastDotPos &gt; 2</code>: There should be at least three characters before the last dot, for example <code>a@b.com</code>.</p></li>
      <li>
       <p><code>(str.length - lastDotPos) &gt; 2</code>: There should be enough characters after the last dot to form a two-character domain. I'm not sure if the brackets are necessary.</p></li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>85</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Bob van Luijt</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Apr 2013 at 13:31</span>
     </div>
    </div>
    <div>
     <p>This is the correct RFC822 version.</p>
     <pre><code>function checkEmail(emailAddress) {
  var sQtext = '[^\\x0d\\x22\\x5c\\x80-\\xff]';
  var sDtext = '[^\\x0d\\x5b-\\x5d\\x80-\\xff]';
  var sAtom = '[^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+';
  var sQuotedPair = '\\x5c[\\x00-\\x7f]';
  var sDomainLiteral = '\\x5b(' + sDtext + '|' + sQuotedPair + ')*\\x5d';
  var sQuotedString = '\\x22(' + sQtext + '|' + sQuotedPair + ')*\\x22';
  var sDomain_ref = sAtom;
  var sSubDomain = '(' + sDomain_ref + '|' + sDomainLiteral + ')';
  var sWord = '(' + sAtom + '|' + sQuotedString + ')';
  var sDomain = sSubDomain + '(\\x2e' + sSubDomain + ')*';
  var sLocalPart = sWord + '(\\x2e' + sWord + ')*';
  var sAddrSpec = sLocalPart + '\\x40' + sDomain; // complete RFC822 email address spec
  var sValidEmail = '^' + sAddrSpec + '$'; // as whole string

  var reValidEmail = new RegExp(sValidEmail);

  return reValidEmail.test(emailAddress);
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>IDN addresses are not validated (info@üpöü.com)</span> <span> - </span> <span class="display-name">D.A.H</span> <span> </span> <span class="date">17 Aug 2014 at 17:38</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>'a@a' returns valid: <a href="https://jsfiddle.net/pmiranda/guoyh4dv/" rel="nofollow noreferrer">jsfiddle.net/pmiranda/guoyh4dv</a></span> <span> - </span> <span class="display-name">pmiranda</span> <span> </span> <span class="date">2 Feb 2021 at 18:18</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@pmiranda That <i>is</i> a valid email address.</span> <span> - </span> <span class="display-name">ruohola</span> <span> </span> <span class="date">29 Sep 2021 at 11:01</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@ruohola it has not top-level domain (separated by periods) <a href="https://datatracker.ietf.org/doc/html/rfc3696" rel="nofollow noreferrer">datatracker.ietf.org/doc/html/rfc3696</a></span> <span> - </span> <span class="display-name">pmiranda</span> <span> </span> <span class="date">29 Sep 2021 at 11:59</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@pmiranda E.g. <code>http://ai</code> is someone's valid domain, so they could use e.g. <code>a@ai</code> as their email.</span> <span> - </span> <span class="display-name">ruohola</span> <span> </span> <span class="date">29 Sep 2021 at 12:40</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Agreed with @ruohola – this is a valid address</span> <span> - </span> <span class="display-name">Bob van Luijt</span> <span> </span> <span class="date">29 Sep 2021 at 14:03</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>77</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Adam McKee</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 May 2009 at 17:19</span>
     </div>
    </div>
    <div>
     <p>This was stolen from <a href="http://codesnippets.joyent.com/posts/show/1917" rel="noreferrer">http://codesnippets.joyent.com/posts/show/1917</a></p>
     <pre><code>email = $('email');
filter = /^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/;
if (filter.test(email.value)) {
  // Yay! valid
  return true;
}
else
  {return false;}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span> <span class="arrow"> <a href="#answer_15">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>74</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ryan Taylor</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Nov 2012 at 14:06</span>
     </div>
    </div>
    <div>
     <p>Do this:</p>
     <pre><code>^([a-zA-Z0-9!#$%&amp;'*+\/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&amp;'*+\/=?^_`{|}~-]+)*@(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?)$
</code></pre>
     <p><strong>It's based on <a href="https://www.ietf.org/rfc/rfc2822.txt" rel="noreferrer">RFC 2822</a></strong></p>
     <p>Test it at <a href="https://regex101.com/r/857lzc/1" rel="noreferrer">https://regex101.com/r/857lzc/1</a></p>
     <p>Often when storing email addresses in the database I make them lowercase and, in practice, regexs can usually be marked case insensitive. In those cases this is slightly shorter:</p>
     <pre><code>[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?
</code></pre>
     <p>Here's an example of it being used in JavaScript (with the case insensitive flag <code>i</code> at the end).</p>
     <pre><code>var emailCheck=/^[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i;
console.log( emailCheck.test('some.body@domain.co.uk') );
</code></pre>
     <p><strong>Note</strong>:<br>
       Technically some emails can include quotes in the section before the <code>@</code> symbol with escape characters inside the quotes (so your email user can be obnoxious and contain stuff like <code>@</code> and <code>"..."</code> as long as it's written in quotes). NOBODY DOES THIS EVER! It's obsolete. But, it IS included in the true <a href="https://www.ietf.org/rfc/rfc2822.txt" rel="noreferrer">RFC 2822</a> standard and omitted here.</p>
     <p><strong>Note 2</strong>: The beginning of an email (before the @ sign) <em>can</em> be case sensitive (via the spec). However, anyone with a case-sensitive email is probably used to having issues, and, in practice, case insensitive is a safe assumption. More info: <a href="https://stackoverflow.com/questions/9807909/are-email-addresses-case-sensitive">Are email addresses case sensitive?</a></p>
     <p>More info: <a href="http://www.regular-expressions.info/email.html" rel="noreferrer">http://www.regular-expressions.info/email.html</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>gautam+@Gmail.com - showing is valid which should not</span> <span> - </span> <span class="display-name">Gautam Parmar</span> <span> </span> <span class="date">6 Aug 2021 at 06:33</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@GautamParmar gmail and others ignore symbols; mail sent to gautam+@gmail.com would end up in gautam@gmail.com's email inbox.</span> <span> - </span> <span class="display-name">TylerH</span> <span> </span> <span class="date">4 May 2022 at 13:20</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_15"><span>Answer 15</span> <span class="arrow"> <a href="#answer_14">↑</a> </span> <span class="arrow"> <a href="#answer_16">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>53</span>
     </div>
     <div>
      <span>Answerer: </span> <span>CVE-RICK</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Jul 2016 at 04:43</span>
     </div>
    </div>
    <div>
     <p>I'm really looking forward to solve this problem. So I modified email validation regular expression above</p>
     <ul>
      <li>
       <p>Original<br><code>/^(([^&lt;&gt;()\[\]\\.,;:\s@"]+(\.[^&lt;&gt;()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/</code></p></li>
      <li>
       <p>Modified<br><code>/^(([^&lt;&gt;()\[\]\.,;:\s@\"]+(\.[^&lt;&gt;()\[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^&lt;&gt;()\.,;\s@\"]+\.{0,1})+[^&lt;&gt;()\.,;:\s@\"]{2,})$/</code></p></li>
     </ul>
     <p>to pass the examples in <a href="https://en.wikipedia.org/wiki/Email_address#cite_note-20/syntax">Wikipedia Email Address</a>.</p>
     <p>And you can see the result in <a href="http://regexr.com/3dnsr">here</a>.</p>
     <p><a href="https://i.stack.imgur.com/m2YBr.png"><img src="/question/stackoverflow/46155/m2YBr.png" alt="enter image description here"></a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_16"><span>Answer 16</span> <span class="arrow"> <a href="#answer_15">↑</a> </span> <span class="arrow"> <a href="#answer_17">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>37</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user2496033</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Jun 2013 at 06:30</span>
     </div>
    </div>
    <div>
     <p>Simply check out if the entered email address is valid or not using HTML.</p>
     <pre><code>&lt;input type="email"/&gt;
</code></pre>
     <p>There isn't any need to write a function for validation.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>This one is easiest solution, we can also use external library like <a href="https://www.npmjs.com/package/email-validator" rel="nofollow noreferrer">email validator</a> to makes things easier, as mentioned here <a href="https://qawithexperts.com/article/javascript/email-validation-using-javascript-with-or-without-regex/317" rel="nofollow noreferrer">qawithexperts.com/article/javascript/…</a></span> <span> - </span> <span class="display-name">Jyoti</span> <span> </span> <span class="date">22 Jan 2022 at 12:02</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_17"><span>Answer 17</span> <span class="arrow"> <a href="#answer_16">↑</a> </span> <span class="arrow"> <a href="#answer_18">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>32</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Liberateur</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Jun 2017 at 09:10</span>
     </div>
    </div>
    <div>
     <p><strong>Wikipedia standard mail syntax :</strong></p>
     <p><a href="https://en.wikipedia.org/wiki/Email_address#Examples" rel="noreferrer">https://en.wikipedia.org/wiki/Email_address#Examples</a> <a href="https://fr.wikipedia.org/wiki/Adresse_%C3%A9lectronique#Syntaxe_exacte" rel="noreferrer">https://fr.wikipedia.org/wiki/Adresse_%C3%A9lectronique#Syntaxe_exacte</a></p>
     <p><strong>Function :</strong></p>
     <pre><code>function validMail(mail)
{
    return /^(([^&lt;&gt;()\[\]\.,;:\s@\"]+(\.[^&lt;&gt;()\[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^&lt;&gt;()\.,;\s@\"]+\.{0,1})+([^&lt;&gt;()\.,;:\s@\"]{2,}|[\d\.]+))$/.test(mail);
}
</code></pre>
     <p><strong>Valid emails :</strong></p>
     <pre><code>validMail('Abc@example.com') // Return true
validMail('Abc@example.com.') // Return true
validMail('Abc@10.42.0.1') // Return true
validMail('user@localserver') // Return true
validMail('Abc.123@example.com') // Return true
validMail('user+mailbox/department=shipping@example.com') // Return true
validMail('"very.(),:;&lt;&gt;[]\".VERY.\"very@\\ \"very\".unusual"@strange.example.com') // Return true
validMail('!#$%&amp;\'*+-/=?^_`.{|}~@example.com') // Return true
validMail('"()&lt;&gt;[]:,;@\\\"!#$%&amp;\'-/=?^_`{}| ~.a"@example.org') // Return true
validMail('"Abc@def"@example.com') // Return true
validMail('"Fred Bloggs"@example.com') // Return true
validMail('"Joe.\\Blow"@example.com') // Return true
validMail('Loïc.Accentué@voilà.fr') // Return true
validMail('" "@example.org') // Return true
validMail('user@[IPv6:2001:DB8::1]') // Return true
</code></pre>
     <p><strong>Invalid emails :</strong></p>
     <pre><code>validMail('Abc.example.com') // Return false
validMail('A@b@c@example.com') // Return false
validMail('a"b(c)d,e:f;g&lt;h&gt;i[j\k]l@example.com') // Return false
validMail('just"not"right@example.com') // Return false
validMail('this is"not\allowed@example.com') // Return false
validMail('this\ still\"not\\allowed@example.com') // Return false
validMail('john..doe@example.com') // Return false
validMail('john.doe@example..com') // Return false
</code></pre>
     <p><strong>Show this test : <a href="https://regex101.com/r/LHJ9gU/1" rel="noreferrer">https://regex101.com/r/LHJ9gU/1</a></strong></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>This address "abc@example" shall return false, but it return true. The wiki page mentioned that: "it must match the requirements for a hostname" <a href="https://en.wikipedia.org/wiki/Email_address#Domain" rel="nofollow noreferrer">en.wikipedia.org/wiki/Email_address#Domain</a></span> <span> - </span> <span class="display-name">Brian Ho</span> <span> </span> <span class="date">16 Sep 2022 at 02:23</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span><code>abc.def@mail</code> return true :(</span> <span> - </span> <span class="display-name">Muhammad Shahzad</span> <span> </span> <span class="date">19 Sep 2022 at 10:39</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_18"><span>Answer 18</span> <span class="arrow"> <a href="#answer_17">↑</a> </span> <span class="arrow"> <a href="#answer_19">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>31</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Zo72</span>
     </div>
     <div>
      <span> Answered: </span> <span>19 Dec 2011 at 18:39</span>
     </div>
    </div>
    <div>
     <p>You should not use regular expressions to validate an input string to check if it's an email. It's too complicated and would not cover all the cases.</p>
     <p>Now since you can only cover 90% of the cases, write something like:</p>
     <pre><code>function isPossiblyValidEmail(txt) {
   return txt.length &gt; 5 &amp;&amp; txt.indexOf('@')&gt;0;
}
</code></pre>
     <p>You can refine it. For instance, 'aaa@' is valid. But overall you get the gist. And don't get carried away... A simple 90% solution is better than 100% solution that does not work.</p>
     <p>The world needs simpler code...</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>27</td>
        <td><span>This allows the entry of so many invalid email addresses it is useless advice.</span> <span> - </span> <span class="display-name">cazlab</span> <span> </span> <span class="date">6 Jan 2012 at 23:07</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_19"><span>Answer 19</span> <span class="arrow"> <a href="#answer_18">↑</a> </span> <span class="arrow"> <a href="#answer_20">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>28</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Juan Pablo</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Feb 2018 at 20:42</span>
     </div>
    </div>
    <div>
     <p>Regex updated! try this</p>
     <pre><code>let val = 'email@domain.com';
if(/^[a-z0-9][a-z0-9-_\.]+@([a-z]|[a-z0-9]?[a-z0-9-]+[a-z0-9])\.[a-z0-9]{2,10}(?:\.[a-z]{2,10})?$/.test(val)) {
   console.log('passed');
}
</code></pre>
     <p>typscript version complete</p>
     <pre><code>//
export const emailValid = (val:string):boolean =&gt; /^[a-z0-9][a-z0-9-_\.]+@([a-z]|[a-z0-9]?[a-z0-9-]+[a-z0-9])\.[a-z0-9]{2,10}(?:\.[a-z]{2,10})?$/.test(val);
</code></pre>
     <p>more info <a href="https://git.io/vhEfc" rel="noreferrer">https://git.io/vhEfc</a></p>
     <p><a href="https://i.stack.imgur.com/uwNgO.png" rel="noreferrer"><img src="/question/stackoverflow/46155/uwNgO.png" alt="regex test case"></a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>I don't see this as useful at all for much of the world--and a non-trivial audience for many customers. It fails for internationalized usernames and domains. My answer below addresses this using the URL interface which already has support built into most runtimes. ref: <a href="https://stackoverflow.com/a/72018404/965666">stackoverflow.com/a/72018404/965666</a></span> <span> - </span> <span class="display-name">jimmont</span> <span> </span> <span class="date">26 Jul 2022 at 01:08</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Maybe make the regex case insensitive. Otherwise it will fail the email address with the uppercase characters.</span> <span> - </span> <span class="display-name">Brian Ho</span> <span> </span> <span class="date">16 Sep 2022 at 02:52</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_20"><span>Answer 20</span> <span class="arrow"> <a href="#answer_19">↑</a> </span> <span class="arrow"> <a href="#answer_21">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>25</span>
     </div>
     <div>
      <span>Answerer: </span> <span>jacobangel</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 May 2009 at 17:23</span>
     </div>
    </div>
    <div>
     <p>It's hard to get an email validator 100% correct. The only real way to get it correct would be to send a test email to the account. That said, there are a few basic checks that can help make sure that you're getting something reasonable.</p>
     <p>Some things to improve:</p>
     <p>Instead of new <code>RegExp</code>, just try writing the <code>regexp</code> out like this:</p>
     <pre><code>if (reg.test(/@/))
</code></pre>
     <p>Second, check to make sure that a period comes after the <code>@</code> sign, and make sure that there are characters between the <code>@</code>s and periods.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_21"><span>Answer 21</span> <span class="arrow"> <a href="#answer_20">↑</a> </span> <span class="arrow"> <a href="#answer_22">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>21</span>
     </div>
     <div>
      <span>Answerer: </span> <span>pera</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Sep 2013 at 02:21</span>
     </div>
    </div>
    <div>
     <p>This is how <a href="https://github.com/chriso/validator.js" rel="noreferrer">node-validator</a> does it:</p>
     <pre><code>/^(?:[\w\!\#\$\%\&amp;\'\*\+\-\/\=\?\^\`\{\|\}\~]+\.)*[\w\!\#\$\%\&amp;\'\*\+\-\/\=\?\^\`\{\|\}\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!\.)){0,61}[a-zA-Z0-9]?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\[(?:(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\]))$/
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_22"><span>Answer 22</span> <span class="arrow"> <a href="#answer_21">↑</a> </span> <span class="arrow"> <a href="#answer_23">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>19</span>
     </div>
     <div>
      <span>Answerer: </span> <span>bman</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Dec 2016 at 02:51</span>
     </div>
    </div>
    <div>
     <h2>A solution that does not check the existence of the TLD is incomplete.</h2>
     <p>Almost all answers to this questions suggest using Regex to validate emails addresses. I think Regex is only good for a rudimentary validation. It seems that the checking validation of email addresses is actually two separate problems:</p>
     <p><strong>1- Validation of email format:</strong> Making sure if the email complies with the format and pattern of emails in RFC 5322 and if the TLD actually exists. A list of all valid TLDs can be found <a href="http://data.iana.org/TLD/tlds-alpha-by-domain.txt" rel="noreferrer">here</a>.</p>
     <p>For example, although the address <code>example@example.ccc</code> will pass the regex, it is not a valid email, because <code>ccc</code> is not a top-level domain by IANA.</p>
     <p><strong>2- Making sure the email actually exists:</strong> For doing this, <strong>the only option</strong> is <a href="https://davidcel.is/posts/stop-validating-email-addresses-with-regex/#just-send-them-an-email-already" rel="noreferrer">to send the users an email</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_23"><span>Answer 23</span> <span class="arrow"> <a href="#answer_22">↑</a> </span> <span class="arrow"> <a href="#answer_24">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>17</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Orchid</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Nov 2013 at 12:26</span>
     </div>
    </div>
    <div>
     <p>Use this code inside your validator function:</p>
     <pre><code>var emailID = document.forms["formName"]["form element id"].value;
atpos = emailID.indexOf("@");
dotpos = emailID.lastIndexOf(".");
if (atpos &lt; 1 || ( dotpos - atpos &lt; 2 ))
{
    alert("Please enter correct email ID")
    return false;
}
</code></pre>
     <p>Else you can use <a href="http://en.wikipedia.org/wiki/JQuery" rel="noreferrer">jQuery</a>. Inside rules define:</p>
     <pre><code>eMailId: {
    required: true,
    email: true
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_24"><span>Answer 24</span> <span class="arrow"> <a href="#answer_23">↑</a> </span> <span class="arrow"> <a href="#answer_25">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>15</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Steve C</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Jun 2012 at 23:41</span>
     </div>
    </div>
    <div>
     <p>In contrast to <em>squirtle</em>, here is a complex solution, but it does a mighty fine job of validating emails properly:</p>
     <pre><code>function isEmail(email) { 
    return /^((([a-z]|\d|[!#\$%&amp;'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&amp;'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i.test(email);
} 
</code></pre>
     <p>Use like so:<br><br></p>
     <pre><code>if (isEmail('youremail@yourdomain.com')){ console.log('This is email is valid'); }
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_25"><span>Answer 25</span> <span class="arrow"> <a href="#answer_24">↑</a> </span> <span class="arrow"> <a href="#answer_26">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>15</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Tugrul</span>
     </div>
     <div>
      <span> Answered: </span> <span>31 Jan 2013 at 09:39</span>
     </div>
    </div>
    <div>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>var testresults

function checkemail() {
  var str = document.validation.emailcheck.value
  var filter = /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,6}(?:\.[a-z]{2})?)$/i
  if (filter.test(str))
    testresults = true
  else {
    alert("Please input a valid email address!")
    testresults = false
  }
  return (testresults)
}

function checkbae() {
  if (document.layers || document.getElementById || document.all)
    return checkemail()
  else
    return true
}</code></pre>
       <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;form name="validation" onSubmit="return checkbae()"&gt;
  Please input a valid email address:&lt;br /&gt;

  &lt;input type="text" size=18 name="emailcheck"&gt;
  &lt;input type="submit" value="Submit"&gt;
&lt;/form&gt;</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_26"><span>Answer 26</span> <span class="arrow"> <a href="#answer_25">↑</a> </span> <span class="arrow"> <a href="#answer_27">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>14</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Linkmichiel</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Apr 2013 at 11:53</span>
     </div>
    </div>
    <div>
     <p>My knowledge of <a href="http://en.wikipedia.org/wiki/Regular_expression" rel="noreferrer">regular expressions</a> is not that good. That's why I check the general syntax with a simple regular expression first and check more specific options with other functions afterwards. This may not be not the best technical solution, but this way I'm way more flexible and faster.</p>
     <p>The most common errors I've come across are spaces (especially at the beginning and end) and occasionally a double dot.</p>
     <pre><code>function check_email(val){
    if(!val.match(/\S+@\S+\.\S+/)){ // Jaymon's / Squirtle's solution
        // Do something
        return false;
    }
    if( val.indexOf(' ')!=-1 || val.indexOf('..')!=-1){
        // Do something
        return false;
    }
    return true;
}

check_email('check@thiscom'); // Returns false
check_email('check@this..com'); // Returns false
check_email(' check@this.com'); // Returns false
check_email('check@this.com'); // Returns true
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_27"><span>Answer 27</span> <span class="arrow"> <a href="#answer_26">↑</a> </span> <span class="arrow"> <a href="#answer_28">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>13</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Prabhat Kasera</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Dec 2016 at 07:44</span>
     </div>
    </div>
    <div>
     <p>Regex for validating email address</p>
     <pre><code>[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])+
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_28"><span>Answer 28</span> <span class="arrow"> <a href="#answer_27">↑</a> </span> <span class="arrow"> <a href="#answer_29">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>12</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Eric Schoonover</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 May 2010 at 22:05</span>
     </div>
    </div>
    <div>
     <p>Here is a very good discussion about using regular expressions to validate email addresses; "<a href="http://fightingforalostcause.net/misc/2006/compare-email-regex.php" rel="noreferrer">Comparing E-mail Address Validating Regular Expressions</a>"</p>
     <p>Here is the current top expression, that is JavaScript compatible, for reference purposes:</p>
     <pre><code>/^[-a-z0-9~!$%^&amp;*_=+}{\'?]+(\.[-a-z0-9~!$%^&amp;*_=+}{\'?]+)*@([a-z0-9_][-a-z0-9_]*(\.[-a-z0-9_]+)*\.(aero|arpa|biz|com|coop|edu|gov|info|int|mil|museum|name|net|org|pro|travel|mobi|[a-z][a-z])|([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}))(:[0-9]{1,5})?$/i
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Extremely outdated now.</span> <span> - </span> <span class="display-name">Slbox</span> <span> </span> <span class="date">3 Sep 2021 at 19:02</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_29"><span>Answer 29</span> <span class="arrow"> <a href="#answer_28">↑</a> </span> <span class="arrow"> <a href="#answer_30">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>12</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Félix Saparelli</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Oct 2010 at 09:37</span>
     </div>
    </div>
    <div>
     <p>Apparently, that's it:</p>
     <pre><code>/^([\w\!\#$\%\&amp;\'\*\+\-\/\=\?\^\`{\|\}\~]+\.)*[\w\!\#$\%\&amp;\'\*\+\-\/\=\?\^\`{\|\}\~]+@((((([a-z0-9]{1}[a-z0-9\-]{0,62}[a-z0-9]{1})|[a-z])\.)+[a-z]{2,6})|(\d{1,3}\.){3}\d{1,3}(\:\d{1,5})?)$/i
</code></pre>
     <p>Taken from <a href="http://fightingforalostcause.net/misc/2006/compare-email-regex.php" rel="noreferrer">http://fightingforalostcause.net/misc/2006/compare-email-regex.php</a> on Oct 1 '10.</p>
     <p>But, of course, that's ignoring internationalization.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_30"><span>Answer 30</span> <span class="arrow"> <a href="#answer_29">↑</a> </span> <span class="arrow"> <a href="#answer_31">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>11</span>
     </div>
     <div>
      <span>Answerer: </span> <span>endyourif</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Jan 2020 at 19:36</span>
     </div>
    </div>
    <div>
     <p>Wow, there are a lot of answers that contain slightly different regular expressions. I've tried many that I've got different results and a variety of different issues with all of them.</p>
     <p>For UI validation, I'm good with the most basic check of <a href="https://www.endyourif.com/validate-an-email-address-in-javascript/" rel="noreferrer">looking for an @ sign</a>. It's important to note, that I always do server-side validation with a standard "validate email" that contains a unique link for the user to confirm their email address.</p>
     <pre><code>if (email.indexOf('@') &gt; 0)
</code></pre>
     <p>I have purposely chosen 0 even with zero-based as it also ensures there is a single character before the @.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_31"><span>Answer 31</span> <span class="arrow"> <a href="#answer_30">↑</a> </span> <span class="arrow"> <a href="#answer_32">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>10</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Negin</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Jan 2017 at 05:38</span>
     </div>
    </div>
    <div>
     <p>I was looking for a Regex in JS that passes all Email Address test cases:</p>
     <ul>
      <li>
       <p><code>email@example.com</code> Valid email</p></li>
      <li>
       <p><code>firstname.lastname@example.com</code> Email contains dot in the address field</p></li>
      <li>
       <p><code>email@subdomain.example.com</code> Email contains dot with subdomain</p></li>
      <li>
       <p><code>firstname+lastname@example.com</code> Plus sign is considered valid character</p></li>
      <li>
       <p><code>email@192.0.2.123</code> Domain is valid IP address</p></li>
      <li>
       <p><code>email@[192.0.2.123]</code> Square bracket around IP address is considered valid</p></li>
      <li>
       <p><code>“email”@example.com</code> Quotes around email is considered valid</p></li>
      <li>
       <p><code>1234567890@example.com</code> Digits in address are valid</p></li>
      <li>
       <p><code>email@domain-one.example</code> Dash in domain name is valid</p></li>
      <li>
       <p><code>_______@example.com</code> Underscore in the address field is valid</p></li>
      <li>
       <p><code>email@example.name</code> <code>.name</code> is valid Top Level Domain name</p></li>
      <li>
       <p><code>email@example.co.jp</code> Dot in Top Level Domain name also considered valid (using <code>co.jp</code> as example here)</p></li>
      <li>
       <p><code>firstname-lastname@example.com</code> Dash in address field is valid</p></li>
     </ul>
     <p>Here we go :</p>
     <p><a href="http://regexr.com/3f07j" rel="noreferrer">http://regexr.com/3f07j</a></p>
     <p>OR regex:</p>
     <pre><code>Regex = /(([^&lt;&gt;()\[\]\\.,;:\s@"]+(\.[^&lt;&gt;()\[\]\\.,;:\s@"]+)*)|(".+"))@[*[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+]*/
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_32"><span>Answer 32</span> <span class="arrow"> <a href="#answer_31">↑</a> </span> <span class="arrow"> <a href="#answer_33">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>10</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Renish Gotecha</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Dec 2019 at 08:52</span>
     </div>
    </div>
    <div>
     <p>In my case, I wanted to avoid <code>~</code> and <code>#</code> that's why I have used <a href="https://regex101.com/r/SOgUIV/1" rel="noreferrer">another solution</a>:</p>
     <pre><code>function validEmail(email){
  const regex = /^((?!\.)[\w\-_.]*[^.])(@\w+)(\.\w+(\.\w+)?[^.\W])$/;
  return regex.test(email);
}
</code></pre>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>function validEmail(email){
  const regex = /^((?!\.)[\w\-_.]*[^.])(@\w+)(\.\w+(\.\w+)?[^.\W])$/;
  return regex.test(email);
}

const emails = [
'pio_pio@factory.com',
'~pio_pio@factory.com',
'pio_~pio@factory.com',
'pio_#pio@factory.com',
'pio_pio@#factory.com',
'pio_pio@factory.c#om',
'pio_pio@factory.c*om',
'pio^_pio@factory.com'
]

for(const email of emails){
  document.write(email+' : '+validEmail(email)+'&lt;/br&gt;');
}</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>This answer - and a few others in this thread - do not escape the hyphen. From what I can see (September 2021) this poses no problem in browsers - at least the Webkit variants. However, this might change. At the time of writing PHP7.3 fails to compile the regex without escaping the hyphen. Future proof your browser side code by escaping the hyphen <code>\-</code> rather than just <code>-</code>.</span> <span> - </span> <span class="display-name">DroidOS</span> <span> </span> <span class="date">29 Sep 2021 at 12:28</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_33"><span>Answer 33</span> <span class="arrow"> <a href="#answer_32">↑</a> </span> <span class="arrow"> <a href="#answer_34">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>9</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ebrahim</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Jul 2020 at 14:55</span>
     </div>
    </div>
    <div>
     <p>Most of the answers here are not linter friendly, it's a mess! Some of them are also outdated! After a lot of time spending, I decided to use an external library named <code>email-validator</code>, install it easily by npm for example and import/require it in your own project:</p>
     <p><a href="https://www.npmjs.com/package/email-validator" rel="nofollow noreferrer">https://www.npmjs.com/package/email-validator</a></p>
     <pre><code>//NodeJs
const validator = require("email-validator");
validator.validate("test@email.com"); // true

//TypeScript/JavaScript
import * as EmailValidator from 'email-validator';
EmailValidator.validate("test@email.com"); // true
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>It's not the answer to the question, but it helped me and saved my time. This email-validator package seem to help round about half a million other (downloads) per week. So worth to mention and deserves some upvotes.</span> <span> - </span> <span class="display-name">Stefan</span> <span> </span> <span class="date">20 Oct 2020 at 15:02</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_34"><span>Answer 34</span> <span class="arrow"> <a href="#answer_33">↑</a> </span> <span class="arrow"> <a href="#answer_35">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user1843640</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Feb 2020 at 15:38</span>
     </div>
    </div>
    <div>
     <p>I prefer to keep it simple and keep my users happy. I also prefer code which is easy to understand. RegEx is not.</p>
     <pre><code>function isValidEmail(value) {
    const atLocation = value.lastIndexOf("@");
    const dotLocation = value.lastIndexOf("."); 
    return (
        atLocation &gt; 0 &amp;&amp;
        dotLocation &gt; atLocation + 1 &amp;&amp;
        dotLocation &lt; value.length - 1
    );
};
</code></pre>
     <ul>
      <li>Get the location of the last "@" and the last "."</li>
      <li>Make sure the "@" is not the first char (there is something before it)</li>
      <li>Make sure the "." is after the "@" and that there is at least one char between them</li>
      <li>Make sure there is at least a single char after the "."</li>
     </ul>
     <p>Will this allow invalid email addresses to pass? Sure, but I don't think you need much more for a good user experience that allows you to enable/disable a button, display an error message, etc. You only know for sure that an email address is valid when you attempt to send an email to that address.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>This will fail for emails ending in a comment containing a @, for example " elldffs@mydomain.kjfdij (this is @ comment)" which is a valid email</span> <span> - </span> <span class="display-name">David Mårtensson</span> <span> </span> <span class="date">16 Feb 2021 at 18:42</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_35"><span>Answer 35</span> <span class="arrow"> <a href="#answer_34">↑</a> </span> <span class="arrow"> <a href="#answer_36">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Neil Thompson</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Dec 2013 at 10:44</span>
     </div>
    </div>
    <div>
     <p>The regular expression provided by Microsoft within <a href="http://en.wikipedia.org/wiki/ASP.NET_MVC_Framework" rel="noreferrer">ASP.NET MVC</a> is</p>
     <pre><code>/^[\w-]+(\.[\w-]+)*@([a-z0-9-]+(\.[a-z0-9-]+)*?\.[a-z]{2,6}|(\d{1,3}\.){3}\d{1,3})(:\d{4})?$/
</code></pre>
     <p>Which I post here in case it's flawed - though it's always been perfect for my needs.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>Doesn't allow +'s in the name part of the email.</span> <span> - </span> <span class="display-name">Paul Gordon</span> <span> </span> <span class="date">9 Mar 2015 at 15:19</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_36"><span>Answer 36</span> <span class="arrow"> <a href="#answer_35">↑</a> </span> <span class="arrow"> <a href="#answer_37">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Darren Cato</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Aug 2012 at 15:00</span>
     </div>
    </div>
    <div>
     <p>Sectrean's solution works great, but it was failing my <a href="https://en.wikipedia.org/wiki/Lint_%28software%29" rel="nofollow">linter</a>. So I added some escapes:</p>
     <pre><code>function validateEmail(email){ 
     var re = /^(([^&lt;&gt;()[]\\.,;:\s@\"]+(\.[^&lt;&gt;()[]\\.,;:\s@\"]+)*)|(\".+\"))@(([[0-9]{1,3}\‌​.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/; 
     return re.test(email); 
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>validateEmail("e_mail@sth.com") and validateEmail("e.mail@sth.com") both return <code>false</code> value</span> <span> - </span> <span class="display-name">Ikrom</span> <span> </span> <span class="date">22 Oct 2013 at 10:04</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_37"><span>Answer 37</span> <span class="arrow"> <a href="#answer_36">↑</a> </span> <span class="arrow"> <a href="#answer_38">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>cyberrspiritt</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Sep 2015 at 06:31</span>
     </div>
    </div>
    <div>
     <p>The best practice is to either use HTML5 built-in email tag.</p>
     <pre><code>&lt;input type="email" name="email"&gt;
</code></pre>
     <p>or the common email syntax as recognizing @ and . from the string is given below.</p>
     <pre><code>^[a-zA-Z0-9_\-.]+@[a-zA-Z0-9\-]+\.[a-zA-Z0-9\-.]+$
</code></pre>
     <blockquote>
      <p>Note that this would still produce <strong>invalid email</strong> that will still match the regex, its almost impossible to catch them all but this will improve the situation a little.</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>See earlier comment 32 this is good, but the problem with this is that it must be inside a form tag and submitted by a submit input, which not everyone has the luxury of doing. Also, you can't really style the error message. – @Jason Nov 12 '11 at 0:08</span> <span> - </span> <span class="display-name">aNewb</span> <span> </span> <span class="date">3 Dec 2020 at 02:24</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_38"><span>Answer 38</span> <span class="arrow"> <a href="#answer_37">↑</a> </span> <span class="arrow"> <a href="#answer_39">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Sbbs</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Jun 2018 at 12:13</span>
     </div>
    </div>
    <div>
     <p>This is a JavaScript translation of the validation suggested by the official Rails guide used by thousands of websites:</p>
     <pre><code>/^([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})$/i
</code></pre>
     <p>Relatively simple but tests against most common errors.</p>
     <p>Tested on a dataset of thousands of emails and it had zero false negatives/positives.</p>
     <p>Example usage:</p>
     <pre><code>const emailRegex = /^([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})$/i;

emailRegex.test('email@example.com');    // true

// Multi-word domains
emailRegex.test('email@example.co.uk');  // true
emailRegex.test('email@mail.gmail.com'); // true

// Valid special characters
emailRegex.test('unusual+but+valid+email1900=/!#$%&amp;\'*+-/=?^_`.{|}~@example.com') // true

// Trailing dots
emailRegex.test('email@example.co.uk.'); // false

// No domain
emailRegex.test('email@example');        // false

// Leading space
emailRegex.test(' email@example.com');   // false

// Trailing space
emailRegex.test('email@example.com ');   // false

// Incorrect domains
emailRegex.test('email@example,com ');   // false

// Other invalid emails
emailRegex.test('invalid.email.com')        // false
emailRegex.test('invalid@email@domain.com') // false
emailRegex.test('email@example..com')       // false
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_39"><span>Answer 39</span> <span class="arrow"> <a href="#answer_38">↑</a> </span> <span class="arrow"> <a href="#answer_40">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>zeros-and-ones</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Aug 2014 at 18:33</span>
     </div>
    </div>
    <div>
     <p>Here is a function I use for front end email validation. (The Regular Expression came from parsley.js)</p>
     <pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Our Company&lt;/title&gt;
    &lt;style&gt;
        .form-style {
            color: #ccc;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Email Validation Form Example&lt;/h1&gt;
    &lt;input type="text" name="email" id="emailInput" class="form-style"&gt;
    &lt;script&gt;
        function validateEmail(emailAddress) {
            var regularExpression = /^((([a-z]|\d|[!#\$%&amp;'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&amp;'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))){2,6}$/i;
             return regularExpression.test(emailAddress);
        }

        function showEmailValidationState(event) {
            if (validateEmail(event.target.value)) {
                document.getElementById("emailInput").style.color = 'black';
            }
        }
    document.getElementById("emailInput").addEventListener("keyup", showEmailValidationState);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_40"><span>Answer 40</span> <span class="arrow"> <a href="#answer_39">↑</a> </span> <span class="arrow"> <a href="#answer_41">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Code Spy</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Mar 2015 at 07:19</span>
     </div>
    </div>
    <div>
     <p><strong><em>Following Regex validations:</em></strong></p>
     <ul>
      <li>No spacial characters before @</li>
      <li>(-) and (.) should not be together after @ No special characters after @ 2 characters must before @ Email length should be less 128 characters</li>
     </ul>
     <pre><code>function validateEmail(email) {
var chrbeforAt = email.substr(0, email.indexOf('@'));
if (!($.trim(email).length &gt; 127)) {
    if (chrbeforAt.length &gt;= 2) {
        var re = /^(([^&lt;&gt;()[\]{}'^?\\.,!|//#%*-+=&amp;;:\s@\"]+(\.[^&lt;&gt;()[\]\\.,;:\s@\"]+)*)|(\".+\"))@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/;
        //var re = /[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/;
        return re.test(email);
    } else {
        return false;
    }
} else {
    return false;
}
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_41"><span>Answer 41</span> <span class="arrow"> <a href="#answer_40">↑</a> </span> <span class="arrow"> <a href="#answer_42">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Priya</span>
     </div>
     <div>
      <span> Answered: </span> <span>31 May 2016 at 08:30</span>
     </div>
    </div>
    <div>
     <p>Use the regular expression:</p>
     <pre class="lang-none prettyprint-override"><code> /^[a-z][a-zA-Z0-9_.]*(\.[a-zA-Z][a-zA-Z0-9_.]*)?@[a-z][a-zA-Z-0-9]*\.[a-z]+(\.[a-z]+)?$/
</code></pre>
     <p>Example:</p>
     <pre><code>function validateEmail(email) {
    var re = /^[a-z][a-zA-Z0-9_.]*(\.[a-zA-Z][a-zA-Z0-9_.]*)?@[a-z][a-zA-Z-0-9]*\.[a-z]+(\.[a-z]+)?$/;
    return re.test(email);
}
</code></pre>
     <p>It should allow only @ , . , _</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_42"><span>Answer 42</span> <span class="arrow"> <a href="#answer_41">↑</a> </span> <span class="arrow"> <a href="#answer_43">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>hmharsh3</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Jul 2017 at 03:33</span>
     </div>
    </div>
    <div>
     <p>You can also try</p>
     <pre><code>var string = "hmharsh3@gmail.com"
var exp = /(\w(=?@)\w+\.{1}[a-zA-Z]{2,})/i
alert(exp.test(string))
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_43"><span>Answer 43</span> <span class="arrow"> <a href="#answer_42">↑</a> </span> <span class="arrow"> <a href="#answer_44">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mattia Rasulo</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Jan 2020 at 17:32</span>
     </div>
    </div>
    <div>
     <p>You can use this regex (from <a href="https://www.w3resource.com/javascript/form/email-validation.php" rel="nofollow noreferrer">w3resource (*not related to W3C)</a>):</p>
     <pre><code>/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/.test(emailValue)
</code></pre>
     <p>If you use Node you can use this in the back-end as well as the front-end.</p>
     <p>I don't know other back-end languages so I cannot evaluate for other use cases.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>This regex fails on 'user+addition@gmail.com' and on 'user@email.longdomain'. Do not use.</span> <span> - </span> <span class="display-name">Xizam</span> <span> </span> <span class="date">24 Mar 2020 at 11:15</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>user+addition is a valid email and longdomain is not necessarily invalid..</span> <span> - </span> <span class="display-name">Mattia Rasulo</span> <span> </span> <span class="date">8 Jan 2021 at 15:30</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Exactly, no regex will ever be able to fully verify the format of an email and even if it would, it cannot know domain specific rules, just check for an @ and be done with it or send a verification email. Anything else is just asking for trouble.</span> <span> - </span> <span class="display-name">David Mårtensson</span> <span> </span> <span class="date">16 Feb 2021 at 18:30</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_44"><span>Answer 44</span> <span class="arrow"> <a href="#answer_43">↑</a> </span> <span class="arrow"> <a href="#answer_45">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Jaskaran Singh</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 Apr 2020 at 00:46</span>
     </div>
    </div>
    <div>
     <p>If you get this error: Using regular expressions is security-sensitive.</p>
     <p>Then here is what you are looking for. This solution is free from " Regular expression Denial of Service (ReDoS) "</p>
     <p>Regex to validate emails without (ReDoS):</p>
     <pre><code>/^[a-z0-9](?!.*?[^\na-z0-9]{2})[^\s@]+@[^\s@]+\.[^\s@]+[a-z0-9]$/
</code></pre>
     <p>Please let me know if this solution works for you. Thanks.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_45"><span>Answer 45</span> <span class="arrow"> <a href="#answer_44">↑</a> </span> <span class="arrow"> <a href="#answer_46">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Watts Epherson</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Aug 2022 at 10:53</span>
     </div>
    </div>
    <div>
     <p>The answer to this question (if you stood back and really thought about it) is that you can't really prevent a user from mistyping their e-mail. Everybody is providing answers that match all the possible letters but nobody has really taken into account the full myriad of characters that can be used.</p>
     <p>I refer you to this post and the answer explaining the amount of characters that can be accepted:- <a href="https://stackoverflow.com/questions/26855757/remove-invalid-characters-from-email">Remove invalid characters from e-mail</a></p>
     <p>You can't predict if the letters are the exact way the user intended them to be - which is the most common mistake.. missing a letter out or typing the wrong letter.</p>
     <p>Ultimately, no matter what you do in Javascript you will always need your backend script to check if the e-mail was sent successfully too and it will probably have a validation process in place too.</p>
     <p>So if you wanted to ensure it was some sort of e-mail address and not their username you only really need to check if there's an @ symbol in there and at least 1 dot and leave all the rest to your backend code.</p>
     <p>I have provided a very basic function that demonstrates a delayed check for real-time input and an instant check. Javascript is acting as a first checkpoint to validate the basics to save posting invalid content and annoying the user.</p>
     <p>It will always assume the bigger check is at the backend though.</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>// Very simple, non-library dependent client-side  e-mail validator
var emailv = {

  // Timeout handler for checkDelay()
  to: null, 
  
  // The core function that takes a string and validates it
  check : function(em){
    
    // Check 1 - The split ensures there's only one @
    var c1 = em.split('@').length == 2;
    
    // Check 2 - Must be at least 1 dot too
    var c2 = em.indexOf('.') &gt; 0;
    
    // Check 3 - ensures there's always something after a @ or dot
    var c3 = !(em.slice(-1)=="@"||em.slice(-1)==".");
    return (c1&amp;&amp;c2&amp;&amp;c3); // If all TRUE, great.
  },
  
  // Shortcut to quickly check any text input by dom id
  checkById : function(inputId){
    d = document.getElementById(inputId);
    return d?emailv.check(d.value):false;
  },
  
  // Check delay for checking on real-time inputs
  checkDelay: function(em){
      clearTimeout(emailv.to);
      emailv.to = setTimeout("emailv.checkDelayP2('"+em+"')",1000);
  },
  
  // Part two  of Check delay
  checkDelayP2: function(em){ 
      if(emailv.check(em)){ // Javascript filter says it seems okay

        // For sakes of this demo, pretend we are now making a background
        // check to see if e-mail is taken. We tell the user to wait..
        emailv.status("Wait..");

        // Pretend the background check took 2 seconds
        // and said e-mail was available
        setTimeout("emailv.status('OK')",2000);
      } else {
        // Javascript say it's bad, mmmkay?
         emailv.status("BAD E-mail");      
      }
  },
  
  status : function(s){
    document.getElementById('emailstatus').innerHTML=s;
  }
}</code></pre>
       <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;h2&gt;1 of 2 - Delayed check&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Waits until the user has stopped typing&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Useful for when you want to then send e-mail to background database to check if it exists.&lt;/li&gt;
&lt;li&gt;Allows them 1 idle second before checking the e-mail address.&lt;/li&gt;
&lt;/ul&gt;
&lt;input type="text" size="50" id="youremail" name="youremail" onkeyup="emailv.checkDelay(this.value)" onpaste="emailv.checkDelay(this.value)" /&gt;
&lt;span id='emailstatus'&gt;&lt;/span&gt;


&lt;h2&gt;2 of 2 - Instant Check&lt;/h2&gt;
&lt;input type="text" size="50" id="youremail2" name="youremail2" /&gt;
&lt;a href="Javascript:void(0)" onclick="alert(emailv.checkById('youremail2')?'Seems okay to me':'This e-mail is dodgy')"&gt;Check e-mail&lt;/a&gt;</code></pre>
      </div>
     </div>
     <p></p>
     <p>It would be better to avoid stopping the user entering a valid e-mail than to apply so many restrictions that it becomes complicated.</p>
     <p>This is just my opinion!</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_46"><span>Answer 46</span> <span class="arrow"> <a href="#answer_45">↑</a> </span> <span class="arrow"> <a href="#answer_47">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Simon Steele</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Sep 2013 at 12:37</span>
     </div>
    </div>
    <div>
     <p>If you're using Closure you can use the built-in <code>goog.format.EmailAddress</code> type:</p>
     <blockquote>
      <p><a href="http://web.archive.org/web/20140130083649/http://docs.closure-library.googlecode.com/git/class_goog_format_EmailAddress.html" rel="nofollow">http://docs.closure-library.googlecode.com/git/class_goog_format_EmailAddress.html</a></p>
     </blockquote>
     <p>For example:</p>
     <pre><code>goog.format.EmailAddress.isValidAddrSpec("blah@blah.com")
</code></pre>
     <p>Note that by reading the source (linked above) you can see the comments state that IDN are not supported and that it only aims to cover <em>most</em> addresses:</p>
     <pre><code>// This is a fairly naive implementation, but it covers 99% of use cases.
// For more details, see http://en.wikipedia.org/wiki/Email_address#Syntax
// TODO(mariakhomenko): we should also be handling i18n domain names as per
// http://en.wikipedia.org/wiki/Internationalized_domain_name
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_47"><span>Answer 47</span> <span class="arrow"> <a href="#answer_46">↑</a> </span> <span class="arrow"> <a href="#answer_48">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ferrakkem Bhuiyan</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Jan 2014 at 05:40</span>
     </div>
    </div>
    <div>
     <pre><code>&lt;pre&gt;
**The personal_info part contains the following ASCII characters.
1.Uppercase (A-Z) and lowercase (a-z) English letters.
2.Digits (0-9).
3.Characters ! # $ % &amp; ' * + - / = ? ^ _ ` { | } ~
4.Character . ( period, dot or fullstop) provided that it is not the first or last character and it will not come one after the other.**
&lt;/pre&gt;
*Example of valid email id*
&lt;pre&gt;
yoursite@ourearth.com
my.ownsite@ourearth.org
mysite@you.me.net
xxxx@gmail.com
xxxxxx@yahoo.com
&lt;/pre&gt;
&lt;pre&gt;
xxxx.ourearth.com [@ is not present] 
xxxx@.com.my [ tld (Top Level domain) can not start with dot "." ]
@you.me.net [ No character before @ ]
xxxx123@gmail.b [ ".b" is not a valid tld ]
xxxx@.org.org [ tld can not start with dot "." ]
.xxxx@mysite.org [ an email should not be start with "." ]
xxxxx()*@gmail.com [ here the regular expression only allows character, digit, underscore and dash ]
xxxx..1234@yahoo.com [double dots are not allowed
&lt;/pre&gt;
**javascript mail code**

    function ValidateEmail(inputText)
    {
    var mailformat = /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/;
    if(inputText.value.match(mailformat))
    {
    document.form1.text1.focus();
    return true;
    }
    else
    {
    alert("You have entered an invalid email address!");
    document.form1.text1.focus();
    return false;
    }
    }
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_48"><span>Answer 48</span> <span class="arrow"> <a href="#answer_47">↑</a> </span> <span class="arrow"> <a href="#answer_49">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>DestyNova</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Aug 2015 at 16:58</span>
     </div>
    </div>
    <div>
     <p>the best one :D (RFC-friendly &amp; no error "too complex") :</p>
     <pre><code>function    isMail(mail)
{
    pattuser = /^([A-Z0-9_%+\-!#$&amp;'*\/=?^`{|}~]+\.?)*[A-Z0-9_%+\-!#$&amp;'*\/=?^`{|}~]+$/i;
    pattdomain = /^([A-Z0-9-]+\.?)*[A-Z0-9-]+(\.[A-Z]{2,9})+$/i;

    tab = mail.split("@");
    if (tab.length != 2)
        return false;
    return (pattuser.test(tab[0]) &amp;&amp; pattdomain.test(tab[1]));
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_49"><span>Answer 49</span> <span class="arrow"> <a href="#answer_48">↑</a> </span> <span class="arrow"> <a href="#answer_50">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Kentonbmax</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Jul 2016 at 17:11</span>
     </div>
    </div>
    <div>
     <p>If you are using ng-pattern and material this does the job.</p>
     <pre><code>vm.validateEmail = '([a-zA-Z0-9_.]{1,})((@[a-zA-Z]{2,})[\\\.]([a-zA-Z]{2}|[a-zA-Z]{3}))';
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_50"><span>Answer 50</span> <span class="arrow"> <a href="#answer_49">↑</a> </span> <span class="arrow"> <a href="#answer_51">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>isapir</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Jan 2019 at 20:04</span>
     </div>
    </div>
    <div>
     <p>Here is the recommended Regex pattern for HTML5 on MDN:</p>
     <blockquote>
      <p>Browsers that support the email input type automatically provide validation to ensure that only text that matches the standard format for Internet e-mail addresses is entered into the input box. Browsers that implement the specification should be using an algorithm equivalent to the following regular expression:</p>
     </blockquote>
     <pre><code>/^[a-zA-Z0-9.!#$%&amp;'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}
[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
</code></pre>
     <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email#Validation" rel="nofollow noreferrer">https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email#Validation</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_51"><span>Answer 51</span> <span class="arrow"> <a href="#answer_50">↑</a> </span> <span class="arrow"> <a href="#answer_52">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>jimmont</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Apr 2022 at 17:51</span>
     </div>
    </div>
    <div>
     <p>Use the <code>URL</code> interface in JavaScript to parse the address in the minimum practical expected format <code>user@host</code> then check that it looks reasonable. Next send a message to it and see if that works (for example require the recipient validate a one-time token via the address). Note that this handles punycode, internationalization, as shown in the samples below.</p>
     <p><a href="https://developer.mozilla.org/en-US/docs/Web/API/URL" rel="nofollow noreferrer">https://developer.mozilla.org/en-US/docs/Web/API/URL</a></p>
     <p>an example with simple tests:</p>
     <pre><code>function validEmail(input=''){
    const emailPatternInput = /^[^@]{1,64}@[^@]{4,253}$/, emailPatternUrl = /^[^@]{1,64}@[a-z][a-z0-9\.-]{3,252}$/i;
    let email, url, valid = false, error, same = false;
    try{
        email = input.trim();
        // handles punycode, etc using browser's own maintained implementation
        url = new URL('http://'+email);
        let urlderived = `${url.username}@${url.hostname}`;
        same = urlderived === email;
        valid = emailPatternInput.test( email );
        if(!valid) throw new Error('invalid email pattern on input:' + email);
        valid = emailPatternUrl.test( urlderived );
        if(!valid) throw new Error('invalid email pattern on url:' + urlderived);
    }catch(err){
        error = err;
    };
    return {email, url, same, valid, error};
}

[
 'user+this@はじめよう.みんな'
, 'stuff@things.eu'
, 'stuff@things'
, 'user+that@host.com'
, 'Jean+François@anydomain.museum','هيا@יאללה'
, '试@例子.测试.مثال.آزمایشی'
, 'not@@really'
, 'no'
].forEach(email=&gt;console.log(validEmail(email), email));
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_52"><span>Answer 52</span> <span class="arrow"> <a href="#answer_51">↑</a> </span> <span class="arrow"> <a href="#answer_53">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Code Spy</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Mar 2015 at 07:21</span>
     </div>
    </div>
    <div>
     <p><strong><em>Following Regex validations:</em></strong></p>
     <ul>
      <li>No spacial characters before @</li>
      <li>(-) and (.) should not be together after @</li>
      <li>No special characters after @ 2 characters must before @</li>
      <li>
       <p>Email length should be less 128 characters</p>
       <pre><code>function validateEmail(email) {
    var chrbeforAt = email.substr(0, email.indexOf('@'));
    if (!($.trim(email).length &gt; 127)) {
        if (chrbeforAt.length &gt;= 2) {
            var re = /^(([^&lt;&gt;()[\]{}'^?\\.,!|//#%*-+=&amp;;:\s@\"]+(\.[^&lt;&gt;()[\]\\.,;:\s@\"]+)*)|(\".+\"))@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/;
            return re.test(email);
        } else {
            return false;
        }
    } else {
        return false;
    }
}
</code></pre></li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_53"><span>Answer 53</span> <span class="arrow"> <a href="#answer_52">↑</a> </span> <span class="arrow"> <a href="#answer_54">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>chemic</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Nov 2016 at 21:21</span>
     </div>
    </div>
    <div>
     <p>Whoever is using @pvl solution and wants it to pass <a href="http://eslint.org/docs/rules/prefer-template" rel="nofollow noreferrer">ESLint Prefer-template</a> then here's a version where I used template literals instead of string concatenation.</p>
     <pre><code>validateEmail(email) {
    let sQtext = '[^\\x0d\\x22\\x5c\\x80-\\xff]';
    let sDtext = '[^\\x0d\\x5b-\\x5d\\x80-\\xff]';
    let sAtom = '[^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+';
    let sQuotedPair = '\\x5c[\\x00-\\x7f]';
    let sDomainLiteral = `\\x5b(${sDtext}|${sQuotedPair})*\\x5d`;
    let sQuotedString = `\\x22(${sQtext}|${sQuotedPair})*\\x22`;
    let sDomainRef = sAtom;
    let sSubDomain = `(${sDomainRef}|${sDomainLiteral})`;
    let sWord = `(${sAtom}|${sQuotedString})`;
    let sDomain = `${sSubDomain}(\\x2e${sSubDomain})*`;
    let sLocalPart = `${sWord}(\\x2e${sWord})*`;
    let sAddrSpec = `${sLocalPart}\\x40${sDomain}`; // complete RFC822 email address spec
    let sValidEmail = `^${sAddrSpec}$`; // as whole string

    let reValidEmail = new RegExp(sValidEmail);

    return reValidEmail.test(email);
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_54"><span>Answer 54</span> <span class="arrow"> <a href="#answer_53">↑</a> </span> <span class="arrow"> <a href="#answer_55">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Himanshu Teotia</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 Feb 2017 at 06:04</span>
     </div>
    </div>
    <div>
     <p>In nodeJS you can also use validator node module and simply use like that</p>
     <p>Install the library with npm install validator</p>
     <pre><code>var validator = require('validator');

validator.isEmail('foo@bar.com'); //=&gt; true 
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_55"><span>Answer 55</span> <span class="arrow"> <a href="#answer_54">↑</a> </span> <span class="arrow"> <a href="#answer_56">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Abhay Shiro</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Apr 2017 at 04:27</span>
     </div>
    </div>
    <div>
     <p>There are some complex RegEx written here, that also works.</p>
     <p>I tested this one and it works too:</p>
     <pre><code>[a-zA-Z0-9._]+[@]+[a-zA-Z0-9]+[.]+[a-zA-Z]{2,6}
</code></pre>
     <p>Please test this here : <a href="http://www.regextester.com/?fam=97334" rel="nofollow noreferrer">http://www.regextester.com/?fam=97334</a></p>
     <p>Hope this helps.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span><code>me@localhost</code> fails.</span> <span> - </span> <span class="display-name">Agi Hammerthief</span> <span> </span> <span class="date">1 Feb 2018 at 21:08</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_56"><span>Answer 56</span> <span class="arrow"> <a href="#answer_55">↑</a> </span> <span class="arrow"> <a href="#answer_57">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Alireza</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Jun 2017 at 06:55</span>
     </div>
    </div>
    <div>
     <p>How about creating a function which will test any string against emails' pattern using regular expression in JavaScript, as we know email addresses can be quite different in different regions, like in UK and Australia it usually ends up with <code>.co.uk</code> or <code>.com.au</code>, so I tried to cover those as well, also check if the string passed to the function, something like this:</p>
     <pre><code>var isEmail = function(str) {
  return typeof str==='string' &amp;&amp; /^[\w+\d+._]+\@[\w+\d+_+]+\.[\w+\d+._]{2,8}$/.test(str);
}
</code></pre>
     <p>and check if it's email like below:</p>
     <pre><code>isEmail('alex@example.com'); //true
isEmail('alireza@test.co.uk'); //true
isEmail('peter.example@yahoo.com.au'); //true
isEmail('alex@example.com'); //true
isEmail('peter_123@news.com'); //true
isEmail('hello7___@ca.com.pt'); //true
isEmail('example@example.co'); //true
isEmail('hallo@example.coassjj#sswzazaaaa'); //false
isEmail('hallo2ww22@example....caaaao'); //false
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>What happens with <code>alireza@test.uk</code> or <code>phil.h\@\@cked+liked~it@haacked.com</code>?</span> <span> - </span> <span class="display-name">Agi Hammerthief</span> <span> </span> <span class="date">1 Feb 2018 at 21:03</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_57"><span>Answer 57</span> <span class="arrow"> <a href="#answer_56">↑</a> </span> <span class="arrow"> <a href="#answer_58">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Behnam</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Jul 2017 at 13:05</span>
     </div>
    </div>
    <div>
     <p>ES6 sample</p>
     <pre><code>const validateEmail=(email)=&gt; /^(([^&lt;&gt;()\[\]\\.,;:\s@"]+(\.[^&lt;&gt;()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(email);
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_58"><span>Answer 58</span> <span class="arrow"> <a href="#answer_57">↑</a> </span> <span class="arrow"> <a href="#answer_59">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Menelaos Kotsollaris</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Feb 2018 at 00:18</span>
     </div>
    </div>
    <div>
     <p>Here's a simple regex that would just check for the basic format of an email e.g., <code>X@Y.C</code>:</p>
     <p><code>\S+@\S+\.\S+</code></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_59"><span>Answer 59</span> <span class="arrow"> <a href="#answer_58">↑</a> </span> <span class="arrow"> <a href="#answer_60">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>JoelBonetR</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 May 2018 at 16:02</span>
     </div>
    </div>
    <div>
     <p>This question is more dificult to answer than seems at first sight.</p>
     <p>There were loads of people around the world looking for "the regex to rule them all" but the truth is that there are tones of email providers.</p>
     <p>What's the problem? Well, "a_z%@gmail.com cannot exists but it may exists an address like that through another provider "a__z@provider.com.</p>
     <p>Why? According to the RFC: <a href="https://en.wikipedia.org/wiki/Email_address#RFC_specification" rel="nofollow noreferrer">https://en.wikipedia.org/wiki/Email_address#RFC_specification</a>.</p>
     <p>I'll take an excerpt to facilitate the lecture:</p>
     <pre><code>The local-part of the email address may use any of these ASCII characters:

- uppercase and lowercase Latin letters A to Z and a to z;
- digits 0 to 9;
- special characters !#$%&amp;'*+-/=?^_`{|}~;
- dot ., provided that it is not the first or last character unless quoted, and provided also that it does not appear consecutively unless quoted (e.g. John..Doe@example.com is not allowed but "John..Doe"@example.com is allowed);[6]
Note that some mail servers wildcard local parts, typically the characters following a plus and less often the characters following a minus, so fred+bah@domain and fred+foo@domain might end up in the same inbox as fred+@domain or even as fred@domain. This can be useful for tagging emails for sorting, see below, and for spam control. Braces { and } are also used in that fashion, although less often.
- space and "(),:;&lt;&gt;@[\] characters are allowed with restrictions (they are only allowed inside a quoted string, as described in the paragraph below, and in addition, a backslash or double-quote must be preceded by a backslash);
- comments are allowed with parentheses at either end of the local-part; e.g. john.smith(comment)@example.com and (comment)john.smith@example.com are both equivalent to john.smith@example.com.
</code></pre>
     <p>So, i can own an email address like that:</p>
     <pre><code>A__z/J0hn.sm{it!}h_comment@example.com.co
</code></pre>
     <p>If you try this address i bet it will fail in all or the major part of regex posted all across the net. But remember this address follows the RFC rules so it's fair valid.</p>
     <p>Imagine my frustration at not being able to register anywhere checked with those regex!!</p>
     <p><strong>The only one who really can validate an email address is the provider of the email address.</strong></p>
     <p>How to deal with, so?</p>
     <p>It doesn't matter if a user adds a non-valid e-mail in almost all cases. You can rely on HTML 5 input type="email" that is running <strong>near</strong> to RFC, little chance to fail. HTML5 input type="email" info: <a href="https://www.w3.org/TR/2012/WD-html-markup-20121011/input.email.html" rel="nofollow noreferrer">https://www.w3.org/TR/2012/WD-html-markup-20121011/input.email.html</a></p>
     <p>For example, this is an RFC valid email:</p>
     <pre><code>"very.(),:;&lt;&gt;[]\".VERY.\"very@\\ \"very\".unusual"@strange.example.com
</code></pre>
     <p>But the html5 validation will tell you that the text before @ must not contain " or () chars for example, which is actually incorrect.</p>
     <p>Anyway, you should do this by accepting the email address and sending an email message to that email address, with a code/link the user must visit to confirm validity.</p>
     <p>A good practice while doing this is the "enter your e-mail again" input to avoid user typing errors. If this is not enough for you, add a pre-submit modal-window with a title "is this your current e-mail?", then the mail entered by the user inside an h2 tag, you know, to show clearly which e-mail they entered, then a "yes, submit" button.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_60"><span>Answer 60</span> <span class="arrow"> <a href="#answer_59">↑</a> </span> <span class="arrow"> <a href="#answer_61">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Antonio</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Apr 2019 at 14:46</span>
     </div>
    </div>
    <div>
     <p>General email regex (RFC 5322 Official Standard): <a href="https://emailregex.com/" rel="nofollow noreferrer">https://emailregex.com/</a></p>
     <p>JavaScript:</p>
     <pre><code>/^(([^&lt;&gt;()\[\]\\.,;:\s@"]+(\.[^&lt;&gt;()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_61"><span>Answer 61</span> <span class="arrow"> <a href="#answer_60">↑</a> </span> <span class="arrow"> <a href="#answer_62">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>jimmont</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Sep 2019 at 03:00</span>
     </div>
    </div>
    <div>
     <p>Use the browser/runtime to handle parsing the input by prepending a protocol and pass it to the <code>URL</code> API, trapping any errors and check the resulting <code>username</code> and <code>hostname</code> properties of the result. It will handle basically all transformations and possibilities (<a href="https://en.wikipedia.org/wiki/Punycode" rel="nofollow noreferrer">punycode</a> of character sets, etc). This only establishes that the input is parsable, not that is valid--that is only possible through checking if the destination machine receives messages for that alias. This provides a close (imo reasonable) guess though, and can be expanded to be more specific and realistic if you're comfortable both maintaining it and also risking invalid rejections. (Note it doesn't attempt to address IPv4 or IPv6 addresses, simply the broad range of customer-facing scenarios using a domain.)</p>
     <pre><code>function validEmail(email=''){
    var $0, url, isValid = false, emailPatternInput = /^[^@]{1,64}@[^@]{4,253}$/, emailPatternUrl = /^[^@]{1,64}@[a-z][a-z0-9\.-]{3,252}$/i;
    email = email.trim();
    try{
        url = new URL('http://'+email);
        $0 = `${url.username}@${url.hostname}`;
        isValid = emailPatternInput.test( email );
        if(!isValid) throw 'invalid email pattern on input:' + email;
        isValid = emailPatternUrl.test( $0 );
        if(!isValid) throw 'invalid email pattern on url:' + $0;
        console.log(`email looks legit "${email}" checking url-parts: "${$0 === email ? '-SAME-':$0}"`);
    }catch(err){
        console.error(`probably not an email address: "${email}"`, err);
    };
    return isValid;
}

['user+this@はじめよう.みんな', 'stuff@things', 'user+that@host.com', 'Jean+François@anydomain.museum','هيا@יאללה', '试@例子.测试.مثال.آزمایشی', 'not@@really', 'no'].forEach(email=&gt;console.log(validEmail(email), email));
</code></pre>
     <p>This is the both the simplest and most generally permissive example I can come up with. Please edit it in cases where it can be made to be more accurate while maintain its simplicity and reasonable generally permissive validity.</p>
     <p>Also see MDN URL docs <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL/URL" rel="nofollow noreferrer">URL</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL" rel="nofollow noreferrer">window.URL</a> and Nodejs for <a href="https://nodejs.org/api/url.html" rel="nofollow noreferrer">URL</a> APIs.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_62"><span>Answer 62</span> <span class="arrow"> <a href="#answer_61">↑</a> </span> <span class="arrow"> <a href="#answer_63">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Vitalii Fedorenko</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Dec 2014 at 01:21</span>
     </div>
    </div>
    <div>
     <p>If you are using AngularJS, just add <code>type="email"</code> to the input element:</p>
     <blockquote>
      <p><a href="https://docs.angularjs.org/api/ng/input/input%5Bemail%5D" rel="nofollow">https://docs.angularjs.org/api/ng/input/input%5Bemail%5D</a></p>
     </blockquote>
     <p>In case there is no input element, it can be created dynamically:</p>
     <pre><code>var isEmail = $compile('&lt;input ng-model="m" type="email"&gt;')($rootScope.$new()).
    controller('ngModel').$validators["email"];

if (isEmail('email@gmail.com')) {
  console.log('valid');
} 
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>But <i>what is</i> this email parser function? Could you post it so that one can use it without angular?</span> <span> - </span> <span class="display-name">Bergi</span> <span> </span> <span class="date">15 Dec 2014 at 02:07</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Yes, if you are going to post a black box answer please dig up the RegEx behind the email parser function and show us what it's using..</span> <span> - </span> <span class="display-name">Eric Bishard</span> <span> </span> <span class="date">24 Aug 2015 at 02:09</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_63"><span>Answer 63</span> <span class="arrow"> <a href="#answer_62">↑</a> </span> <span class="arrow"> <a href="#answer_64">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user2081554</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Feb 2015 at 08:33</span>
     </div>
    </div>
    <div>
     <p>I know its not regex but any way...</p>
     <p>This is example with node and npm package <a href="https://www.npmjs.com/package/email-existence" rel="nofollow">email-existence</a> this is ultimate checking if email exist and if its in the right form :)</p>
     <p>This will ping the email if its responding if it got no response it will return false or else true.</p>
     <pre><code>function doesEmailExist(email) {
    var emailExistence = require('email-existence');
    return emailExistence.check(email,function (err,status) {
            if (status) {
                return status;
            }
            else {
                throw new Error('Email does not exist');
            }
        });
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_64"><span>Answer 64</span> <span class="arrow"> <a href="#answer_63">↑</a> </span> <span class="arrow"> <a href="#answer_65">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Dinesh Devkota</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Aug 2015 at 14:24</span>
     </div>
    </div>
    <div>
     <p>If you want to use Jquery and want to have modern approach then use JQuery input mask with validation.</p>
     <p><a href="http://bseth99.github.io/projects/jquery-ui/5-jquery-masks.html" rel="nofollow">http://bseth99.github.io/projects/jquery-ui/5-jquery-masks.html</a></p>
     <p>Demo on how simple jquery input mask is here: <a href="http://codepen.io/anon/pen/gpRyBp" rel="nofollow">http://codepen.io/anon/pen/gpRyBp</a></p>
     <p><strong>Example of simple input mask for date forexample NOT full validation</strong></p>
     <pre><code> &lt;input id="date" type="text" placeholder="YYYY-MM-DD"/&gt;
</code></pre>
     <p>and the script:</p>
     <pre><code> $("#date").mask("9999-99-99",{placeholder:"YYYY-MM-DD"});
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_65"><span>Answer 65</span> <span class="arrow"> <a href="#answer_64">↑</a> </span> <span class="arrow"> <a href="#answer_66">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>takatan</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Jun 2017 at 07:52</span>
     </div>
    </div>
    <div>
     <p>I'd like to add a short note about non-ASCII characters. Rnevius's (and co.) solution is brilliant, but it allows to add Cyrillic, Japanese, Emoticons and other unicode symbols which may be restricted by some servers.</p>
     <p>The code below will print <code>true</code> though it contains UTF-8 character <code>Ё</code>.</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>console.log (/^(([^&lt;&gt;()\[\]\\.,;:\s@"]+(\.[^&lt;&gt;()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test ('Ё@example.org'))</code></pre>
      </div>
     </div>
     <p></p>
     <p>In my case all non-ASCII symbols are prohibited so I have modified the original expression to exclude all characters above U+007F:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>/^(([^\u0080-\uffff&lt;&gt;()\[\]\\.,;:\s@"]+(\.[^\u0080-\uffff&lt;&gt;()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/</code></pre>
      </div>
     </div>
     <p></p>
     <p>Maybe this will help someone to prevent undesired behaviour.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Nah I think this is an unusual enough use case that it should be its own answer</span> <span> - </span> <span class="display-name">jcollum</span> <span> </span> <span class="date">13 Aug 2017 at 17:48</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_66"><span>Answer 66</span> <span class="arrow"> <a href="#answer_65">↑</a> </span> <span class="arrow"> <a href="#answer_67">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mizanur Rahaman</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Feb 2018 at 09:56</span>
     </div>
    </div>
    <div>
     <pre><code> &lt;input type="email" class="form-control" required="required" placeholder="Email Address" name="Email" id="Email" autocomplete="Email"&gt;
 &lt;button class="btn-1 shadow-0 full-width" type="button" id="register"&gt;Register account&lt;/button&gt;
</code></pre>
     <p></p>
     <pre><code> $("#register").click(function(){       
    var rea = /^[a-zA-Z0-9.!#$%&amp;'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    var Email = $("#Email").val();
    var x = rea.test(Email);
    if (!x) {
        alert('Type Your valid Email');
        return false;
    }           
 &lt;/script&gt;
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_67"><span>Answer 67</span> <span class="arrow"> <a href="#answer_66">↑</a> </span> <span class="arrow"> <a href="#answer_68">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>aabiro</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Jul 2018 at 10:15</span>
     </div>
    </div>
    <div>
     <p>Here is a solution that works and includes validation/notification fuctionality in a form:</p>
     <p>You can run it <a href="https://codepen.io/aabiro/pen/eyGJMV" rel="nofollow noreferrer">at this link</a></p>
     <p><strong><em>JAVASCRIPT</em></strong></p>
     <pre><code>(function() {
  'use strict';

  window.addEventListener('load', function() {
    var form = document.getElementById('needs-validation');
    form.addEventListener('submit', function(event) {
      if (form.checkValidity() === false) {
        event.preventDefault();
      }
      form.classList.add('was-validated');
      event.preventDefault();              
    }, false);
  }, false);
})();
</code></pre>
     <p><strong><em>HTML</em></strong></p>
     <pre><code>&lt;p class='title'&gt;
    &lt;b&gt;Email validation&lt;/b&gt;
  &lt;hr size="30px;"&gt;
&lt;/p&gt;
&lt;br&gt;

&lt;form id="needs-validation" novalidate&gt;
  &lt;p class='form_text'&gt;Try it out!&lt;/p&gt;
  &lt;div class="form-row"&gt;
    &lt;div class="col-12"&gt;
      &lt;input type="email" class="form-control" placeholder="Email Address" required&gt;
        &lt;div class="invalid-feedback"&gt;
          Please enter a valid email address.
        &lt;/div&gt;
    &lt;/div&gt;
  &lt;div class="row"&gt;
    &lt;div class="col-12"&gt;
      &lt;button type="submit" 
          class="btn btn-default btn-block"&gt;Sign up now
      &lt;/button&gt;
    &lt;/div&gt;
   &lt;/div&gt;
&lt;/form&gt;
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_68"><span>Answer 68</span> <span class="arrow"> <a href="#answer_67">↑</a> </span> <span class="arrow"> <a href="#answer_69">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>mpyw</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Jul 2018 at 10:53</span>
     </div>
    </div>
    <div>
     <p>I wrote a JavaScript email validator which is fully compatile with PHP's <code>filter_var($value, FILTER_VALIDATE_EMAIL)</code> implementation.</p>
     <p><a href="https://github.com/mpyw/FILTER_VALIDATE_EMAIL.js" rel="nofollow noreferrer">https://github.com/mpyw/FILTER_VALIDATE_EMAIL.js</a></p>
     <pre><code>import validateEmail from 'filter-validate-email'

const value = '...'
const result = validateEmail(value)
</code></pre>
     <p>is equivalent to:</p>
     <pre><code>&lt;?php

$value = '...';
$result = (bool)filter_var($value, FILTER_VALIDATE_EMAIL, FILTER_FLAG_EMAIL_UNICODE);
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_69"><span>Answer 69</span> <span class="arrow"> <a href="#answer_68">↑</a> </span> <span class="arrow"> <a href="#answer_70">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>incalite</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Feb 2019 at 20:19</span>
     </div>
    </div>
    <div>
     <p>Here's how I do it. I'm using match() to check for the standard email pattern and I'm adding a class to the input text to notify the user accordingly. Hope that helps!</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>$(document).ready(function(){
  $('#submit').on('click', function(){
      var email = $('#email').val();
      var pat = /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/;
      if (email.match(pat)){
        $('#email')
          .addClass('input-valid');
        return false;
      } else {
        $('#email')
        	.addClass('input-error')
          .val('');
        return false;
      }
  });
});</code></pre>
       <pre class="snippet-code-css lang-css prettyprint-override"><code>.input-error {
  border: 1px solid red;
  color: red;
}

.input-valid {
  border: 1px solid green;
  color: green;
}</code></pre>
       <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt;
&lt;form&gt;
    &lt;input type="text" id="email" placeholder="name@service.xx" class=""&gt;
    &lt;input type="submit" id="submit" value="Send"/&gt;
&lt;/form&gt;</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_70"><span>Answer 70</span> <span class="arrow"> <a href="#answer_69">↑</a> </span> <span class="arrow"> <a href="#answer_71">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Nicolas Zozol</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Jun 2019 at 10:14</span>
     </div>
    </div>
    <div>
     <p>If you want something a human can read and <strong>maintain</strong>, I would recommend <a href="https://github.com/masala-oss/masala-parser" rel="nofollow noreferrer">Masala Parser</a> (I'm one of the creators of it).</p>
     <pre class="lang-js prettyprint-override"><code>import {C,Streams} from '@masala/parser'

const illegalCharset = ' @\u00A0\n\t';
const extendedIllegalCharset = illegalCharset + '.';


// Assume 'nicolas@internal.masala.co.uk'
export function simpleEmail() {

    return C.charNotIn(illegalCharset).rep() // 'nicolas'
        .then(C.char('@'))
        .then(subDns())  //'internal.masala.co.'
        .then(C.charNotIn(extendedIllegalCharset).rep()) //'uk'
        .eos(); // Must be end of the char stream
}

// x@internal.masala.co.uk =&gt; extract 'internal.masala.co.'
function  subDns() {
    return C.charNotIn(extendedIllegalCharset).rep().then(C.char('.')).rep()
}

function validateEmail(email:string) {
    console.log(email + ': ' + (simpleEmail().parse(Streams.ofString(email)).isAccepted()));
}


validateEmail('nicolas@internal.masala.co.uk'); // True
validateEmail('nz@co.'); // False, trailing "."
</code></pre>
     <p>If you want to accept the ultimate ugly email version, you can add in quotes in the first part:</p>
     <pre class="lang-js prettyprint-override"><code>
function inQuote() {
    return C.char('"')
        .then(C.notChar('"').rep())
        .then(C.char('"'))
}

function allEmail() {

    return inQuote().or(C.charNotIn(illegalCharset))
        .rep() // repeat (inQuote or anyCharacter)
        .then(C.char('@'))
        .then(subDns())
        .then(C.charNotIn(extendedIllegalCharset).rep())
        .eos() // Must be end of the character stream
        // Create a structure
        .map(function (characters) { return ({ email: characters.join('') }); });
}
</code></pre>
     <p><code>'"nicolas""love-quotes"@masala.co.uk'</code> is officially valid, but should it be in your system?</p>
     <p>At least with Masala, you give yourself a chance to understand it. And so for the next year, colleague.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_71"><span>Answer 71</span> <span class="arrow"> <a href="#answer_70">↑</a> </span> <span class="arrow"> <a href="#answer_72">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Eboubaker</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Nov 2019 at 22:22</span>
     </div>
    </div>
    <div>
     <p>These will work with the top used emails(<strong>they match exactly the rules of each one</strong>). <br><br><strong>Gmail</strong> <br><code>/^[a-z]((?!\.\.)([a-z\.])){4,28}[a-z0-9]@gmail.com$/i</code> <br><br><strong>Yahoo</strong> <br><code>/^[a-z]((?!\.\.)([\w\.])){3,30}[\w]@yahoo.com$/i</code> <br><br><strong>Outlook</strong>/<strong>Hotmail</strong> <br><code>/[a-z]((?!\.\.)([\w\.])){0,62}[\w]@(outlook.com|hotmail.com)$/i</code></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Do you know that <code>\w</code> already includes <code>\d</code> and <code>_</code>? Please, have a look at these sites: <a href="https://www.iana.org/domains/root/db" rel="nofollow noreferrer">TLD list</a>; <a href="https://en.wikipedia.org/wiki/Email_address#Examples" rel="nofollow noreferrer">valid/invalid addresses</a>; <a href="http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html" rel="nofollow noreferrer">regex for RFC822 email address</a></span> <span> - </span> <span class="display-name">Toto</span> <span> </span> <span class="date">18 Nov 2019 at 12:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Toto that's right, i don't know how i lost it there, i actually used this regex in my database handaling :\, thanks again.</span> <span> - </span> <span class="display-name">Eboubaker</span> <span> </span> <span class="date">21 Nov 2019 at 16:30</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Gmail's domain is not <code>@google.com</code>, it's <code>@gmail.com</code> or (for very old accounts) <code>@googlemail.com</code></span> <span> - </span> <span class="display-name">David Wheatley</span> <span> </span> <span class="date">21 Jan 2020 at 17:36</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_72"><span>Answer 72</span> <span class="arrow"> <a href="#answer_71">↑</a> </span> <span class="arrow"> <a href="#answer_73">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Nazmul Haque</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Nov 2020 at 07:09</span>
     </div>
    </div>
    <div>
     <pre><code>     // Html form call function name at submit button

    &lt;form name="form1" action="#"&gt; 
    &lt;input type='text' name='text1'/&gt;
    &lt;input type="submit" name="submit" value="Submit" 
    onclick="ValidateEmail(document.form1.text1)"/&gt;
   &lt;/from&gt;

    // Write the function name ValidateEmail below

    &lt;script&gt;
     function ValidateEmail(inputText)
    {
  var mailformat = /^[a-zA-Z0-9.!#$%&amp;'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/;
    if(inputText.value.match(mailformat))
    {
    alert("Valid email address!");
    document.form1.text1.focus();
    return true;
    }
    else
   {
    alert("You have entered an invalid email address!");
    document.form1.text1.focus();
    return false;
    }
    }
   &lt;/script&gt;
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_73"><span>Answer 73</span> <span class="arrow"> <a href="#answer_72">↑</a> </span> <span class="arrow"> <a href="#answer_74">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>FDisk</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Apr 2021 at 09:42</span>
     </div>
    </div>
    <div>
     <p>Yet another perfect regexp for email validation</p>
     <pre class="lang-js prettyprint-override"><code>/^([^\s\@])+\@(([^\s\@\.])+\.)+([^\s\.]{2,})+$/
</code></pre>
     <p>You can test it here <a href="https://regex101.com/r/FV3pUI/2" rel="nofollow noreferrer">https://regex101.com/r/FV3pUI/2</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_74"><span>Answer 74</span> <span class="arrow"> <a href="#answer_73">↑</a> </span> <span class="arrow"> <a href="#answer_75">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Force Bolt</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Apr 2021 at 06:43</span>
     </div>
    </div>
    <div>
     <pre><code>// Try this regular Expression by ES6 function

const emailValidate = (email) =&gt; {
  const regexp= /^[\w.%+-]+@[\w.-]+\.[\w]{2,6}$/;
  return regexp.test(email);
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>This is a good example of why people say don't use regex for this. Take just a single piece of this, the assertion that a top-level domain will be 6 letters or less. This rejects just under half of all valid TLDs -- there are currently over 650 TLDs that are more than 6 characters, you can see them all at <a href="https://data.iana.org/TLD/tlds-alpha-by-domain.txt" rel="nofollow noreferrer">data.iana.org/TLD/tlds-alpha-by-domain.txt</a></span> <span> - </span> <span class="display-name">Jason Kohles</span> <span> </span> <span class="date">5 May 2022 at 02:17</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_75"><span>Answer 75</span> <span class="arrow"> <a href="#answer_74">↑</a> </span> <span class="arrow"> <a href="#answer_76">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Yogesh Jindal</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Jul 2014 at 18:36</span>
     </div>
    </div>
    <div>
     <p>One of my coworker shared this regex with me. I like it a lot.</p>
     <pre><code>function isValidEmailAddress (email) {
    var validEmail = false;
    if (email) {
        email = email.trim().toLowerCase();
        var pattern = /^[\w-']+(\.[\w-']+)*@([a-zA-Z0-9]+[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)*?\.[a-zA-Z]{2,6}|(\d{1,3}\.){3}\d{1,3})(:\d{4})?$/;
        validEmail = pattern.exec(email);
    }

    return validEmail;
}

if (typeof String.prototype.trim !== 'function') {
    String.prototype.trim = function() {
        return this.replace(/^\s+|\s+$/g, '');
    };
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_76"><span>Answer 76</span> <span class="arrow"> <a href="#answer_75">↑</a> </span> <span class="arrow"> <a href="#answer_77">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>jaydev thakkar</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Jul 2015 at 08:19</span>
     </div>
    </div>
    <div>
     <pre><code>\b[a-z][\w\d_\.]+@\w+\.[a-z]{2}[a-z]?\.?[a-z]{,2}\s
</code></pre>
     <p>It allows:</p>
     <pre><code>abcxyz123@qwert.com    
abc123xyz@asdf.co.in   
abc1_xyz1@gmail1.com   
abc.xyz@gmail.com.in
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Nice try: 2 updates here: For match ranges, we provide <code>{min,max}</code>. A blank <code>min</code> is error, but can have a blank <code>max</code>. I mean <code>[a-z]{,2}</code> is wrong, write as <code>{0,2}</code>. Moreover: your regex shows <code>kamal@_gmail.com</code> as valid which is not!</span> <span> - </span> <span class="display-name">Kamal Nayan</span> <span> </span> <span class="date">14 Mar 2016 at 10:46</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_77"><span>Answer 77</span> <span class="arrow"> <a href="#answer_76">↑</a> </span> <span class="arrow"> <a href="#answer_78">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Jangli Coder</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Mar 2017 at 07:57</span>
     </div>
    </div>
    <div>
     <p>If you define your regular expression as a string then all backslashes need to be escaped, so instead of '\w' you should have '\w'.</p>
     <p>Alternatively, define it as a regular expression:</p>
     <pre><code>var pattern = /^\w+@[a-zA-Z_]+?\.[a-zA-Z]{2,3}$/; 
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_78"><span>Answer 78</span> <span class="arrow"> <a href="#answer_77">↑</a> </span> <span class="arrow"> <a href="#answer_79">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>B. Bohdan</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Mar 2019 at 16:27</span>
     </div>
    </div>
    <div>
     <p>There is my version of an email validator. This code is done with object-oriented programming and realized as a class with static methods. You will find two versions of the validators: strict(<code>EmailValidator.validate</code>) and kind(<code>EmailValidator.validateKind</code>).</p>
     <p>The first throws an error if an email is invalid and returns email otherwise. The second returns Boolean value that says if an email is valid. I prefer the strict version in most of the cases.</p>
     <pre><code>export class EmailValidator {
    /**
     * @param {string} email
     * @return {string}
     * @throws {Error}
     */
    static validate(email) {
        email = this.prepareEmail(email);

        const isValid = this.validateKind(email);

        if (isValid)
            return email;

        throw new Error(`Got invalid email: ${email}.`);
    }

    /**
     * @param {string} email
     * @return {boolean}
     */
    static validateKind(email) {
        email = this.prepareEmail(email);

        const regex = this.getRegex();

        return regex.test(email);
    }

    /**
     * @return {RegExp}
     * @private
     */
    static getRegex() {
        return /^(([^&lt;&gt;()\[\]\\.,;:\s@"]+(\.[^&lt;&gt;()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    }

    /**
     * @param {string} email
     * @return {string}
     * @private
     */
    static prepareEmail(email) {
        return String(email).toLowerCase();
    }
}
</code></pre>
     <p>To validate an email you can follow these ways:</p>
     <pre><code>// First way.

try {
    EmailValidator.validate('balovbohdan@gmail.com');
} catch (e) {
    console.error(e.message);
}
</code></pre>
     <pre><code>// Second way.

const email = 'balovbohdan@gmail.com';
const isValid = EmailValidator.validateKind(email);

if (isValid)
    console.log(`Email is valid: ${email}.`);
else
    console.log(`Email is invalid: ${email}.`);
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_79"><span>Answer 79</span> <span class="arrow"> <a href="#answer_78">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Raheel</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Apr 2019 at 08:43</span>
     </div>
    </div>
    <div>
     <p>I am using this function</p>
     <pre><code>/**
 * @param {*} email
 */
export const validateEmail = email =&gt; {
    return new RegExp(/[\w-]+@([\w-]+\.)+[\w-]+/gm).test(email);
};
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>Doesn't work for Unicode. <code>validateEmail('køkø@gmail.com') === false</code>. Forget validation using checks like this. Test for <code>@</code> and just send the user an email.</span> <span> - </span> <span class="display-name">oligofren</span> <span> </span> <span class="date">24 Sep 2019 at 09:36</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>