<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>What is the difference between venv, pyvenv, pyenv, virtualenv, virtualenvwrapper, pipenv, etc?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>What is the difference between venv, pyvenv, pyenv, virtualenv, virtualenvwrapper, pipenv, etc?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>1987</span>
    </div>
    <div>
     <span>Asker: </span> <span>Flimm</span>
    </div>
    <div>
     <span>Asked: </span> <span>10 Jan 2017 at 16:27</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/41573587/what-is-the-difference-between-venv-pyvenv-pyenv-virtualenv-virtualenvwrappe">source</a>
    </div>
   </div>
   <div>
    <p>Python 3.3 includes in its standard library the new package <code>venv</code>. What does it do, and how does it differ from all the other packages that match the regex <code>(py)?(v|virtual|pip)?env</code>?</p>
   </div>
   <div class="tags">
    <span class="tag">python</span><span class="tag">virtualenv</span><span class="tag">virtualenvwrapper</span><span class="tag">pyenv</span><span class="tag">python-venv</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>50</td>
       <td><span>And to preempt the close votes, I felt this was a more general question than <a href="http://stackoverflow.com/questions/29950300/what-is-the-relationship-between-virtualenv-and-pyenv" title="what is the relationship between virtualenv and pyenv">stackoverflow.com/questions/29950300/…</a> , and so I didn't feel comfortable editing that question or posting an overly general answer on that post.</span> <span> - </span> <span class="display-name">Flimm</span> <span> </span> <span class="date">10 Jan 2017 at 16:33</span></td>
      </tr>
      <tr>
       <td>36</td>
       <td><span>This guide is both useful &amp; constantly updated as python continues to add more &amp; more "one &amp; only one obvious way" to do things: <a href="http://docs.python-guide.org/en/latest/dev/virtualenvs/" rel="nofollow noreferrer">docs.python-guide.org/en/latest/dev/virtualenvs</a></span> <span> - </span> <span class="display-name">michael</span> <span> </span> <span class="date">17 Nov 2017 at 11:08</span></td>
      </tr>
      <tr>
       <td>4</td>
       <td><span>As of 3.6 I found it easier to get virtualenv working in comparison to pyenv on macOS (I'm a pyNoob)</span> <span> - </span> <span class="display-name">Kermit</span> <span> </span> <span class="date">29 Jan 2018 at 23:32</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>@HashRocketSyntax <code>virtualenv</code> and <code>pyenv</code> do not perform the same function, and are not alternatives to each other. See my answer.</span> <span> - </span> <span class="display-name">Flimm</span> <span> </span> <span class="date">6 Feb 2018 at 07:12</span></td>
      </tr>
      <tr>
       <td>22</td>
       <td><span>I burned an entire day wasting time with pipenv. Bottom line, it’s overmarketed. Venv and virtualenv if you need py2 are the proper tools. Conda (miniconda if you don’t need the full stack) is also very good. Very good writeup: <a href="https://chriswarrick.com/blog/2018/07/17/pipenv-promises-a-lot-delivers-very-little/" rel="nofollow noreferrer">chriswarrick.com/blog/2018/07/17/…</a></span> <span> - </span> <span class="display-name">SwimBikeRun</span> <span> </span> <span class="date">8 Jul 2019 at 05:19</span></td>
      </tr>
      <tr>
       <td>2</td>
       <td><span>I don't want to be overwhelmed so I use Anaconda</span> <span> - </span> <span class="display-name">off99555</span> <span> </span> <span class="date">4 Oct 2019 at 14:20</span></td>
      </tr>
      <tr>
       <td>8</td>
       <td><span>I think the accepted answer below has some unfortunate bias against <code>venv</code>, which is the correct tool to use going forward for Python 3. It should really be first on the list, followed by <code>virtualenv</code>. <a href="https://docs.python.org/3/library/venv.html" rel="nofollow noreferrer">docs.python.org/3/library/venv.html</a></span> <span> - </span> <span class="display-name">EntangledLoops</span> <span> </span> <span class="date">7 Oct 2020 at 19:13</span></td>
      </tr>
      <tr>
       <td>3</td>
       <td><span>avoid all of these problems and just use <code>conda</code> (Miniconda). Its better than all the solutions listed here and makes them all obselete. As a bonus, it works with more than just Python, you can install a wide variety of software with it, not just Python packages. It includes an installation of <code>pip</code> so all your <code>pip install</code>'s will continue to work as normal. With <code>conda</code> you can install an entire app software stack such as specific versions of Django, Gunicorn, Celery, PostgreSQL, RabbitMQ, nginx, Java, R, etc. all at the same time.</span> <span> - </span> <span class="display-name">user5359531</span> <span> </span> <span class="date">6 Jul 2021 at 14:12</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Not as up-to-date as needed for our purposes here, unfortunately: <a href="https://github.com/realpython/python-guide/issues/529" rel="nofollow noreferrer">github.com/realpython/python-guide/issues/529</a></span> <span> - </span> <span class="display-name">odigity</span> <span> </span> <span class="date">22 Mar 2022 at 00:02</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Would be nice to see <code>pip-tools</code> added to this guide.</span> <span> - </span> <span class="display-name">odigity</span> <span> </span> <span class="date">22 Mar 2022 at 00:24</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>I use conda whenever possible, because it offers a much smaller "confusion surface", i.e., number of py-pip packages to understand and contend with. I always install pip inside my conda environments and then let conda manage and index all the pip packages that do not (yet) have conda-formatted packages. I try to ignore all the pip-xxx and pyenv-xxx variants... the endless variations make my head spin. I wish all Python package developers would go the final mile and instead learn to build conda packages from pip-formatted packages, to help make the Python package confusion surface smaller.</span> <span> - </span> <span class="display-name">Rich Lysakowski PhD</span> <span> </span> <span class="date">27 Jul 2022 at 04:34</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2242</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Flimm</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Jan 2017 at 16:27</span>
     </div>
    </div>
    <div>
     <p><strong>This is my personal recommendation for beginners:</strong> start by learning <a href="https://pypi.org/project/virtualenv/" rel="noreferrer"><code>virtualenv</code></a> and <a href="https://pypi.org/project/pip/" rel="noreferrer"><code>pip</code></a>, tools which work with both Python 2 and 3 and in a variety of situations, and pick up other tools once you start needing them.</p>
     <p>Now on to answer the question: what is the difference between these similarly named things: venv, virtualenv, etc?</p>
     <h1>PyPI packages not in the standard library:</h1>
     <ul>
      <li>
       <p><strong><a href="https://pypi.python.org/pypi/virtualenv" rel="noreferrer"><code>virtualenv</code></a></strong> is a very popular tool that creates isolated Python environments for Python libraries. If you're not familiar with this tool, I highly recommend learning it, as it is a very useful tool.</p>
       <p>It works by installing a bunch of files in a directory (eg: <code>env/</code>), and then modifying the <code>PATH</code> environment variable to prefix it with a custom <code>bin</code> directory (eg: <code>env/bin/</code>). An exact copy of the <code>python</code> or <code>python3</code> binary is placed in this directory, but Python is programmed to look for libraries relative to its path first, in the environment directory. It's not part of Python's standard library, but is officially blessed by the PyPA (Python Packaging Authority). Once activated, you can install packages in the virtual environment using <code>pip</code>.</p></li>
      <li>
       <p><strong><a href="https://github.com/pyenv/pyenv" rel="noreferrer"><code>pyenv</code></a></strong> is used to isolate Python versions. For example, you may want to test your code against Python 2.7, 3.6, 3.7 and 3.8, so you'll need a way to switch between them. Once activated, it prefixes the <code>PATH</code> environment variable with <code>~/.pyenv/shims</code>, where there are special files matching the Python commands (<code>python</code>, <code>pip</code>). These are not copies of the Python-shipped commands; they are special scripts that decide on the fly which version of Python to run based on the <code>PYENV_VERSION</code> environment variable, or the <code>.python-version</code> file, or the <code>~/.pyenv/version</code> file. <code>pyenv</code> also makes the process of downloading and installing multiple Python versions easier, using the command <code>pyenv install</code>.</p></li>
      <li>
       <p><strong><a href="https://github.com/pyenv/pyenv-virtualenv" rel="noreferrer"><code>pyenv-virtualenv</code></a></strong> is a plugin for <code>pyenv</code> by the same author as <code>pyenv</code>, to allow you to use <code>pyenv</code> and <code>virtualenv</code> at the same time conveniently. However, if you're using Python 3.3 or later, <code>pyenv-virtualenv</code> will try to run <code>python -m venv</code> if it is available, instead of <code>virtualenv</code>. You can use <code>virtualenv</code> and <code>pyenv</code> together without <code>pyenv-virtualenv</code>, if you don't want the convenience features.</p></li>
      <li>
       <p><strong><a href="https://pypi.python.org/pypi/virtualenvwrapper" rel="noreferrer"><code>virtualenvwrapper</code></a></strong> is a set of extensions to <code>virtualenv</code> (see <a href="http://virtualenvwrapper.readthedocs.io/en/latest/" rel="noreferrer">docs</a>). It gives you commands like <code>mkvirtualenv</code>, <code>lssitepackages</code>, and especially <code>workon</code> for switching between different <code>virtualenv</code> directories. This tool is especially useful if you want multiple <code>virtualenv</code> directories.</p></li>
      <li>
       <p><strong><a href="https://github.com/pyenv/pyenv-virtualenvwrapper" rel="noreferrer"><code>pyenv-virtualenvwrapper</code></a></strong> is a plugin for <code>pyenv</code> by the same author as <code>pyenv</code>, to conveniently integrate <code>virtualenvwrapper</code> into <code>pyenv</code>.</p></li>
      <li>
       <p><strong><a href="https://pypi.python.org/pypi/pipenv" rel="noreferrer"><code>pipenv</code></a></strong> aims to combine <code>Pipfile</code>, <code>pip</code> and <code>virtualenv</code> into one command on the command-line. The <code>virtualenv</code> directory typically gets placed in <code>~/.local/share/virtualenvs/XXX</code>, with <code>XXX</code> being a hash of the path of the project directory. This is different from <code>virtualenv</code>, where the directory is typically in the current working directory. <code>pipenv</code> is meant to be used when developing Python applications (as opposed to libraries). There are alternatives to <code>pipenv</code>, such as <code>poetry</code>, which I won't list here since this question is only about the packages that are similarly named.</p></li>
     </ul>
     <h1>Standard library:</h1>
     <ul>
      <li>
       <p><strong><code>pyvenv</code></strong> (not to be confused with <strong><a href="https://github.com/pyenv/pyenv" rel="noreferrer"><code>pyenv</code></a></strong> in the previous section) is a script shipped with Python 3.3 to 3.7. It was <a href="https://docs.python.org/3/whatsnew/3.8.html#api-and-feature-removals" rel="noreferrer">removed from Python 3.8</a> as it had problems (not to mention the confusing name). Running <code>python3 -m venv</code> has exactly the same effect as <code>pyvenv</code>.</p></li>
      <li>
       <p><strong><a href="https://docs.python.org/3/library/venv.html" rel="noreferrer"><code>venv</code></a></strong> is a package shipped with Python 3, which you can run using <code>python3 -m venv</code> (although for some reason some distros separate it out into a separate distro package, such as <code>python3-venv</code> on Ubuntu/Debian). It serves the same purpose as <code>virtualenv</code>, but only has a subset of its features (<a href="https://virtualenv.pypa.io/en/latest/" rel="noreferrer">see a comparison here</a>). <code>virtualenv</code> continues to be more popular than <code>venv</code>, especially since the former supports both Python 2 and 3.</p></li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>308</td>
        <td><span>This is very helpful! So why are there 8 tangled things instead of 1? (“There should be one – and preferably only one – obvious way to do it.” -- The Zen of Python)</span> <span> - </span> <span class="display-name">Jerry101</span> <span> </span> <span class="date">10 Apr 2017 at 19:14</span></td>
       </tr>
       <tr>
        <td>122</td>
        <td><span>@Jerry101, the introduction of venv is in part a response to that mess. If you want to help improve the situation, I suggest you use venv and encourage others to do the same.</span> <span> - </span> <span class="display-name">Magnus Lind Oxlund</span> <span> </span> <span class="date">14 May 2017 at 18:35</span></td>
       </tr>
       <tr>
        <td>82</td>
        <td><span>"the introduction of venv is in part a response to that mess" How come when there are too many things that do 'something like X', people always think they can improve that mess by making an other thing that does 'something like X'. Its kind of funny actually. We are now 4 years later... so may be pertinent to ask, did <code>venv</code> actually solve that problem?</span> <span> - </span> <span class="display-name">Kris</span> <span> </span> <span class="date">26 May 2017 at 00:24</span></td>
       </tr>
       <tr>
        <td>64</td>
        <td><span>The only two tools on the list that truly cover what is arguably the same territory are virtualenv and venv, so the characterization that we're dealing with a mess caused by several competing tools is not very precise. The list does, however, consist of several virtual environment-related tools, all with similar-sounding names. That can be confusing, especially to users who are just learning about them. Did venv improve the situation? It did offer a more light-weight alternative to other virtual environment tools, benefiting from native modifications and a spot in the standard library. …</span> <span> - </span> <span class="display-name">Magnus Lind Oxlund</span> <span> </span> <span class="date">29 May 2017 at 17:48</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@Ajned , you should celebrate that as a newbie you have ran into this article early on. I have used Python for years on and off and finally after reading this answer some of the things have cleared up for me :)</span> <span> - </span> <span class="display-name">azec-pdx</span> <span> </span> <span class="date">27 Jun 2021 at 00:44</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@MagnusLindOxlund - I feel the pain, but I would argue that clusterization of the tools listed in the answer is further possible to those that let you manage: (1) Python virtual environments, (2)Python packages, (3) Python versions and (4) Convenience tools that make (1) and (2) more user-friendly. I am curious if there is equivalent question/answer on StackOverflow that discusses <code>pip</code> vs. <code>pipx</code> vs. <code>poetry</code> vs. <code>setuptools</code> ... etc.</span> <span> - </span> <span class="display-name">azec-pdx</span> <span> </span> <span class="date">27 Jun 2021 at 00:49</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>HI, @Flimm can you update the answer with the explanation to What <code>Pipenv</code> is ?</span> <span> - </span> <span class="display-name">pl-jay</span> <span> </span> <span class="date">14 Sep 2021 at 10:22</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@pl-jay The answer already explains what <code>pipenv</code> is.</span> <span> - </span> <span class="display-name">Flimm</span> <span> </span> <span class="date">14 Sep 2021 at 11:53</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>After all these years I still prefer virtualenv. I tried venv and it just wasn't as nice and somewhat was a pain.</span> <span> - </span> <span class="display-name">dman</span> <span> </span> <span class="date">17 Sep 2021 at 19:57</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>I'm sorry to come across as such a cynic, and it seems like I'm the first, but I'll proudly be the first to say that this answer is actually NOT helpful to me, this is information overload. In particular, this does not provide any sense of confidence in which tools we should use today that provides the best fighting chance to avoid a python-specific dependency dumpster fire in the near future. At first I thought that the Python 2-to-3 transition was the root of the problem, but now I realize that it is perhaps a symptom of the real issue?</span> <span> - </span> <span class="display-name">Steven Lu</span> <span> </span> <span class="date">31 Oct 2021 at 20:21</span></td>
       </tr>
       <tr>
        <td>30</td>
        <td><span>Obligatory <a href="https://xkcd.com/927/" rel="nofollow noreferrer">xkcd.com/927</a></span> <span> - </span> <span class="display-name">Steven Lu</span> <span> </span> <span class="date">31 Oct 2021 at 20:49</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@StevenLu If this is information overload, just go with the recommendation for beginners at the beginning of the answer.</span> <span> - </span> <span class="display-name">Flimm</span> <span> </span> <span class="date">1 Nov 2021 at 09:01</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Avoid ALL pip virtual environments whenever possible. Use conda instead. Conda provides a unified approach. It is maintained by teams of professional open source developers and has a reputable company providing funding and a commercially supported version. The teams that maintain pip, venv, virtualenv, pipenv, and many other pip variants have limited resources by comparison. The pip virtual environment plurality is frustrating for beginners. Use pip virtual environments and their (too) many variants as a last resort when conda packages do not exist.</span> <span> - </span> <span class="display-name">Rich Lysakowski PhD</span> <span> </span> <span class="date">16 Dec 2021 at 23:38</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Kris <i>We are now 4 years later... so may be pertinent to ask, did venv actually solve that problem?</i> - it didn't as it still requires some magic batches to <i>activate</i> an environment. I should be able to use an environment without these kind of workarounds. That's why I never use any environments, but clone the entire python installation an use this as this is the only way to run scripts and not having to care about how do I properly activate anything. As long as <i>activation</i> is necessery, the issue is not solved.</span> <span> - </span> <span class="display-name">t3chb0t</span> <span> </span> <span class="date">4 Dec 2022 at 10:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@t3chb0t How? And how can you ensure a clean "environment" (python binaries + site-packages + .local)? This seems even more effort than simply using the <code>venv</code> module. In the case of duplicating your python environment, you can use a slim python docker image and install all dependencies <i>globally</i>. The startup is a bit more involved for simply running a script but at least python and the dependencies are encapsulated. This is also good for reproducibility etc.</span> <span> - </span> <span class="display-name">E. Körner</span> <span> </span> <span class="date">6 Dec 2022 at 11:53</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@E.Körner I clone the entire python installation folder and use this as an environment. I then run scripts by simply calling <code>some\path\python.exe myapp.py</code> and it automatically picks everything up without any activation magic. I don't like venv, it's also voodoo. Having a clean installation with the required packages is much eaiser to use than relying on yet another environment framework.</span> <span> - </span> <span class="display-name">t3chb0t</span> <span> </span> <span class="date">6 Dec 2022 at 12:58</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@t3chb0t I fear no solution will satisfy you, as you somehow have to select what version of Python and libraries you want.</span> <span> - </span> <span class="display-name">toolforger</span> <span> </span> <span class="date">21 Dec 2022 at 22:43</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Flimm would it make sense to compare the use of these different softwares for handling environments with the user of different <a href="https://unix.stackexchange.com/q/743501/530603">container</a> softwares i.e. Docker and Podman?</span> <span> - </span> <span class="display-name">Johan</span> <span> </span> <span class="date">30 Apr 2023 at 10:57</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>555</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Rian Rizvi</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Nov 2017 at 19:00</span>
     </div>
    </div>
    <div>
     <p>I would just avoid the use of <code>virtualenv</code> after Python3.3+ and instead use the standard shipped library <code>venv</code>. To create a new virtual environment you would type:</p>
     <pre><code>$ python3 -m venv &lt;MYVENV&gt;  
</code></pre>
     <p><code>virtualenv</code> tries to copy the Python binary into the virtual environment's bin directory. However it does not update library file links embedded into that binary, so if you build Python from source into a non-system directory with relative path names, the Python binary breaks. Since this is how you make a copy distributable Python, it is a big flaw. BTW to inspect embedded library file links on OS X, use <code>otool</code>. For example from within your virtual environment, type:</p>
     <pre><code>$ otool -L bin/python
python:
    @executable_path/../Python (compatibility version 3.4.0, current version 3.4.0)
    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0)
</code></pre>
     <p>Consequently I would avoid <code>virtualenvwrapper</code> and <code>pipenv</code>. <code>pyvenv</code> is deprecated. <code>pyenv</code> seems to be used often where <code>virtualenv</code> is used but I would stay away from it also since I think <code>venv</code> also does what <code>pyenv</code> is built for.</p>
     <p><code>venv</code> creates virtual environments in the shell that are <strong>fresh</strong> and <strong>sandboxed</strong>, with <strong>user-installable libraries</strong>, and it's <strong>multi-python safe</strong>.</p>
     <p><strong>Fresh</strong>: because virtual environments only start with the standard libraries that ship with python, you have to install any other libraries all over again with <code>pip install</code> while the virtual environment is active.</p>
     <p><strong>Sandboxed</strong>: because none of these new library installs are visible outside the virtual environment, so you can delete the whole environment and start again without worrying about impacting your base python install.</p>
     <p><strong>User-installable libraries</strong>: because the virtual environment's target folder is created without <code>sudo</code> in some directory you already own, so you won't need <code>sudo</code> permissions to install libraries into it.</p>
     <p><strong>multi-python safe</strong>: because when virtual environments activate, the shell only sees the python version (3.4, 3.5 etc.) that was used to build that virtual environment.</p>
     <p><code>pyenv</code> is similar to <code>venv</code> in that it lets you manage multiple python environments. However with <code>pyenv</code> you can't conveniently rollback library installs to some start state and you will likely need <code>admin</code> privileges at some point to update libraries. So I think it is also best to use <code>venv</code>.</p>
     <p>In the last couple of years I have found many problems in build systems (emacs packages, python standalone application builders, installers...) that ultimately come down to issues with <code>virtualenv</code>. I think python will be a better platform when we eliminate this additional option and only use <code>venv</code>.</p>
     <p>EDIT: Tweet of the BDFL,</p>
     <blockquote>
      <p>I use venv (in the stdlib) and a bunch of shell aliases to quickly switch.</p>
      <p>— Guido van Rossum (@gvanrossum) <a href="https://twitter.com/gvanrossum/status/1319328122618048514" rel="noreferrer">October 22, 2020</a></p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>Great answer @RiazRizvi and it provides many insights in parallel to accepted answer. However, I would argue that <code>pyenv</code> still has it's place under the sun despite <code>venv</code> getting traction for virtual environments. The classic reason I can think of still using <code>pyenv</code> right now in my workflows is that highest Python runtime that AWS Lambda supports is 3.8 and Python 3.9 being out I want other non-Lambda projects to be 3.9 based. So I still need <code>pyenv</code> to switch between versions. Using <code>pyenv-virtualenv</code> allows users to use both <code>pyenv</code> and <code>venv</code> (not `virtualenv) together.</span> <span> - </span> <span class="display-name">azec-pdx</span> <span> </span> <span class="date">27 Jun 2021 at 00:57</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>what's wrong with <code>virtualenvwrapper</code>?</span> <span> - </span> <span class="display-name">user32882</span> <span> </span> <span class="date">27 Nov 2021 at 04:46</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>@riaz rizvi Multi python safe: how do you creat virtual environment for different python versions? I thought it always defaults to the python (system wide installed) version that is used to create the venv</span> <span> - </span> <span class="display-name">soMuchToLearnAndShare</span> <span> </span> <span class="date">28 Nov 2021 at 23:18</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>somuchtolearnandshare - make the explicit call to the python you want to use - <code>$ path/to/python3x -m venv &lt;MYVENVx&gt; </code> or <code>$ path/to/python3y -m venv &lt;MYVENVy&gt; </code> then when you activate the environment you will activate the python that was used to create the environment</span> <span> - </span> <span class="display-name">Rian Rizvi</span> <span> </span> <span class="date">29 Nov 2021 at 16:17</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Avoid ALL pip virtual environments whenever possible. Use conda instead. Conda provides a unified approach. It is maintained by teams of professional open source developers and has a reputable company providing funding and a commercially supported version. The teams that maintain pip, venv, virtualenv, pipenv, and many other pip variants have limited resources by comparison. The pip virtual environment plurality is frustrating for beginners. Use pip virtual environments and their (too) many variants as a last resort when conda packages do not exist.</span> <span> - </span> <span class="display-name">Rich Lysakowski PhD</span> <span> </span> <span class="date">16 Dec 2021 at 23:39</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@RichLysakowskiPhD Do you recommend anaconda, miniconda or even better yet, mamba? And not that it matters, but I'm curious, what IDE and text editor do you use? Would you consider VS Code with extensions to be an IDE now or still just a text editor? Or do you do everything in colab/jupyterlab? Peace.</span> <span> - </span> <span class="display-name">Edison</span> <span> </span> <span class="date">28 Dec 2021 at 04:35</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Edison , I use conda directly most of the time, unless I am being lazy (then I might use Anaconda Navigator). If I have damaged a conda environment inadvertently by using pip interleaved with conda installation commands, then I will use conda to rollback to an earlier conda environment revision (see conda list --revisions) or use conda to remove the environment after exporting the environment.yaml file. I use Spyder, JupyterLab, VSCode, and PyCharm (in that order depending on the simplicity of what I am working on). Simpler is better. VSCode + plugins is a good full function IDE.</span> <span> - </span> <span class="display-name">Rich Lysakowski PhD</span> <span> </span> <span class="date">28 Dec 2021 at 17:25</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@RichLysakowskiPhD Thanks. Why do you have Spyder/PyCharm? Is there something VSCode cannot do? p.s. Why do people want to use full-blown version of Anaconda? Why would someone choose Anaconda over Miniconda? Mamba is full C++ rewrite of Conda so apparently we should be using that. What do you think? What's your opinion on JupyterLab vs Colab? Stick with JupyterLab unless you need GPU/TPU? But I like the idea of everything in the cloud. Easy access, sharing etc.</span> <span> - </span> <span class="display-name">Edison</span> <span> </span> <span class="date">30 Dec 2021 at 03:20</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Conda is a wrapper around virtualenv, so all the drawbacks to virtualenv apply to Conda. However Conda does verify the packages they support, so while it only provides a subset of all Python packages, for data science especially, they have most of what you need. I would say for Windows only users who tend to be weak on the command line, Conda is a safe bet, especially data scientists. But if you want full clarity of your environment, to deploy solutions to customers for example, and you want full access to all the latest packages, stick with pip which has as much support as Python proper.</span> <span> - </span> <span class="display-name">Rian Rizvi</span> <span> </span> <span class="date">2 Jan 2022 at 20:23</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>117</span>
     </div>
     <div>
      <span>Answerer: </span> <span>F1Linux</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Jan 2020 at 22:49</span>
     </div>
    </div>
    <div>
     <h2>UPDATE 20200825:</h2>
     <p><em><strong>Added below "<em><strong>Conclusion</strong></em>" paragraph</strong></em></p>
     <p>I've went down the <code>pipenv</code> rabbit hole (<em>it's a deep and dark hole indeed...</em>) and <em><strong>since the last answer is over 2 years ago</strong></em>, felt it was useful to update the discussion with the latest developments on the Python virtual envelopes topic I've found.</p>
     <h2>DISCLAIMER:</h2>
     <p>This answer is <strong>NOT</strong> about continuing the raging debate about the merits of <em><strong>pipenv</strong></em> <em>versus</em> <em><strong>venv</strong></em> as envelope solutions- <em>I make no endorsement of either</em>. It's about <em><strong>PyPA</strong></em> endorsing conflicting standards and how future development of <em><strong>virtualenv</strong></em> promises to negate making an <em><strong>either/or</strong></em> choice between them at all. I focused on these two tools precisely because they are the anointed ones by <em><strong>PyPA</strong></em>.</p>
     <h2>venv</h2>
     <p>As the OP notes, <em><strong>venv</strong></em> is a tool for virtualizing environments. <em><strong>NOT</strong></em> a third party solution, but native tool. <em><strong>PyPA</strong></em> endorses <em><strong>venv</strong></em> for creating <strong>VIRTUAL ENVELOPES</strong>: "<a href="https://docs.python.org/3/library/venv.html" rel="noreferrer">Changed in version 3.5: The use of venv is now recommended for creating virtual environments</a>".</p>
     <h2>pipenv</h2>
     <p><em><strong>pipenv</strong></em>- like <em><strong>venv</strong></em> - can be used to create virtual envelopes but additionally rolls-in package management and <a href="https://pipenv-fork.readthedocs.io/en/latest/advanced.html#detection-of-security-vulnerabilities" rel="noreferrer">vulnerability checking</a> functionality. Instead of using <code>requirements.txt</code>, <code>pipenv</code> delivers package management via <a href="https://github.com/pypa/pipfile" rel="noreferrer">Pipfile</a>. As <a href="https://packaging.python.org/guides/tool-recommendations/" rel="noreferrer"><em><strong>PyPA</strong></em> endorses pipenv for <strong>PACKAGE MANAGEMENT</strong></a>, that would seem to imply <code>pipfile</code> is to supplant <code>requirements.txt</code>.</p>
     <p><strong>HOWEVER</strong>: <em><strong>pipenv</strong></em> uses <em><strong>virtualenv</strong></em> as its tool for creating virtual envelopes, <strong>NOT</strong> <em><strong>venv</strong></em> which is endorsed by <em><strong>PyPA</strong></em> as the go-to tool for creating virtual envelopes.</p>
     <h2>Conflicting Standards:</h2>
     <p>So if settling on a virtual envelope solution wasn't difficult enough, we now have <em><strong>PyPA</strong></em> endorsing two different tools which use different virtual envelope solutions. The raging Github debate on <em><strong>venv vs virtualenv</strong></em> which highlights this conflict can be found <a href="https://github.com/pypa/pipenv/issues/15" rel="noreferrer">here</a>.</p>
     <h2>Conflict Resolution:</h2>
     <p>The Github debate referenced in above link has steered <em><strong>virtualenv</strong></em> development in the direction of accommodating <em><strong>venv</strong></em> in <a href="https://github.com/pypa/virtualenv/issues/1366" rel="noreferrer">future releases</a>:</p>
     <blockquote>
      <p>prefer built-in venv: if the target python has venv we'll create the environment using that (and then perform subsequent operations on that to facilitate other guarantees we offer)</p>
     </blockquote>
     <h2>Conclusion:</h2>
     <p>So it looks like there will be some future convergence between the two rival virtual envelope solutions, but as of now <em><strong>pipenv</strong></em>- which uses <code>virtualenv</code> - varies materially from <code>venv</code>.</p>
     <p>Given <a href="https://realpython.com/pipenv-guide/#problems-that-pipenv-solves" rel="noreferrer">the problems <em><strong>pipenv</strong></em> solves</a> and the fact that <em><strong>PyPA</strong></em> has given its blessing, it <em><strong>appears</strong></em> to have a bright future. And if <em><strong>virtualenv</strong></em> delivers on its proposed development objectives, choosing a virtual envelope solution should no longer be a case of either <em><strong>pipenv</strong></em> OR <em><strong>venv</strong></em>.</p>
     <h2><strong>Update 20200825</strong>:</h2>
     <p>An oft repeated criticism of <em><strong>Pipenv</strong></em> I saw when producing this analysis was that it was not actively maintained. Indeed, what's the point of using a solution whose future could be seen questionable due to lack of continuous development? After a dry spell of about 18 months, <em><strong>Pipenv</strong></em> is once again being actively developed. Indeed, large and material updates have since been <a href="https://pipenv.pypa.io/en/latest/changelog/" rel="noreferrer">released</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span>And what about pyenv? This is a good answer, because it looks at future directions, but it's not clear how it interacts with pyenv or conda or other environment mamagers</span> <span> - </span> <span class="display-name">naught101</span> <span> </span> <span class="date">19 Jun 2021 at 09:44</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Avoid ALL pip virtual environments whenever possible. Use conda instead. Conda provides a unified approach. It is maintained by teams of professional open source developers and has a reputable company providing funding and a commercially supported version. The teams that maintain pip, venv, virtualenv, pipenv, and many other pip variants have limited resources by comparison. The pip virtual environment plurality is frustrating for beginners. Use pip virtual environments and their (too) many variants as a last resort when conda packages do not exist.</span> <span> - </span> <span class="display-name">Rich Lysakowski PhD</span> <span> </span> <span class="date">16 Dec 2021 at 23:39</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@naught101 <code>pyenv</code> is not an alternative to <code>virtualenv</code>. And neither of those things are alternatives to <code>pipenv</code>. They do different things. Just like Django, Python and PostgreSQL are different things.</span> <span> - </span> <span class="display-name">Flimm</span> <span> </span> <span class="date">22 Apr 2022 at 09:25</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Flimm: different how?</span> <span> - </span> <span class="display-name">naught101</span> <span> </span> <span class="date">23 Apr 2022 at 06:37</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@naught101 See the other answers for this question post (including my own).</span> <span> - </span> <span class="display-name">Flimm</span> <span> </span> <span class="date">25 Apr 2022 at 09:21</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>89</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Lie Ryan</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Jan 2021 at 23:35</span>
     </div>
    </div>
    <div>
     <p>Let's start with the problems these tools want to solve:</p>
     <div class="s-table-container">
      <table class="s-table">
       <thead>
        <tr>
         <th>use case</th>
         <th>solution</th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td>My system package manager don't have the Python versions I wanted or I want to install multiple Python versions side by side, Python 3.9.0 and Python 3.9.1, Python 3.5.3, etc</td>
         <td>Then use pyenv.</td>
        </tr>
        <tr>
         <td>I want to install and run multiple applications with different, conflicting dependencies.</td>
         <td>Then use virtualenv or venv. These are almost completely interchangeable, the difference being that virtualenv supports older python versions and has a few more minor unique features, while venv is in the standard library.</td>
        </tr>
        <tr>
         <td>I'm developing an /application/ and need to manage my dependencies, and manage the dependency resolution of the dependencies of my project.</td>
         <td>Then use pipenv or poetry.</td>
        </tr>
        <tr>
         <td>I'm developing a /library/ or a /package/ and want to specify the dependencies that my library users need to install</td>
         <td>Then use setuptools.</td>
        </tr>
        <tr>
         <td>I used virtualenv, but I don't like virtualenv folders being scattered around various project folders. I want a centralised management of the environments and some simple project management</td>
         <td>Then use virtualenvwrapper. Variant: pyenv-virtualenvwrapper if you also use pyenv.</td>
        </tr>
       </tbody>
      </table>
     </div>
     <p><strong>Not recommended</strong></p>
     <ul>
      <li>pyvenv (!=pipenv &amp; !=pyenv). This is deprecated, use venv or virtualenv instead.</li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>What about Conda? Would you recommend against it entirely? And what information would you use to decide between pipenv and poetry?</span> <span> - </span> <span class="display-name">naught101</span> <span> </span> <span class="date">19 Jun 2021 at 09:46</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@lie Ryan <code>I'm developing an /application/ and need to manage my dependencies, and manage the dependency resolution of the dependencies of my project. Then use pipenv or poetry.</code> &gt; is this something similar to <code>requirements </code> file? What use case/problem would one use <code>venv</code> and <code>pipenv</code> together?</span> <span> - </span> <span class="display-name">soMuchToLearnAndShare</span> <span> </span> <span class="date">28 Nov 2021 at 23:36</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>pipenv/poetry used two file workflow for managing dependencies. First file specifies the logical dependency, and the second file is a dependency lock file that's automatically generated by pipenv/poetry. requirements.txt is kinda a mix of the two file, which is simpler, but not having separate lock file makes it less flexible and harder to maintain the dependency list.</span> <span> - </span> <span class="display-name">Lie Ryan</span> <span> </span> <span class="date">29 Nov 2021 at 02:46</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@soMuchToLearnAndShare pipenv is built on top of virtualenv/venv, so you always use them together. Pipenv adds a number of higher level features than virtualenv, namely dependency management. Virtualenv doesn't manage dependencies, all it does is provide isolated environment to install dependencies.</span> <span> - </span> <span class="display-name">Lie Ryan</span> <span> </span> <span class="date">29 Nov 2021 at 02:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Hi @Lie Ryan, <code>HOWEVER: pipenv uses virtualenv as its tool for creating virtual envelopes, NOT venv which is endorsed by PyPA as the go-to tool for creating virtual envelopes.</code> from @F1Linux made me understand i should not use pipenv since venv is the recommended one. Am i wrong? meaning, it is better to use <code>pyenv</code>(for python version management) + <code>venv</code> + <code>requirements.txt</code> for a python application.</span> <span> - </span> <span class="display-name">soMuchToLearnAndShare</span> <span> </span> <span class="date">1 Dec 2021 at 12:45</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>pipenv and virtualenv/venv do completely different things. They are not interchangeable.</span> <span> - </span> <span class="display-name">Lie Ryan</span> <span> </span> <span class="date">2 Dec 2021 at 06:38</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@soMuchToLearnAndShare venv is available in the standard library and that's a major benefit over virtualenv. I don't want to put words over PyPA mouth, but virtualenv does have a couple extra features that venv doesn't, and it works across larger range of Python versions. If you need the additional features that virtualenv provides over venv, then you obviously should use virtualenv. If you're satisfied with your current setup with venv, then there's no reason to choose virtualenv.</span> <span> - </span> <span class="display-name">Lie Ryan</span> <span> </span> <span class="date">2 Dec 2021 at 06:40</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@soMuchToLearnAndShare but there's no reason to avoid virtualenv either if you don't mind the additional install. If you want to use pipenv, then it only supports virtualenv. There's no reason to avoid pipenv just because it uses virtualenv, especially as using pipenv already means that you need additional install anyway. At the end of the day, the environment directory created by virtualenv and venv are nearly identical, so your choice of virtual environment tool mostly only matter when creating the environment and not so much when using it.</span> <span> - </span> <span class="display-name">Lie Ryan</span> <span> </span> <span class="date">2 Dec 2021 at 06:46</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Avoid ALL pip virtual environments whenever possible. Use conda instead. Conda provides a unified approach. It is maintained by teams of professional open source developers and has a reputable company providing funding and a commercially supported version. The teams that maintain pip, venv, virtualenv, pipenv, and many other pip variants have limited resources by comparison. The pip virtual environment plurality is frustrating for beginners. Use pip virtual environments and their (too) many variants as a last resort when conda packages do not exist.</span> <span> - </span> <span class="display-name">Rich Lysakowski PhD</span> <span> </span> <span class="date">16 Dec 2021 at 23:39</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span><code>virtualenvwrapper</code> does not seem to be very actively maintained. The latest release on <a href="https://pypi.org/project/virtualenvwrapper/" rel="nofollow noreferrer">PyPi</a> currently is from early 2019, compatibility is listed for up to Python 3.6 and commits to the <a href="https://bitbucket.org/virtualenvwrapper/virtualenvwrapper/commits/" rel="nofollow noreferrer">source repository</a> are very infrequent.</span> <span> - </span> <span class="display-name">Stefan Schmidt</span> <span> </span> <span class="date">14 Oct 2022 at 20:38</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@StefanSchmidt: virtualenvwrapper is just a bunch of very simple shell script, it is built on very stable grounds as the features it depends on for the shell scripting and Python are unlikely to ever change, so it still works just fine and will likely continue to work to eternity. There's really little reason for it to change, and little need to worry about the slow pace changes in the source repository.</span> <span> - </span> <span class="display-name">Lie Ryan</span> <span> </span> <span class="date">17 Oct 2022 at 18:05</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@LieRyan Thanks for your feedback! I gave <code>virtualenvwrapper </code> and <code>pyenv-virtualenvwrapper </code> a try. As far as I can see without doing extensive testing, despite the lack of recent updates they indeed both seem to work with Python 3.10.8.</span> <span> - </span> <span class="display-name">Stefan Schmidt</span> <span> </span> <span class="date">19 Oct 2022 at 11:05</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>24</span>
     </div>
     <div>
      <span>Answerer: </span> <span>ArnuldOnData</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 May 2020 at 04:18</span>
     </div>
    </div>
    <div>
     <p><strong>Jan 2020 Update</strong></p>
     <p>@Flimm has explained all the differences very well. Generally, we want to know the difference between all tools because we want to decide what's best for us. So, the next question would be: which one to use? I suggest you choose one of the two official ways to manage virtual environments:</p>
     <ul>
      <li>Python Packaging now <a href="https://packaging.python.org/tutorials/managing-dependencies/" rel="noreferrer">recommends Pipenv</a></li>
      <li>Python.org now <a href="https://docs.python.org/3/library/venv.html" rel="noreferrer">recommends venv</a></li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>Note that <code>pipenv</code> and <code>venv</code> aren't alternatives to each other, just like Django and Python aren't alternatives to each other. With <code>venv</code> alone, you can't install packages, for instance, whereas <code>pipenv</code> does offer a mechanism to install packages.</span> <span> - </span> <span class="display-name">Flimm</span> <span> </span> <span class="date">22 Apr 2022 at 09:22</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>I did not get you when you said with <b>venv</b> you can't install packages. I mean I can install everything available through <b>pip</b> in a virtual environment created using <b>venv</b> e.g. I have 4 different virtual environments in 4 different directories with different python and pandas versions but same jupyter lab version. All through <b>venv</b></span> <span> - </span> <span class="display-name">ArnuldOnData</span> <span> </span> <span class="date">6 May 2022 at 16:48</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Flimm <code>python -m venv foo; source foo/bin/activate; pip install numpy</code>. Both <code>venv</code> and <code>pip</code> are available out of the box. The comment sounds a little misleading.</span> <span> - </span> <span class="display-name">Magnus Lind Oxlund</span> <span> </span> <span class="date">29 Jan 2023 at 17:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@MagnusLindOxlund You cannot replace <code>venv</code> with <code>pip</code> in your example or vice-versa. You can't do<code>venv install numpy</code>, and you can't do <code>pip foo ; source foo/bin/activate</code> . So I stand by my comment that they are not alternatives to each other. Also, <code>venv</code> and <code>pip</code> are not available out of the box, say on an Ubuntu installation (even though <code>python3</code> is available out of the box). On Ubuntu, you would have to install <code>python3-venv</code> (using APT) to get <code>venv</code>, and separately you would have to install <code>python3-pip</code> to get <code>pip</code>.</span> <span> - </span> <span class="display-name">Flimm</span> <span> </span> <span class="date">30 Jan 2023 at 21:47</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>17</span>
     </div>
     <div>
      <span>Answerer: </span> <span>mirek</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Oct 2020 at 15:45</span>
     </div>
    </div>
    <div>
     <ul>
      <li><strong>pyenv</strong> - manages different python versions,</li>
      <li><strong>all others</strong> - create virtual environment (which has isolated python version and installed "requirements"),</li>
     </ul>
     <p><strong>pipenv</strong> want combine all, in addition to previous it installs "requirements" (into the active virtual environment or create its own if none is active)</p>
     <p>So maybe you will be happy with pipenv only.</p>
     <p>But I use: pyenv + pyenv-virtualenvwrapper, + pipenv (pipenv for installing requirements only).</p>
     <p>In Debian:</p>
     <ol>
      <li>
       <p><code>apt install libffi-dev</code></p></li>
      <li>
       <p>install pyenv based on <a href="https://www.tecmint.com/pyenv-install-and-manage-multiple-python-versions-in-linux/" rel="noreferrer">https://www.tecmint.com/pyenv-install-and-manage-multiple-python-versions-in-linux/</a>, but..</p></li>
      <li>
       <p>.. but instead of pyenv-virtualenv install pyenv-virtualenvwrapper (which can be standalone library or pyenv plugin, here the 2nd option):</p>
       <pre class="lang-sh prettyprint-override"><code>$ pyenv install 3.9.0

$ git clone https://github.com/pyenv/pyenv-virtualenvwrapper.git $(pyenv root)/plugins/pyenv-virtualenvwrapper
# inside ~/.bashrc add:
# export $VIRTUALENVWRAPPER_PYTHON="/usr/bin/python3"
$ source ~/.bashrc

$ pyenv virtualenvwrapper
</code></pre></li>
     </ol>
     <p>Then create virtual environments for your projects (workingdir must exist):</p>
     <pre><code>pyenv local 3.9.0  # to prevent 'interpreter not found' in mkvirtualenv
python -m pip install --upgrade pip setuptools wheel
mkvirtualenv &lt;venvname&gt; -p python3.9 -a &lt;workingdir&gt;
</code></pre>
     <p>and switch between projects:</p>
     <pre><code>workon &lt;venvname&gt;
python -m pip install --upgrade pip setuptools wheel pipenv
</code></pre>
     <p>Inside a project I have the file requirements.txt, without fixing the versions inside (if some version limitation is not neccessary). You have 2 possible tools to install them into the current virtual environment: <strong>pip-tools</strong> or <strong>pipenv</strong>. Lets say you will use pipenv:</p>
     <pre><code>pipenv install -r requirements.txt
</code></pre>
     <p>this will create Pipfile and Pipfile.lock files, fixed versions are in the 2nd one. If you want reinstall somewhere exactly same versions then (Pipfile.lock must be present):</p>
     <pre><code>pipenv install
</code></pre>
     <p>Remember that Pipfile.lock is related to some Python version and need to be recreated if you use a different one.</p>
     <p>As you see I write requirements.txt. This has some problems: You must remove a removed package from Pipfile too. So writing Pipfile directly is probably better.</p>
     <p>So you can see I use pipenv very poorly. Maybe if you will use it well, it can replace everything?</p>
     <p><strong>EDIT 2021.01</strong>: I have changed my stack to: <code>pyenv + pyenv-virtualenvwrapper + poetry</code>. Ie. I use no apt or pip installation of virtualenv or virtualenvwrapper, and instead I install <code>pyenv</code>'s plugin <code>pyenv-virtualenvwrapper</code>. This is easier way.</p>
     <p><code>Poetry</code> is great for me:</p>
     <pre><code>poetry add &lt;package&gt;   # install single package
poetry remove &lt;package&gt;
poetry install   # if you remove poetry.lock poetry will re-calculate versions
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>can you please elaborate on your current stack, I mean <code>pyenv + pyenv-virtualenvwrapper + poetry</code>, especially how you instruct <code>poetry</code> to use a specifique version installed via <code>pyenv</code>, and if you are disabling create virtual environment in <code>poetry</code>?</span> <span> - </span> <span class="display-name">Yassine Sedrani</span> <span> </span> <span class="date">11 Nov 2021 at 15:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Sounds like a mess to understand and keep track of! Couldn't you eliminate all the rigamarole with the conda package, using its environment and package manager features? conda is a single tool that does the work of all three or four packages mentioned in your answer.</span> <span> - </span> <span class="display-name">Rich Lysakowski PhD</span> <span> </span> <span class="date">6 Jun 2022 at 06:34</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ben L</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Feb 2023 at 14:59</span>
     </div>
    </div>
    <div>
     <p>I want to add <code>docker</code> into this list, as well as <code>conda</code> that several answer already mentioned.</p>
     <p>conda is heavier than the virtual environments the title mentioned. It also give isolation on some system-python tools, such as ffmpeg or gpu drivers.</p>
     <p>docker is even better, it gives you a whole new OS to play with. With a good Dockerfile and a <code>docker build</code>, <code>docker run</code> script, you have good documentation of how your environment is built, and it is easy to populate, migrate to other environment (staging, production, cloud). It helps you in the long run.</p>
     <p>Another thing: PyCharm provides several options to select your virtual environment. It helps the new-comers not to worry about this thing. Recommend to use it before you know what the virtual environment is.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>The question is about things that have confusingly similar names "<i>env</i>". It's not about tools like Docker or Conda.</span> <span> - </span> <span class="display-name">Flimm</span> <span> </span> <span class="date">8 Feb 2023 at 17:44</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>I think this discussion should extend to "what is the best way to use different python versions in development or production environment. " That is more valuable.</span> <span> - </span> <span class="display-name">Ben L</span> <span> </span> <span class="date">8 Feb 2023 at 18:02</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>I know what you mean. Honestly, the question I asked didn't turn out to be the one that people need answering when they visit this page. Stack Overflow's system is about specific Q&amp;A, and in general I find it works quite well, but it seems to have broken down a bit in this question, which is one of my most upvoted posts.</span> <span> - </span> <span class="display-name">Flimm</span> <span> </span> <span class="date">8 Feb 2023 at 20:10</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Rich Lysakowski PhD</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Dec 2021 at 23:39</span>
     </div>
    </div>
    <div>
     <p>As a Python newcomer this question frustrated me endlessly and confused me for months. Which virtual environment and package manager(s) should I invest in learning when I know that I will be using it for years to come?</p>
     <p>The best article answering this vexing question is <a href="https://jakevdp.github.io/blog/2016/08/25/conda-myths-and-misconceptions/" rel="nofollow noreferrer">https://jakevdp.github.io/blog/2016/08/25/conda-myths-and-misconceptions/</a> by Jake Vanderplas. Although a few years old, it provides practical answers and the history of Python package and virtual environment managers from the trenches as these state-of-the-art was developing.</p>
     <p>It was particularly frustrating for me in the data science and "big data cloud computing" communities, because conda is widely used as a virtual environment manager and full function package manager for Python and JavaScript, SQL, Java, HTML5, and Jupyter Notebooks.</p>
     <p>So why use pip at all, when conda does everything that pip and venv variants do?</p>
     <p>The answer is, "because you MUST use pip if a conda package is simply not available." Many times a required package is only available in pip format and there is no easy solution but to use pip. You can learn to use <code>conda build</code> but if you are not the package maintainer, then you must convince the package owner to generate a conda package for each new release (or do it yourself.)</p>
     <p>These pip-based packages differ along many important and practical dimensions:</p>
     <ul>
      <li>stability</li>
      <li>maturity</li>
      <li>complexity</li>
      <li>active support (versus dying or dead)</li>
      <li>levels of adoption near the Python ecosystem "core" versus "on the fringes" (i.e., integrated into Python.org distro)</li>
      <li>easy to figure out and use (for beginners)</li>
     </ul>
     <p>I will answer your question for two packages from dimension of package maturity and stability.</p>
     <p>venv and virtualenv are the most mature, stability, and community support. From the online documentation you can see that virtualenv is in version 20.x as of today. <a href="https://virtualenv.pypa.io/en/latest/" rel="nofollow noreferrer">virtualenv</a></p>
     <blockquote>
      <p>virtualenv is a tool to create isolated Python environments. Since Python 3.3, a subset of it has been integrated into the standard library under the venv module. The venv module does not offer all features of this library, to name just a few more prominent:</p>
      <pre><code>is slower (by not having the app-data seed method),

is not as extendable,

cannot create virtual environments for arbitrarily installed python versions (and automatically discover these),

is not upgrade-able via pip,

does not have as rich programmatic API (describe virtual environments without creating them).
</code></pre>
     </blockquote>
     <p>virtualenvwrapper is set of scripts to help people use virtualenv (it is a "wrapper" that not well-maintained, its last update was in 2019. <a href="https://pypi.org/project/virtualenvwrapper/" rel="nofollow noreferrer">virtualenvwrapper</a></p>
     <p>My recommendation is to avoid ALL pip virtual environments whenever possible. Use conda instead. Conda provides a unified approach. It is maintained by teams of professional open source developers and has a reputable company providing funding and a commercially supported version. The teams that maintain pip, venv, virtualenv, pipenv, and many other pip variants have limited resources by comparison. The pip virtual environment plurality is frustrating for beginners. The pip-based virtual environment tools complexity, fragmentation, fringe and unsupported packages, and wildly inconsistent support drove me to use conda. For data science work, my recommendation is that to use a pip-based virtual environment manager as a last resort when conda packages do not exist.</p>
     <p>The differences between the venv variants still scare me because my time is limited to learn new packages. pipenv, venv, pyvenv, pyenv, virtualenv, virtualenvwrapper, poetry, and others have dozens of differences and complexities that take days to understand. I hate going down a path and find support for a package goes belly-up when a maintainer resigns (or gets too busy to maintain it). I just need to get my job done.</p>
     <p>In the spirit of being helpful, here are a few links to help you dive in over your head, but not get lost in Dante's Inferno (re: pip).</p>
     <p><a href="https://towardsdatascience.com/virtual-environments-104c62d48c54" rel="nofollow noreferrer">A Guide to Python’s Virtual Environments</a></p>
     <p>Choosing "core" Python packages to invest in for your career (long-term), versus getting a job done short term) is important. However, it is a business analysis question. Are you trying to simply get a task done, or a professional software engineer who builds scalable performant systems that require the least amount of maintenance effort over time? IMHO, conda will take you to the latter place more easily than dealing with pip-plurality problems. conda is still missing 1-step pip-package migration tools that make this a moot question. If we could simply convert pip packages into conda packages then pypi.org and conda-forge could be merged. Pip is necessary because conda packages are not (yet) universal. Many Python programmers are either too lazy to create conda packages, or they only program in Python and don't need conda's language-agnostic / multi-lingual support.</p>
     <p>conda has been a god-send for me, because it supports cloud software engineering and data science's need for multilingual support of JavaScript, SQL, and Jupyter Notebook extensions, and conda plays well within Docker and other cloud-native environments. I encourage you to learn and master conda, which will enable you to side-step many complex questions that pip-based tools may never answer.</p>
     <p>Keep it simple! I need one package that does 90% of what I need and guidance and workarounds for the 10% remaining edge cases.</p>
     <p>Check out the articles linked herein to learn more about pip-based virtual environments.</p>
     <p>I hope this is helpful to the original poster and gives pip and conda aficionados some things to think about.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span>Quote: <code>Pip is necessary because conda packages are not (yet) universal. Many Python programmers are either too lazy to create conda packages, or they only program in Python and don't need conda's language-agnostic / multi-lingual support.</code> --- if so - then isn't this making a strong hint why not to use conda? Or if conda wants to be universal, then there should be a clear time soon enough for that. So despite the many pip/virtualenv flavors then maybe better pick a winner and cancel all the rest than pick conda ... (is virtualenv[wrapper] already the winner?)</span> <span> - </span> <span class="display-name">arntg</span> <span> </span> <span class="date">5 Feb 2022 at 22:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>My answer is opinionated in favor of simplicity, i.e., using ONE tool for virtual environment, dependency, and package management for Python AND other languages. The conda system lacks just one function/module to make this entire cloudy confusion of alternatives disappear and become moot, a module to convert any pip-only format packages into conda packages reliably. conda is singly better supported than the fragmented cast of characters that include pipenv, virtualenv, venv, pyenv, poetry, and others. Someone will get around to writing a functional converter soon.</span> <span> - </span> <span class="display-name">Rich Lysakowski PhD</span> <span> </span> <span class="date">12 Feb 2022 at 00:16</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I just found a package last week called "pip2conda". When I get around to testing it, I will let you know if it fulfills the promise of its name.</span> <span> - </span> <span class="display-name">Rich Lysakowski PhD</span> <span> </span> <span class="date">22 Apr 2022 at 07:55</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>The motivation for conda is to have a single, unified package AND environment manager. Reduce complexity, uncomplicate life for Pythonista who are also polyglots, "There should be one-- and preferably only one --obvious way to do it." The Zen of Python, by Tim Peters ... Simple is better than complex. ... There should be one-- and preferably only one --obvious way to do it. ... If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. ... Conda is one honking great idea -- let's do more of those!</span> <span> - </span> <span class="display-name">Rich Lysakowski PhD</span> <span> </span> <span class="date">6 Jun 2022 at 06:46</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>