<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>What's "P=NP?", and why is it such a famous question?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>What's "P=NP?", and why is it such a famous question?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>270</span>
    </div>
    <div>
     <span>Asker: </span> <span>raldi</span>
    </div>
    <div>
     <span>Asked: </span> <span>21 Sep 2008 at 16:07</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/111307/whats-p-np-and-why-is-it-such-a-famous-question">source</a>
    </div>
   </div>
   <div>
    <p>The question of whether P=NP is perhaps the most famous in all of Computer Science. What does it mean? And why is it so interesting?</p>
    <p>Oh, and for extra credit, please post a proof of the statement's truth or falsehood. :)</p>
   </div>
   <div class="tags">
    <span class="tag">computer-science</span><span class="tag">theory</span><span class="tag">complexity-theory</span><span class="tag">np-complete</span><span class="tag">p-np</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>20</td>
       <td><span>As nicely laid out by Scott Aaronson, MIT "If P = NP, then the world would be a profoundly different place than we usually assume it to be. There would be no special value in "creative leaps," no fundamental gap between solving a problem and recognizing the solution once it's found. Everyone who could appreciate a symphony would be Mozart; everyone who could follow a step-by-step argument would be Gauss..." excerpt from <a href="http://en.wikipedia.org/wiki/Complexity_classes_P_and_NP" rel="nofollow noreferrer">en.wikipedia.org/wiki/Complexity_classes_P_and_NP</a> .</span> <span> - </span> <span class="display-name">gts</span> <span> </span> <span class="date">31 Jul 2012 at 22:10</span></td>
      </tr>
      <tr>
       <td>2</td>
       <td><span>See also <a href="http://cs.stackexchange.com/questions/9556/in-basic-terms-what-is-the-definition-of-p-np-np-complete-and-np-hard">In basic terms, what is the definition of P, NP, NP-Complete, and NP-Hard?</a> on <a href="https://cs.stackexchange.com">Computer Science</a>.</span> <span> - </span> <span class="display-name">Kaveh</span> <span> </span> <span class="date">9 Jun 2014 at 21:17</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>416</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Dima</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Sep 2008 at 15:20</span>
     </div>
    </div>
    <div>
     <p>P stands for polynomial time. NP stands for non-deterministic polynomial time.</p>
     <p>Definitions:</p>
     <ul>
      <li>
       <p><strong>Polynomial time</strong> means that the complexity of the algorithm is O(n^k), where n is the size of your data (e. g. number of elements in a list to be sorted), and k is a constant.</p></li>
      <li>
       <p><strong>Complexity</strong> is time measured in the number of operations it would take, as a function of the number of data items.</p></li>
      <li>
       <p><strong>Operation</strong> is whatever makes sense as a basic operation for a particular task. For sorting, the basic operation is a comparison. For matrix multiplication, the basic operation is multiplication of two numbers.</p></li>
     </ul>
     <p>Now the question is, what does deterministic vs. non-deterministic mean? There is an abstract computational model, an imaginary computer called a Turing machine (TM). This machine has a finite number of states, and an infinite tape, which has discrete cells into which a finite set of symbols can be written and read. At any given time, the TM is in one of its states, and it is looking at a particular cell on the tape. Depending on what it reads from that cell, it can write a new symbol into that cell, move the tape one cell forward or backward, and go into a different state. This is called a state transition. Amazingly enough, by carefully constructing states and transitions, you can design a TM, which is equivalent to any computer program that can be written. This is why it is used as a theoretical model for proving things about what computers can and cannot do.</p>
     <p>There are two kinds of TM's that concern us here: deterministic and non-deterministic. A deterministic TM only has one transition from each state for each symbol that it is reading off the tape. A non-deterministic TM may have several such transition, i. e. it is able to check several possibilities simultaneously. This is sort of like spawning multiple threads. The difference is that a non-deterministic TM can spawn as many such "threads" as it wants, while on a real computer only a specific number of threads can be executed at a time (equal to the number of CPUs). In reality, computers are basically deterministic TMs with finite tapes. On the other hand, a non-deterministic TM cannot be physically realized, except maybe with a quantum computer.</p>
     <p>It has been proven that any problem that can be solved by a non-deterministic TM can be solved by a deterministic TM. However, it is not clear how much time it will take. The statement P=NP means that if a problem takes polynomial time on a non-deterministic TM, then one can build a deterministic TM which would solve the same problem also in polynomial time. So far nobody has been able to show that it can be done, but nobody has been able to prove that it cannot be done, either.</p>
     <p>NP-complete problem means an NP problem X, such that any NP problem Y can be reduced to X by a polynomial reduction. That implies that if anyone ever comes up with a polynomial-time solution to an NP-complete problem, that will also give a polynomial-time solution to any NP problem. Thus that would prove that P=NP. Conversely, if anyone were to prove that P!=NP, then we would be certain that there is no way to solve an NP problem in polynomial time on a conventional computer.</p>
     <p>An example of an NP-complete problem is the problem of finding a truth assignment that would make a boolean expression containing n variables true.<br>
       For the moment in practice any problem that takes polynomial time on the non-deterministic TM can only be done in exponential time on a deterministic TM or on a conventional computer.<br>
       For example, the only way to solve the truth assignment problem is to try 2^n possibilities.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>5</td>
        <td><span>It isn't true that the only way to solve SAT is enumeration of cases. See <a href="http://en.wikipedia.org/wiki/Boolean_satisfiability_problem#Algorithms_for_solving_SAT" rel="nofollow noreferrer">en.wikipedia.org/wiki/…</a> for info on the DPLL algorithm, which is actually very efficient in many common cases.</span> <span> - </span> <span class="display-name">Doug McClean</span> <span> </span> <span class="date">24 Sep 2008 at 16:40</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Okay, you made this way more complicated by bringing in non-deterministic Turing machines. That's totally a peripheral issue.</span> <span> - </span> <span class="display-name">Derek Park</span> <span> </span> <span class="date">24 Sep 2008 at 16:46</span></td>
       </tr>
       <tr>
        <td>47</td>
        <td><span>Derek, I beg to disagree. I really don't see how you explain P and NP without Turing machines. I was once in an algorithms class, which tried that. If I didn't know about TM's, I'd be totally lost.</span> <span> - </span> <span class="display-name">Dima</span> <span> </span> <span class="date">24 Sep 2008 at 18:20</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Derek, correction. I think you did a nice job. Computed vs. verified makes a lot of sense. However, it is harder to see why something verified in P-time may ever be computed in P-time, without using the TM as a model.</span> <span> - </span> <span class="display-name">Dima</span> <span> </span> <span class="date">24 Sep 2008 at 18:26</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Well, my statement was unnecessarily harsh. The two expressions (yours and mine) of NP are apparently formally equivalent, so both are actually correct. I'd always heard P/NP expressed the way I described.</span> <span> - </span> <span class="display-name">Derek Park</span> <span> </span> <span class="date">25 Sep 2008 at 04:41</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>As for needing the TM model, I honestly have as much trouble seeing how all non-deterministic TMs can computed on deterministic TMs as I do seeing how all polynomial-verification problem can be polynomial-computation problems. Both are hard for me to imagine being true.</span> <span> - </span> <span class="display-name">Derek Park</span> <span> </span> <span class="date">25 Sep 2008 at 04:44</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Well, with the TM explanation you start by proving that for any non-deterministic TM you can build a deterministic TM, which solves the same problem. Then you naturally ask the question: if I have a polynomial-time NTM, can I build an equivalent polynomial-time DTM?</span> <span> - </span> <span class="display-name">Dima</span> <span> </span> <span class="date">25 Sep 2008 at 16:15</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Re: emulating NDTMs with DTMs - the only difference is that NDTMs know 'instinctively' what choice to make at any branch point. You can simulate this behaviour by making <i>every</i> choice at branch points, through breadth-first search, and you'll eventually follow the same computation path as the NDTLM</span> <span> - </span> <span class="display-name">HenryR</span> <span> </span> <span class="date">27 Sep 2008 at 21:39</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Stepping in way late to an argument which is way over my head, but as a laymen I found Dima's explanation easier to grok than explanations based on verifiability have been. But that's just me</span> <span> - </span> <span class="display-name">1800 INFORMATION</span> <span> </span> <span class="date">11 Feb 2009 at 08:01</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I like this answer, except that the definition of NP-complete at the end is vague/wrong. NP-complete means an NP problem X, such that any NP problem Y can be reduced to X by a polynomial reduction. A polynomial reduction means that any case of the problem Y can be solved by solving one or more cases of the problem X, and that counting each case of solving X as "1", Y would be P. So for example the problem "sort" can be polynomially reduced to the problem "partition", as in Quicksort. It turns out that there are lots of important NP-complete problems, for example subset-sum and 3-SAT.</span> <span> - </span> <span class="display-name">Steve Jessop</span> <span> </span> <span class="date">19 Feb 2011 at 10:40</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>It's true <i>in practice</i> that solving NP-complete problems takes greater than polynomial time on a real computer, but that's not what it means, it's just the current state of the art, as a consequence of the fact that P=NP is unknown. If anyone found a polynomial algorithm to solve any NP-complete problem, that would prove P=NP, and we know that hasn't happened because it would be in the news! Conversely if it was proved that P!=NP, then we could confidently say that no NP-complete problem is solvable in polynomial time.</span> <span> - </span> <span class="display-name">Steve Jessop</span> <span> </span> <span class="date">19 Feb 2011 at 10:45</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Steve Jessop: thanks for the clarification. You are right, my explanation of NP-complete is vague. My goal there was to give the practical implication of NP-completeness.</span> <span> - </span> <span class="display-name">Dima</span> <span> </span> <span class="date">19 Feb 2011 at 13:33</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Steve Jessop: I have edited the part about NP-completeness. Please take a look if it is making sense now.</span> <span> - </span> <span class="display-name">Dima</span> <span> </span> <span class="date">19 Feb 2011 at 13:43</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>Correction in the second to last paragraph: "we would be certain that there is no way to solve an NP <b>Complete</b> problem in polynomial time on a conventional computer", since P is a subset of NP and proving P != NP does not necessarily say anything about what problems in NP that are not NP-Complete are actually in P.</span> <span> - </span> <span class="display-name">Millie Smith</span> <span> </span> <span class="date">5 Nov 2014 at 03:34</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I still have one question: since NP is <i>non-deterministic polynomial time</i>, and P is <b>not</b> said to be <i>non-deterministic</i>, does this mean that P <b>is</b> then <i>deterministic</i>?</span> <span> - </span> <span class="display-name">Rafael Eyng</span> <span> </span> <span class="date">4 Oct 2016 at 02:39</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>104</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Derek Park</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Sep 2008 at 17:03</span>
     </div>
    </div>
    <div>
     <ol>
      <li>A yes-or-no problem is in <strong>P</strong> (<strong>P</strong>olynomial time) if the answer can be computed in polynomial time.</li>
      <li>A yes-or-no problem is in <strong>NP</strong> (<strong>N</strong>on-deterministic <strong>P</strong>olynomial time) if a yes answer can be <em>verified</em> in polynomial time.</li>
     </ol>
     <p>Intuitively, we can see that if a problem is in <strong>P</strong>, then it is in <strong>NP</strong>. Given a potential answer for a problem in <strong>P</strong>, we can verify the answer by simply recalculating the answer.</p>
     <p>Less obvious, and much more difficult to answer, is whether all problems in <strong>NP</strong> are in <strong>P</strong>. Does the fact that we can verify an answer in polynomial time mean that we can compute that answer in polynomial time?</p>
     <p>There are a large number of important problems that are known to be <strong>NP</strong>-complete (basically, if any these problems are proven to be in <strong>P</strong>, then <em>all</em> <strong>NP</strong> problems are proven to be in <strong>P</strong>). If <strong>P</strong> = <strong>NP</strong>, then all of these problems will be proven to have an efficient (polynomial time) solution.</p>
     <p>Most scientists believe that <strong>P</strong>!=<strong>NP</strong>. However, no proof has yet been established for either <strong>P</strong> = <strong>NP</strong> or <strong>P</strong>!=<strong>NP</strong>. If anyone provides a proof for either conjecture, <a href="http://en.wikipedia.org/wiki/Millennium_Prize_Problems" rel="noreferrer">they will win US $1 million</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>24</span>
     </div>
     <div>
      <span>Answerer: </span> <span>David Thornley</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Sep 2008 at 16:26</span>
     </div>
    </div>
    <div>
     <p>To give the simplest answer I can think of:</p>
     <p>Suppose we have a problem that takes a certain number of inputs, and has various potential solutions, which may or may not solve the problem for given inputs. A logic puzzle in a puzzle magazine would be a good example: the inputs are the conditions ("George doesn't live in the blue or green house"), and the potential solution is a list of statements ("George lives in the yellow house, grows peas, and owns the dog"). A famous example is the Traveling Salesman problem: given a list of cities, and the times to get from any city to any other, and a time limit, a potential solution would be a list of cities in the order the salesman visits them, and it would work if the sum of the travel times was less than the time limit.</p>
     <p>Such a problem is in NP if we can efficiently check a potential solution to see if it works. For example, given a list of cities for the salesman to visit in order, we can add up the times for each trip between cities, and easily see if it's under the time limit. A problem is in P if we can efficiently find a solution if one exists.</p>
     <p>(Efficiently, here, has a precise mathematical meaning. Practically, it means that large problems aren't unreasonably difficult to solve. When searching for a possible solution, an inefficient way would be to list all possible potential solutions, or something close to that, while an efficient way would require searching a much more limited set.)</p>
     <p>Therefore, the P=NP problem can be expressed this way: If you can verify a solution for a problem of the sort described above efficiently, can you find a solution (or prove there is none) efficiently? The obvious answer is "Why should you be able to?", and that's pretty much where the matter stands today. Nobody has been able to prove it one way or another, and that bothers a lot of mathematicians and computer scientists. That's why anybody who can prove the solution is up for a million dollars from the Claypool Foundation.</p>
     <p>We generally assume that P does not equal NP, that there is no general way to find solutions. If it turned out that P=NP, a lot of things would change. For example, cryptography would become impossible, and with it any sort of privacy or verifiability on the Internet. After all, we can efficiently take the encrypted text and the key and produce the original text, so if P=NP we could efficiently find the key without knowing it beforehand. Password cracking would become trivial. On the other hand, there's whole classes of planning problems and resource allocation problems that we could solve effectively.</p>
     <p>You may have heard the description NP-complete. An NP-complete problem is one that is NP (of course), and has this interesting property: if it is in P, every NP problem is, and so P=NP. If you could find a way to efficiently solve the Traveling Salesman problem, or logic puzzles from puzzle magazines, you could efficiently solve anything in NP. An NP-complete problem is, in a way, the hardest sort of NP problem.</p>
     <p>So, if you can find an efficient general solution technique for any NP-complete problem, or prove that no such exists, fame and fortune are yours.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>In your second last paragraph you have "in a way, the hardest sort". You should say NP-complete are the hardest since they are NP-hard.</span> <span> - </span> <span class="display-name">grom</span> <span> </span> <span class="date">24 Nov 2008 at 05:14</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>I'm not sure that fortune would be yours. The government might want your head.</span> <span> - </span> <span class="display-name">Millie Smith</span> <span> </span> <span class="date">5 Nov 2014 at 03:30</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>9</span>
     </div>
     <div>
      <span>Answerer: </span> <span>terminus</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Sep 2008 at 16:14</span>
     </div>
    </div>
    <div>
     <p>A short summary from my humble knowledge:</p>
     <p>There are some easy computational problems (like finding the shortest path between two points in a graph), which can be calculated pretty fast ( O(n^k), where n is the size of the input and k is a constant (in the case of graphs, it's the number of vertexes or edges)).</p>
     <p>Other problems, like finding a path that crosses every vertex in a graph or getting the RSA private key from the public key is harder (O(e^n)).</p>
     <p>But CS speak tells that the problem is that we cannot 'convert' a non-deterministic Turing-machine to a deterministic one, we can, however, transform non-deterministic finite automatons (like the regex parser) into deterministic ones (well, you can, but the run-time of the machine will take long). That is, we have to try every possible path (usually smart CS professors can exclude a few ones).</p>
     <p>It's interesting because nobody even has any idea of the solution. Some say it's true, some say it's false, but there is no consensus. Another interesting thing is that a solution would be harmful for public/private key encryptions (like RSA). You could break them as easily as generating an RSA key is now.</p>
     <p>And it's a pretty inspiring problem.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>That's not quite true - you can convert a NDTM to a DTM, but the new machine has a running time exponential in the running time of the original (you effectively breadth first search the state transition graph of the NDTM).</span> <span> - </span> <span class="display-name">Adam Wright</span> <span> </span> <span class="date">24 Sep 2008 at 15:25</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@AdamWright an answer a bit late, but the runtime of the expanded machine has to be the same of the NDTM, because by definition they are equivalent. The only difference is that the expanded one just so happens to be the NDTM "in action" for a given step of depth.</span> <span> - </span> <span class="display-name">wafL</span> <span> </span> <span class="date">26 Oct 2022 at 21:57</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>rjzii</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Sep 2008 at 15:26</span>
     </div>
    </div>
    <div>
     <p>There is not much I can add to the what and why of the P=?NP part of the question, but in regards to the proof. Not only would a proof be worth some extra credit, but it would solve one of the <a href="http://www.claymath.org/millennium-problems/p-vs-np-problem" rel="nofollow noreferrer">Millennium Problems</a>. An interesting poll was recently conducted and the <a href="http://www.cs.umd.edu/~gasarch/papers/poll.pdf" rel="nofollow noreferrer">published results (PDF)</a> are definitely worth reading in regards to the subject of a proof.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Jonas Kölker</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Feb 2009 at 07:26</span>
     </div>
    </div>
    <div>
     <p>First, some definitions:</p>
     <ul>
      <li>
       <p>A particular problem is in P if you can compute a solution in time less than <code>n^k</code> for some <code>k</code>, where <code>n</code> is the size of the input. For instance, sorting can be done in <code>n log n</code> which is less than <code>n^2</code>, so sorting is polynomial time.</p></li>
      <li>
       <p>A problem is in NP if there exists a <code>k</code> such that there exists a solution of size at most <code>n^k</code> which you can verify in time at most <code>n^k</code>. Take 3-coloring of graphs: given a graph, a 3-coloring is a list of (vertex, color) pairs which has size <code>O(n)</code> and you can verify in time <code>O(m)</code> (or <code>O(n^2)</code>) whether all neighbors have different colors. So a graph is 3-colorable only if there is a short and readily verifiable solution.</p></li>
     </ul>
     <p>An equivalent definition of NP is "problems solvable by a <em>N</em>ondeterministic Turing machine in <em>P</em>olynomial time". While that tells you where the name comes from, it doesn't give you the same intuitive feel of what NP problems are like.</p>
     <p>Note that P is a subset of NP: if you can find a solution in polynomial time, there is a solution which can be verified in polynomial time--just check that the given solution is equal to the one you can find.</p>
     <p>Why is the question <code>P =? NP</code> interesting? To answer that, one first needs to see what NP-complete problems are. Put simply,</p>
     <ul>
      <li>A problem L is NP-complete if (1) L is in P, and (2) an algorithm which solves L can be used to solve any problem L' in NP; that is, given an instance of L' you can create an instance of L that has a solution if and only if the instance of L' has a solution. Formally speaking, every problem L' in NP is <em>reducible</em> to L.</li>
     </ul>
     <p>Note that the instance of L must be polynomial-time computable and have polynomial size, in the size of L'; that way, solving an NP-complete problem in polynomial time gives us a polynomial time solution to <em>all</em> NP problems.</p>
     <p>Here's an example: suppose we know that 3-coloring of graphs is an NP-hard problem. We want to prove that deciding the satisfiability of boolean formulas is an NP-hard problem as well.</p>
     <p>For each vertex v, have two boolean variables v_h and v_l, and the requirement (v_h or v_l): each pair can only have the values {01, 10, 11}, which we can think of as color 1, 2 and 3.</p>
     <p>For each edge (u, v), have the requirement that (u_h, u_l) != (v_h, v_l). That is,</p>
     <blockquote>
      <p><code>not ((u_h and not u_l) and (v_h and not v_l) or ...)</code> enumerating all the equal configurations and stipulation that neither of them are the case.</p>
     </blockquote>
     <p><code>AND</code>'ing together all these constraints gives a boolean formula which has polynomial size (<code>O(n+m)</code>). You can check that it takes polynomial time to compute as well: you're doing straightforward <code>O(1)</code> stuff per vertex and per edge.</p>
     <p>If you can solve the boolean formula I've made, then you can also solve graph coloring: for each pair of variables v_h and v_l, let the color of v be the one matching the values of those variables. By construction of the formula, neighbors won't have equal colors.</p>
     <p>Hence, if 3-coloring of graphs is NP-complete, so is boolean-formula-satisfiability.</p>
     <p>We know that 3-coloring of graphs is NP-complete; however, historically we have come to know that by first showing the NP-completeness of boolean-circuit-satisfiability, and then reducing that to 3-colorability (instead of the other way around).</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>