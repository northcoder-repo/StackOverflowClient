<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Byte order mark screws up file reading in Java</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>Byte order mark screws up file reading in Java</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>126</span>
    </div>
    <div>
     <span>Asker: </span> <span>Tom</span>
    </div>
    <div>
     <span>Asked: </span> <span>2 Dec 2009 at 20:04</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/1835430/byte-order-mark-screws-up-file-reading-in-java">source</a>
    </div>
   </div>
   <div>
    <p>I'm trying to read CSV files using Java. Some of the files may have a byte order mark in the beginning, but not all. When present, the byte order gets read along with the rest of the first line, thus causing problems with string compares.</p>
    <p>Is there an easy way to skip the byte order mark when it is present?</p>
   </div>
   <div class="tags">
    <span class="tag">java</span><span class="tag">utf-8</span><span class="tag">byte-order-mark</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td></td>
       <td><span>maybe: <a href="http://www.rgagnon.com/javadetails/java-handle-utf8-file-with-bom.html" rel="nofollow noreferrer">rgagnon.com/javadetails/java-handle-utf8-file-with-bom.html</a></span> <span> - </span> <span class="display-name">Chris</span> <span> </span> <span class="date">24 Jul 2012 at 18:14</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>126</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Gregory Pakosz</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Dec 2009 at 20:20</span>
     </div>
    </div>
    <div>
     <p><strong>EDIT</strong>: I've made a proper release on GitHub: <a href="https://github.com/gpakosz/UnicodeBOMInputStream" rel="noreferrer">https://github.com/gpakosz/UnicodeBOMInputStream</a></p>
     <hr>
     <p>Here is a class I coded a while ago, I just edited the package name before pasting. Nothing special, it is quite similar to solutions posted in SUN's bug database. Incorporate it in your code and you're fine.</p>
     <pre><code>/* ____________________________________________________________________________
 * 
 * File:    UnicodeBOMInputStream.java
 * Author:  Gregory Pakosz.
 * Date:    02 - November - 2005    
 * ____________________________________________________________________________
 */
package com.stackoverflow.answer;

import java.io.IOException;
import java.io.InputStream;
import java.io.PushbackInputStream;

/**
 * The &lt;code&gt;UnicodeBOMInputStream&lt;/code&gt; class wraps any
 * &lt;code&gt;InputStream&lt;/code&gt; and detects the presence of any Unicode BOM
 * (Byte Order Mark) at its beginning, as defined by
 * &lt;a href="http://www.faqs.org/rfcs/rfc3629.html"&gt;RFC 3629 - UTF-8, a transformation format of ISO 10646&lt;/a&gt;
 * 
 * &lt;p&gt;The
 * &lt;a href="http://www.unicode.org/unicode/faq/utf_bom.html"&gt;Unicode FAQ&lt;/a&gt;
 * defines 5 types of BOMs:&lt;ul&gt;
 * &lt;li&gt;&lt;pre&gt;00 00 FE FF  = UTF-32, big-endian&lt;/pre&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;pre&gt;FF FE 00 00  = UTF-32, little-endian&lt;/pre&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;pre&gt;FE FF        = UTF-16, big-endian&lt;/pre&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;pre&gt;FF FE        = UTF-16, little-endian&lt;/pre&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;pre&gt;EF BB BF     = UTF-8&lt;/pre&gt;&lt;/li&gt;
 * &lt;/ul&gt;&lt;/p&gt;
 * 
 * &lt;p&gt;Use the {@link #getBOM()} method to know whether a BOM has been detected
 * or not.
 * &lt;/p&gt;
 * &lt;p&gt;Use the {@link #skipBOM()} method to remove the detected BOM from the
 * wrapped &lt;code&gt;InputStream&lt;/code&gt; object.&lt;/p&gt;
 */
public class UnicodeBOMInputStream extends InputStream
{
  /**
   * Type safe enumeration class that describes the different types of Unicode
   * BOMs.
   */
  public static final class BOM
  {
    /**
     * NONE.
     */
    public static final BOM NONE = new BOM(new byte[]{},"NONE");

    /**
     * UTF-8 BOM (EF BB BF).
     */
    public static final BOM UTF_8 = new BOM(new byte[]{(byte)0xEF,
                                                       (byte)0xBB,
                                                       (byte)0xBF},
                                            "UTF-8");

    /**
     * UTF-16, little-endian (FF FE).
     */
    public static final BOM UTF_16_LE = new BOM(new byte[]{ (byte)0xFF,
                                                            (byte)0xFE},
                                                "UTF-16 little-endian");

    /**
     * UTF-16, big-endian (FE FF).
     */
    public static final BOM UTF_16_BE = new BOM(new byte[]{ (byte)0xFE,
                                                            (byte)0xFF},
                                                "UTF-16 big-endian");

    /**
     * UTF-32, little-endian (FF FE 00 00).
     */
    public static final BOM UTF_32_LE = new BOM(new byte[]{ (byte)0xFF,
                                                            (byte)0xFE,
                                                            (byte)0x00,
                                                            (byte)0x00},
                                                "UTF-32 little-endian");

    /**
     * UTF-32, big-endian (00 00 FE FF).
     */
    public static final BOM UTF_32_BE = new BOM(new byte[]{ (byte)0x00,
                                                            (byte)0x00,
                                                            (byte)0xFE,
                                                            (byte)0xFF},
                                                "UTF-32 big-endian");

    /**
     * Returns a &lt;code&gt;String&lt;/code&gt; representation of this &lt;code&gt;BOM&lt;/code&gt;
     * value.
     */
    public final String toString()
    {
      return description;
    }

    /**
     * Returns the bytes corresponding to this &lt;code&gt;BOM&lt;/code&gt; value.
     */
    public final byte[] getBytes()
    {
      final int     length = bytes.length;
      final byte[]  result = new byte[length];

      // Make a defensive copy
      System.arraycopy(bytes,0,result,0,length);

      return result;
    }

    private BOM(final byte bom[], final String description)
    {
      assert(bom != null)               : "invalid BOM: null is not allowed";
      assert(description != null)       : "invalid description: null is not allowed";
      assert(description.length() != 0) : "invalid description: empty string is not allowed";

      this.bytes          = bom;
      this.description  = description;
    }

            final byte    bytes[];
    private final String  description;

  } // BOM

  /**
   * Constructs a new &lt;code&gt;UnicodeBOMInputStream&lt;/code&gt; that wraps the
   * specified &lt;code&gt;InputStream&lt;/code&gt;.
   * 
   * @param inputStream an &lt;code&gt;InputStream&lt;/code&gt;.
   * 
   * @throws NullPointerException when &lt;code&gt;inputStream&lt;/code&gt; is
   * &lt;code&gt;null&lt;/code&gt;.
   * @throws IOException on reading from the specified &lt;code&gt;InputStream&lt;/code&gt;
   * when trying to detect the Unicode BOM.
   */
  public UnicodeBOMInputStream(final InputStream inputStream) throws  NullPointerException,
                                                                      IOException

  {
    if (inputStream == null)
      throw new NullPointerException("invalid input stream: null is not allowed");

    in = new PushbackInputStream(inputStream,4);

    final byte  bom[] = new byte[4];
    final int   read  = in.read(bom);

    switch(read)
    {
      case 4:
        if ((bom[0] == (byte)0xFF) &amp;&amp;
            (bom[1] == (byte)0xFE) &amp;&amp;
            (bom[2] == (byte)0x00) &amp;&amp;
            (bom[3] == (byte)0x00))
        {
          this.bom = BOM.UTF_32_LE;
          break;
        }
        else
        if ((bom[0] == (byte)0x00) &amp;&amp;
            (bom[1] == (byte)0x00) &amp;&amp;
            (bom[2] == (byte)0xFE) &amp;&amp;
            (bom[3] == (byte)0xFF))
        {
          this.bom = BOM.UTF_32_BE;
          break;
        }

      case 3:
        if ((bom[0] == (byte)0xEF) &amp;&amp;
            (bom[1] == (byte)0xBB) &amp;&amp;
            (bom[2] == (byte)0xBF))
        {
          this.bom = BOM.UTF_8;
          break;
        }

      case 2:
        if ((bom[0] == (byte)0xFF) &amp;&amp;
            (bom[1] == (byte)0xFE))
        {
          this.bom = BOM.UTF_16_LE;
          break;
        }
        else
        if ((bom[0] == (byte)0xFE) &amp;&amp;
            (bom[1] == (byte)0xFF))
        {
          this.bom = BOM.UTF_16_BE;
          break;
        }

      default:
        this.bom = BOM.NONE;
        break;
    }

    if (read &gt; 0)
      in.unread(bom,0,read);
  }

  /**
   * Returns the &lt;code&gt;BOM&lt;/code&gt; that was detected in the wrapped
   * &lt;code&gt;InputStream&lt;/code&gt; object.
   * 
   * @return a &lt;code&gt;BOM&lt;/code&gt; value.
   */
  public final BOM getBOM()
  {
    // BOM type is immutable.
    return bom;
  }

  /**
   * Skips the &lt;code&gt;BOM&lt;/code&gt; that was found in the wrapped
   * &lt;code&gt;InputStream&lt;/code&gt; object.
   * 
   * @return this &lt;code&gt;UnicodeBOMInputStream&lt;/code&gt;.
   * 
   * @throws IOException when trying to skip the BOM from the wrapped
   * &lt;code&gt;InputStream&lt;/code&gt; object.
   */
  public final synchronized UnicodeBOMInputStream skipBOM() throws IOException
  {
    if (!skipped)
    {
      in.skip(bom.bytes.length);
      skipped = true;
    }
    return this;
  }

  /**
   * {@inheritDoc}
   */
  public int read() throws IOException
  {
    return in.read();
  }

  /**
   * {@inheritDoc}
   */
  public int read(final byte b[]) throws  IOException,
                                          NullPointerException
  {
    return in.read(b,0,b.length);
  }

  /**
   * {@inheritDoc}
   */
  public int read(final byte b[],
                  final int off,
                  final int len) throws IOException,
                                        NullPointerException
  {
    return in.read(b,off,len);
  }

  /**
   * {@inheritDoc}
   */
  public long skip(final long n) throws IOException
  {
    return in.skip(n);
  }

  /**
   * {@inheritDoc}
   */
  public int available() throws IOException
  {
    return in.available();
  }

  /**
   * {@inheritDoc}
   */
  public void close() throws IOException
  {
    in.close();
  }

  /**
   * {@inheritDoc}
   */
  public synchronized void mark(final int readlimit)
  {
    in.mark(readlimit);
  }

  /**
   * {@inheritDoc}
   */
  public synchronized void reset() throws IOException
  {
    in.reset();
  }

  /**
   * {@inheritDoc}
   */
  public boolean markSupported() 
  {
    return in.markSupported();
  }

  private final PushbackInputStream in;
  private final BOM                 bom;
  private       boolean             skipped = false;

} // UnicodeBOMInputStream
</code></pre>
     <p>And you're using it this way:</p>
     <pre><code>import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.InputStreamReader;

public final class UnicodeBOMInputStreamUsage
{
  public static void main(final String[] args) throws Exception
  {
    FileInputStream fis = new FileInputStream("test/offending_bom.txt");
    UnicodeBOMInputStream ubis = new UnicodeBOMInputStream(fis);

    System.out.println("detected BOM: " + ubis.getBOM());

    System.out.print("Reading the content of the file without skipping the BOM: ");
    InputStreamReader isr = new InputStreamReader(ubis);
    BufferedReader br = new BufferedReader(isr);

    System.out.println(br.readLine());

    br.close();
    isr.close();
    ubis.close();
    fis.close();

    fis = new FileInputStream("test/offending_bom.txt");
    ubis = new UnicodeBOMInputStream(fis);
    isr = new InputStreamReader(ubis);
    br = new BufferedReader(isr);

    ubis.skipBOM();

    System.out.print("Reading the content of the file after skipping the BOM: ");
    System.out.println(br.readLine());

    br.close();
    isr.close();
    ubis.close();
    fis.close();
  }

} // UnicodeBOMInputStreamUsage
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>Sorry for the long scrolling areas, too bad there is no attachment feature</span> <span> - </span> <span class="display-name">Gregory Pakosz</span> <span> </span> <span class="date">2 Dec 2009 at 20:22</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>You're welcome. I remember I discovered this problem after editing XML configuration files with the most widespread XML editor in the world: Notepad.exe which inserts a BOM when saving back a file that contains Unicode characters :)</span> <span> - </span> <span class="display-name">Gregory Pakosz</span> <span> </span> <span class="date">4 Dec 2009 at 07:27</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Great decorator! It may be a good idea to delegate the BOM recognition to the BOM class, too, though. Chain of responsibility, someone?</span> <span> - </span> <span class="display-name">xtofl</span> <span> </span> <span class="date">23 May 2011 at 09:01</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>yeah well the great chain of design patterns... ;)</span> <span> - </span> <span class="display-name">Gregory Pakosz</span> <span> </span> <span class="date">10 Aug 2011 at 09:19</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>This should be in core Java API</span> <span> - </span> <span class="display-name">Denys Kniazhev-Support Ukraine</span> <span> </span> <span class="date">7 Dec 2012 at 16:42</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Why not add javaCharset key as a member in UnicodeBOMInputStream whose value can be used to read file accordingly in InputStreamReader isr = new InputStreamReader(ubis, ubis.getCharsetKey()) where getCharsetKey return the Java.charset values as per the BOM found.</span> <span> - </span> <span class="display-name">Varun Bhatia</span> <span> </span> <span class="date">20 Mar 2013 at 07:01</span></td>
       </tr>
       <tr>
        <td>10</td>
        <td><span>10 years have passed and I'm still receiving karma for this :D I'm looking at you Java!</span> <span> - </span> <span class="display-name">Gregory Pakosz</span> <span> </span> <span class="date">22 May 2015 at 10:33</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Using your code I managed to solve this BOM problem... but strangely your code as written didn't work for me: <code>int read = in.read( bom )</code> in fact returned <b><i>4</i></b> for me, not 3, so everything went wrong, despite the fact that this was a UTF-8 BOM. I followed up with <code>in.skip( 3 )</code>... and was then able to SAX parse my file. Strange that no-one else has mentioned this. NB offending BOM characters: "ï»¿". Also, <code>int</code> casts of the <code>bytes</code> at the start of the line came out at: "-17, -69, -65, 60, 63, 120, 109, 108, 32, 118, 101, 114, 115, 105, 111, ...". This might be of some help...</span> <span> - </span> <span class="display-name">mike rodent</span> <span> </span> <span class="date">3 Mar 2017 at 20:00</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Which byte array, by the way, comes out as "<b>EFBBBF</b>3C3F786D6C2076657..." using, for example, <code>org.apache.commons.codec.binary.Hex.encodeHexString( bytes )</code></span> <span> - </span> <span class="display-name">mike rodent</span> <span> </span> <span class="date">4 Mar 2017 at 08:09</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Not worked for me!! I don't know why but maybe my file in in locale "fa_IR"</span> <span> - </span> <span class="display-name">Mohsen Abasi</span> <span> </span> <span class="date">14 Aug 2017 at 10:05</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I think Java is following a "lazy" pattern: it does things reactively, assuming all the data input is in good order and format. Same happens with Java way of reading keystore and build cert chain. Java: pillar in the "lazy" world, yes you are!</span> <span> - </span> <span class="display-name">WesternGun</span> <span> </span> <span class="date">15 Sep 2017 at 12:28</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Upvoted because answer provides history regarding why file input stream does not provide the option to discard BOM by default.</span> <span> - </span> <span class="display-name">MxLDevs</span> <span> </span> <span class="date">30 Apr 2018 at 19:09</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>107</span>
     </div>
     <div>
      <span>Answerer: </span> <span>rescdsk</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Sep 2011 at 15:28</span>
     </div>
    </div>
    <div>
     <p>The <a href="http://commons.apache.org/io/" rel="noreferrer"><strong>Apache Commons IO</strong></a> library has an <code>InputStream</code> that can detect and discard BOMs: <a href="http://commons.apache.org/io/apidocs/org/apache/commons/io/input/BOMInputStream.html" rel="noreferrer"><code>BOMInputStream</code> (javadoc)</a>:</p>
     <pre><code>BOMInputStream bomIn = new BOMInputStream(in);
int firstNonBOMByte = bomIn.read(); // Skips BOM
if (bomIn.hasBOM()) {
    // has a UTF-8 BOM
}
</code></pre>
     <p>If you also need to detect different encodings, it can also distinguish among various different byte-order marks, e.g. UTF-8 vs. UTF-16 big + little endian - details at the doc link above. You can then use the detected <a href="http://commons.apache.org/io/apidocs/org/apache/commons/io/ByteOrderMark.html" rel="noreferrer"><code>ByteOrderMark</code></a> to choose a <a href="http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html?is-external=true" rel="noreferrer"><code>Charset</code></a> to decode the stream. (There's probably a more streamlined way to do this if you need all of this functionality - maybe the UnicodeReader in BalusC's answer?). Note that, in general, there's not a very good way to detect what encoding some bytes are in, but if the stream starts with a BOM, apparently this can be helpful.</p>
     <p><strong>Edit</strong>: If you need to detect the BOM in UTF-16, UTF-32, etc, then the constructor should be:</p>
     <pre><code>new BOMInputStream(is, ByteOrderMark.UTF_8, ByteOrderMark.UTF_16BE,
        ByteOrderMark.UTF_16LE, ByteOrderMark.UTF_32BE, ByteOrderMark.UTF_32LE)
</code></pre>
     <p>Upvote @martin-charlesworth's comment :)</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Just skips the BOM. Should be the perfect solution for 99% of the use cases.</span> <span> - </span> <span class="display-name">atamanroman</span> <span> </span> <span class="date">7 May 2012 at 07:39</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span>I used this answer successfully. However, I would respectfully add the <code>boolean</code> arg for specifying whether to include or exclude the BOM. Example: <code>BOMInputStream bomIn = new BOMInputStream(in, false); // don't include the BOM</code></span> <span> - </span> <span class="display-name">Kevin Meredith</span> <span> </span> <span class="date">7 Oct 2013 at 17:12</span></td>
       </tr>
       <tr>
        <td>21</td>
        <td><span>I would also add that this only detects UTF-8 BOM. If you want to detect all the utf-X BOMs then you need to pass them in to the BOMInputStream constructor. <code>BOMInputStream bomIn = new BOMInputStream(is, ByteOrderMark.UTF_8, ByteOrderMark.UTF_16BE, ByteOrderMark.UTF_16LE, ByteOrderMark.UTF_32BE, ByteOrderMark.UTF_32LE);</code></span> <span> - </span> <span class="display-name">Martin Charlesworth</span> <span> </span> <span class="date">26 Jun 2014 at 16:29</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>As for the comment of @KevinMeredith, I want to stress that the constructor with boolean is clearer, but the default constructor has already got rid of UTF-8 BOM, as the JavaDoc suggests: <code>BOMInputStream(InputStream delegate) Constructs a new BOM InputStream that excludes a ByteOrderMark.UTF_8 BOM.</code></span> <span> - </span> <span class="display-name">WesternGun</span> <span> </span> <span class="date">15 Sep 2017 at 12:18</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Skipping solves most of my problems. If my file starts with a BOM UTF_16BE, can I create an InputReader by skipping the BOM and reading the file as UTF_8? So far it works, I want to understand if there is any edge case? Thanks in advance.</span> <span> - </span> <span class="display-name">Bhaskar</span> <span> </span> <span class="date">26 May 2020 at 21:22</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>39</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user1092126</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Aug 2013 at 13:57</span>
     </div>
    </div>
    <div>
     <p>More simple solution:</p>
     <pre><code>public class BOMSkipper
{
    public static void skip(Reader reader) throws IOException
    {
        reader.mark(1);
        char[] possibleBOM = new char[1];
        reader.read(possibleBOM);

        if (possibleBOM[0] != '\ufeff')
        {
            reader.reset();
        }
    }
}
</code></pre>
     <p>Usage sample:</p>
     <pre><code>BufferedReader input = new BufferedReader(new InputStreamReader(new FileInputStream(file), fileExpectedCharset));
BOMSkipper.skip(input);
//Now UTF prefix not present:
input.readLine();
...
</code></pre>
     <p>It works with all 5 UTF encodings!</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>Very nice Andrei. But could you explain why it works? How does the pattern 0xFEFF successfully match UTF-8 files which seem to have a different pattern and 3 bytes instead of 2? And how can that pattern match both endians of UTF16 and UTF32?</span> <span> - </span> <span class="display-name">Vahid Pazirandeh</span> <span> </span> <span class="date">27 May 2014 at 19:08</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>As you can see - I don't use byte stream but character stream opened with expected charset. So if the first character from this stream is BOM - I skip it. BOM can have different byte representation for each encoding, but this is one character. Please read this article, it helps me: <a href="http://www.joelonsoftware.com/articles/Unicode.html" rel="nofollow noreferrer">joelonsoftware.com/articles/Unicode.html</a></span> <span> - </span> <span class="display-name">user1092126</span> <span> </span> <span class="date">28 May 2014 at 22:21</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Nice solution, just make sure to check if file is not empty to avoid IOException in skip method before reading. You may do that by calling if (reader.ready()){ reader.read(possibleBOM) ... }</span> <span> - </span> <span class="display-name">Snow</span> <span> </span> <span class="date">17 Jun 2014 at 13:49</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I see you have covered 0xFE 0xFF, which is the Byte order Mark for UTF-16BE. But, what if the first 3 bytes are 0xEF 0xBB 0xEF ? (the byte order mark for UTF-8). You claim that this works for all UTF-8 formats. Which could be true (I haven't tested your code), but then how does it work ?</span> <span> - </span> <span class="display-name">bvdb</span> <span> </span> <span class="date">7 Jul 2016 at 08:40</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>See my answer to Vahid: I open not the byte stream but character stream and read one character from it. Never mind what utf encoding used for file - bom prefix can represented by different count of bytes, but in terms of characters it's just one character</span> <span> - </span> <span class="display-name">user1092126</span> <span> </span> <span class="date">19 Jul 2016 at 22:58</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Great solution, Andrei! Thank you very much!</span> <span> - </span> <span class="display-name">Software Craftsman</span> <span> </span> <span class="date">30 Apr 2018 at 09:31</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The mark() method mark a position in the input to which the stream can be "reset" by calling the reset() method. It needed for future reads, after BOM skipping</span> <span> - </span> <span class="display-name">user1092126</span> <span> </span> <span class="date">7 Aug 2018 at 06:35</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>If you're trying to mark the second index, you should call it after reading.</span> <span> - </span> <span class="display-name">shmosel</span> <span> </span> <span class="date">7 Aug 2018 at 18:26</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>25</span>
     </div>
     <div>
      <span>Answerer: </span> <span>BalusC</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Dec 2009 at 20:29</span>
     </div>
    </div>
    <div>
     <p><a href="http://code.google.com/apis/gdata/" rel="noreferrer">Google Data API</a> has an <a href="http://code.google.com/apis/gdata/javadoc/com/google/gdata/util/io/base/UnicodeReader.html" rel="noreferrer"><code>UnicodeReader</code></a> which automagically detects the encoding.</p>
     <p>You can use it instead of <code>InputStreamReader</code>. Here's an -slightly compactized- extract of its source which is pretty straightforward:</p>
     <pre><code>public class UnicodeReader extends Reader {
    private static final int BOM_SIZE = 4;
    private final InputStreamReader reader;

    /**
     * Construct UnicodeReader
     * @param in Input stream.
     * @param defaultEncoding Default encoding to be used if BOM is not found,
     * or &lt;code&gt;null&lt;/code&gt; to use system default encoding.
     * @throws IOException If an I/O error occurs.
     */
    public UnicodeReader(InputStream in, String defaultEncoding) throws IOException {
        byte bom[] = new byte[BOM_SIZE];
        String encoding;
        int unread;
        PushbackInputStream pushbackStream = new PushbackInputStream(in, BOM_SIZE);
        int n = pushbackStream.read(bom, 0, bom.length);

        // Read ahead four bytes and check for BOM marks.
        if ((bom[0] == (byte) 0xEF) &amp;&amp; (bom[1] == (byte) 0xBB) &amp;&amp; (bom[2] == (byte) 0xBF)) {
            encoding = "UTF-8";
            unread = n - 3;
        } else if ((bom[0] == (byte) 0xFE) &amp;&amp; (bom[1] == (byte) 0xFF)) {
            encoding = "UTF-16BE";
            unread = n - 2;
        } else if ((bom[0] == (byte) 0xFF) &amp;&amp; (bom[1] == (byte) 0xFE)) {
            encoding = "UTF-16LE";
            unread = n - 2;
        } else if ((bom[0] == (byte) 0x00) &amp;&amp; (bom[1] == (byte) 0x00) &amp;&amp; (bom[2] == (byte) 0xFE) &amp;&amp; (bom[3] == (byte) 0xFF)) {
            encoding = "UTF-32BE";
            unread = n - 4;
        } else if ((bom[0] == (byte) 0xFF) &amp;&amp; (bom[1] == (byte) 0xFE) &amp;&amp; (bom[2] == (byte) 0x00) &amp;&amp; (bom[3] == (byte) 0x00)) {
            encoding = "UTF-32LE";
            unread = n - 4;
        } else {
            encoding = defaultEncoding;
            unread = n;
        }

        // Unread bytes if necessary and skip BOM marks.
        if (unread &gt; 0) {
            pushbackStream.unread(bom, (n - unread), unread);
        } else if (unread &lt; -1) {
            pushbackStream.unread(bom, 0, 0);
        }

        // Use given encoding.
        if (encoding == null) {
            reader = new InputStreamReader(pushbackStream);
        } else {
            reader = new InputStreamReader(pushbackStream, encoding);
        }
    }

    public String getEncoding() {
        return reader.getEncoding();
    }

    public int read(char[] cbuf, int off, int len) throws IOException {
        return reader.read(cbuf, off, len);
    }

    public void close() throws IOException {
        reader.close();
    }
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>It seems that the link says Google Data API is deprecated ? Where should one look for the Google Data API now ?</span> <span> - </span> <span class="display-name">SOUser</span> <span> </span> <span class="date">7 Jul 2016 at 02:17</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@XichenLi: GData API is been deprecated for its intented purpose. I didn't intend to suggest to use GData API directly (OP isn't using any GData service), but I intend to take over the source code as example for your own implementation. That's also why I included it in my answer, ready for copypaste.</span> <span> - </span> <span class="display-name">BalusC</span> <span> </span> <span class="date">7 Jul 2016 at 11:02</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>There's a bug in this. The UTF-32LE case is unreachable. In order for <code>(bom[0] == (byte) 0xFF) &amp;&amp; (bom[1] == (byte) 0xFE) &amp;&amp; (bom[2] == (byte) 0x00) &amp;&amp; (bom[3] == (byte) 0x00)</code> to be true, then the UTF-16LE case (<code>(bom[0] == (byte) 0xFF) &amp;&amp; (bom[1] == (byte) 0xFE)</code>) would have already matched.</span> <span> - </span> <span class="display-name">Joshua Taylor</span> <span> </span> <span class="date">19 Jul 2017 at 14:05</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Since this code is from the Google Data API, I posted <a href="https://github.com/google/gdata-java-client/issues/471" rel="nofollow noreferrer">issue 471</a> about it.</span> <span> - </span> <span class="display-name">Joshua Taylor</span> <span> </span> <span class="date">19 Jul 2017 at 14:32</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>16</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Kevin Meredith</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Sep 2013 at 15:58</span>
     </div>
    </div>
    <div>
     <p>The <code>Apache Commons IO</code> Library's <a href="https://commons.apache.org/proper/commons-io/javadocs/api-2.2/org/apache/commons/io/input/BOMInputStream.html" rel="noreferrer">BOMInputStream</a> has already been mentioned by @rescdsk, but I did not see it mention how to get an <code>InputStream</code> <strong>without</strong> the BOM.</p>
     <p>Here's how I did it in Scala.</p>
     <pre><code> import java.io._
 val file = new File(path_to_xml_file_with_BOM)
 val fileInpStream = new FileInputStream(file)   
 val bomIn = new BOMInputStream(fileInpStream, 
         false); // false means don't include BOM
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Single arg constructor does it: <code>public BOMInputStream(InputStream delegate) { this(delegate, false, ByteOrderMark.UTF_8); }</code>. It excludes <code>UTF-8 BOM</code> by default.</span> <span> - </span> <span class="display-name">Vladimir Vagaytsev</span> <span> </span> <span class="date">15 Jul 2016 at 17:05</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Good point, Vladimir. I see that in its docs - <a href="https://commons.apache.org/proper/commons-io/javadocs/api-2.2/org/apache/commons/io/input/BOMInputStream.html#BOMInputStream(java.io.InputStream)" rel="nofollow noreferrer">commons.apache.org/proper/commons-io/javadocs/api-2.2/org/…</a>: <code>Constructs a new BOM InputStream that excludes a ByteOrderMark.UTF_8 BOM.</code></span> <span> - </span> <span class="display-name">Kevin Meredith</span> <span> </span> <span class="date">15 Jul 2016 at 17:10</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Andreas Baaserud</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Nov 2015 at 19:31</span>
     </div>
    </div>
    <div>
     <p>To simply remove the BOM characters from your file, I recomend using <a href="https://commons.apache.org/proper/commons-io/apidocs/org/apache/commons/io/input/BOMInputStream.html#BOMInputStream(java.io.InputStream,%20boolean)" rel="noreferrer">Apache Common IO</a></p>
     <pre><code>public BOMInputStream(InputStream delegate,
              boolean include)
Constructs a new BOM InputStream that detects a a ByteOrderMark.UTF_8 and optionally includes it.
Parameters:
delegate - the InputStream to delegate to
include - true to include the UTF-8 BOM or false to exclude it
</code></pre>
     <p>Set include to false and your BOM characters will be excluded.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Brian Agnew</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Dec 2009 at 20:09</span>
     </div>
    </div>
    <div>
     <p>Regrettably not. You'll have to identify and skip yourself. <a href="http://mindprod.com/jgloss/bom.html" rel="nofollow noreferrer">This page</a> details what you have to watch for. Also see <a href="https://stackoverflow.com/questions/712004/does-java-have-methods-to-get-the-various-byte-order-marks">this SO question</a> for more details.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Lee</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Feb 2021 at 02:35</span>
     </div>
    </div>
    <div>
     <p>Here is my code to read csv files in most char sets. It should cover 99% situations.</p>
     <pre class="lang-java prettyprint-override"><code>        try(InputStream inputStream = new FileInputStream(csvFile);){
            BOMInputStream bomInputStream = new BOMInputStream(inputStream ,ByteOrderMark.UTF_8, ByteOrderMark.UTF_16LE, ByteOrderMark.UTF_16BE, ByteOrderMark.UTF_32LE, ByteOrderMark.UTF_32BE);
            Charset charset;
            if(!bomInputStream.hasBOM()) charset = StandardCharsets.UTF_8;
            else if(bomInputStream.hasBOM(ByteOrderMark.UTF_8)) charset = StandardCharsets.UTF_8;
            else if(bomInputStream.hasBOM(ByteOrderMark.UTF_16LE)) charset = StandardCharsets.UTF_16LE;
            else if(bomInputStream.hasBOM(ByteOrderMark.UTF_16BE)) charset = StandardCharsets.UTF_16BE;
            else { throw new Exception("The charset of the file " + csvFile + " is not supported.");}
            
            try(Reader streamReader = new InputStreamReader(bomInputStream, charset);
                BufferedReader bufferedReader = new BufferedReader(streamReader);) {
                for(String line; (line = bufferedReader.readLine()) != null; ) {
                    String[] columns = line.split(",");
             //read csv columns
            }
        }
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>IMO the best answer (and coding example), except that it falls back to UTF-8 if there is no BOM. See also my general answer below.</span> <span> - </span> <span class="display-name">Heri</span> <span> </span> <span class="date">4 Dec 2021 at 12:55</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Heri</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Dec 2021 at 12:54</span>
     </div>
    </div>
    <div>
     <p>IMO none of the given answers is really satisfying. Just skipping the BOM and then read the rest of the stream in the current platform's default encoding is definitively wrong. Remember: The platform default on Unix/Linux and windows differ: former is UTF-8, later is ANSI. Such a solution only works if the rest of the stream (after the BOM) only contains 7-bit ASCII characters (which, I admit, in most programmer near files like configurations is true). But as soon there are non ASCII characters, you will fail with this approach.</p>
     <p>That's why all java classes/methods, which can convert byte arrays/streams to string (and vice versa) have a second parameter indicating the encoding to be used (Reader, Writer, Scanner, String.getBytes(), etc.).</p>
     <p>There are so much character encodings out in the world, not only UTF-xx. And still - in the current year 2021 - there are so much encoding problems between end user applications, especially if they run on different platforms (iOS, windows, unix). All these problems only exist because the programmer was too lazy to learn how character encoding works.</p>
     <p>Thus, it's an absolute MUST to evaluate first the encoding to be used, and then performing the string/stream conversion using the found encoding. Consulting the respective specification(s) is the first step. And only if you cannot be sure which encoding you encounter while reading a stream you have to evaluate it by yourself. But caution: such an evaluation always will only be a 'best guess', there is no algorithm which can cover all possibilities.</p>
     <p>In this sense, Lee's answer (and coding example) from Feb 6,2021 is IMO the best one, except that he falls back to UTF-8 if there is no BOM.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Amy B Higgins</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Jan 2018 at 19:23</span>
     </div>
    </div>
    <div>
     <p>I had the same problem, and because I wasn't reading in a bunch of files I did a simpler solution. I think my encoding was UTF-8 because when I printed out the offending character with the help of this page: <a href="https://stackoverflow.com/questions/2220366/get-unicode-value-of-a-character">Get unicode value of a character</a> I found that it was <code>\ufeff</code>. I used the code <code>System.out.println( "\\u" + Integer.toHexString(str.charAt(0) | 0x10000).substring(1) );</code> to print out the offending unicode value.</p>
     <p>Once I had the offending unicode value, I replaced it in the first line of my file before I went on reading. The business logic of that section:</p>
     <pre><code>String str = reader.readLine().trim();
str = str.replace("\ufeff", "");
</code></pre>
     <p>This fixed my problem. Then I was able to go on processing the file with no issue. I added on <code>trim()</code> just in case of leading or trailing whitespace, you can do that or not, based on what your specific needs are.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>That did not work for me, but I used .replaceFirst("\u00EF\u00BB\u00BF", "") which did.</span> <span> - </span> <span class="display-name">StackUMan</span> <span> </span> <span class="date">19 Feb 2018 at 13:24</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user8514159</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Sep 2020 at 12:00</span>
     </div>
    </div>
    <div>
     <p>NotePad++ is a good tool to convert UTF-8 encoding to UTF-8(BOM) encoding.</p>
     <p><a href="https://notepad-plus-plus.org/downloads/" rel="nofollow noreferrer">https://notepad-plus-plus.org/downloads/</a></p>
     <p><strong>UTF8BOMTester.java</strong></p>
     <pre><code>public class UTF8BOMTester {

public static void main(String[] args) throws FileNotFoundException, IOException {
    // TODO Auto-generated method stub
    File file = new File("test.txt");
    boolean same = UTF8BOMInputStream.isSameEncodingType(file);
    System.out.println(same);
    if (same) {
        UTF8BOMInputStream is = new UTF8BOMInputStream(file);
        BufferedReader br = new BufferedReader(new InputStreamReader(is, "UTF-8"));
        System.out.println(br.readLine());
    }

}

static void bytesPrint(byte[] b) {
    for (byte a : b)
        System.out.printf("%x ", a);
}}
</code></pre>
     <p><strong>UTF8BOMInputStream.java</strong></p>
     <pre><code>public class UTF8BOMInputStream extends InputStream {

byte[] SYMBLE_BOM = { (byte) 0xEF, (byte) 0xBB, (byte) 0xBF };
FileInputStream fis;
final boolean isSameEncodingType;
public UTF8BOMInputStream(File file) throws IOException {
    FileInputStream fis=new FileInputStream(file);
    byte[] symble=new byte[3];
    fis.read(symble);
    bytesPrint(symble);
    isSameEncodingType=isSameEncodingType(symble);
    if(isSameEncodingType)
        this.fis=fis;
    else
        this.fis=null;
    
}

@Override
public int read() throws IOException {
    return fis.read();
}

void bytesPrint(byte[] b) {
    for (byte a : b)
        System.out.printf("%x ", a);
}

boolean bytesCompare(byte[] a, byte[] b) {
    if (a.length != b.length)
        return false;

    for (int i = 0; i &lt; a.length; i++) {
        if (a[i] != b[i])
            return false;
    }
    return true;
}
boolean isSameEncodingType(byte[] symble) {
    return bytesCompare(symble,SYMBLE_BOM);
}
public static boolean isSameEncodingType(File file) throws IOException {
    return (new UTF8BOMInputStream(file)).isSameEncodingType;
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>