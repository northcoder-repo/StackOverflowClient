<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>What's the difference between passing by reference vs. passing by value?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>What's the difference between passing by reference vs. passing by value?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>697</span>
    </div>
    <div>
     <span>Asker: </span> <span>ritu</span>
    </div>
    <div>
     <span>Asked: </span> <span>17 Dec 2008 at 01:49</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/373419/whats-the-difference-between-passing-by-reference-vs-passing-by-value">source</a>
    </div>
   </div>
   <div>
    <p>What is the difference between</p>
    <ol>
     <li>a parameter passed by reference</li>
     <li>a parameter passed by value?</li>
    </ol>
    <p>Could you give me some examples, please?</p>
   </div>
   <div class="tags">
    <span class="tag">language-agnostic</span><span class="tag">pass-by-reference</span><span class="tag">pass-by-value</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td></td>
       <td><span><i>Related:</i> <a href="http://stackoverflow.com/q/2139224">How to pass objects to functions in C++?</a></span> <span> - </span> <span class="display-name">Roger Pate</span> <span> </span> <span class="date">11 Nov 2010 at 01:48</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>If you don't know what an <i>address</i> or <i>value</i> is then see <a href="http://stackoverflow.com/a/36208432/5175709">here</a></span> <span> - </span> <span class="display-name">mfaani</span> <span> </span> <span class="date">3 Mar 2017 at 16:05</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1241</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Dylan Beattie</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Jan 2009 at 13:28</span>
     </div>
    </div>
    <div>
     <p>First and foremost, <strong>the "pass by value vs. pass by reference" distinction as defined in the CS theory is now obsolete</strong> because <strong>the technique originally defined as "pass by reference" has since fallen out of favor</strong> and is seldom used now.<sup>1</sup></p>
     <p><strong>Newer languages<sup>2</sup> tend to use a different (but similar) pair of techniques to achieve the same effects</strong> (see below) which is the primary source of confusion.</p>
     <p>A secondary source of confusion is the fact that <strong>in "pass by reference", "reference" has a narrower meaning than the general term "reference"</strong> (because the phrase predates it).</p>
     <hr>
     <p>Now, the authentic definition is:</p>
     <ul>
      <li>
       <p>When a parameter is <strong>passed by reference</strong>, the caller and the callee <strong>use the same variable</strong> for the parameter. If the callee modifies the parameter variable, the effect is visible to the caller's variable.</p></li>
      <li>
       <p>When a parameter is <strong>passed by value</strong>, the caller and callee have <strong>two independent variables</strong> with the same value. If the callee modifies the parameter variable, the effect is not visible to the caller.</p></li>
     </ul>
     <p>Things to note in this definition are:</p>
     <ul>
      <li>
       <p><strong>"Variable" here means the caller's (local or global) variable itself</strong> -- i.e. if I pass a local variable by reference and assign to it, I'll change the caller's variable itself, not e.g. whatever it is pointing to if it's a pointer.</p>
       <ul>
        <li>This is now considered bad practice (as an implicit dependency). As such, <strong>virtually all newer languages are exclusively, or almost exclusively pass-by-value.</strong> Pass-by-reference is now chiefly used in the form of "output/inout arguments" in languages where a function cannot return more than one value.</li>
       </ul></li>
      <li>
       <p><strong>The meaning of "reference" in "pass by reference"</strong>. The difference with the general "reference" term is that <strong>this "reference" is temporary and implicit.</strong> What the callee gets is <strong>a "variable" that is somehow "the same" as the original one.</strong> How specifically this effect is achieved is irrelevant (e.g. the language may also expose some implementation details -- addresses, pointers, dereferencing -- this is all irrelevant; if the net effect is this, it's pass-by-reference).</p></li>
     </ul>
     <hr>
     <p><strong>Now, in modern languages, variables tend to be of "reference types"</strong> (another concept invented later than "pass by reference" and inspired by it), i.e. the actual object data is stored separately somewhere (usually, on the heap), and only "references" to it are ever held in variables and passed as parameters.<sup>3</sup></p>
     <p><strong>Passing such a reference falls under pass-by-value</strong> because a variable's value is technically the reference itself, not the referred object. However, <strong>the net effect on the program can be the same as either pass-by-value or pass-by-reference:</strong></p>
     <ul>
      <li>If a reference is just taken from a caller's variable and passed as an argument, this has the same effect as pass-by-reference: if the referred object is <em>mutated</em> in the callee, the caller will see the change. 
       <ul>
        <li>However, if a variable holding this reference is <em>reassigned,</em> it will stop pointing to that object, so any further operations on this variable will instead affect whatever it is pointing to now.</li>
       </ul></li>
      <li>To have the same effect as pass-by-value, a copy of the object is made at some point. Options include: 
       <ul>
        <li>The caller can just make a private copy before the call and give the callee a reference to that instead.</li>
        <li>In some languages, some object types are "immutable": any operation on them that seems to alter the value creates a completely new object without affecting the original one. So, passing an object of such a type as an argument always has the effect of pass-by-value: a copy for the callee will be made automatically if and when it needs a change, and the caller's object will never be affected. 
         <ul>
          <li>In functional languages, <em>all</em> objects are immutable.</li>
         </ul></li>
       </ul></li>
     </ul>
     <p>As you may see, <strong>this pair of techniques is almost the same as those in the definition, only with a level of indirection: just replace "variable" with "referenced object".</strong></p>
     <p>There's no agreed-upon name for them, which leads to contorted explanations like "call by value where the value is a reference". In 1975, Barbara Liskov suggested the term "<a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing" rel="nofollow noreferrer">call-by-object-sharing</a>" (or sometimes just "call-by-sharing") though it never quite caught on. Moreover, neither of these phrases draws a parallel with the original pair. No wonder the old terms ended up being reused in the absence of anything better, leading to confusion.<sup>4</sup></p>
     <p>(I would use the terms <em>"new"</em> or <em>"indirect" pass-by-value/pass-by-reference</em> for the new techniques.)</p>
     <hr>
     <p><strong>NOTE</strong>: For a long time, this answer used to say:</p>
     <blockquote>
      <p>Say I want to share a web page with you. If I tell you the URL, I'm passing by reference. You can use that URL to see the same web page I can see. If that page is changed, we both see the changes. If you delete the URL, all you're doing is destroying your reference to that page - you're not deleting the actual page itself.</p>
      <p>If I print out the page and give you the printout, I'm passing by value. Your page is a disconnected copy of the original. You won't see any subsequent changes, and any changes that you make (e.g. scribbling on your printout) will not show up on the original page. If you destroy the printout, you have destroyed your copy of the object - but the original web page remains intact.</p>
     </blockquote>
     <p>This is <em>mostly</em> correct <em>except</em> the narrower meaning of "reference" -- it being both temporary and implicit (it doesn't have to, but being explicit and/or persistent are additional features, not a part of the pass-by-reference semantic, as explained above). A closer analogy would be giving you a copy of a document vs inviting you to work on the original.</p>
     <hr>
     <p><sup>1</sup><sub>Unless you are programming in Fortran or Visual Basic, it's not the default behavior, and in most languages in modern use, true call-by-reference is not even possible.</sub></p>
     <p><sup>2</sup><sub>A fair amount of older ones support it, too</sub></p>
     <p><sup>3</sup><sub>In several modern languages, all types are reference types. This approach was pioneered by the language CLU in 1975 and has since been adopted by many other languages, including Python and Ruby. And many more languages use a hybrid approach, where some types are "value types" and others are "reference types" -- among them are C#, Java, and JavaScript.</sub></p>
     <p><sup>4</sup><sub>There's nothing bad with recycling a fitting old term <em>per se,</em> but one has to somehow make it clear which meaning is used each time. Not doing that is exactly what keeps confusing.</sub></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>I personally would use the terms <b>"new"</b> or <b>"indirect" pass-by-value/pass-by-reference</b> for the new techniques.</span> <span> - </span> <span class="display-name">ivan_pozdeev</span> <span> </span> <span class="date">6 Mar 2019 at 09:22</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>The “authentic” definition you provide is not the definition given in almost every introductory programming course. Google what is pass by reference and you will not get that answer. The authentic definition you provide is misuse of the word reference, as when you follow that definition you’re using an <i>alias</i> not a reference: you have two variables that are actually the same variable, that is an alias and not a reference. Your authentic definition causes for mass confusion for no reason. Just say pass by reference means passing address. It makes sense and would avoid this pointless confusion.</span> <span> - </span> <span class="display-name">ICW</span> <span> </span> <span class="date">12 Sep 2019 at 19:01</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@YungGun 1)Please provide a link to a "definition given in almost every introductory programming course". Also note that this aims to be clear in today's realities, not in realities of a decade or three ago when some CS course was written. 2)"Address" cannot be used in definition because it deliberately abstracts from possible implementations. E.g. some languages (Fortran) don't have pointers; they also differ in whether they expose the raw address to the user (VB doesn't); it also doesn't have to be a raw memory address, anything that would allow to link to the variable would do.</span> <span> - </span> <span class="display-name">ivan_pozdeev</span> <span> </span> <span class="date">17 Sep 2019 at 17:37</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@ivan_podeev no link sorry. I say "almost every introductory course" because personally, I went to college and took programming bootcamps too that taught me that. These courses were modern (less than 5 years ago). A "raw address" is a synonym for a "pointer"... You may be technically correct (according to some cherry picked link) but the language you're using is impractical and confusing for most programmers. If you want my full thoughts on it I've written a 3500 word blog post: <a href="https://medium.com/@isaaccway228/the-technically-correct-definition-of-pass-by-reference-is-nonsense-d89ca22180a5" rel="nofollow noreferrer">medium.com/@isaaccway228/…</a></span> <span> - </span> <span class="display-name">ICW</span> <span> </span> <span class="date">27 Sep 2019 at 23:39</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@YungGun "too long, didn't read". A glance shows exactly the confusions outlined in the answer. Pass by reference is an abstract technique agnostic to implementation. It doesn't matter what exactly is passed under the hood, it matters what the effect on the program is.</span> <span> - </span> <span class="display-name">ivan_pozdeev</span> <span> </span> <span class="date">1 Oct 2019 at 05:13</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>"effect on the program can be the same as either pass-by-value or pass-by-reference": I don't agree that the effect is the same as the old "pass-by-reference", since the caller variable cannot be reassigned from inside the callee</span> <span> - </span> <span class="display-name">Rafael Eyng</span> <span> </span> <span class="date">19 Jan 2020 at 15:50</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>'Barbara Liskov suggested the term "call-by-object-sharing"' - would be nice a clarification if this name refers to the first or to the second technique. The current text doesn't make that clear</span> <span> - </span> <span class="display-name">Rafael Eyng</span> <span> </span> <span class="date">19 Jan 2020 at 15:55</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@RafaelEyng 2) "call-by-object-sharing"' descibes both new techniques. As such, it's useless to draw a distinction, so I didn't see the need to elaborate more. If you can think of a wording to mention that that wouldn't make the text less clear and focused, be my guest. 1) earlier than that, I explicitly write that reassigning caller's variables is now seen as bad practice; this should make it clear that "the same effect" as it's needed now does not need to include that part -- moreover, deliberately omits it.</span> <span> - </span> <span class="display-name">ivan_pozdeev</span> <span> </span> <span class="date">24 Jun 2020 at 11:49</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@IsaacCWay no, that is the definition it has always had. If people think passing addresses is equivalent to call by reference they are simply mistaken. The classic examples here are C, which is <i>always call by value</i>, and Fortran, which used to be <i>only</i> call by reference, although modern versions of Fortran can use either evaluation strategy.</span> <span> - </span> <span class="display-name">juanpa.arrivillaga</span> <span> </span> <span class="date">16 Mar 2021 at 18:30</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@juanpa.arrivillaga For practical purposes the definition you're saying is correct is simply not useful to most people and is actually quite confusing. Anyone can look at the words "call by reference" and "call by value" an interpret them however they want to, what I'm suggesting is that it makes very little sense to interpret them in the way you're interpreting them. It is extremely common to refer to variables whos type is designated to store memory addresses of variables as "references". In C, you may pass these memory addresses to functions as parameters.</span> <span> - </span> <span class="display-name">ICW</span> <span> </span> <span class="date">23 Mar 2021 at 01:41</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@juanpa.arrivillaga So, here we're passing a variable that stores a memory address, which is commonly referred to as a reference, to a function, yet you are trying I'm not passing by reference, even though I am inarguably, literally, passing a reference to a variable as a function parameter? I'm sorry, that makes no sense whatsoever. Furthermore, you offer no sources at all. C function calls by reference: <a href="https://www.tutorialspoint.com/cprogramming/c_function_call_by_reference.htm" rel="nofollow noreferrer">tutorialspoint.com/cprogramming/…</a> , c++ references: <a href="https://www.tutorialspoint.com/cplusplus/cpp_references.htm" rel="nofollow noreferrer">tutorialspoint.com/cplusplus/cpp_references.htm</a></span> <span> - </span> <span class="display-name">ICW</span> <span> </span> <span class="date">23 Mar 2021 at 01:45</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@juanpa.arrivillaga if a reference type exists within a programming language, and you may pass that reference instead of the value of a variable of a function parameter, the language has pass by reference literally and indisputably. I'm not arguing that the definition you're arguing for was never the official definition. What I am saying is that your definition doesn't make sense, and you have provided no argument whatsoever as to why your definition makes any sense other than "That's the way it's always been". That is not a real argument. If that is your reasoning you don't think for yourself</span> <span> - </span> <span class="display-name">ICW</span> <span> </span> <span class="date">23 Mar 2021 at 01:49</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@ICW The confusion of values and pointers was historically introduced by Kernighan &amp; Ritchie themselves, inside a narrow <i>world of pointers</i>, which then sadly was ported to object orientation. Before them, a ´by reference´ was equivalent to ´sharing an instance´, as hinted by ivan pozdeev. Think, the answer above is unique in documenting, that terms were used with different semantics over the time, and I think every honest discussion will accept this as fact.</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">28 Apr 2022 at 13:09</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@ICW .... that <a href="https://www.tutorialspoint.com/cplusplus/cpp_references.htm" rel="nofollow noreferrer">tutorialspoint.com/cplusplus/cpp_references.htm</a> is not quite correct: You may define a null reference by de-referencing a typed (non-void) null-pointer.</span> <span> - </span> <span class="display-name">Sam Ginrich</span> <span> </span> <span class="date">28 Apr 2022 at 13:18</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>181</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Johannes Schaub - litb</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Dec 2008 at 01:52</span>
     </div>
    </div>
    <div>
     <p>It's a way how to pass arguments to functions. Passing by reference means the called functions' parameter will be the same as the callers' passed argument (not the value, but the identity - the variable itself). Pass by value means the called functions' parameter will be a copy of the callers' passed argument. The value will be the same, but the identity - the variable - is different. Thus changes to a parameter done by the called function in one case changes the argument passed and in the other case just changes the value of the parameter in the called function (which is only a copy). In a quick hurry:</p>
     <ul>
      <li>Java only supports pass by value. Always copies arguments, even though when copying a reference to an object, the parameter in the called function will point to the same object and changes to that object will be see in the caller. Since this can be confusing, <a href="https://jonskeet.uk/java/passing.html" rel="noreferrer">here</a> is what Jon Skeet has to say about this.</li>
      <li>C# supports pass by value and pass by reference (keyword <code>ref</code> used at caller and called function). Jon Skeet also has a nice explanation of this <a href="https://jonskeet.uk/csharp/parameters.html" rel="noreferrer">here</a>.</li>
      <li>C++ supports pass by value and pass by reference (reference parameter type used at called function). You will find an explanation of this below.</li>
     </ul>
     <p>Codes</p>
     <p>Since my language is C++, i will use that here</p>
     <pre class="lang-cpp prettyprint-override"><code>// passes a pointer (called reference in java) to an integer
void call_by_value(int *p) { // :1
    p = NULL;
}

// passes an integer
void call_by_value(int p) { // :2
    p = 42;
}

// passes an integer by reference
void call_by_reference(int &amp; p) { // :3
    p = 42;
}

// this is the java style of passing references. NULL is called "null" there.
void call_by_value_special(int *p) { // :4
    *p = 10; // changes what p points to ("what p references" in java)
    // only changes the value of the parameter, but *not* of 
    // the argument passed by the caller. thus it's pass-by-value:
    p = NULL;
}

int main() {
    int value = 10;
    int * pointer = &amp;value;

    call_by_value(pointer); // :1
    assert(pointer == &amp;value); // pointer was copied

    call_by_value(value); // :2
    assert(value == 10); // value was copied

    call_by_reference(value); // :3
    assert(value == 42); // value was passed by reference

    call_by_value_special(pointer); // :4
    // pointer was copied but what pointer references was changed.
    assert(value == 10 &amp;&amp; pointer == &amp;value);
}
</code></pre>
     <p>And an example in Java won't hurt:</p>
     <pre class="lang-java prettyprint-override"><code>class Example {
    int value = 0;

    // similar to :4 case in the c++ example
    static void accept_reference(Example e) { // :1
        e.value++; // will change the referenced object
        e = null; // will only change the parameter
    }

    // similar to the :2 case in the c++ example
    static void accept_primitive(int v) { // :2
        v++; // will only change the parameter
    }        

    public static void main(String... args) {
        int value = 0;
        Example ref = new Example(); // reference

        // note what we pass is the reference, not the object. we can't 
        // pass objects. The reference is copied (pass-by-value).
        accept_reference(ref); // :1
        assert ref != null &amp;&amp; ref.value == 1;

        // the primitive int variable is copied
        accept_primitive(value); // :2
        assert value == 0;
    }
}
</code></pre>
     <p>Wikipedia</p>
     <p><a href="http://en.wikipedia.org/wiki/Pass_by_reference#Call_by_value" rel="noreferrer"><code>http://en.wikipedia.org/wiki/Pass_by_reference#Call_by_value</code></a></p>
     <p><a href="http://en.wikipedia.org/wiki/Pass_by_reference#Call_by_reference" rel="noreferrer"><code>http://en.wikipedia.org/wiki/Pass_by_reference#Call_by_reference</code></a></p>
     <p>This guy pretty much nails it:</p>
     <p><a href="http://javadude.com/articles/passbyvalue.htm" rel="noreferrer">http://javadude.com/articles/passbyvalue.htm</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>The places where you are passing pointer to your function. Isn't pointer simply allows you to modify the value it is pointed to, and it gets reflected on the value that pointer pointed. The formal parameters if modified using pointer ..should also change the arguments? or am I missing something ? ..should not those be a pass by reference ..then?</span> <span> - </span> <span class="display-name">Avan</span> <span> </span> <span class="date">20 Feb 2022 at 03:18</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>122</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Daniel Pryden</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Jan 2016 at 03:38</span>
     </div>
    </div>
    <div>
     <p>Many answers here (and in particular the most highly upvoted answer) are factually incorrect, since they misunderstand what "call by reference" really means. Here's my attempt to set matters straight.</p>
     <h2>TL;DR</h2>
     <p>In simplest terms:</p>
     <ul>
      <li><em>call by value</em> means that you pass <strong>values</strong> as function arguments</li>
      <li><em>call by reference</em> means that you pass <strong>variables</strong> as function arguments</li>
     </ul>
     <p>In metaphoric terms:</p>
     <ul>
      <li><em><strong>Call by value</strong></em> is where <strong>I write down something on a piece of paper and hand it to you</strong>. Maybe it's a URL, maybe it's a complete copy of War and Peace. No matter what it is, it's on a piece of paper which I've given to you, and so now it is effectively <strong>your piece of paper</strong>. You are now free to scribble on that piece of paper, or use that piece of paper to find something somewhere else and fiddle with it, whatever.</li>
      <li><em><strong>Call by reference</strong></em> is when <strong>I give you my notebook which has something written down in it</strong>. You may scribble in my notebook (maybe I want you to, maybe I don't), and afterwards I keep my notebook, with whatever scribbles you've put there. Also, if what either you or I wrote there is information about how to find something somewhere else, either you or I can go there and fiddle with that information.</li>
     </ul>
     <h2>What "call by value" and "call by reference" <em>don't</em> mean</h2>
     <p>Note that both of these concepts are completely independent and orthogonal from the concept of <em><strong>reference types</strong></em> (which in Java is all types that are subtypes of <code>Object</code>, and in C# all <code>class</code> types), or the concept of <em><strong>pointer types</strong></em> like in C (which are semantically equivalent to Java's "reference types", simply with different syntax).</p>
     <p>The notion of <em>reference type</em> corresponds to a URL: it is both itself a piece of information, and it is a <em>reference</em> (a <em>pointer</em>, if you will) to other information. You can have many copies of a URL in different places, and they don't change what website they all link to; if the website is updated then every URL copy will still lead to the updated information. Conversely, changing the URL in any one place won't affect any other written copy of the URL.</p>
     <p>Note that C++ has a notion of "references" (e.g. <code>int&amp;</code>) that is <strong>not</strong> like Java and C#'s "reference types", but <strong>is</strong> like "call by reference". Java and C#'s "reference types", and <em>all</em> types in Python, are like what C and C++ call "pointer types" (e.g. <code>int*</code>).</p>
     <hr>
     <p>OK, here's the longer and more formal explanation.</p>
     <h2>Terminology</h2>
     <p>To start with, I want to highlight some important bits of terminology, to help clarify my answer and to ensure we're all referring to the same ideas when we are using words. (In practice, I believe the vast majority of confusion about topics such as these stems from using words in ways that to not fully communicate the meaning that was intended.)</p>
     <p>To start, here's an example in some C-like language of a function declaration:</p>
     <pre class="lang-c prettyprint-override"><code>void foo(int param) {  // line 1
    param += 1;
}
</code></pre>
     <p>And here's an example of calling this function:</p>
     <pre class="lang-c prettyprint-override"><code>void bar() {
    int arg = 1;  // line 2
    foo(arg);     // line 3
}
</code></pre>
     <p>Using this example, I want to define some important bits of terminology:</p>
     <ul>
      <li><code>foo</code> is a <em>function</em> declared on line 1 (Java insists on making all functions methods, but the concept is the same without loss of generality; C and C++ make a distinction between declaration and definition which I won't go into here)</li>
      <li><code>param</code> is a <em>formal parameter</em> to <code>foo</code>, also declared on line 1</li>
      <li><code>arg</code> is a <em>variable</em>, specifically a <em>local variable</em> of the function <code>bar</code>, declared and initialized on line 2</li>
      <li><code>arg</code> is also an <em>argument</em> to a specific <em>invocation</em> of <code>foo</code> on line 3</li>
     </ul>
     <p>There are two very important sets of concepts to distinguish here. The first is <em>value</em> versus <em>variable</em>:</p>
     <ul>
      <li>A <em><strong>value</strong></em> is the <strong>result of evaluating an expression</strong> in the language. For example, in the <code>bar</code> function above, after the line <code>int arg = 1;</code>, the expression <code>arg</code> has the <em>value</em> <code>1</code>.</li>
      <li>A <em><strong>variable</strong></em> is a <strong>container for values</strong>. A variable can be mutable (this is the default in most C-like languages), read-only (e.g. declared using Java's <code>final</code> or C#'s <code>readonly</code>) or deeply immutable (e.g. using C++'s <code>const</code>).</li>
     </ul>
     <p>The other important pair of concepts to distinguish is <em>parameter</em> versus <em>argument</em>:</p>
     <ul>
      <li>A <em><strong>parameter</strong></em> (also called a <em>formal parameter</em>) is a <em>variable</em> which must be supplied by the caller when calling a function.</li>
      <li>An <em><strong>argument</strong></em> is a <em>value</em> that is supplied by the caller of a function to satisfy a specific formal parameter of that function</li>
     </ul>
     <h2>Call by value</h2>
     <p>In <em>call by value</em>, the function's formal parameters are variables that are newly created for the function invocation, and which are initialized with the <em>values</em> of their arguments.</p>
     <p>This works exactly the same way that any other kinds of variables are initialized with values. For example:</p>
     <pre class="lang-c prettyprint-override"><code>int arg = 1;
int another_variable = arg;
</code></pre>
     <p>Here <code>arg</code> and <code>another_variable</code> are completely independent variables -- their values can change independently of each other. However, at the point where <code>another_variable</code> is declared, it is initialized to hold the same value that <code>arg</code> holds -- which is <code>1</code>.</p>
     <p>Since they are independent variables, changes to <code>another_variable</code> do not affect <code>arg</code>:</p>
     <pre class="lang-c prettyprint-override"><code>int arg = 1;
int another_variable = arg;
another_variable = 2;

assert arg == 1; // true
assert another_variable == 2; // true
</code></pre>
     <p>This is exactly the same as the relationship between <code>arg</code> and <code>param</code> in our example above, which I'll repeat here for symmetry:</p>
     <pre class="lang-c prettyprint-override"><code>void foo(int param) {
  param += 1;
}

void bar() {
  int arg = 1;
  foo(arg);
}
</code></pre>
     <p>It is exactly as if we had written the code this way:</p>
     <pre class="lang-c prettyprint-override"><code>// entering function "bar" here
int arg = 1;
// entering function "foo" here
int param = arg;
param += 1;
// exiting function "foo" here
// exiting function "bar" here
</code></pre>
     <p>That is, the defining characteristic of what <em>call by value</em> means is that the callee (<code>foo</code> in this case) receives <em>values</em> as arguments, but has its own separate <em>variables</em> for those values from the variables of the caller (<code>bar</code> in this case).</p>
     <p>Going back to my metaphor above, if I'm <code>bar</code> and you're <code>foo</code>, when I call you, I hand you a piece of paper with a <em>value</em> written on it. You call that piece of paper <code>param</code>. That value is a <strong>copy</strong> of the value I have written in my notebook (my local variables), in a variable I call <code>arg</code>.</p>
     <p>(As an aside: depending on hardware and operating system, there are various <em>calling conventions</em> about how you call one function from another. The calling convention is like us deciding whether I write the value on a piece of my paper and then hand it to you, or if you have a piece of paper that I write it on, or if I write it on the wall in front of both of us. This is an interesting subject as well, but far beyond the scope of this already long answer.)</p>
     <h2>Call by reference</h2>
     <p>In <em>call by reference</em>, the function's formal parameters are simply <em>new names</em> for the same variables that the caller supplies as arguments.</p>
     <p>Going back to our example above, it's equivalent to:</p>
     <pre class="lang-c prettyprint-override"><code>// entering function "bar" here
int arg = 1;
// entering function "foo" here
// aha! I note that "param" is just another name for "arg"
arg /* param */ += 1;
// exiting function "foo" here
// exiting function "bar" here
</code></pre>
     <p>Since <code>param</code> is just another name for <code>arg</code> -- that is, they are <strong>the same variable</strong>, changes to <code>param</code> are reflected in <code>arg</code>. This is the fundamental way in which call by reference differs from call by value.</p>
     <p>Very few languages support call by reference, but C++ can do it like this:</p>
     <pre class="lang-c prettyprint-override"><code>void foo(int&amp; param) {
  param += 1;
}

void bar() {
  int arg = 1;
  foo(arg);
}
</code></pre>
     <p>In this case, <code>param</code> doesn't just have the same <em>value</em> as <code>arg</code>, it actually <strong>is</strong> <code>arg</code> (just by a different name) and so <code>bar</code> can observe that <code>arg</code> has been incremented.</p>
     <p>Note that this is <strong>not</strong> how any of Java, JavaScript, C, Objective-C, Python, or nearly any other popular language today works. This means that those languages are <strong>not</strong> call by reference, they are call by value.</p>
     <h2>Addendum: call by object sharing</h2>
     <p>If what you have is <em>call by value</em>, but the actual value is a <em>reference type</em> or <em>pointer type</em>, then the "value" itself isn't very interesting (e.g. in C it's just an integer of a platform-specific size) -- what's interesting is what that value <strong>points to</strong>.</p>
     <p>If what that reference type (that is, pointer) points to is <strong>mutable</strong> then an interesting effect is possible: you can modify the pointed-to value, and the caller can observe changes to the pointed-to value, even though the caller cannot observe changes to the pointer itself.</p>
     <p>To borrow the analogy of the URL again, the fact that I gave you a <strong>copy</strong> of the URL to a website is not particularly interesting if the thing we both care about is the website, not the URL. The fact that you scribbling over your copy of the URL doesn't affect my copy of the URL isn't a thing we care about (and in fact, in languages like Java and Python the "URL", or reference type value, can't be modified at all, only the thing pointed to by it can).</p>
     <p>Barbara Liskov, when she invented the CLU programming language (which had these semantics), realized that the existing terms "call by value" and "call by reference" weren't particularly useful for describing the semantics of this new language. So she invented a new term: <a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing" rel="noreferrer"><strong>call by object sharing</strong></a>.</p>
     <p>When discussing languages that are technically call by value, but where common types in use are reference or pointer types (that is: nearly every modern imperative, object-oriented, or multi-paradigm programming language), I find it's a lot less confusing to simply avoid talking about <em>call by value</em> or <em>call by reference</em>. Stick to <strong>call by object sharing</strong> (or simply <strong>call by object</strong>) and nobody will be confused. :-)</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Explained Better : There are two very important sets of concepts to distinguish here. <code>The first is value versus variable.</code> <code>The other important pair of concepts to distinguish is parameter versus argument:</code></span> <span> - </span> <span class="display-name">S.K. Venkat</span> <span> </span> <span class="date">6 Jul 2016 at 10:07</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>Excellent answer. I think that I would add that no new storage needs to be created in pass by reference. The parameter name references the original storage (memory).Thanks</span> <span> - </span> <span class="display-name">drlolly</span> <span> </span> <span class="date">5 May 2017 at 13:32</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>Best answer IMO</span> <span> - </span> <span class="display-name">Rafael Eyng</span> <span> </span> <span class="date">19 Jan 2020 at 17:20</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>77</span>
     </div>
     <div>
      <span>Answerer: </span> <span>mfaani</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Mar 2016 at 19:24</span>
     </div>
    </div>
    <div>
     <p>Before understanding the two terms, you <strong><strong>must</strong></strong> understand the following. Every object has two things that can make it be distinguished.</p>
     <ul>
      <li>Its value.</li>
      <li>Its address.</li>
     </ul>
     <p>So if you say <code>employee.name = "John"</code>, know that there are two things about <code>name</code>. Its value which is <code>"John"</code> and also its location in the memory which is some hexadecimal number maybe like this: <code>0x7fd5d258dd00</code>.</p>
     <p>Depending on the language's architecture or the <em>type</em> (class, struct, etc.) of your object, you would be either transferring <code>"John"</code> or <code>0x7fd5d258dd00</code></p>
     <p>Passing <code>"John"</code> is known as passing by value.</p>
     <p>Passing <code>0x7fd5d258dd00</code> is known as passing by reference. Anyone who is pointing to this memory location will have access to the value of <code>"John"</code>.</p>
     <p>For more on this, I recommend you to read about <a href="https://stackoverflow.com/a/4955259/5175709">dereferencing a pointer</a> and also <a href="https://stackoverflow.com/a/38024319/5175709">why choose struct (value type) over class (reference type)</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>That is i was looking for, actually one should look for the concept not just the explanation, thumbs up bro.</span> <span> - </span> <span class="display-name">Haisum Usman</span> <span> </span> <span class="date">28 Jan 2017 at 15:48</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Java is always pass by value. Passing references to objects in java is considered pass by value. This contradicts your statement "Passing 0x7fd5d258dd00 is known as passing by reference.".</span> <span> - </span> <span class="display-name">chetan</span> <span> </span> <span class="date">11 May 2020 at 08:33</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>It's not enough to distinguish between <code>value</code> and <code>address</code>. The question is whether new memory is used for whatever you pass. You can pass an <code>address</code> based on <i>pass-by-value</i> (new storage for the address within the callee) so that changing this address within the callee won't affect the caller's original variable (old storage) that still keeps the original address.</span> <span> - </span> <span class="display-name">Wolfson</span> <span> </span> <span class="date">17 Sep 2020 at 13:56</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Does the C++ standard say anything about memory and memory addresses? Isn't that implementation-dependent?</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">16 Aug 2022 at 14:09</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Sorry bud. I have no c++ experience.</span> <span> - </span> <span class="display-name">mfaani</span> <span> </span> <span class="date">16 Aug 2022 at 18:25</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@chetan no, it's not a contradiction. Passing an object/string/integer/whatever by its address is "passing an <i>object/string/etc</i> by reference", which equals to "passing <i>its address</i> by value". So it's never just <i>passing</i> by reference or <i>passing</i> by value; it's always <i>passing something</i> by reference or by value.</span> <span> - </span> <span class="display-name">Vadim Samokhin</span> <span> </span> <span class="date">29 Oct 2022 at 07:40</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@VadimSamokhin It is a contradiction. Passing the address of an object is NOT pass by reference. That way Java would be pass by reference for objects. The real distinguishing factor is if a new variable was created in the function or not. Like passing a reference variable in C using <code>&amp;var</code> will be considered pass by reference since no new variable is created.</span> <span> - </span> <span class="display-name">chetan</span> <span> </span> <span class="date">30 Oct 2022 at 11:16</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>55</span>
     </div>
     <div>
      <span>Answerer: </span> <span>isekaijin</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Dec 2008 at 02:03</span>
     </div>
    </div>
    <div>
     <p>Here is an example:</p>
     <pre class="lang-cpp prettyprint-override"><code>#include &lt;iostream&gt;

void by_val(int arg) { arg += 2; }
void by_ref(int&amp;arg) { arg += 2; }

int main()
{
    int x = 0;
    by_val(x); std::cout &lt;&lt; x &lt;&lt; std::endl;  // prints 0
    by_ref(x); std::cout &lt;&lt; x &lt;&lt; std::endl;  // prints 2

    int y = 0;
    by_ref(y); std::cout &lt;&lt; y &lt;&lt; std::endl;  // prints 2
    by_val(y); std::cout &lt;&lt; y &lt;&lt; std::endl;  // prints 2
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>I think there is one problem as last line should print 0 instead of 2. Kindly tell me if I'm missing something.</span> <span> - </span> <span class="display-name">Taimoor Changaiz</span> <span> </span> <span class="date">11 Mar 2014 at 17:43</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@TaimoorChangaiz; Which "last line"? By the way, if you can use IRC, please come to ##programming on Freenode. It would be a lot easier to explain things there. My nick there is "pyon".</span> <span> - </span> <span class="display-name">isekaijin</span> <span> </span> <span class="date">11 Mar 2014 at 17:57</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@EduardoLeón by_val(y); std::cout &lt;&lt; y &lt;&lt; std::endl; // prints 2</span> <span> - </span> <span class="display-name">Taimoor Changaiz</span> <span> </span> <span class="date">12 Mar 2014 at 12:18</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>@TaimoorChangaiz: Why would it not print 2? <code>y</code> has already been set to 2 by the preceding line. Why would it go back to 0?</span> <span> - </span> <span class="display-name">isekaijin</span> <span> </span> <span class="date">12 Mar 2014 at 13:30</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@EduardoLeón my bad. yes you are right. Thanks for correction</span> <span> - </span> <span class="display-name">Taimoor Changaiz</span> <span> </span> <span class="date">12 Mar 2014 at 17:09</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>31</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Than Skourtan</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Nov 2014 at 20:07</span>
     </div>
    </div>
    <div>
     <p>The simplest way to get this is on an <a href="https://en.wikipedia.org/wiki/Microsoft_Excel" rel="nofollow noreferrer">Excel</a> file. Let’s say for example that you have two numbers, 5 and 2 in cells A1 and B1 accordingly, and you want to find their sum in a third cell, let's say A2.</p>
     <p>You can do this in two ways.</p>
     <ul>
      <li>
       <p>Either by <strong>passing their values to cell A2</strong> by typing <em>= 5 + 2</em> into this cell. In this case, if the values of the cells A1 or B1 change, the sum in A2 remains the same.</p></li>
      <li>
       <p>Or by <strong>passing the “references” of the cells A1 and B1 to cell A2</strong> by typing <em>= A1 + B1</em>. In this case, if the values of the cells A1 or B1 change, the sum in A2 changes too.</p></li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>This is the simplest and the best example among all other answers.</span> <span> - </span> <span class="display-name">Amit Ray</span> <span> </span> <span class="date">26 Jan 2018 at 18:21</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>23</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Craig</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Dec 2008 at 01:53</span>
     </div>
    </div>
    <div>
     <p>When passing by reference you are basically passing a pointer to the variable. Pass by value you are passing a copy of the variable.</p>
     <p>In basic usage this normally means pass by reference, changes to the variable will seen be in the calling method and in pass by value they won’t.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>18</span>
     </div>
     <div>
      <span>Answerer: </span> <span>MetaGuru</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Dec 2008 at 02:18</span>
     </div>
    </div>
    <div>
     <p>Pass by value sends a <em>copy</em> of the data stored in the variable you specify, and pass by reference sends a direct link to the variable itself.</p>
     <p>So if you pass a variable by reference and then change the variable inside the block you passed it into, the original variable will be changed. If you simply pass by value, the original variable will not be able to be changed by the block you passed it into, but you will get a copy of whatever it contained at the time of the call.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>13</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Hamed Naeemaei</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Dec 2021 at 21:00</span>
     </div>
    </div>
    <div>
     <p>Take a look at this photo:</p>
     <p>In the first case (<strong>pass by reference</strong>), when the variable is set or changed inside the function, the external variable also changes.</p>
     <p>But in the second case (<strong>pass by value</strong>), changing the variable inside the function doesn't have any effect on the external variable.</p>
     <p>For reading the article, see this <a href="https://blog.penjee.com/passing-by-value-vs-by-reference-java-graphical/" rel="nofollow noreferrer">link</a>.</p>
     <p><a href="https://blog.penjee.com/wp-content/uploads/2015/02/pass-by-reference-vs-pass-by-value-animation.gif" rel="nofollow noreferrer"><img src="https://blog.penjee.com/wp-content/uploads/2015/02/pass-by-reference-vs-pass-by-value-animation.gif" alt="Call by reference vs call by value"></a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>9</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user326964</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Dec 2015 at 22:57</span>
     </div>
    </div>
    <div>
     <p>Pass by value - The function copies the variable and works with a copy (so it doesn't change anything in the original variable)</p>
     <p>Pass by reference - The function uses the original variable. If you change the variable in the other function, it changes in the original variable too.</p>
     <p>Example (copy and use/try this yourself and see):</p>
     <pre class="lang-cpp prettyprint-override"><code>#include &lt;iostream&gt;

using namespace std;

void funct1(int a) // Pass-by-value
{
    a = 6; // Now "a" is 6 only in funct1, but not in main or anywhere else
}

void funct2(int &amp;a)  // Pass-by-reference
{
    a = 7; // Now "a" is 7 both in funct2, main and everywhere else it'll be used
}

int main()
{
    int a = 5;

    funct1(a);
    cout &lt;&lt; endl &lt;&lt; "A is currently " &lt;&lt; a &lt;&lt; endl &lt;&lt; endl; // Will output 5
    funct2(a);
    cout &lt;&lt; endl &lt;&lt; "A is currently " &lt;&lt; a &lt;&lt; endl &lt;&lt; endl; // Will output 7

    return 0;
}
</code></pre>
     <p>Keep it simple, peeps. Walls of text can be a bad habit.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>This is really helpful in understanding whether the parameter value was changed or not, thanks!</span> <span> - </span> <span class="display-name">Kevin Zhao</span> <span> </span> <span class="date">17 May 2016 at 14:35</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Tina Endresen</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Dec 2008 at 03:36</span>
     </div>
    </div>
    <div>
     <p>A major difference between them is that value-type variables store values, so specifying a value-type variable in a method call passes a copy of that variable's value to the method. Reference-type variables store references to objects, so specifying a reference-type variable as an argument passes the method a copy of the actual reference that refers to the object. Even though the reference itself is passed by value, the method can still use the reference it receives to interact with—and possibly modify—the original object. Similarly, when returning information from a method via a return statement, the method returns a copy of the value stored in a value-type variable or a copy of the reference stored in a reference-type variable. When a reference is returned, the calling method can use that reference to interact with the referenced object. So, in effect, objects are always passed by reference.</p>
     <p>In c#, to pass a variable by reference so the called method can modify the variable's, C# provides keywords ref and out. Applying the ref keyword to a parameter declaration allows you to pass a variable to a method by reference—the called method will be able to modify the original variable in the caller. The ref keyword is used for variables that already have been initialized in the calling method. Normally, when a method call contains an uninitialized variable as an argument, the compiler generates an error. Preceding a parameter with keyword out creates an output parameter. This indicates to the compiler that the argument will be passed into the called method by reference and that the called method will assign a value to the original variable in the caller. If the method does not assign a value to the output parameter in every possible path of execution, the compiler generates an error. This also prevents the compiler from generating an error message for an uninitialized variable that is passed as an argument to a method. A method can return only one value to its caller via a return statement, but can return many values by specifying multiple output (ref and/or out) parameters.</p>
     <p>see c# discussion and examples here <a href="http://msdn.microsoft.com/en-us/library/0f66670z(VS.71).aspx" rel="noreferrer">link text</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>DEADFACE</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Dec 2008 at 02:10</span>
     </div>
    </div>
    <div>
     <p>Examples:</p>
     <pre class="lang-cpp prettyprint-override"><code>class Dog 
{ 
public:
    barkAt( const std::string&amp; pOtherDog ); // const reference
    barkAt( std::string pOtherDog ); // value
};
</code></pre>
     <p><code>const &amp;</code> is generally best. You don't incur the construction and destruction penalty. If the reference isn't const your interface is suggesting that it will change the passed in data.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Stanley</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Jan 2011 at 22:05</span>
     </div>
    </div>
    <div>
     <p>If you don't want to change the value of the original variable after passing it into a function, the function should be constructed with a "<strong>pass by value</strong>" parameter.</p>
     <p>Then the function will have <em>only</em> the value, but not the address of the passed in variable. Without the variable's address, the code inside the function cannot change the variable value as seen from the outside of the function.</p>
     <p>But if you want to give the function the <em>ability to change the value of the variable</em> as seen from the outside, you need to use <strong>pass by reference</strong>. As both the value and the address (reference) are passed in and are available inside the function.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span> <span class="arrow"> <a href="#answer_15">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Monster</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Jul 2014 at 13:46</span>
     </div>
    </div>
    <div>
     <p>In short, Passed by value is WHAT it is and passed by reference is WHERE it is.</p>
     <p>If your value is VAR1 = "Happy Guy!", you will only see "Happy Guy!". If VAR1 changes to "Happy Gal!", you won't know that. If it's passed by reference, and VAR1 changes, you will.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_15"><span>Answer 15</span> <span class="arrow"> <a href="#answer_14">↑</a> </span> <span class="arrow"> <a href="#answer_16">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>abhinisha thakur</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Jun 2013 at 10:15</span>
     </div>
    </div>
    <div>
     <p>Pass by value means how to pass a value to a function by making use of arguments. In pass by value, we copy the data stored in the variable we specify, and it is slower than pass by reference because the data is copied.</p>
     <p>Or we make changes in the copied data. The original data is not affected. And in pass by reference or pass by address, we send a direct link to the variable itself. Or passing a pointer to a variable. It is faster because less time is consumed.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_16"><span>Answer 16</span> <span class="arrow"> <a href="#answer_15">↑</a> </span> <span class="arrow"> <a href="#answer_17">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>BugShotGG</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Apr 2015 at 11:49</span>
     </div>
    </div>
    <div>
     <p>Here is an example that demonstrates the differences between <strong>pass by value - pointer value - reference</strong>:</p>
     <pre class="lang-cpp prettyprint-override"><code>void swap_by_value(int a, int b){
    int temp;

    temp = a;
    a = b;
    b = temp;
}   
void swap_by_pointer(int *a, int *b){
    int temp;

    temp = *a;
    *a = *b;
    *b = temp;
}    
void swap_by_reference(int &amp;a, int &amp;b){
    int temp;

    temp = a;
    a = b;
    b = temp;
}

int main(void){
    int arg1 = 1, arg2 = 2;

    swap_by_value(arg1, arg2);
    cout &lt;&lt; arg1 &lt;&lt; " " &lt;&lt; arg2 &lt;&lt; endl;    //prints 1 2

    swap_by_pointer(&amp;arg1, &amp;arg2);
    cout &lt;&lt; arg1 &lt;&lt; " " &lt;&lt; arg2 &lt;&lt; endl;    //prints 2 1

    arg1 = 1;                               //reset values
    arg2 = 2;
    swap_by_reference(arg1, arg2);
    cout &lt;&lt; arg1 &lt;&lt; " " &lt;&lt; arg2 &lt;&lt; endl;    //prints 2 1
}
</code></pre>
     <p>The “passing by reference” method has <strong>an important limitation</strong>. If a parameter is declared as <strong>passed by reference</strong> (so it is preceded by the &amp; sign) its corresponding <strong>actual parameter must be a variable</strong>.</p>
     <p>An actual parameter referring to “passed by value” formal parameter may be <strong>an expression</strong> in general, so it is allowed to use not only a variable but also a literal or even a function invocation's result.</p>
     <p>The function is not able to place a value in something other than a variable. It cannot assign a new value to a literal or force an expression to change its result.</p>
     <p><em>PS: You can also check Dylan Beattie answer in the current thread that explains it in plain words.</em></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>You state "if a parameter is declared [as a reference] its corresponding actual parameter must be a variable", but that is not true in general. If a reference is bound to a temporary (such as the return value of a function), its lifetime is extended to match the reference. See <a href="http://en.cppreference.com/w/cpp/language/reference_initialization#Lifetime_of_a_temporary" rel="nofollow noreferrer">here</a> for details.</span> <span> - </span> <span class="display-name">Chris Hunt</span> <span> </span> <span class="date">24 Apr 2017 at 15:13</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_17"><span>Answer 17</span> <span class="arrow"> <a href="#answer_16">↑</a> </span> <span class="arrow"> <a href="#answer_18">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Misaal D'souza</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Jan 2021 at 15:37</span>
     </div>
    </div>
    <div>
     <p><strong>1. Pass By Value / Call By Value</strong></p>
     <pre><code>   void printvalue(int x) 
   {
       x = x + 1 ;
       cout &lt;&lt; x ;  // 6
   }

   int x = 5;
   printvalue(x);
   cout &lt;&lt; x;    // 5
</code></pre>
     <p>In call by value, when you pass a value to <code>printvalue(x)</code> i.e. the argument which is <code>5</code>, it is copied to <code>void printvalue(int x)</code>. Now, we have two different values <code>5</code> and the copied value <code>5</code> and these two values are stored in different memory locations. So if you make any change inside <code>void printvalue(int x)</code> it won't reflect back to the argument.</p>
     <p><strong>2. Pass By Reference/ Call By Reference</strong></p>
     <pre><code>   void printvalue(int &amp;x) 
   {
      x = x + 1 ;
      cout &lt;&lt; x ; // 6
   }

   int x = 5;
   printvalue(x);
   cout &lt;&lt; x;   // 6
</code></pre>
     <p>In call by reference, there's only one difference. We use <code>&amp;</code> i.e. the address operator. By doing<br><code>void printvalue(int &amp;x)</code> we are referring to the address of <code>x</code> which tells us that it both refers to the same location. Hence, any changes made inside the function will reflect outside.</p>
     <p>Now that you're here, you should also know about ...</p>
     <p><strong>3. Pass By Pointer/ Call By Address</strong></p>
     <pre><code>   void printvalue(int* x) 
   {
      *x = *x + 1 ;
      cout &lt;&lt; *x ; // 6
   }

   int x = 5;
   printvalue(&amp;x);
   cout &lt;&lt; x;   // 6
</code></pre>
     <p>In pass by address, the pointer <code>int* x</code> holds the address passed to it <code>printvalue(&amp;x)</code>. Hence, any changes done inside the function will reflect outside.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_18"><span>Answer 18</span> <span class="arrow"> <a href="#answer_17">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>sifr_dot_in</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Aug 2021 at 07:24</span>
     </div>
    </div>
    <div>
     <p>The question is "vs".</p>
     <p>And nobody has pointed to an important point. In passing with values, additional memory is occupied to store the passed variable values.</p>
     <p>While in passing with a reference, no additional memory is occupied for the values (memory efficient in circumstances).</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>But only <b><i>temporary</i></b> additional memory (on the stack)?</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">16 Aug 2022 at 14:05</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>What do you mean by "vs" (in this context)? Can you elaborate?</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">16 Aug 2022 at 14:05</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@PeterMortensen "vs" can be taken as against or comparing side by side.</span> <span> - </span> <span class="display-name">sifr_dot_in</span> <span> </span> <span class="date">17 Aug 2022 at 03:22</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@PeterMortensen if u say "But only temporary ...", the "additional memory" point was expected here.</span> <span> - </span> <span class="display-name">sifr_dot_in</span> <span> </span> <span class="date">17 Aug 2022 at 03:25</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>