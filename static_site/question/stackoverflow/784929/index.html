<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>What is the !! (not not) operator in JavaScript?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>What is the !! (not not) operator in JavaScript?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>4076</span>
    </div>
    <div>
     <span>Asker: </span> <span>Hexagon Theory</span>
    </div>
    <div>
     <span>Asked: </span> <span>24 Apr 2009 at 08:13</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/784929">source</a>
    </div>
   </div>
   <div>
    <p>I saw some code that seems to use an operator I don't recognize, in the form of two exclamation points, like so: <code>!!</code>. Can someone please tell me what this operator does?</p>
    <p>The context in which I saw this was,</p>
    <pre><code>this.vertical = vertical !== undefined ? !!vertical : this.vertical;
</code></pre>
   </div>
   <div class="tags">
    <span class="tag">javascript</span><span class="tag">operators</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>1379</td>
       <td><span>Remember it by "bang, bang you're boolean"</span> <span> - </span> <span class="display-name">Gus</span> <span> </span> <span class="date">15 Feb 2012 at 18:35</span></td>
      </tr>
      <tr>
       <td>121</td>
       <td><span>Just for the record, don't do what is quoted there. Do <code>if(vertical !== undefined) this.vertical = Boolean(vertical);</code> - it is much cleaner and clearer what is going on, requires no unnecessary assignment, is entirely standard, and is just as fast (on current FF and Chrome) <a href="http://jsperf.com/boolean-conversion-speed" rel="nofollow noreferrer">jsperf.com/boolean-conversion-speed</a> .</span> <span> - </span> <span class="display-name">Phil H</span> <span> </span> <span class="date">12 Feb 2014 at 09:43</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>"any decent programmer should know what's going on..." - it sometimes helps the compiler generate better code in compiled languages. I know it used to be recommended by Microsoft when using C code because it generated the best code. (It probably still is recommended, but I can't find the reference at the moment).</span> <span> - </span> <span class="display-name">jww</span> <span> </span> <span class="date">1 Apr 2014 at 12:11</span></td>
      </tr>
      <tr>
       <td>119</td>
       <td><span>!! is not an operator. It's just the ! operator twice.</span> <span> - </span> <span class="display-name">Vivek</span> <span> </span> <span class="date">16 Jul 2014 at 07:21</span></td>
      </tr>
      <tr>
       <td>79</td>
       <td><span>@schabluk, for the record, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" rel="nofollow noreferrer">order of operations</a> is the reason <code>!!5/0</code> produces <code>Infinity</code> rather than <code>true</code>, as produced by <code>Boolean(5/0)</code>. <code>!!5/0</code> is equivalent to <code>(!!5)/0</code> -- a.k.a <code>true/0</code> -- due to the <code>!</code> operator having a higher precedence than the <code>/</code> operator. If you wanted to Booleanize <code>5/0</code> using a double-bang, you'd need to use <code>!!(5/0)</code>.</span> <span> - </span> <span class="display-name">matty</span> <span> </span> <span class="date">24 May 2015 at 13:47</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Put simply: !!vertical gives you a boolean value as to whether 'vertical' is defined or non-false.</span> <span> - </span> <span class="display-name">user2808054</span> <span> </span> <span class="date">13 Oct 2015 at 09:23</span></td>
      </tr>
      <tr>
       <td>2</td>
       <td><span><a href="http://stackoverflow.com/q/2527086/995714">What does !!(x) mean in C (esp. the Linux kernel)?</a></span> <span> - </span> <span class="display-name">phuclv</span> <span> </span> <span class="date">29 Apr 2017 at 09:40</span></td>
      </tr>
      <tr>
       <td>2</td>
       <td><span>Simplely explain: <code>!!value === Boolean(value)</code></span> <span> - </span> <span class="display-name">Shuai Li</span> <span> </span> <span class="date">14 Dec 2018 at 07:16</span></td>
      </tr>
      <tr>
       <td>40</td>
       <td><span>@Gus Just so you know, I read your comment waaaay back in 2012. Over the course of the 7 years since then, I've always said humorously in my mind "Bang bang! you're boolean!" when inverting a boolean, and I've always remembered how as a result. I decided to look up your comment today and let you know :-)</span> <span> - </span> <span class="display-name">Zachary Schuessler</span> <span> </span> <span class="date">19 Jul 2019 at 17:39</span></td>
      </tr>
      <tr>
       <td>8</td>
       <td><span>@ZacharySchuessler thx, I'm pleased so many like it, and I've even seen it quoted (and credited) in tutorial sites and such now which is awesome :) never dreamed I'd be coining such a popular mnemonic.</span> <span> - </span> <span class="display-name">Gus</span> <span> </span> <span class="date">28 Aug 2019 at 14:10</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>I like to think of it as an "is truthy" check.</span> <span> - </span> <span class="display-name">BillMux</span> <span> </span> <span class="date">10 Dec 2021 at 11:14</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>it will just force the variable to have a boolean value. Its useful for assertions and checks.</span> <span> - </span> <span class="display-name">Jone Polvora</span> <span> </span> <span class="date">26 Mar 2022 at 19:02</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>!!!!!!!!!!!!!!!!!!false === false</span> <span> - </span> <span class="display-name">Aidin53</span> <span> </span> <span class="date">6 Jul 2022 at 05:05</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>unique code <code>true + 1 = 2</code> .brr</span> <span> - </span> <span class="display-name">perona chan</span> <span> </span> <span class="date">17 May 2023 at 14:54</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3632</span>
     </div>
     <div>
      <span>Answerer: </span> <span>stevehipwell</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Apr 2009 at 08:18</span>
     </div>
    </div>
    <div>
     <p>It converts <code>Object</code> to <code>boolean</code>. If it was falsy (e.g., <code>0</code>, <code>null</code>, <code>undefined</code>, etc.), it would be <code>false</code>, otherwise, <code>true</code>.</p>
     <pre><code>!object  // Inverted Boolean
!!object // Noninverted Boolean, so true Boolean representation
</code></pre>
     <p>So <code>!!</code> is not an operator; it's just the <code>!</code> operator twice.</p>
     <p>It may be simpler to do:</p>
     <pre><code>Boolean(object) // Boolean
</code></pre>
     <p>Real World Example "Test IE version":</p>
     <pre><code>const isIE8 = !! navigator.userAgent.match(/MSIE 8.0/);
console.log(isIE8); // Returns true or false
</code></pre>
     <p>If you ⇒</p>
     <pre><code>console.log(navigator.userAgent.match(/MSIE 8.0/));
// Returns either an Array or null
</code></pre>
     <p>But if you ⇒</p>
     <pre><code>console.log(!!navigator.userAgent.match(/MSIE 8.0/));
// Returns either true or false
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>161</td>
        <td><span>It converts a nonboolean to an inverted boolean (for instance, !5 would be false, since 5 is a non-false value in JS), then boolean-inverts that so you get the original value as a boolean (so !!5 would be true).</span> <span> - </span> <span class="display-name">Chuck</span> <span> </span> <span class="date">24 Apr 2009 at 17:14</span></td>
       </tr>
       <tr>
        <td>153</td>
        <td><span>An easy way to describe it is: Boolean(5) === !!5; Same casting, fewer characters.</span> <span> - </span> <span class="display-name">Micah Snyder</span> <span> </span> <span class="date">24 Apr 2009 at 18:27</span></td>
       </tr>
       <tr>
        <td>59</td>
        <td><span>This is used to convert truthy values to boolean true, and falsy values too boolean false.</span> <span> - </span> <span class="display-name">thetoolman</span> <span> </span> <span class="date">16 Jul 2012 at 03:53</span></td>
       </tr>
       <tr>
        <td>17</td>
        <td><span>@Micah Snyder be careful that in JavaScript it's better to use boolean primitives instead of creating objects that box booleans with new Boolean(). Here's an example to see the difference: <a href="http://jsfiddle.net/eekbu/" rel="nofollow noreferrer">jsfiddle.net/eekbu</a></span> <span> - </span> <span class="display-name">victorvartan</span> <span> </span> <span class="date">3 Feb 2013 at 12:24</span></td>
       </tr>
       <tr>
        <td>9</td>
        <td><span>As far as I know, this bang-bang pattern is not useful inside a if(…_ statement; only in a return statement of a function that should return a boolean.</span> <span> - </span> <span class="display-name">rds</span> <span> </span> <span class="date">26 Mar 2014 at 19:43</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Why would anyone need to use this? I'm trying to think of a use case.</span> <span> - </span> <span class="display-name">sparkyShorts</span> <span> </span> <span class="date">5 Dec 2016 at 18:26</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>@sparkyShorts, if your code uses <code>===</code> to compare boolean values, then you must type cast "truthy" values to booleans using <code>!!</code>, otherwise your results will be wrong. For example, assuming 0 indicates false and 1 indicates true, then <code>1 === true</code> will fail, whereas <code>!!1 === true</code> works correctly.</span> <span> - </span> <span class="display-name">geofflee</span> <span> </span> <span class="date">2 Mar 2017 at 00:33</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@sparkyShorts Another example: Consider a property on an object <code>obj.myString</code> that could have a string value, but could also be an empty string, null, or undefined. It's much less code (albeit more obscure) to write <code>if (!!obj.myString) { doSomething() };</code> than it is to write <code>if (typeof obj.myString !== 'undefined' &amp;&amp; obj.myString !== null &amp;&amp; obj.myString !== '') { doSomething() };</code></span> <span> - </span> <span class="display-name">Dale Harris</span> <span> </span> <span class="date">20 Mar 2018 at 17:15</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Is it a good practice to negate !!! (3 times) an object to get the boolean value?</span> <span> - </span> <span class="display-name">Diego Ponciano</span> <span> </span> <span class="date">8 Sep 2021 at 23:09</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@DiegoPonciano No, <code>!!!value</code> would negate <code>!!value</code>, which in the end is the same as <code>!value</code>.</span> <span> - </span> <span class="display-name">Abel</span> <span> </span> <span class="date">17 Nov 2021 at 07:00</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>@victorvartan Your <a href="http://jsfiddle.net/eekbu/" rel="nofollow noreferrer">jsfiddle</a> uses <code>new Boolean(5)</code>, but if you change it to just use <code>Boolean(5)</code> then your code returns true for both variables</span> <span> - </span> <span class="display-name">icc97</span> <span> </span> <span class="date">4 Mar 2022 at 10:11</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1013</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Tom Ritter</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Sep 2009 at 17:28</span>
     </div>
    </div>
    <div>
     <p>It's a horribly obscure way to do a type conversion.</p>
     <p><code>!</code> means <em>NOT</em>. So <code>!true</code> is <code>false</code>, and <code>!false</code> is <code>true</code>. <code>!0</code> is <code>true</code>, and <code>!1</code> is <code>false</code>.</p>
     <p>So you're converting a value to a Boolean, inverting it, and then inverting it again.</p>
     <pre><code>// Maximum Obscurity:
val.enabled = !!userId;

// Partial Obscurity:
val.enabled = (userId != 0) ? true : false;

// And finally, much easier to understand:
val.enabled = (userId != 0);

// Or just
val.enabled = Boolean(userId);
</code></pre>
     <p><strong>Note:</strong> the latter two expressions aren't exactly equivalent to the first expression when it comes to some edge case (when <code>userId</code> is <code>[]</code>, for example), due to the way the <code>!=</code> operator works and what values are considered <em>truthy</em>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>109</td>
        <td><span>!!false = false. !!true = true</span> <span> - </span> <span class="display-name">cllpse</span> <span> </span> <span class="date">10 Sep 2009 at 17:38</span></td>
       </tr>
       <tr>
        <td>135</td>
        <td><span>Is the "much easier to understand" variant really much easier to understand here? The check against 0 is not an actual check against 0, but a check against the somewhat weird list of values Javascript considers equal to 0. <code>userId ? true : false</code> makes more clear that there is conversion going on and handles the case where userId's value might have been explicitly set to <code>undefined</code></span> <span> - </span> <span class="display-name">Ben Regenspan</span> <span> </span> <span class="date">13 Oct 2010 at 16:26</span></td>
       </tr>
       <tr>
        <td>82</td>
        <td><span>My brain doesn't have any problem decoding <code>!!var</code> into <code>Boolean(var)</code> .. and <code>!!</code> is faster (less instructions to process) and shorter than the alternatives.</span> <span> - </span> <span class="display-name">adamJLev</span> <span> </span> <span class="date">24 Oct 2010 at 23:36</span></td>
       </tr>
       <tr>
        <td>10</td>
        <td><span><code>!!false</code> is false. <code>false != 0</code> is true. So they're not equivalent. <code>!!</code> serves the useful purpose of coercing <i>anything</i> to a boolean.</span> <span> - </span> <span class="display-name">slim</span> <span> </span> <span class="date">21 Aug 2020 at 16:19</span></td>
       </tr>
       <tr>
        <td>22</td>
        <td><span>I realize you wrote this answer many years ago, but in the interest of refining it for today: The easiest to understand is to <b>say what you mean</b>: <code>Boolean(x)</code>. I don't consider any of your alternatives easy to understand. Worse, there is at least one case where using equality operator <code>x != 0</code> gives a different result than <code>Boolean(x)</code> or <code>!!x</code>: try <code>[]</code> for x. Also, if you do like using equality operator, to get its "truthiness" rules, why wouldn't you do the more obvious <code>(userId == true)</code> instead of <code>(userId != 0)</code>?</span> <span> - </span> <span class="display-name">ToolmakerSteve</span> <span> </span> <span class="date">27 Oct 2020 at 20:17</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@cllpse You mean !!false === false and !!true === true ? ;-)</span> <span> - </span> <span class="display-name">Maik Lowrey</span> <span> </span> <span class="date">8 Apr 2021 at 20:33</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>It's worth noting though that <code>!!</code> is portable to virtually any C-style language</span> <span> - </span> <span class="display-name">Sam Johnson</span> <span> </span> <span class="date">13 Aug 2021 at 06:42</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@slim <code>false != 0</code> is actually <code>false</code>.</span> <span> - </span> <span class="display-name">Unmitigated</span> <span> </span> <span class="date">5 Aug 2022 at 19:54</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>581</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Salman A</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 May 2012 at 09:06</span>
     </div>
    </div>
    <div>
     <p><code>!!expr</code> (two <code>!</code> operators followed by an expression) returns a Boolean value (<code>true</code> or <code>false</code>) depending on the <em>truthiness</em> of the expression. It makes more sense when used on non-boolean types. Consider these examples, especially the 3rd example and onward:</p>
     <pre><code>          !!false === false
           !!true === true

              !!0 === false
!!parseInt("foo") === false // NaN is falsy
              !!1 === true
             !!-1 === true  // -1 is truthy
          !!(1/0) === true  // Infinity is truthy

             !!"" === false // empty string is falsy
          !!"foo" === true  // non-empty string is truthy
        !!"false" === true  // ...even if it contains a falsy value

     !!window.foo === false // undefined value is falsy
      !!undefined === false // undefined primitive is falsy
           !!null === false // null is falsy

             !!{} === true  // an (empty) object is truthy
             !![] === true  // an (empty) array is truthy; PHP programmers beware!
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>80</td>
        <td><span>Worth noting: <code>!!new Boolean(false) // true</code></span> <span> - </span> <span class="display-name">Camilo Martin</span> <span> </span> <span class="date">18 Dec 2012 at 08:05</span></td>
       </tr>
       <tr>
        <td>59</td>
        <td><span>...But also <code>!!Boolean(false) // false</code></span> <span> - </span> <span class="display-name">Camilo Martin</span> <span> </span> <span class="date">18 Dec 2012 at 08:06</span></td>
       </tr>
       <tr>
        <td>127</td>
        <td><span><code>new Boolean(false)</code> is an object and an object is truthy even if it contains a falsy value!</span> <span> - </span> <span class="display-name">Salman A</span> <span> </span> <span class="date">18 Dec 2012 at 08:15</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Definite suggestion to add <code>!!undefined //false</code> to this great answer!</span> <span> - </span> <span class="display-name">Yashwin Munsadwala</span> <span> </span> <span class="date">16 Jun 2021 at 17:27</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@SalmanA to expand to your correct comment <code>!!(new Boolean(false).valueOf()) // false</code> (because new Boolean returns an instance of a Boolean object, which is truthy, while Boolean(false) or Boolean valueOf() coerces the expression's value to a primative boolean).</span> <span> - </span> <span class="display-name">Tym Pollack</span> <span> </span> <span class="date">16 Aug 2021 at 14:25</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Be aware that <code>!!" "</code> === true. That's an empty whitespace</span> <span> - </span> <span class="display-name">Skillz</span> <span> </span> <span class="date">4 Nov 2022 at 22:57</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>213</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Benny Schmidt</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Feb 2013 at 23:45</span>
     </div>
    </div>
    <div>
     <p><strong>Brew some tea:</strong></p>
     <p><code>!!</code> is not an operator. It is the double-use of <code>!</code> -- which is the logical "not" operator.</p>
     <hr>
     <p><strong>In theory:</strong></p>
     <p><strong><code>!</code></strong> determines the "truth" of what a value is not:</p>
     <ul>
      <li>
       <p>The truth is that <code>false</code> is not <code>true</code> (that's why <code>!false</code> results in <strong><code>true</code></strong>)</p></li>
      <li>
       <p>The truth is that <code>true</code> is not <code>false</code> (that's why <code>!true</code> results in <strong><code>false</code></strong>)</p></li>
     </ul>
     <hr>
     <p><strong><code>!!</code></strong> determines the "truth" of what a value is <em>not</em> not:</p>
     <ul>
      <li>
       <p>The truth is that <code>true</code> is not <em>not</em> <code>true</code> (that's why <code>!!true</code> results in <strong><code>true</code></strong>)</p></li>
      <li>
       <p>The truth is that <code>false</code> is not <em>not</em> <code>false</code> (that's why <code>!!false</code> results in <strong><code>false</code></strong>)</p></li>
     </ul>
     <hr>
     <p>What we wish to determine in the comparison is the "truth" <em>about</em> the value of a reference, not the <em>value of</em> the reference itself. There is a use-case where we might want to know the truth about a value, even if we expect the value to be <em><code>false</code></em> (or falsey), or if we expect the value not to be typeof <code>boolean</code>.</p>
     <hr>
     <p><strong>In practice:</strong></p>
     <p>Consider a concise function which detects feature functionality (and in this case, platform compatibility) by way of <strong><a href="http://en.wikipedia.org/wiki/Type_system#Dynamic_typing" rel="noreferrer">dynamic typing</a></strong> (aka "duck typing"). We want to write a function that returns <code>true</code> if a user's browser supports the HTML5 <code>&lt;audio&gt;</code> element, but we don't want the function to throw an error if <code>&lt;audio&gt;</code> is undefined; and we don't want to use <code>try ... catch</code> to handle any possible errors (because they're gross); <em>and also</em> we don't want to use a check inside the function that won't consistently reveal the truth about the feature (for example, <code>document.createElement('audio')</code> will still create an element called <code>&lt;audio&gt;</code> even if HTML5 <code>&lt;audio&gt;</code> is not supported).</p>
     <hr>
     <p>Here are the three approaches:</p>
     <pre><code>// this won't tell us anything about HTML5 `&lt;audio&gt;` as a feature
var foo = function(tag, atr) { return document.createElement(tag)[atr]; }

// this won't return true if the feature is detected (although it works just fine)
var bar = function(tag, atr) { return !document.createElement(tag)[atr]; }

// this is the concise, feature-detecting solution we want
var baz = function(tag, atr) { return !!document.createElement(tag)[atr]; }

foo('audio', 'preload'); // returns "auto"
bar('audio', 'preload'); // returns false
baz('audio', 'preload'); // returns true
</code></pre>
     <p>Each function accepts an argument for a <code>&lt;tag&gt;</code> and an <code>attribute</code> to look for, but they each return different values based on what the comparisons determine.</p>
     <p><strong>But wait, there's more!</strong></p>
     <p>Some of you probably noticed that in this specific example, one could simply check for a property using the slightly <strong><a href="http://jsperf.com/hasownproperty-vs-comparison" rel="noreferrer">more performant</a></strong> means of checking if the object in question <em>has</em> a property. There are two ways to do this:</p>
     <pre><code>// the native `hasOwnProperty` method
var qux = function(tag, atr) { return document.createElement(tag).hasOwnProperty(atr); }

// the `in` operator
var quux = function(tag, atr) { return atr in document.createElement(tag); }

qux('audio', 'preload');  // returns true
quux('audio', 'preload'); // returns true
</code></pre>
     <p><strong>We digress...</strong></p>
     <p>However rare these situations may be, there may exist a few scenarios where the most concise, most performant, and thus most preferred means of getting <code>true</code> from a non-boolean, possibly undefined value is indeed by using <code>!!</code>. Hopefully this ridiculously clears it up.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>7</td>
        <td><span>totally awesome answer, but I fail to see the utility of the !! construct. Since an <code>if()</code> statement already casts the expression to boolean, explicitly casting the return value of a testing function to boolean is redundant - since "truthiness" === true as far as an <code>if()</code> statement goes anyway. Or am I missing a scenario where you NEED a truthy expression to actually be boolean <code>true</code>?</span> <span> - </span> <span class="display-name">Tom Auger</span> <span> </span> <span class="date">6 Apr 2016 at 13:27</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>@TomAuger <code>if()</code> statements do cast boolean against falsey values, but say you want to actually set a boolean flag on an object - it won't cast it like an <code>if()</code> statement does. For example <code>object.hasTheThing = !!castTheReturnValToBoolNoMatterWhat()</code> would set either <code>true</code> or <code>false</code> instead of the real return value. Another example is maybe all admins are <code>id</code> of <code>0</code> and non-admins are id <code>1</code> or higher. To get <code>true</code> if someone is not an admin you could do <code>person.isNotAdmin = !!admin.id</code>. Few use cases, but it's concise when there is.</span> <span> - </span> <span class="display-name">Benny Schmidt</span> <span> </span> <span class="date">31 May 2018 at 15:41</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>121</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Crescent Fresh</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Sep 2009 at 17:26</span>
     </div>
    </div>
    <div>
     <p><code>!!</code> converts the value to the right of it to its equivalent Boolean value. (Think poor man's way of "type-casting".) Its <em>intent</em> is usually to convey to the reader that the code does not care <em>what</em> value is in the variable, but what its <a href="http://11heavens.com/falsy-and-truthy-in-javascript" rel="noreferrer">"truth" value</a> is.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>5</td>
        <td><span>Or in the case of a boolean value on the right, it does nothing.</span> <span> - </span> <span class="display-name">Daniel A. White</span> <span> </span> <span class="date">10 Sep 2009 at 17:28</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>@Daniel: <code>!</code> still flips the value to the right. In the case of a boolean the right-most <code>!</code> negates the value, while the left-most <code>!</code> negates it once again. Net effect is that there is no change, but most engines will generate op codes for the double negation.</span> <span> - </span> <span class="display-name">Crescent Fresh</span> <span> </span> <span class="date">10 Sep 2009 at 17:34</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>93</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Christoph</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Sep 2009 at 21:15</span>
     </div>
    </div>
    <div>
     <p><code>!!foo</code> applies the unary <em>not</em> operator twice and is used to cast to a Boolean type similar to the use of unary plus <code>+foo</code> to cast to a number and concatenating an empty string <code>''+foo</code> to cast to a string.</p>
     <p>Instead of these hacks, you can also use the constructor functions corresponding to the primitive types (<em>without</em> using <code>new</code>) to explicitly cast values, i.e.,</p>
     <pre><code>Boolean(foo) === !!foo
Number(foo)  === +foo
String(foo)  === ''+foo
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>But then you can run into issues with instanceof. new Boolean(1) instanceof Object -&gt; true !!1 instanceof Object -&gt; false</span> <span> - </span> <span class="display-name">Seamus</span> <span> </span> <span class="date">7 Oct 2010 at 12:53</span></td>
       </tr>
       <tr>
        <td>16</td>
        <td><span>no, you can't: notice that the constructor functions are called without <code>new</code> - as explicitly mentioned in my answer</span> <span> - </span> <span class="display-name">Christoph</span> <span> </span> <span class="date">8 Oct 2010 at 09:46</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>fantastic! This is useful for a little hack when you need to evaluate strings with "0" as false instead of true. (i.e. when reading values from selects, because they are read as String). So, if you want to consider "0" as negative (Boolean false), asuming <code>x="0"</code> just do: <code>x=!!+x; //false</code> which is the same as <code>Boolean(Number(x))</code> Number (or +x) converts the string "0" to 0, which DOES evaluate to false, and then Boolean (!!x) casts it to boolean directly. Easy peasy!</span> <span> - </span> <span class="display-name">DiegoDD</span> <span> </span> <span class="date">3 Jun 2013 at 18:13</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@DiegoDD why would you choose <code>!!+x</code> vs <code>x !== "0"</code>?</span> <span> - </span> <span class="display-name">placeybordeaux</span> <span> </span> <span class="date">29 Dec 2015 at 23:46</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@placeybordeaux because for example you may want to convert the value and assign it to other variable, regardless if you are going to compare it to something else or not.</span> <span> - </span> <span class="display-name">DiegoDD</span> <span> </span> <span class="date">5 Jan 2016 at 18:26</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I do hope this becomes the accepted answer <code>Boolean(foo)</code> is clearer to read for everyone than <code>!!foo</code>. Code should be written so that others can read it, not for minor performance gains or for neat tricks.</span> <span> - </span> <span class="display-name">icc97</span> <span> </span> <span class="date">4 Mar 2022 at 10:15</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>92</span>
     </div>
     <div>
      <span>Answerer: </span> <span>ruffin</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Apr 2015 at 18:14</span>
     </div>
    </div>
    <div>
     <p>So many answers doing half the work. Yes, <code>!!X</code> could be read as "the truthiness of X [represented as a Boolean]". But <code>!!</code> isn't, practically speaking, so important for figuring out whether a single variable is (or even if many variables are) truthy or falsy. <code>!!myVar === true</code> is the same as just <code>myVar</code>. Comparing <code>!!X</code> to a "real" Boolean isn't really useful.</p>
     <p>The only thing you gain with <code>!!</code> is the ability to check the truthiness of multiple variables <em>against each other</em> in a repeatable, standardized (and <a href="https://en.wikipedia.org/wiki/JSLint" rel="nofollow noreferrer">JSLint</a> friendly) fashion.</p>
     <h3>Simply casting :(</h3>
     <p>That is...</p>
     <ul>
      <li><code>0 === false</code> is <code>false</code>.</li>
      <li><code>!!0 === false</code> is <code>true</code>.</li>
     </ul>
     <p>The above's not so useful. <code>if (!0)</code> gives you the same results as <code>if (!!0 === false)</code>. I can't think of a good case for casting a variable to Boolean and then comparing to a "true" Boolean.</p>
     <p>See "== and !=" from <a href="https://web.archive.org/web/20151116022846/http://old.jslint.com/lint.html#eqeq" rel="nofollow noreferrer">JSLint's directions</a> (note: site has changed; this is an archived copy) for a little on why:</p>
     <blockquote>
      <p>The == and != operators do type coercion before comparing. This is bad because it causes ' \t\r\n' == 0 to be true. This can mask type errors. JSLint cannot reliably determine if == is being used correctly, so it is best to not use == and != at all and to always use the more reliable === and !== operators instead.</p>
      <p>If you only care that a value is truthy or falsy, then use the short form. Instead of<br><code>(foo != 0)</code></p>
      <p>just say<br><code>(foo)</code></p>
      <p>and instead of<br><code>(foo == 0)</code></p>
      <p>say<br><code>(!foo)</code></p>
     </blockquote>
     <p>Note that there are some <a href="https://stackoverflow.com/a/3619813/1028230">unintuitive cases</a> where a Boolean will be cast to a number (<code>true</code> is cast to <code>1</code> and <code>false</code> to <code>0</code>) when comparing a Boolean to a number. In this case, <code>!!</code> might be mentally useful. Though, again, <strong>these are cases where you're comparing a non-Boolean to a hard-typed Boolean, which is, in my opinion, a serious mistake.</strong> <code>if (-1)</code> is still the way to go here.</p>
     <div class="s-table-container">
      <table class="s-table">
       <thead>
        <tr>
         <th><strong>Original</strong></th>
         <th><strong>Equivalent</strong></th>
         <th><strong>Result</strong></th>
         <th><strong>Notes</strong></th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td><code>if (-1 == true) console.log("spam")</code></td>
         <td><code>if (-1 == 1)</code></td>
         <td>undefined</td>
         <td></td>
        </tr>
        <tr>
         <td><code>if (-1 == false) console.log("spam")</code></td>
         <td><code>if (-1 == 0)</code></td>
         <td>undefined</td>
         <td></td>
        </tr>
        <tr>
         <td><code>if (true == -1) console.log("spam")</code></td>
         <td><code>if (1 == -1)</code></td>
         <td>undefined</td>
         <td>Order doesn't<br>
          matter...</td>
        </tr>
        <tr>
         <td><code>if (!!-1 == true) console.log("spam")</code></td>
         <td><code>if (true == true)</code></td>
         <td>spam</td>
         <td>better</td>
        </tr>
        <tr>
         <td><code>if (-1) console.log("spam")</code></td>
         <td><code>if (truthy)</code></td>
         <td>spam</td>
         <td>still best</td>
        </tr>
       </tbody>
      </table>
     </div>
     <p>And things get even crazier depending on your engine. <a href="https://en.wikipedia.org/wiki/Windows_Script_Host" rel="nofollow noreferrer">WScript</a>, for instance, wins the prize.</p>
     <pre><code>function test()
{
    return (1 === 1);
}
WScript.echo(test());
</code></pre>
     <p>Because of <a href="https://stackoverflow.com/a/14462348/1028230">some historical Windows jive</a>, that'll output -1 in a message box! Try it in a cmd.exe prompt and see! But <code>WScript.echo(-1 == test())</code> still gives you 0, or WScript's <code>false</code>. <a href="https://www.google.com/search?q=look+away+I%27m+hideous" rel="nofollow noreferrer">Look away. It's hideous.</a></p>
     <h3>Comparing truthiness :)</h3>
     <p>But what if I have two values I need to check for equal truthiness/falsiness?</p>
     <p>Pretend we have <code>myVar1 = 0;</code> and <code>myVar2 = undefined;</code>.</p>
     <ul>
      <li><code>myVar1 === myVar2</code> is <code>0 === undefined</code> and is obviously false.</li>
      <li><code>!!myVar1 === !!myVar2</code> is <code>!!0 === !!undefined</code> and is true! Same truthiness! (In this case, both "have a truthiness of falsy".)</li>
     </ul>
     <p>So the only place you'd really need to use "Boolean-cast variables" would be if you had a situation where you're checking if both variables have the <em>same</em> truthiness, right? That is, <b>use <code>!!</code> if you need to see if two variables are <em>both truthy or both falsy</em> (or not), that is, <em>of equal</em> (or not) <em>truthiness</em>.</b></p>
     <p>I can't think of a great, non-contrived use case for that offhand. Maybe you have "linked" fields in a form?</p>
     <pre><code>if (!!customerInput.spouseName !== !!customerInput.spouseAge ) {
    errorObjects.spouse = "Please either enter a valid name AND age "
        + "for your spouse or leave all spouse fields blank.";
}
</code></pre>
     <p>So now if you have a truthy for both <em>or</em> a falsy for both spouse name and age, you can continue. Otherwise you've only got one field with a value (or a very early arranged marriage) and need to create an extra error on your <code>errorObjects</code> collection.</p>
     <p>Though even in this case, the <code>!!</code> really is superfluous. One <code>!</code> was enough to cast to a Boolean, and you're just checking equality.</p>
     <hr>
     <p><strong>EDIT 24 Oct 2017, 6 Feb 19:</strong></p>
     <h2>Third-party libraries that expect explicit Boolean values</h2>
     <p>Here's an interesting case... <code>!!</code> might be useful when third-party libraries expect explicit Boolean values.</p>
     <h3>React</h3>
     <p>For instance, <a href="https://react-cn.github.io/react/tips/false-in-jsx.html" rel="nofollow noreferrer">False in JSX (React) has a special meaning</a> that's not triggered on simple falsiness. If you tried returning something like the following in your JSX, expecting an int in <code>messageCount</code>...</p>
     <p><code>{messageCount &amp;&amp; &lt;div&gt;You have messages!&lt;/div&gt;}</code></p>
     <p>... you might be surprised to see React render a <code>0</code> when you have zero messages. You have to explicitly return false for JSX not to render. The above statement returns <code>0</code>, which JSX happily renders, as it should. It can't tell you didn't have <code>Count: {messageCount}</code>.</p>
     <ul>
      <li>
       <p>One fix involves the bangbang, which coerces <code>0</code> into <code>!!0</code>, which is <code>false</code>: <code>{!!messageCount &amp;&amp; &lt;div&gt;You have messages!&lt;/div&gt;}</code></p></li>
      <li>
       <p>JSX' documentation suggests you be more explicit, write self-commenting code, and use a comparison to force to a Boolean. <code>{messageCount &gt; 0 &amp;&amp; &lt;div&gt;You have messages!&lt;/div&gt;}</code></p></li>
      <li>
       <p>I'm more comfortable handling falsiness myself with a ternary -- <code>{messageCount ? &lt;div&gt;You have messages!&lt;/div&gt; : false}</code></p></li>
     </ul>
     <h3>TypeScript</h3>
     <p>The same deal in TypeScript: If you have a function that returns a Boolean (or you're assigning a value to a Boolean variable), you [usually] can't return/assign a boolean-y value; it has to be a strongly typed boolean. This means, <strong>iff <code>myObject</code> is strongly typed</strong>, <code>return !myObject;</code> works for a function returning a Boolean, but <code>return myObject;</code> doesn't. You have to <code>return !!myObject</code> (or cast to the proper Boolean another way) to match TypeScript's expectations.</p>
     <blockquote>
      <p>The exception for TypeScript? If <code>myObject</code> was an <code>any</code>, you're back in JavaScript's Wild West and can return it without <code>!!</code>, even if your return type is a Boolean.</p>
     </blockquote>
     <p>Keep in mind that <strong>these <em>are JSX and TypeScript conventions</em>, not ones inherent to JavaScript</strong>.</p>
     <p>But if you see strange <code>0</code>s in your rendered JSX, think loose falsy management.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Good explanation. So would you say the !! is not strictly necessary in this <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" rel="nofollow noreferrer">Worker feature detection</a> example? <code>if (!!window.Worker)</code></span> <span> - </span> <span class="display-name">jk7</span> <span> </span> <span class="date">6 May 2015 at 20:41</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Nope, you wouldn't need it. Truthiness and <code>true</code> "externally" operate exactly the same in an <code>if</code>. I keep trying, but I can't think of a reason to prefer casting truthiness to a boolean value outside of the sort of convoluted "compare truthinesses" case, above, except for readability if you reuse the value later, as in the <code>q</code> library example. But even then, it's a information-lossy shortcut, and I'd argue you're better off evaluating truthiness each time.</span> <span> - </span> <span class="display-name">ruffin</span> <span> </span> <span class="date">6 May 2015 at 20:54</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>67</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Greg</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Apr 2009 at 08:18</span>
     </div>
    </div>
    <div>
     <p>It's just the logical NOT operator, twice. It's used to convert something to Boolean, e.g.:</p>
     <pre><code>true === !!10

false === !!0
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>35</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Paul McMillan</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Sep 2009 at 17:27</span>
     </div>
    </div>
    <div>
     <p>It converts the suffix to a Boolean value.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>32</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Steve Harrison</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Apr 2009 at 08:20</span>
     </div>
    </div>
    <div>
     <p>It seems that the <code>!!</code> operator results in a double negation.</p>
     <pre><code>var foo = "Hello, World!";

!foo // Result: false
!!foo // Result: true
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>32</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Bill the Lizard</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Sep 2009 at 17:28</span>
     </div>
    </div>
    <div>
     <p>It's a double <code>not</code> operation. The first <code>!</code> converts the value to Boolean and inverts its logical value. The second <code>!</code> inverts the logical value back.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>31</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Alireza</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Jun 2017 at 04:16</span>
     </div>
    </div>
    <div>
     <p><code>!!</code> is using the <code>NOT</code> operation twice together. <code>!</code> converts the value to a Boolean and reverses it, so using it twice, showing the Boolean (false or true) of that value. Here is a simple example to see how <code>!!</code> works:</p>
     <p>At first, the place you have:</p>
     <pre><code>var zero = 0;
</code></pre>
     <p>Then you do <code>!0</code>. It will be converted to Boolean and be evaluated to <code>true</code>, because 0 is <code>falsy</code>, so you get the reversed value and converted to Boolean, so it gets evaluated to <code>true</code>.</p>
     <pre><code>!zero; //true
</code></pre>
     <p>But we don't want the reversed <strong>Boolean version</strong> of the value, so we can reverse it again to get our result! That's why we use another <code>!</code>.</p>
     <p>Basically, <code>!!</code> makes us sure the value we get is Boolean, not falsy, truthy, string, etc...</p>
     <p>So it's like using the <em>Boolean</em> function in JavaScript, but an easier and shorter way to convert a value to Boolean:</p>
     <pre><code>var zero = 0;
!!zero; //false
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>30</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Prakash</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Mar 2011 at 11:53</span>
     </div>
    </div>
    <div>
     <p>It simulates the behavior of the <code>Boolean()</code> casting function. The first <code>NOT</code> returns a Boolean value no matter what operand it is given. The second <code>NOT</code> negates that <code>Boolean</code> value and so gives the <code>true</code> Boolean value of a variable. The end result is the same as using the <code>Boolean()</code> function on a value.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>When was that Boolean() function introduced? Is it actually a function (not a constructor?)? Can you link to documentation in your answer? (But <b><i>without</i></b> "Edit:", "Update:", or similar - the answer should appear as if it was written today.)</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">5 Aug 2022 at 12:04</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>OK, <i>"<a href="https://www.w3schools.com/js/js_booleans.asp" rel="nofollow noreferrer">The Boolean() Function</a>"</i>. But that is W3Schools. What is the official documentation?</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">5 Aug 2022 at 14:12</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span> <span class="arrow"> <a href="#answer_15">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>24</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Annika Backstrom</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Sep 2009 at 17:29</span>
     </div>
    </div>
    <div>
     <p>! is "Boolean not", which essentially typecasts the value of "enable" to its boolean opposite. The second ! flips this value. So, <code>!!enable</code> means "not not enable," giving you the value of <code>enable</code> as a Boolean.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_15"><span>Answer 15</span> <span class="arrow"> <a href="#answer_14">↑</a> </span> <span class="arrow"> <a href="#answer_16">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>23</span>
     </div>
     <div>
      <span>Answerer: </span> <span>GreQ</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 May 2016 at 10:18</span>
     </div>
    </div>
    <div>
     <p>I think worth mentioning is that a condition combined with logical AND/OR will not return a Boolean value, but the last success or first fail in case of <code>&amp;&amp;</code> and the first success or last fail in case of <code>||</code> of the condition chain.</p>
     <pre><code>res = (1 &amp;&amp; 2); // res is 2
res = (true &amp;&amp; alert) // res is function alert()
res = ('foo' || alert) // res is 'foo'
</code></pre>
     <p>In order to cast the condition to a true Boolean literal we can use the double negation:</p>
     <pre><code>res = !!(1 &amp;&amp; 2); // res is true
res = !!(true &amp;&amp; alert) // res is true
res = !!('foo' || alert) // res is true
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_16"><span>Answer 16</span> <span class="arrow"> <a href="#answer_15">↑</a> </span> <span class="arrow"> <a href="#answer_17">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>20</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Navin Rauniyar</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Apr 2014 at 04:29</span>
     </div>
    </div>
    <div>
     <p>The <code>!!</code> construct is a simple way of turning any JavaScript expression into its Boolean equivalent.</p>
     <p>For example: <code>!!"he shot me down" === true</code> and <code>!!0 === false</code>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>Very close to the important distinction. <b>Key is that <code>0 === false</code> is false and <code>!!0 === false</code> is true.</b></span> <span> - </span> <span class="display-name">ruffin</span> <span> </span> <span class="date">29 Apr 2015 at 17:38</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_17"><span>Answer 17</span> <span class="arrow"> <a href="#answer_16">↑</a> </span> <span class="arrow"> <a href="#answer_18">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>19</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Justin Johnson</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Sep 2009 at 21:19</span>
     </div>
    </div>
    <div>
     <p>It's not a single operator; it's two. It's equivalent to the following and is a quick way to cast a value to Boolean.</p>
     <pre><code>val.enabled = !(!enable);
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_18"><span>Answer 18</span> <span class="arrow"> <a href="#answer_17">↑</a> </span> <span class="arrow"> <a href="#answer_19">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>19</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Twitter khuong291</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Jul 2018 at 03:52</span>
     </div>
    </div>
    <div>
     <p>It forces all things to Boolean.</p>
     <p>For example:</p>
     <pre><code>console.log(undefined);   // -&gt; undefined
console.log(!undefined);  // -&gt; true
console.log(!!undefined); // -&gt; false

console.log('abc');   // -&gt; abc
console.log(!'abc');  // -&gt; false
console.log(!!'abc'); // -&gt; true

console.log(0 === false);   // -&gt; false
console.log(!0 === false);  // -&gt; false
console.log(!!0 === false); // -&gt; true
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_19"><span>Answer 19</span> <span class="arrow"> <a href="#answer_18">↑</a> </span> <span class="arrow"> <a href="#answer_20">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>16</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Darren Clark</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Apr 2009 at 08:33</span>
     </div>
    </div>
    <div>
     <p>I suspect this is a leftover from C++ where people override the <code>!</code> operator, but not the <em>bool</em> operator.</p>
     <p>So to get a negative (or positive) answer in that case, you would first need to use the <code>!</code> operator to get a Boolean, but if you wanted to check the positive case you would use <code>!!</code>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_20"><span>Answer 20</span> <span class="arrow"> <a href="#answer_19">↑</a> </span> <span class="arrow"> <a href="#answer_21">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>15</span>
     </div>
     <div>
      <span>Answerer: </span> <span>KWallace</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Mar 2019 at 18:43</span>
     </div>
    </div>
    <div>
     <p>This question has been answered quite thoroughly, but I'd like to add an answer that I hope is as simplified as possible, making the meaning of !! as simple to grasp as can be.</p>
     <p>Because JavaScript has what are called "truthy" and "falsy" values, there are expressions that when evaluated in other expressions will result in a true or false condition, even though the value or expression being examined is not actually <code>true</code> or <code>false</code>.</p>
     <p>For instance:</p>
     <pre><code>if (document.getElementById('myElement')) {
    // Code block
}
</code></pre>
     <p>If that element does in fact exist, the expression will evaluate as true, and the code block will be executed.</p>
     <p>However:</p>
     <pre><code>if (document.getElementById('myElement') == true) {
    // Code block
}
</code></pre>
     <p>...will <em>not</em> result in a true condition, and the code block will not be executed, even if the element does exist.</p>
     <p>Why? Because <code>document.getElementById()</code> is a "truthy" expression that will evaluate as true in this <code>if()</code> statement, but it is not an actual Boolean value of <code>true</code>.</p>
     <p>The double "not" in this case is quite simple. It is simply two <code>not</code>s back to back.</p>
     <p>The first one simply "inverts" the truthy or falsy value, resulting in an actual Boolean type, and then the second one "inverts" it back again to its original state, but now in an actual Boolean value. That way you have consistency:</p>
     <pre><code>if (!!document.getElementById('myElement')) {}
</code></pre>
     <p>and</p>
     <pre><code>if (!!document.getElementById('myElement') == true) {}
</code></pre>
     <p>will <em>both</em> return true, as expected.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_21"><span>Answer 21</span> <span class="arrow"> <a href="#answer_20">↑</a> </span> <span class="arrow"> <a href="#answer_22">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>14</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Damian Yerrick</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Mar 2016 at 14:46</span>
     </div>
    </div>
    <div>
     <p>The <code>if</code> and <code>while</code> statements and the <code>?</code> operator use truth values to determine which branch of code to run. For example, zero and NaN numbers and the empty string are false, but other numbers and strings are true. Objects are true, but the undefined value and <code>null</code> are both false.</p>
     <p>The double negation operator <code>!!</code> calculates the truth value of a value. It's actually two operators, where <code>!!x</code> means <code>!(!x)</code>, and behaves as follows:</p>
     <ul>
      <li>If <code>x</code> is a false value, <code>!x</code> is <code>true</code>, and <code>!!x</code> is <code>false</code>.</li>
      <li>If <code>x</code> is a true value, <code>!x</code> is <code>false</code>, and <code>!!x</code> is <code>true</code>.</li>
     </ul>
     <p>When used at the top level of a Boolean context (<code>if</code>, <code>while</code>, or <code>?</code>), the <code>!!</code> operator is behaviorally a no-op. For example, <code>if (x)</code> and <code>if (!!x)</code> mean the same thing.</p>
     <h2>Practical uses</h2>
     <p>However it has several practical uses.</p>
     <p>One use is to lossily compress an object to its truth value, so that your code isn't holding a reference to a big object and keeping it alive. Assigning <code>!!some_big_object</code> to a variable instead of <code>some_big_object</code> lets go of it for the garbage collector. This is useful for cases that produce either an object or a false value such as <code>null</code> or the undefined value, such as browser feature detection.</p>
     <p>Another use, which I mentioned in an <a href="https://stackoverflow.com/a/35525827/2738262">answer about C's corresponding <code>!!</code> operator</a>, is with "lint" tools that look for common typos and print diagnostics. For example, in both C and JavaScript, a few common typos for Boolean operations produce other behaviors whose output isn't quite as Boolean:</p>
     <ul>
      <li><code>if (a = b)</code> is assignment followed by use of the truth value of <code>b</code>; <code>if (a == b)</code> is an equality comparison.</li>
      <li><code>if (a &amp; b)</code> is a bitwise AND; <code>if (a &amp;&amp; b)</code> is a logical AND. <code>2 &amp; 5</code> is <code>0</code> (a false value); <code>2 &amp;&amp; 5</code> is true.</li>
     </ul>
     <p>The <code>!!</code> operator reassures the lint tool that what you wrote is what you meant: do this operation, then take the truth value of the result.</p>
     <p>A third use is to produce logical XOR and logical XNOR. In both C and JavaScript, <code>a &amp;&amp; b</code> performs a logical AND (true if both sides are true), and <code>a &amp; b</code> performs a bitwise AND. <code>a || b</code> performs a logical OR (true if at least one are true), and <code>a | b</code> performs a bitwise OR. There's a bitwise XOR (exclusive OR) as <code>a ^ b</code>, but there's no built-in operator for logical XOR (true if exactly one side is true). You might, for example, want to allow the user to enter text in exactly one of two fields. What you can do is convert each to a truth value and compare them: <code>!!x !== !!y</code>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_22"><span>Answer 22</span> <span class="arrow"> <a href="#answer_21">↑</a> </span> <span class="arrow"> <a href="#answer_23">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>11</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Sergey Ilinsky</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Dec 2010 at 20:21</span>
     </div>
    </div>
    <div>
     <p>It is double Boolean negation. It is often used to check if a value is not undefined.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_23"><span>Answer 23</span> <span class="arrow"> <a href="#answer_22">↑</a> </span> <span class="arrow"> <a href="#answer_24">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>11</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ryan Taylor</span>
     </div>
     <div>
      <span> Answered: </span> <span>19 Oct 2016 at 21:00</span>
     </div>
    </div>
    <div>
     <p>I just wanted to add that</p>
     <pre><code>if(variableThing){
  // do something
}
</code></pre>
     <p>is the same as</p>
     <pre><code>if(!!variableThing){
  // do something
}
</code></pre>
     <p>But this can be an issue when something is undefined.</p>
     <pre><code>// a === undefined, b is an empty object (eg. b.asdf === undefined)
var a, b = {};

// Both of these give error a.foo is not defined etc.
// you'd see the same behavior for !!a.foo and !!b.foo.bar

a.foo 
b.foo.bar

// This works -- these return undefined

a &amp;&amp; a.foo
b.foo &amp;&amp; b.foo.bar
b &amp;&amp; b.foo &amp;&amp; b.foo.bar
</code></pre>
     <p>The trick here is the chain of <code>&amp;&amp;</code>s will return <strong>the first falsey value</strong> it finds -- and this can be fed to an if statement etc. So if b.foo is undefined, it will return undefined and skip the <code>b.foo.bar</code> statement, and we get no error.</p>
     <p>The above return undefined but if you have an empty string, false, null, 0, undefined those values will return and soon as we encounter them in the chain -- <code>[]</code> and <code>{}</code> are both "truthy" and we will continue down the so-called "&amp;&amp; chain" to the next value to the right.</p>
     <p><strong>P.S.</strong> Another way of doing the above (<code>b &amp;&amp; b.foo</code>) is <code>(b || {}).foo</code>. Those are equivalent, because if b is undefined then <code>b || {}</code> will be <code>{}</code>, and you'll be accessing a value in an empty object (no error) instead of trying to access a value within "undefined" (causes an error).</p>
     <p>So, <code>(b || {}).foo</code> is the same as <code>b &amp;&amp; b.foo</code> and <code>((b || {}).foo || {}).bar</code> is the same as <code>b &amp;&amp; b.foo &amp;&amp; b.foo.bar</code>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_24"><span>Answer 24</span> <span class="arrow"> <a href="#answer_23">↑</a> </span> <span class="arrow"> <a href="#answer_25">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>10</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Warren Davis</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Apr 2014 at 13:05</span>
     </div>
    </div>
    <div>
     <p>There are tons of great answers here, but if you've read down this far, this helped me to 'get it'. Open the console in Chrome (etc.), and start typing:</p>
     <pre><code>!(!(1))
!(!(0))
!(!('truthy')) 
!(!(null))
!(!(''))
!(!(undefined))
!(!(new Object())
!(!({}))
woo = 'hoo'
!(!(woo))
...etc., etc., until the light goes on ;)
</code></pre>
     <p>Naturally, these are all the same as merely typing !!someThing, but the added parentheses might help make it more understandable.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Re <i>"Open the console in Chrome"</i>: Can you be more specific (instructions)? (But (<b><i>without</i></b> "Edit:", "Update:", or similar - the answer should appear as if it was written today).)</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">5 Aug 2022 at 12:14</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_25"><span>Answer 25</span> <span class="arrow"> <a href="#answer_24">↑</a> </span> <span class="arrow"> <a href="#answer_26">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>10</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Greg Gum</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Dec 2015 at 12:50</span>
     </div>
    </div>
    <div>
     <p><code>!!x</code> is shorthand for <code>Boolean(x)</code>.</p>
     <p>The first bang forces the JavaScript engine to run <code>Boolean(x)</code>, but it also has the side effect of inverting the value. So the second bang undoes the side effect.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_26"><span>Answer 26</span> <span class="arrow"> <a href="#answer_25">↑</a> </span> <span class="arrow"> <a href="#answer_27">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Wouter Vanherck</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Mar 2017 at 07:15</span>
     </div>
    </div>
    <div>
     <p>After seeing all these great answers, I would like to add another reason for using <code>!!</code>. Currently I'm working in Angular 2-4 (TypeScript) and I want to return a Boolean as <code>false</code> when my user is not authenticated. If he isn't authenticated, the token-string would be <code>null</code> or <code>""</code>. I can do this by using the next block of code:</p>
     <pre><code>public isAuthenticated(): boolean {
   return !!this.getToken();
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_27"><span>Answer 27</span> <span class="arrow"> <a href="#answer_26">↑</a> </span> <span class="arrow"> <a href="#answer_28">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>efkan</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Jul 2017 at 07:03</span>
     </div>
    </div>
    <div>
     <p>It returns the Boolean value of a variable.</p>
     <p>Instead, the <code>Boolean</code> class can be used.</p>
     <p>(Please read the code descriptions.)</p>
     <pre><code>var X = "test"; // The X value is "test" as a String value
var booleanX = !!X // booleanX is `true` as a Boolean value because non-empty strings evaluates as `true` in Boolean
var whatIsXValueInBoolean = Boolean(X) // whatIsXValueInBoolean is `true` again
console.log(Boolean(X) === !!X) // Writes `true`
</code></pre>
     <p>Namely, <code>Boolean(X) = !!X</code> in use.</p>
     <p>Please check code snippet out below <strong>↓</strong></p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>let a = 0
console.log("a: ", a) // Writes a value in its kind
console.log("!a: ", !a) // Writes '0 is NOT true in Boolean' value as Boolean - so that's true. In Boolean, 0 means false and 1 means true.
console.log("!!a: ", !!a) // Writes 0 value in Boolean. 0 means false.
console.log("Boolean(a): ", Boolean(a)) // Equals `!!a`
console.log("\n") // Newline

a = 1
console.log("a: ", a)
console.log("!a: ", !a)
console.log("!!a: ", !!a) // Writes 1 value in Boolean
console.log("\n") // Newline

a = ""
console.log("a: ", a)
console.log("!a: ", !a) // Writes '"" is NOT true in Boolean' value as Boolean - so that's true. In Boolean, empty strings, null and undefined values mean false and if there is a string it means true.
console.log("!!a: ", !!a) // Writes "" value in Boolean
console.log("\n") // Newline

a = "test"
console.log("a: ", a) // Writes a value in its kind
console.log("!a: ", !a)
console.log("!!a: ", !!a) // Writes "test" value in Boolean

console.log("Boolean(a) === !!a: ", Boolean(a) === !!a) // writes true</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>Upvoted.. Was actually gonna answer with this if not here already. Using the Boolean object imo is a better approach from a readability standpoint. For example, there is no "what does Boolean do" SO question with 3k plus upvotes - like this current question.</span> <span> - </span> <span class="display-name">iPzard</span> <span> </span> <span class="date">26 Jan 2021 at 20:47</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_28"><span>Answer 28</span> <span class="arrow"> <a href="#answer_27">↑</a> </span> <span class="arrow"> <a href="#answer_29">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Lucky Brain</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Jan 2021 at 13:52</span>
     </div>
    </div>
    <div>
     <p>It is important to remember the evaluations to <code>true</code> and <code>false</code> in <strong>JavaScript</strong>:</p>
     <ul>
      <li>
       <p>Everything with a "Value" is <code>true</code> (namely <strong>truthy</strong>), for example:</p>
       <ul>
        <li><code>101</code>,</li>
        <li><code>3.1415</code>,</li>
        <li><code>-11</code>,</li>
        <li><code>"Lucky Brain"</code>,</li>
        <li><code>new Object()</code></li>
        <li>and, of course, <code>true</code></li>
       </ul></li>
      <li>
       <p>Everything without a "Value" is <code>false</code> (namely <strong>falsy</strong>), for example:</p>
       <ul>
        <li><code>0</code>,</li>
        <li><code>-0</code>,</li>
        <li><code>""</code> (empty string),</li>
        <li><code>undefined</code>,</li>
        <li><code>null</code>,</li>
        <li><code>NaN</code> (not a number)</li>
        <li>and, of course, <code>false</code></li>
       </ul></li>
     </ul>
     <p>Applying the "<strong>logical not</strong>" operator (<code>!</code>) evaluates the operand, converting it to <code>boolean</code> and then negating it. Applying it twice will negate the negation, effectively converting the value to <code>boolean</code>. Not applying the operator will just be a regular assignment of the exact value. Examples:</p>
     <pre><code>var value = 23; // number
var valueAsNegatedBoolean = !value; // boolean falsy (because 23 is truthy)
var valueAsBoolean = !!value; // boolean truthy
var copyOfValue = value; // number 23

var value2 = 0;
var value2AsNegatedBoolean = !value2; // boolean truthy (because 0 is falsy)
var value2AsBoolean = !!value2; // boolean falsy
var copyOfValue2 = value2; // number 0
</code></pre>
     <ul>
      <li><code>value2 = value;</code> assigns the exact object <code>value</code> even if it is not <code>boolean</code> hence <code>value2</code> won't necessarily end up being <code>boolean</code>.</li>
      <li><code>value2 = !!value;</code> assigns a guaranteed <code>boolean</code> as the result of the double negation of the operand <code>value</code> and it is equivalent to the following but much shorter and readable:</li>
     </ul>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>if (value) {
  value2 = true;
} else {
  value2 = false;
}</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>How does this add anything new or useful to the other answers?</span> <span> - </span> <span class="display-name">Andreas</span> <span> </span> <span class="date">21 Jan 2021 at 17:36</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>None of the other answers clarifies the concepts of how JavaScript evaluates what is <b>truthy</b> or <b>falsy</b>. Novice JavaScript developers need to know that the "not not" operator is using implicitly the original loose comparison method instead of the exact <code>===</code> or <code>!==</code> operators and also the hidden cast operation that is happening behind the scenes and I show it in the example I provide.</span> <span> - </span> <span class="display-name">Lucky Brain</span> <span> </span> <span class="date">22 Jan 2021 at 01:33</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_29"><span>Answer 29</span> <span class="arrow"> <a href="#answer_28">↑</a> </span> <span class="arrow"> <a href="#answer_30">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>JeevanReddy Avanaganti</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Mar 2015 at 08:25</span>
     </div>
    </div>
    <div>
     <p>Here is a piece of code from AngularJS:</p>
     <pre><code>var requestAnimationFrame = $window.requestAnimationFrame ||
                            $window.webkitRequestAnimationFrame ||
                            $window.mozRequestAnimationFrame;

var rafSupported = !!requestAnimationFrame;
</code></pre>
     <p>Their intention is to set rafSupported to true or false based on the availability of function in requestAnimationFrame.</p>
     <p>It can be achieved by checking in the following way in general:</p>
     <pre><code>if(typeof requestAnimationFrame === 'function')
    rafSupported =true;
else
    rafSupported =false;
</code></pre>
     <p>The short way could be using <code>!!</code></p>
     <pre><code>rafSupported = !!requestAnimationFrame;
</code></pre>
     <p>So if requestAnimationFrame was assigned a function then !requestAnimationFrame would be false and one more <code>!</code> of it would be true.</p>
     <p>If requestAnimationFrame was assigned undefined then !requestAnimationFrame would be true and one more <code>!</code> of it would be false.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_30"><span>Answer 30</span> <span class="arrow"> <a href="#answer_29">↑</a> </span> <span class="arrow"> <a href="#answer_31">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Abhay Dixit</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Jul 2016 at 10:25</span>
     </div>
    </div>
    <div>
     <p>Use the logical not operator two times.</p>
     <p>It means <code>!true = false</code> <em>and</em> <code>!!true = true</code>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_31"><span>Answer 31</span> <span class="arrow"> <a href="#answer_30">↑</a> </span> <span class="arrow"> <a href="#answer_32">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>GibboK</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Jul 2015 at 07:29</span>
     </div>
    </div>
    <div>
     <p>Some operators in JavaScript perform implicit type conversions, and are sometimes used for type conversion.</p>
     <p>The unary <code>!</code> operator converts its operand to a Boolean and negates it.</p>
     <p>This fact leads to the following idiom that you can see in your source code:</p>
     <pre><code>!!x // Same as Boolean(x). Note double exclamation mark
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_32"><span>Answer 32</span> <span class="arrow"> <a href="#answer_31">↑</a> </span> <span class="arrow"> <a href="#answer_33">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mystical</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Apr 2017 at 14:47</span>
     </div>
    </div>
    <div>
     <p><code>!!</code> is similar to using the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean" rel="nofollow noreferrer"><em>Boolean constructor</em></a>, or arguably more like the <a href="https://www.w3schools.com/js/js_booleans.asp" rel="nofollow noreferrer"><em>Boolean function.</em></a></p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>console.log(Boolean(null)); // Preferred over the Boolean object

console.log(new Boolean(null).valueOf()); // Not recommended for converting non-Boolean values

console.log(!!null); // A hacky way to omit calling the Boolean function, but essentially does the same thing.


// The context you saw earlier (your example)
var vertical;

function Example(vertical)
{
        this.vertical = vertical !== undefined ? !!vertical :
        this.vertical;
        // Let's break it down: If vertical is strictly not undefined, return the Boolean value of vertical and set it to this.vertical. If not, don't set a value for this.vertical (just ignore it and set it back to what it was before; in this case, nothing).

        return this.vertical;
}

console.log("\n---------------------")

// vertical is currently undefined

console.log(new Example(vertical).vertical); // The falsy or truthy value of this.vertical
console.log(!!new Example(vertical).vertical); // Coerced value of this.vertical

vertical = 12.5; // Set vertical to 12.5, a truthy value.
console.log(new Example(vertical).vertical); // The falsy or truthy value of this.vertical which happens to be true anyway
console.log(!!new Example(vertical).vertical); // Coerced value of this.vertical

vertical = -0; // Set vertical to -0, a falsy value.
console.log(new Example(vertical).vertical); // The falsy or truthy value of this.vertical which happens to be false either way
console.log(!!new Example(vertical).vertical); // Coerced value of this.vertical</code></pre>
      </div>
     </div>
     <p></p>
     <p><em>Falsy values</em> in JavaScript <strong>coerce</strong> to <em>false</em>, and <em>truthy values</em> <strong>coerce</strong> to <em>true.</em> Falsy and truthy values can also be used in <code>if</code> statements and will essentially "map" to their corresponding Boolean value. However, you will probably not find yourself having to use proper Boolean values often, as they mostly differ in output (return values).</p>
     <blockquote>
      <p>Although this may seem similar to casting, realistically this is likely a <em>mere</em> coincidence and is not 'built' or purposely made for and like a Boolean cast. So let's not call it that.</p>
     </blockquote>
     <hr>
     <h3>Why and how it works</h3>
     <p>To be concise, it looks something like this: <code>! ( !null )</code>. Whereas, <code>null</code> is <strong>falsy</strong>, so <code>!null</code> would be <strong>true</strong>. Then <code>!true</code> would be <strong>false</strong> and it would essentially <em>invert back</em> to what it was before, except this time as a <em>proper Boolean value</em> (or even <em>vice versa</em> with <em>truthy values</em> like <code>{}</code> or <code>1</code>).</p>
     <br>
     <h3>Going back to your example</h3>
     <p>Overall, the context that you saw simply adjusts <code>this.vertical</code> depending on whether or not <code>vertical</code> is defined, and if so; it will be set to the resulting Boolean value of vertical, otherwise it will not change. In other words, if <code>vertical</code> is defined; <code>this.vertical</code> will be set to the Boolean value of it, otherwise, it will stay the same. I guess that in itself is an example of how you would use <code>!!</code>, and what it does.</p>
     <br>
     <h3>Vertical I/O Example</h3>
     <p>Run this example and fiddle around with the vertical value in the input. See what the result coerces to so that you can fully understand your context's code. In the input, enter any valid JavaScript value.</p>
     <p><strong>Remember to include the quotations if you are testing out a string.</strong> Don't mind the CSS and HTML code too much, simply run this snippet and play around with it. However, you might want to take a look at the non-DOM-related JavaScript code though (the use of the Example constructor and the vertical variable).</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>var vertical = document.getElementById("vertical");
var p = document.getElementById("result");

function Example(vertical)
{
        this.vertical = vertical !== undefined ? !!vertical :
        this.vertical;

        return this.vertical;
}

document.getElementById("run").onclick = function()
{

  p.innerHTML = !!(new Example(eval(vertical.value)).vertical);

}</code></pre>
       <pre class="snippet-code-css lang-css prettyprint-override"><code>input
{
  text-align: center;
  width: 5em;
}

button
{
  margin: 15.5px;
  width: 14em;
  height: 3.4em;
  color: blue;
}

var
{
  color: purple;
}

p {
  margin: 15px;
}

span.comment {
  color: brown;
}</code></pre>
       <pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;!--Vertical I/O Example--&gt;
&lt;h4&gt;Vertical Example&lt;/h4&gt;
&lt;code id="code"&gt;&lt;var class="var"&gt;var&lt;/var&gt; vertical = &lt;input type="text" id="vertical" maxlength="9" /&gt;; &lt;span class="comment"&gt;//Enter any valid JavaScript value&lt;/span&gt;&lt;/code&gt;
&lt;br /&gt;
&lt;button id="run"&gt;Run&lt;/button&gt;
&lt;p id="result"&gt;...&lt;/p&gt;</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_33"><span>Answer 33</span> <span class="arrow"> <a href="#answer_32">↑</a> </span> <span class="arrow"> <a href="#answer_34">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Umesh Bhutada</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Apr 2022 at 07:39</span>
     </div>
    </div>
    <div>
     <p><code>!!</code> is simply the NOT operator twice. The net effect is just converting anything to ensure a Boolean data type. For example.</p>
     <p>!!undefined is false <br>
       !!0 is false <br>
       !!null is false <br>
       !!anyobject is true <br>
       !!true is true <br>
       !!false is false <br>
       !0 is true <br>
       !1 is false <br>
       !!'' is false</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_34"><span>Answer 34</span> <span class="arrow"> <a href="#answer_33">↑</a> </span> <span class="arrow"> <a href="#answer_35">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Lakmal</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Oct 2019 at 19:56</span>
     </div>
    </div>
    <div>
     <p>To cast your JavaScript variables to Boolean,</p>
     <pre><code>var firstname = "test";
// Type of firstname is string

var firstNameNotEmpty = !!firstname;
// Type of firstNameNotEmpty is Boolean
</code></pre>
     <p>JavaScript <strong>false</strong> for <em>""</em>, <em>0</em>, <em>undefined</em>, and <em>null</em>.</p>
     <p>JavaScript is <strong>true</strong> for number other than <em>zero</em>, <em>not empty strings</em>, <em>{}</em>, <em>[]</em> and <em>new Date()</em> so,</p>
     <pre><code>!!("test") /* Is true */
!!("") /* Is false */
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_35"><span>Answer 35</span> <span class="arrow"> <a href="#answer_34">↑</a> </span> <span class="arrow"> <a href="#answer_36">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user3698272</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Jun 2014 at 03:35</span>
     </div>
    </div>
    <div>
     <pre><code>a = 1;
alert(!a) // -&gt; false : a is not not defined
alert(!!a) // -&gt; true : a is not not defined
</code></pre>
     <p>For <code>!a</code>, it checks whether <code>a</code> is <strong>NOT</strong> defined, while <code>!!a</code> checks if the variable is defined.</p>
     <p><code>!!a</code> is the same as <code>!(!a)</code>. If <code>a</code> is defined, <code>a</code> is <code>true</code>, <code>!a</code> is <code>false</code>, and <code>!!a</code> is <code>true</code>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_36"><span>Answer 36</span> <span class="arrow"> <a href="#answer_35">↑</a> </span> <span class="arrow"> <a href="#answer_37">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Abdulsalam</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Sep 2022 at 11:39</span>
     </div>
    </div>
    <div>
     <p>This is the simplest answer I've found: It is equivalent to <code>Boolean(value)</code> in how it works.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_37"><span>Answer 37</span> <span class="arrow"> <a href="#answer_36">↑</a> </span> <span class="arrow"> <a href="#answer_38">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>anatol</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Oct 2022 at 05:16</span>
     </div>
    </div>
    <div>
     <p>You can consider <code>!!</code> in this way:</p>
     <ol>
      <li>When the first <code>!</code> applies, the variable becomes boolean, but with an opposite value</li>
      <li>Then, the second <code>!</code> just recovers a justice and revert value back to its original equivalent</li>
     </ol>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_38"><span>Answer 38</span> <span class="arrow"> <a href="#answer_37">↑</a> </span> <span class="arrow"> <a href="#answer_39">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>nguyenhoavuong</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Nov 2021 at 03:56</span>
     </div>
    </div>
    <div>
     <p><code>!!</code> is not an operator. It's just the <code>!</code> operator twice.</p>
     <p>But with JavaScript, apply <code>!!</code> for converting Object to Boolean is redundant and verbose in the most cases because:</p>
     <blockquote>
      <p>Any object of which the value is not undefined or null, including a Boolean object whose value is false, evaluates to true when passed to a conditional statement</p>
     </blockquote>
     <p>Example: <code>if ({}) { console.log("{} is true")} // logs: "{} is true"</code></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>"...a Boolean object whose value is false, evaluates to true when..." Huh? I mean JavaScript deserves hate for all it's stupidity, but I don't believe it is really that stupid is it?</span> <span> - </span> <span class="display-name">swpalmer</span> <span> </span> <span class="date">19 Nov 2021 at 15:18</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@swpalmer <a href="https://jsfiddle.net/rsgqb5zp/" rel="nofollow noreferrer">jsfiddle.net/rsgqb5zp</a> watch and be amazed! But less glibly there is a distinction between Boolean (big b) objects which are reference types and boolean (small b) which are value types. The if conditional checks reference types to see if they are not null or undefined.</span> <span> - </span> <span class="display-name">Tim Seguine</span> <span> </span> <span class="date">6 Dec 2021 at 20:32</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_39"><span>Answer 39</span> <span class="arrow"> <a href="#answer_38">↑</a> </span> <span class="arrow"> <a href="#answer_40">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mahdi Abedi</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Sep 2018 at 04:37</span>
     </div>
    </div>
    <div>
     <p>Sometimes it is necessary to check whether we have a value in the function or not, and the amount itself is not important to us, but whether or not it matters.</p>
     <p>For example, we want to check if the user has a major or not and we have a function just like:</p>
     <pre><code>hasMajor() {return this.major} // It returns "(users major is) Science"
</code></pre>
     <p>But the answer is not important to us. We just want to check if it has a major or not and we need a Boolean value (true or false). How do we get it?</p>
     <p>Just like this:</p>
     <pre><code>hasMajor() { return !(!this.major)}
</code></pre>
     <p>Or as the same</p>
     <pre><code>hasMajor() {return !!this.major)}
</code></pre>
     <p>If <em>this.major</em> has a value then <code>!this.major</code> returns false, but because the value has exits and we need to return true, we use <code>!</code> twice to return the correct answer, <code>!(!this.major)</code>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_40"><span>Answer 40</span> <span class="arrow"> <a href="#answer_39">↑</a> </span> <span class="arrow"> <a href="#answer_41">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mile Mijatović</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Jul 2020 at 09:18</span>
     </div>
    </div>
    <div>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>const foo = 'bar';
console.log(!!foo); // Boolean: true</code></pre>
      </div>
     </div>
     <p></p>
     <p>! negates (inverts) a value <em>and</em> always returns/ produces a Boolean. So !'bar' would yield false (because 'bar' is truthy =&gt; negated + Boolean = false). With the additional ! operator, the value is negated again, so false becomes true.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_41"><span>Answer 41</span> <span class="arrow"> <a href="#answer_40">↑</a> </span> <span class="arrow"> <a href="#answer_42">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Umesh Bhutada</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Jun 2022 at 21:05</span>
     </div>
    </div>
    <div>
     <p>Just to check if exist</p>
     <pre><code>if(!!isComplianceOnHold){
//write code here is not undefined
//if isComplianceOnHold is undefined or null will not enter in net is false
// if isComplianceOnHold is not null or even boolean net result is true and enter inside if block
}
</code></pre>
     <blockquote>
      <p>Any object of which the value is not undefined or null, including a Boolean object whose value is false, evaluates to true when passed to a conditional statement</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_42"><span>Answer 42</span> <span class="arrow"> <a href="#answer_41">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>rob_james</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Apr 2012 at 12:22</span>
     </div>
    </div>
    <div>
     <p>This is a really handy way to check for undefined, "undefined", null, "null", ""</p>
     <pre><code>if (!!var1 &amp;&amp; !!var2 &amp;&amp; !!var3 &amp;&amp; !!var4 ){
   //... some code here
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Why? I still need to know var1 through 4 have values in them.</span> <span> - </span> <span class="display-name">rob_james</span> <span> </span> <span class="date">28 Oct 2012 at 17:22</span></td>
       </tr>
       <tr>
        <td>8</td>
        <td><span>Because the <code>&amp;&amp;</code> operators already "convert" its operators to boolean.</span> <span> - </span> <span class="display-name">nalply</span> <span> </span> <span class="date">29 Oct 2012 at 07:31</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>huh - cool! Cheers. For the record, I was trying to indicate that it was good to check a lot of values. Can you imagine doing that without boolean conversion?! Mental! Anyway, that is good to know. Does the same happen with <code>||</code> ?</span> <span> - </span> <span class="display-name">rob_james</span> <span> </span> <span class="date">29 Oct 2012 at 21:25</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span>I have to take back my comment. I was wrong. It's not the <code>&amp;&amp;</code> operators, but the <code>if</code> statement which "converts". Perhaps a good StackOverflow question?</span> <span> - </span> <span class="display-name">nalply</span> <span> </span> <span class="date">30 Oct 2012 at 09:16</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>I think it is the &amp;&amp; operator, as if you remove the surrounding if, you still get all the same behavior of the expression, which if is just testing the result of...</span> <span> - </span> <span class="display-name">aikeru</span> <span> </span> <span class="date">21 Aug 2013 at 21:18</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>For the record, it's definitely the <code>if</code> that converts - <code>&amp;&amp;</code> returns either the first falsy value or the last value. For instance, with <code>var a = b &amp;&amp; c &amp;&amp; d</code>, <code>a</code> will be equal to <code>b</code> (the actual value of <code>b</code>, not true or false) if <code>b</code> is falsy, <code>c</code> if <code>b</code> is truthy and <code>c</code> is falsy, or <code>d</code> if both <code>b</code> and <code>c</code> are truthy (regardless of <code>d</code>'s truthiness).</span> <span> - </span> <span class="display-name">John Montgomery</span> <span> </span> <span class="date">11 Sep 2017 at 18:39</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>