<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>What is the dependency inversion principle and why is it important?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>What is the dependency inversion principle and why is it important?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>222</span>
    </div>
    <div>
     <span>Asker: </span> <span>Phillip Wells</span>
    </div>
    <div>
     <span>Asked: </span> <span>15 Sep 2008 at 12:53</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/62539/what-is-the-dependency-inversion-principle-and-why-is-it-important">source</a>
    </div>
   </div>
   <div>
    <p>What is the dependency inversion principle and why is it important?</p>
   </div>
   <div class="tags">
    <span class="tag">oop</span><span class="tag">solid-principles</span><span class="tag">glossary</span><span class="tag">principles</span><span class="tag">dependency-inversion</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>3</td>
       <td><span></span> <span> - </span> <span class="display-name">LCJ</span> <span> </span> <span class="date">6 Feb 2014 at 19:33</span></td>
      </tr>
      <tr>
       <td>13</td>
       <td><span></span> <span> - </span> <span class="display-name">8bitjunkie</span> <span> </span> <span class="date">6 May 2019 at 10:03</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>158</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Derek Greer</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Jul 2009 at 15:20</span>
     </div>
    </div>
    <div>
     <h2>What Is It?</h2>
     <p>The books Agile Software Development, Principles, Patterns, and Practices and Agile Principles, Patterns, and Practices in C# are the best resources for fully understanding the original goals and motivations behind the Dependency Inversion Principle. The article "The Dependency Inversion Principle" is also a good resource, but due to the fact that it is a condensed version of a draft which eventually made its way into the previously mentioned books, it leaves out some important discussion on the concept of a package and interface ownership which are key to distinguishing this principle from the more general advise to "program to an interface, not an implementation" found within the book Design Patterns (Gamma, et. al).</p>
     <p>To provide a summary, the Dependency Inversion Principle is primarily about <strong>reversing</strong> the conventional direction of dependencies from "higher level" components to "lower level" components such that "lower level" components are dependent upon the interfaces <strong>owned</strong> by the "higher level" components. (Note: "higher level" component here refers to the component requiring external dependencies/services, not necessarily its conceptual position within a layered architecture.) In doing so, coupling isn't <strong>reduced</strong> so much as it is <strong>shifted</strong> from components that are theoretically less valuable to components which are theoretically more valuable.</p>
     <p>This is achieved by designing components whose external dependencies are expressed in terms of an interface for which an implementation must be provided by the consumer of the component. In other words, the defined interfaces express what is needed by the component, not how you use the component (e.g. "INeedSomething", not "IDoSomething").</p>
     <p>What the Dependency Inversion Principle does not refer to is the simple practice of abstracting dependencies through the use of interfaces (e.g. MyService → [ILogger ⇐ Logger]). While this decouples a component from the specific implementation detail of the dependency, it does not invert the relationship between the consumer and dependency (e.g. [MyService → IMyServiceLogger] ⇐ Logger.</p>
     <h2>Why Is It Important?</h2>
     <p>The importance of the Dependency Inversion Principle can be distilled down to a singular goal of being able to reuse software components which rely upon external dependencies for a portion of their functionality (logging, validation, etc.)</p>
     <p>Within this general goal of reuse, we can delineate two sub-types of reuse:</p>
     <ol>
      <li>
       <p>Using a software component within multiple applications with sub-dependency implementations (e.g. You've developed a DI container and want to provide logging, but don't want to couple your container to a specific logger such that everyone that uses your container has to also use your chosen logging library).</p></li>
      <li>
       <p>Using software components within an evolving context (e.g. You've developed business-logic components which remain the same across multiple versions of an application where the implementation details are evolving).</p></li>
     </ol>
     <p>With the first case of reusing components across multiple applications, such as with an infrastructure library, the goal is to provide a core infrastructure need to your consumers without coupling your consumers to sub-dependencies of your own library since coupling to such dependencies requires your consumers to require the same dependencies as well. This can be problematic when consumers of your library choose to use a different library for the same infrastructure needs (e.g. NLog vs. log4net), or if they choose to use a later version of the required library which isn't backward compatible with the version required by your library.</p>
     <p>With the second case of reusing business-logic components (i.e. "higher-level components"), the goal is to isolate the core domain implementation of your application from the changing needs of your implementation details (i.e. changing/upgrading persistence libraries, messaging libraries, encryption strategies, etc.). Ideally, changing the implementation details of an application shouldn't break the components encapsulating the application's business logic.</p>
     <p>Note: Some may object to describing this second case as actual reuse, reasoning that components such as business-logic components used within a single evolving application represents only a single use. The idea here, however, is that each change to the application's implementation details renders a new context and therefore a different use case, though the ultimate goals could be distinguished as isolation vs. portability.</p>
     <p>While following the Dependency Inversion Principle in this second case can offer some benefit, it should be noted that its value as applied to modern languages such as Java and C# is much reduced, perhaps to the point of being irrelevant. As discussed earlier, the DIP involves separating implementation details into separate packages completely. In the case of an evolving application, however, simply utilizing interfaces defined in terms of the business domain will guard against needing to modify higher-level components due to changing needs of implementation detail components, even if the implementation details ultimately reside within the same package. This portion of the principle reflects aspects that were pertinent to the language in view when the principle was codified (i.e. C++) which aren't relevant to newer languages. That said, the importance of the Dependency Inversion Principle primarily lies with the development of reusable software components/libraries.</p>
     <p>A longer discussion of this principle as it relates to the simple use of interfaces, Dependency Injection, and the Separated Interface pattern can be found <a href="http://aspiringcraftsman.com/2008/12/28/examining-dependency-inversion/" rel="noreferrer">here</a>. Additionally, a discussion of how the principle relates to dynamically-typed languages such as JavaScript can be found <a href="http://aspiringcraftsman.com/2012/01/22/solid-javascript-the-dependency-inversion-principle/" rel="noreferrer">here</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>17</td>
        <td><span></span> <span> - </span> <span class="display-name">Patrick McElhaney</span> <span> </span> <span class="date">31 Aug 2009 at 13:45</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span></span> <span> - </span> <span class="display-name">ejaenv</span> <span> </span> <span class="date">13 Dec 2012 at 13:37</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">Casper Leon Nielsen</span> <span> </span> <span class="date">8 Jan 2013 at 17:58</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span></span> <span> - </span> <span class="display-name">TSmith</span> <span> </span> <span class="date">2 Apr 2013 at 15:59</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">VF1</span> <span> </span> <span class="date">21 Jul 2016 at 16:00</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">VF1</span> <span> </span> <span class="date">21 Jul 2016 at 16:01</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span></span> <span> - </span> <span class="display-name">Derek Greer</span> <span> </span> <span class="date">23 Nov 2016 at 17:39</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">Derek Greer</span> <span> </span> <span class="date">23 Nov 2016 at 17:49</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">VF1</span> <span> </span> <span class="date">23 Nov 2016 at 18:07</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">Derek Greer</span> <span> </span> <span class="date">25 Nov 2016 at 17:47</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">FaceBro</span> <span> </span> <span class="date">10 Mar 2017 at 14:26</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">Birb</span> <span> </span> <span class="date">22 Mar 2017 at 08:28</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">humbaba</span> <span> </span> <span class="date">6 Sep 2018 at 09:40</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Derek Greer</span> <span> </span> <span class="date">7 Sep 2018 at 12:22</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Derek Greer</span> <span> </span> <span class="date">15 Feb 2019 at 22:08</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">Derek Greer</span> <span> </span> <span class="date">16 Feb 2019 at 00:08</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Wael Alshabani</span> <span> </span> <span class="date">31 May 2019 at 00:04</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Derek Greer</span> <span> </span> <span class="date">31 May 2019 at 15:12</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Derek Greer</span> <span> </span> <span class="date">31 May 2019 at 15:17</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">Mark Amery</span> <span> </span> <span class="date">10 Jun 2019 at 10:36</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span></span> <span> - </span> <span class="display-name">Derek Greer</span> <span> </span> <span class="date">19 Jun 2019 at 15:21</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">Alan Evangelista</span> <span> </span> <span class="date">11 Nov 2020 at 10:30</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Derek Greer</span> <span> </span> <span class="date">11 Feb 2022 at 17:29</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">szx</span> <span> </span> <span class="date">14 May 2023 at 09:01</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>122</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Carl Seleborg</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Sep 2008 at 12:57</span>
     </div>
    </div>
    <div>
     <p>Check this document out: <a href="https://drive.google.com/file/d/0BwhCYaYDn8EgMjdlMWIzNGUtZTQ0NC00ZjQ5LTkwYzQtZjRhMDRlNTQ3ZGMz/view" rel="noreferrer">The Dependency Inversion Principle</a>.</p>
     <p>It basically says:</p>
     <ul>
      <li>High level modules should not depend upon low-level modules. Both should depend upon abstractions.</li>
      <li>Abstractions should never depend upon details. Details should depend upon abstractions.</li>
     </ul>
     <p>As to why it is important, in short: changes are risky, and by depending on a concept instead of on an implementation, you reduce the need for change at call sites.</p>
     <p>Effectively, the DIP reduces coupling between different pieces of code. The idea is that although there are many ways of implementing, say, a logging facility, the way you would use it should be relatively stable in time. If you can extract an interface that represents the concept of logging, this interface should be much more stable in time than its implementation, and call sites should be much less affected by changes you could make while maintaining or extending that logging mechanism.</p>
     <p>By also making the implementation depend on an interface, you get the possibility to choose at run-time which implementation is better suited for your particular environment. Depending on the cases, this may be interesting too.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>34</td>
        <td><span></span> <span> - </span> <span class="display-name">Rogério</span> <span> </span> <span class="date">30 Aug 2009 at 21:42</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span></span> <span> - </span> <span class="display-name">Tim Williscroft</span> <span> </span> <span class="date">30 Aug 2009 at 22:50</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span></span> <span> - </span> <span class="display-name">Rogério</span> <span> </span> <span class="date">31 Aug 2009 at 17:33</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">P.K</span> <span> </span> <span class="date">31 Aug 2009 at 18:48</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">user20358</span> <span> </span> <span class="date">26 Sep 2012 at 20:47</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span></span> <span> - </span> <span class="display-name">ejaenv</span> <span> </span> <span class="date">13 Dec 2012 at 13:53</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">darxtrix</span> <span> </span> <span class="date">23 Apr 2017 at 10:12</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">8bitjunkie</span> <span> </span> <span class="date">6 May 2019 at 10:04</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">Juzer Ali</span> <span> </span> <span class="date">12 Aug 2019 at 11:55</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">OfirD</span> <span> </span> <span class="date">3 Jan 2021 at 22:16</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Tim Williscroft</span> <span> </span> <span class="date">18 Apr 2021 at 23:48</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Derek Greer</span> <span> </span> <span class="date">22 Jul 2022 at 21:08</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>17</span>
     </div>
     <div>
      <span>Answerer: </span> <span>xurxodev</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Feb 2016 at 06:12</span>
     </div>
    </div>
    <div>
     <p>Dependency inversion well applied gives flexibility and stability at the level of the entire architecture of your application. It will allow your application to evolve more securely and stable.</p>
     <h2>Traditional layered architecture</h2>
     <p>Traditionally a layered architecture UI depended on the business layer and this in turn depended on the data access layer.</p>
     <p><a href="https://i.stack.imgur.com/6e2K9.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/6e2K9.png" alt=""></a></p>
     <p>You have to understand layer, package, or library. Let's see how the code would be.</p>
     <p>We would have a library or package for the data access layer.</p>
     <pre><code>// DataAccessLayer.dll
public class ProductDAO {

}
</code></pre>
     <p>And another library or package layer business logic that depends on the data access layer.</p>
     <pre><code>// BusinessLogicLayer.dll
using DataAccessLayer;
public class ProductBO { 
    private ProductDAO productDAO;
}
</code></pre>
     <h2>Layered architecture with dependency inversion</h2>
     <p>The dependency inversion indicates the following:</p>
     <blockquote>
      <p>High-level modules should not depend on low-level modules. Both should depend on abstractions.</p>
     </blockquote>
     <blockquote>
      <p>Abstractions should not depend on details. Details should depend on abstractions.</p>
     </blockquote>
     <p>What are the high-level modules and low level? Thinking modules such as libraries or packages, high-level module would be those that traditionally have dependencies and low level on which they depend.</p>
     <p>In other words, module high level would be where the action is invoked and low level where the action is performed.</p>
     <p>A reasonable conclusion to draw from this principle is that there should be no dependence between concretions, but there must be a dependence on an abstraction. But according to the approach we take we can be misapplying investment depend dependency, but an abstraction.</p>
     <p>Imagine that we adapt our code as follows:</p>
     <p>We would have a library or package for the data access layer which define the abstraction.</p>
     <pre><code>// DataAccessLayer.dll
public interface IProductDAO
public class ProductDAO : IProductDAO{

}
</code></pre>
     <p>And another library or package layer business logic that depends on the data access layer.</p>
     <pre><code>// BusinessLogicLayer.dll
using DataAccessLayer;
public class ProductBO { 
    private IProductDAO productDAO;
}
</code></pre>
     <p>Although we are depending on an abstraction dependency between business and data access remains the same.</p>
     <p><a href="https://i.stack.imgur.com/6e2K9.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/6e2K9.png" alt=""></a></p>
     <p>To get dependency inversion, the persistence interface must be defined in the module or package where this high level logic or domain is and not in the low-level module.</p>
     <p>First define what the domain layer is and the abstraction of its communication is defined persistence.</p>
     <pre><code>// Domain.dll
public interface IProductRepository;

using DataAccessLayer;
public class ProductBO { 
    private IProductRepository productRepository;
}
</code></pre>
     <p>After the persistence layer depends on the domain, getting to invert now if a dependency is defined.</p>
     <pre><code>// Persistence.dll
public class ProductDAO : IProductRepository{

}
</code></pre>
     <p><a href="https://i.stack.imgur.com/c7Xln.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/c7Xln.png" alt=""></a><br><sub>(source: <a href="https://xurxodev.com/content/images/2016/02/Dependency-Inversion-Layers.png" rel="nofollow noreferrer">xurxodev.com</a>)</sub></p>
     <h2>Deepening the principle</h2>
     <p>It is important to assimilate the concept well, deepening the purpose and benefits. If we stay in mechanically and learn the typical case repository, we will not be able to identify where we can apply the principle of dependence.</p>
     <p>But why do we invert a dependency? What is the main objective beyond specific examples?</p>
     <p>Such commonly <strong>allows the most stable things, that are not dependent on less stable things, to change more frequently.</strong></p>
     <p>It is easier for the persistence type to be changed, either the database or technology to access the same database than the domain logic or actions designed to communicate with persistence. Because of this, the dependence is reversed because as it is easier to change the persistence if this change occurs. In this way we will not have to change the domain. The domain layer is the most stable of all, which is why it should not depend on anything.</p>
     <p>But there is not just this repository example. There are many scenarios where this principle applies and there are architectures based on this principle.</p>
     <h2>Architectures</h2>
     <p>There are architectures where dependency inversion is key to its definition. In all the domains it is the most important and it is abstractions that will indicate the communication protocol between the domain and the rest of the packages or libraries are defined.</p>
     <h3>Clean Architecture</h3>
     <p>In <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="nofollow noreferrer">Clean architecture</a> the domain is located in the center and if you look in the direction of the arrows indicating dependency, it is clear what are the most important and stable layers. The outer layers are considered unstable tools so avoid depending on them.</p>
     <p><a href="https://i.stack.imgur.com/uNQZQ.jpg" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/uNQZQ.jpg" alt=""></a><br><sub>(source: <a href="https://8thlight.com/blog/" rel="nofollow noreferrer">8thlight.com</a>)</sub></p>
     <h3>Hexagonal Architecture</h3>
     <p>It happens the same way with the hexagonal architecture, where the domain is also located in the central part and ports are abstractions of communication from the domino outward. Here again it is evident that the domain is the most stable and traditional dependence is inverted.</p>
     <p><a href="https://i.stack.imgur.com/cDymr.jpg" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/cDymr.jpg" alt=""></a><br><sub>(source: <a href="https://a.pragprog.com/magazines/2009-12/images/HexagonalArchitecture__bbe7fy__.jpg" rel="nofollow noreferrer">pragprog.com</a>)</sub></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">Mark Amery</span> <span> </span> <span class="date">18 Jan 2020 at 16:41</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>16</span>
     </div>
     <div>
      <span>Answerer: </span> <span>nikhil.singhal</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Sep 2016 at 18:50</span>
     </div>
    </div>
    <div>
     <p>When we design software applications we can consider the low level classes the classes which implement basic and primary operations (disk access, network protocols,...) and high level classes the classes which encapsulate complex logic (business flows, ...).</p>
     <p>The last ones rely on the low level classes. A natural way of implementing such structures would be to write low level classes and once we have them to write the complex high level classes. Since high level classes are defined in terms of others this seems the logical way to do it. But this is not a flexible design. What happens if we need to replace a low level class?</p>
     <p>The Dependency Inversion Principle states that:</p>
     <ul>
      <li>High level modules should not depend upon low level modules. Both should depend upon abstractions.</li>
      <li>Abstractions should not depend upon details. Details should depend upon abstractions.</li>
     </ul>
     <p>This principle seeks to "invert" the conventional notion that high level modules in software should depend upon the lower level modules. Here high level modules own the abstraction (for example, deciding the methods of the interface) which are implemented by lower level modules. Thus making lower level modules dependent on higher level modules.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>11</span>
     </div>
     <div>
      <span>Answerer: </span> <span>martin.ra</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Jul 2015 at 16:49</span>
     </div>
    </div>
    <div>
     <p>Basically it says:</p>
     <p>Class should depend on abstractions (e.g interface, abstract classes), not specific details (implementations).</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Dariux</span> <span> </span> <span class="date">10 Jan 2018 at 20:19</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">ekim boran</span> <span> </span> <span class="date">13 Jan 2018 at 16:12</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>10</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Rogério</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Aug 2009 at 22:30</span>
     </div>
    </div>
    <div>
     <p>To me, the Dependency Inversion Principle, as described in the <a href="http://www.objectmentor.com/resources/articles/dip.pdf" rel="noreferrer">official article</a>, is really a misguided attempt to increase the reusability of modules that are inherently less reusable, as well as a way to workaround an issue in the C++ language.</p>
     <p>The issue in C++ is that header files typically contain declarations of private fields and methods. Therefore, if a high-level C++ module includes the header file for a low-level module, it will depend on actual <b>implementation</b> details of that module. And that, obviously, is not a good thing. But this is not an issue in the more modern languages commonly used today.</p>
     <p>High-level modules are inherently less reusable than low-level modules because the former are normally more application/context specific than the latter. For example, a component that implements an UI screen is of the highest-level and also very (completely?) specific to the application. Trying to reuse such a component in a different application is counter-productive, and can only lead to over-engineering.</p>
     <p>So, the creation of a separate abstraction at the same level of a component A that depends on a component B (which does not depend on A) can be done only if component A will really be useful for reuse in different applications or contexts. If that's not the case, then applying DIP would be bad design.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Przemek Pokrywka</span> <span> </span> <span class="date">22 Mar 2013 at 19:40</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span></span> <span> - </span> <span class="display-name">Dirk Bester</span> <span> </span> <span class="date">25 Aug 2013 at 20:09</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span></span> <span> - </span> <span class="display-name">Rogério</span> <span> </span> <span class="date">26 Aug 2013 at 13:46</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">knockNrod</span> <span> </span> <span class="date">21 Apr 2016 at 13:38</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Rogério</span> <span> </span> <span class="date">21 Apr 2016 at 18:52</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Rogério</span> <span> </span> <span class="date">21 Apr 2016 at 19:09</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">humbaba</span> <span> </span> <span class="date">6 Sep 2018 at 09:33</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Mark Amery</span> <span> </span> <span class="date">18 Jan 2020 at 15:57</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Mark Amery</span> <span> </span> <span class="date">18 Jan 2020 at 15:58</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>mattvonb</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 May 2016 at 17:48</span>
     </div>
    </div>
    <div>
     <p>A much clearer way to state the Dependency Inversion Principle is:</p>
     <p>Your modules which encapsulate complex business logic should not depend directly on other modules which encapsulate business logic. Instead, they should depend only on interfaces to simple data.</p>
     <p>I.e., instead of implementing your class <code>Logic</code> as people usually do:</p>
     <pre><code>class Dependency { ... }
class Logic {
    private Dependency dep;
    int doSomething() {
        // Business logic using dep here
    }
}
</code></pre>
     <p>you should do something like:</p>
     <pre><code>class Dependency { ... }
interface Data { ... }
class DataFromDependency implements Data {
    private Dependency dep;
    ...
}
class Logic {
    int doSomething(Data data) {
        // compute something with data
    }
}
</code></pre>
     <p><code>Data</code> and <code>DataFromDependency</code> should live in the same module as <code>Logic</code>, not with <code>Dependency</code>.</p>
     <p>Why do this?</p>
     <ol>
      <li>The two business logic modules are now decoupled. When <code>Dependency</code> changes, you don't need to change <code>Logic</code>.</li>
      <li>Understanding what <code>Logic</code> does is a much simpler task: it operates only on what looks like an ADT.</li>
      <li><code>Logic</code> can now be more easily tested. You can now directly instantiate <code>Data</code> with fake data and pass it in. No need for mocks or complex test scaffolding.</li>
     </ol>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">Mark Amery</span> <span> </span> <span class="date">18 Jan 2020 at 16:52</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">mattvonb</span> <span> </span> <span class="date">19 Feb 2021 at 23:16</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Hace</span>
     </div>
     <div>
      <span> Answered: </span> <span>20 Jan 2009 at 20:06</span>
     </div>
    </div>
    <div>
     <p>Good answers and good examples are already given by others here.</p>
     <p>The reason <a href="http://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="nofollow noreferrer">DIP</a> is important is because it ensures the OO-principle "loosely coupled design".</p>
     <p>The objects in your software should NOT get into a hierarchy where some objects are the top-level ones, dependent on low-level objects. Changes in low-level objects will then ripple-through to your top-level objects which makes the software very fragile for change.</p>
     <p>You want your 'top-level' objects to be very stable and not fragile for change, therefore you need to invert the dependencies.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>6</td>
        <td><span></span> <span> - </span> <span class="display-name">Rogério</span> <span> </span> <span class="date">30 Aug 2009 at 22:01</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Staale</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Sep 2008 at 13:01</span>
     </div>
    </div>
    <div>
     <p><a href="http://en.wikipedia.org/wiki/Inversion_of_Control" rel="nofollow noreferrer">Inversion of control</a> (IoC) is a design pattern where an object gets handed its dependency by an outside framework, rather than asking a framework for its dependency.</p>
     <p>Pseudocode example using traditional lookup:</p>
     <pre><code>class Service {
    Database database;
    init() {
        database = FrameworkSingleton.getService("database");
    }
}
</code></pre>
     <p>Similar code using IoC:</p>
     <pre><code>class Service {
    Database database;
    init(database) {
        this.database = database;
    }
}
</code></pre>
     <p>The benefits of IoC are:</p>
     <ul>
      <li>You have no dependency on a central framework, so this can be changed if desired.</li>
      <li>Since objects are created by injection, preferably using interfaces, it's easy to create unit tests that replace dependencies with mock versions.</li>
      <li>Decoupling off code.</li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">4 Aug 2009 at 23:18</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span></span> <span> - </span> <span class="display-name">Rogério</span> <span> </span> <span class="date">8 Nov 2010 at 15:38</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Richard Tingle</span> <span> </span> <span class="date">22 Jun 2015 at 14:13</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span></span> <span> - </span> <span class="display-name">zeraDev</span> <span> </span> <span class="date">25 Mar 2019 at 15:25</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">ahnbizcad</span> <span> </span> <span class="date">6 Nov 2020 at 22:20</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>yoAlex5</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Mar 2021 at 22:51</span>
     </div>
    </div>
    <div>
     <p><strong>Dependency Inversion Principle(DIP)</strong></p>
     <p>It is a part of SOLID<a href="https://stackoverflow.com/a/66087638/4770877"><sup>[About]</sup></a> which is a part of OOD and was introduced by Uncle Bob. It is about <strong>loose coupling</strong> between classes(layers...). Class should not be depended on <strong>concrete</strong> realization, class should be depended on <strong>abstraction/interface</strong></p>
     <p>Problem:</p>
     <pre><code>//A -&gt; B
class A {
  B b

  func foo() {
     b = B();
  }
}
</code></pre>
     <p>Solution:</p>
     <pre><code>//A -&gt; IB &lt;|- B
//client[A -&gt; IB] &lt;|- B is the Inversion 
class A {
  IB ib // An abstraction between High level module A and low level module B

  func foo() {
     ib = B()
  }
}
</code></pre>
     <p>Now <code>A</code> is not depended on <code>B</code>(one to one), now <code>A</code> is depended on interface <code>IB</code> which is implemented by <code>B</code>, it means that A depends on multiple realization of <code>IB</code>(one to many)</p>
     <p><a href="https://stackoverflow.com/a/67401178/4770877">[DIP vs DI vs IoC]</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Marc Hughes</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Sep 2008 at 12:59</span>
     </div>
    </div>
    <div>
     <p>The point of dependency inversion is to make reusable software.</p>
     <p>The idea is that instead of two pieces of code relying on each other, they rely on some abstracted interface. Then you can reuse either piece without the other.</p>
     <p>The way this is most commonly achieved is through an inversion of control (IoC) container like Spring in Java. In this model, properties of objects are set up through an XML configuration instead of the objects going out and finding their dependency.</p>
     <p>Imagine this pseudocode...</p>
     <pre><code>public class MyClass
{
  public Service myService = ServiceLocator.service;
}
</code></pre>
     <p>MyClass directly depends on both the Service class and the ServiceLocator class. It needs both of those if you want to use it in another application. Now imagine this...</p>
     <pre><code>public class MyClass
{
  public IService myService;
}
</code></pre>
     <p>Now, MyClass relies on a single interface, the IService interface. We'd let the IoC container actually set the value of that variable.</p>
     <p>So now, MyClass can easily be reused in other projects, without bringing the dependency of those other two classes along with it.</p>
     <p>Even better, you don't have to drag the dependencies of MyService, and the dependencies of those dependencies, and the... well, you get the idea.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span></span> <span> - </span> <span class="display-name">Rogério</span> <span> </span> <span class="date">30 Aug 2009 at 22:11</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">ahnbizcad</span> <span> </span> <span class="date">6 Nov 2020 at 22:22</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>mike</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Jan 2020 at 17:38</span>
     </div>
    </div>
    <div>
     <p>If we can take it as a given that a "high level" employee at a corporation is paid for the execution of their plans, and that these plans are delivered by the aggregate execution of many "low level" employee's plans, then we could say it is generally a terrible plan if the high level employee's plan description in any way is coupled to the specific plan of any lower level employee.</p>
     <p>If a high level executive has a plan to "improve delivery time", and indicates that an employee in the shipping line must have coffee and do stretches each morning, then that plan is highly coupled and has low cohesion. But if the plan makes no mention of any specific employee, and in fact simply requires "an entity that can perform work is prepared to work", then the plan is loosely coupled and more cohesive: the plans do not overlap and can easily be substituted. Contractors, or robots, can easily replace the employees and the high level's plan remains unchanged.</p>
     <p>"High level" in the dependency inversion principle means "more important".</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">Mark Amery</span> <span> </span> <span class="date">18 Jan 2020 at 17:44</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Sumanth Varada</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Apr 2020 at 08:24</span>
     </div>
    </div>
    <div>
     <p>I can see good explanation has been given in above answers. However i wants to provide some easy explanation with simple example.</p>
     <p><strong><em>Dependency Inversion Principle allows the programmer to remove the hardcoded dependencies so that the application becomes loosely coupled and extendable.</em></strong></p>
     <p><strong>How to achieve this :</strong> through abstraction</p>
     <p><strong>Without dependency inversion:</strong></p>
     <pre><code> class Student {
    private Address address;

    public Student() {
        this.address = new Address();
    }
}
class Address{
    private String perminentAddress;
    private String currentAdrress;

    public Address() {
    }
} 
</code></pre>
     <p><strong><em>In above code snippet, address object is hard-coded. Instead if we can use dependency inversion and inject the address object by passing through constructor or setter method. Let's see.</em></strong></p>
     <p><strong>With dependency inversion:</strong></p>
     <pre><code>class Student{
    private Address address;

    public Student(Address address) {
        this.address = address;
    }
    //or
    public void setAddress(Address address) {
        this.address = address;
    }
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span> <span class="arrow"> <a href="#answer_15">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Rejwanul Reja</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Mar 2019 at 12:32</span>
     </div>
    </div>
    <div>
     <p>Dependency Inversion Principle (DIP) says that</p>
     <p>i) High level modules should not depend upon low-level modules. Both should depend upon abstractions.</p>
     <p>ii) Abstractions should never depend upon details. Details should depend upon abstractions.</p>
     <p>Example:</p>
     <pre><code>    public interface ICustomer
    {
        string GetCustomerNameById(int id);
    }

    public class Customer : ICustomer
    {
        //ctor
        public Customer(){}

        public string GetCustomerNameById(int id)
        {
            return "Dummy Customer Name";
        }
    }

    public class CustomerFactory
    {
        public static ICustomer GetCustomerData()
        {
            return new Customer();
        }
    }

    public class CustomerBLL
    {
        ICustomer _customer;
        public CustomerBLL()
        {
            _customer = CustomerFactory.GetCustomerData();
        }

        public string GetCustomerNameById(int id)
        {
            return _customer.GetCustomerNameById(id);
        }
    }

    public class Program
    {
        static void Main()
        {
            CustomerBLL customerBLL = new CustomerBLL();
            int customerId = 25;
            string customerName = customerBLL.GetCustomerNameById(customerId);


            Console.WriteLine(customerName);
            Console.ReadKey();
        }
    }
</code></pre>
     <p>Note: Class should depend on abstractions like interface or abstract classes, not specific details (implementation of interface).</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_15"><span>Answer 15</span> <span class="arrow"> <a href="#answer_14">↑</a> </span> <span class="arrow"> <a href="#answer_16">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Daniel Andres Pelaez Lopez</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 Apr 2019 at 14:46</span>
     </div>
    </div>
    <div>
     <p>Dependency inversion: Depend on abstractions, not on concretions.</p>
     <p>Inversion of control: Main vs Abstraction, and how the Main is the glue of the systems.</p>
     <p><img src="https://i.stack.imgur.com/qU57n.png" alt="DIP and IoC"></p>
     <p>These are some good posts talking about this:</p>
     <p><a href="https://coderstower.com/2019/03/26/dependency-inversion-why-you-shouldnt-avoid-it/" rel="nofollow noreferrer">https://coderstower.com/2019/03/26/dependency-inversion-why-you-shouldnt-avoid-it/</a></p>
     <p><a href="https://coderstower.com/2019/04/02/main-and-abstraction-the-decoupled-peers/" rel="nofollow noreferrer">https://coderstower.com/2019/04/02/main-and-abstraction-the-decoupled-peers/</a></p>
     <p><a href="https://coderstower.com/2019/04/09/inversion-of-control-putting-all-together/" rel="nofollow noreferrer">https://coderstower.com/2019/04/09/inversion-of-control-putting-all-together/</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_16"><span>Answer 16</span> <span class="arrow"> <a href="#answer_15">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>John Silence</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Jun 2019 at 11:17</span>
     </div>
    </div>
    <div>
     <p>Adding to the flurry of generally good answers, I'd like to add a tiny sample of my own to demonstrate good vs. bad practice. And yes, I'm not one to throw stones!</p>
     <p>Say, you want a little program to <strong>convert a string into base64 format</strong> via console I/O. Here's the naive approach:</p>
     <pre><code>class Program
{
    static void Main(string[] args)
    {
        /*
         * BadEncoder: High-level class *contains* low-level I/O functionality.
         * Hence, you'll have to fiddle with BadEncoder whenever you want to change
         * the I/O mode or details. Not good. A good encoder should be I/O-agnostic --
         * problems with I/O shouldn't break the encoder!
         */
        BadEncoder.Run();            
    }
}

public static class BadEncoder
{
    public static void Run()
    {
        Console.WriteLine(Convert.ToBase64String(Encoding.UTF8.GetBytes(Console.ReadLine())));
    }
}    
</code></pre>
     <p>The DIP basically says that high-level components shouldn't be dependent on low-level implementation, where "level" is the distance from I/O according to Robert C. Martin ("Clean Architecture"). But how do you get out of this predicament? Simply by making the central Encoder dependent only on interfaces without bothering how those are implemented:</p>
     <pre><code>class Program
{
    static void Main(string[] args)
    {           
        /* Demo of the Dependency Inversion Principle (= "High-level functionality
         * should not depend upon low-level implementations"): 
         * You can easily implement new I/O methods like
         * ConsoleReader, ConsoleWriter without ever touching the high-level
         * Encoder class!!!
         */            
        GoodEncoder.Run(new ConsoleReader(), new ConsoleWriter());        }
}

public static class GoodEncoder
{
    public static void Run(IReadable input, IWriteable output)
    {
        output.WriteOutput(Convert.ToBase64String(Encoding.ASCII.GetBytes(input.ReadInput())));
    }
}

public interface IReadable
{
    string ReadInput();
}

public interface IWriteable
{
    void WriteOutput(string txt);
}

public class ConsoleReader : IReadable
{
    public string ReadInput()
    {
        return Console.ReadLine();
    }
}

public class ConsoleWriter : IWriteable
{
    public void WriteOutput(string txt)
    {
        Console.WriteLine(txt);
    }
}
</code></pre>
     <p>Note that you don't need to touch <code>GoodEncoder</code> in order to change the I/O mode — that class is happy with the I/O interfaces it knows; any low-level implementation of <code>IReadable</code> and <code>IWriteable</code> won't ever bother it.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Mark Amery</span> <span> </span> <span class="date">18 Jan 2020 at 17:36</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>