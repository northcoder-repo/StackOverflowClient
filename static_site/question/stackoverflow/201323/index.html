<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>How can I validate an email address using a regular expression?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>How can I validate an email address using a regular expression?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>4064</span>
    </div>
    <div>
     <span>Asker: </span> <span>acrosman</span>
    </div>
    <div>
     <span>Asked: </span> <span>14 Oct 2008 at 14:14</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/201323/how-can-i-validate-an-email-address-using-a-regular-expression">source</a>
    </div>
   </div>
   <div>
    <p>Over the years I have slowly developed a <a href="http://en.wikipedia.org/wiki/Regular_expression" rel="noreferrer">regular expression</a> that validates <em>most</em> email addresses correctly, assuming they don't use an IP address as the server part.</p>
    <p>I use it in several PHP programs, and it works most of the time. However, from time to time I get contacted by someone that is having trouble with a site that uses it, and I end up having to make some adjustment (most recently I realized that I wasn't allowing four-character <a href="https://en.wikipedia.org/wiki/Top-level_domain" rel="noreferrer">TLDs</a>).</p>
    <p><em>What is the best regular expression you have or have seen for validating emails?</em></p>
    <p>I've seen several solutions that use functions that use several shorter expressions, but I'd rather have one long complex expression in a simple function instead of several short expression in a more complex function.</p>
   </div>
   <div class="tags">
    <span class="tag">regex</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>8</td>
       <td><span>The regex that can validate that an IDNA is correctly formatted does not fit in stackexchange. (the rules on canonicalisation ate really tortuous and particularly ill-suited to regex processing)</span> <span> - </span> <span class="display-name">Jasen</span> <span> </span> <span class="date">29 Aug 2017 at 23:51</span></td>
      </tr>
      <tr>
       <td>12</td>
       <td><span>Why you should not do this: <a href="https://stackoverflow.com/q/48055431/6699433">Can it cause harm to validate email addresses with a regex?</a></span> <span> - </span> <span class="display-name">klutt</span> <span> </span> <span class="date">9 Jan 2018 at 14:30</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>The regexes may be <b>variable</b> as in some cases, an email con can contain a space, and in other times, it cannot contain any spaces.</span> <span> - </span> <span class="display-name">Ṃųỻịgǻňạcểơửṩ</span> <span> </span> <span class="date">23 Jul 2018 at 04:21</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>You can check Symfonys regex for loose and strict check: <a href="https://github.com/symfony/symfony/blob/5.x/src/Symfony/Component/Validator/Constraints/EmailValidator.php" rel="nofollow noreferrer">github.com/symfony/symfony/blob/5.x/src/Symfony/Component/…</a></span> <span> - </span> <span class="display-name">Did</span> <span> </span> <span class="date">16 May 2021 at 16:15</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Using just regex can harm server security but if it is just as an input pattern, i suggest use this: <a href="https://stackoverflow.com/questions/5601647/html5-email-input-pattern-attribute/65442112#65442112" title="html5 email input pattern attribute">stackoverflow.com/questions/5601647/…</a></span> <span> - </span> <span class="display-name">MMMahdy-PAPION</span> <span> </span> <span class="date">7 Jun 2021 at 21:42</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>use this expression for email id - <code>^([\w-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([\w-‌​]+\.)+))([a-zA-Z]{2,‌​4}|[0-9]{1,3})(\]?)$</code></span> <span> - </span> <span class="display-name">Pritesh</span> <span> </span> <span class="date">19 Jul 2021 at 06:08</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Similar: <i><a href="https://stackoverflow.com/questions/46155/">What's the best way to validate an email address in JavaScript?</a></i></span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">16 Feb 2022 at 23:20</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Late to the party, but since PHP was mentioned, consider using <a href="https://www.php.net/manual/en/function.filter-var.php" rel="nofollow noreferrer">filter_var()</a></span> <span> - </span> <span class="display-name">Mavelo</span> <span> </span> <span class="date">23 Mar 2022 at 03:19</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Does this answer your question? <a href="https://stackoverflow.com/questions/46155/how-can-i-validate-an-email-address-in-javascript">How can I validate an email address in JavaScript?</a></span> <span> - </span> <span class="display-name">TylerH</span> <span> </span> <span class="date">4 May 2022 at 13:18</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>See also [ Regex validation of email addresses according to RFC5321/RFC5322 ](<a href="https://stackoverflow.com/questions/13992403/regex-validation-of-email-addresses-according-to-rfc5321-rfc5322" title="regex validation of email addresses according to rfc5321 rfc5322">stackoverflow.com/questions/13992403/…</a>)</span> <span> - </span> <span class="display-name">Michael Freidgeim</span> <span> </span> <span class="date">25 Nov 2022 at 05:14</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3285</span>
     </div>
     <div>
      <span>Answerer: </span> <span>bortzmeyer</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Oct 2008 at 14:26</span>
     </div>
    </div>
    <div>
     <p>The <a href="http://ex-parrot.com/%7Epdw/Mail-RFC822-Address.html" rel="noreferrer">fully RFC 822 compliant regex</a> is inefficient and obscure because of its length. Fortunately, RFC 822 was superseded twice and the current specification for email addresses is <a href="https://datatracker.ietf.org/doc/html/rfc5322" rel="noreferrer">RFC 5322</a>. RFC 5322 leads to a regex that can be understood if studied for a few minutes and is efficient enough for actual use.</p>
     <p>One RFC 5322 compliant regex can be found at the top of the page at <a href="http://emailregex.com/" rel="noreferrer">http://emailregex.com/</a> but uses the IP address pattern that is floating around the internet with a bug that allows <code>00</code> for any of the unsigned byte decimal values in a dot-delimited address, which is illegal. The rest of it appears to be consistent with the RFC 5322 grammar and passes several tests using <code>grep -Po</code>, including cases domain names, IP addresses, bad ones, and account names with and without quotes.</p>
     <p>Correcting the <code>00</code> bug in the IP pattern, we obtain a working and fairly fast regex. (Scrape the rendered version, not the markdown, for actual code.)</p>
     <blockquote>
      <p>(?:[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])</p>
     </blockquote>
     <p>or:</p>
     <pre><code>(?:[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
</code></pre>
     <p>Here is <a href="https://regexper.com/#(%3F%3A%5Ba-z0-9!%23%24%25%26%27*%2B%2F%3D%3F%5E_%60%7B%7C%7D%7E-%5D%2B(%3F%3A%5C.%5Ba-z0-9!%23%24%25%26%27*%2B%2F%3D%3F%5E_%60%7B%7C%7D%7E-%5D%2B)*%7C%22(%3F%3A%5B%5Cx01-%5Cx08%5Cx0b%5Cx0c%5Cx0e-%5Cx1f%5Cx21%5Cx23-%5Cx5b%5Cx5d-%5Cx7f%5D%7C%5C%5C%5B%5Cx01-%5Cx09%5Cx0b%5Cx0c%5Cx0e-%5Cx7f%5D)*%22)%40(%3F%3A(%3F%3A%5Ba-z0-9%5D(%3F%3A%5Ba-z0-9-%5D*%5Ba-z0-9%5D)%3F%5C.)%2B%5Ba-z0-9%5D(%3F%3A%5Ba-z0-9-%5D*%5Ba-z0-9%5D)%3F%7C%5C%5B(%3F%3A(%3F%3A(2(5%5B0-5%5D%7C%5B0-4%5D%5B0-9%5D)%7C1%5B0-9%5D%5B0-9%5D%7C%5B1-9%5D%3F%5B0-9%5D))%5C.)%7B3%7D(%3F%3A(2(5%5B0-5%5D%7C%5B0-4%5D%5B0-9%5D)%7C1%5B0-9%5D%5B0-9%5D%7C%5B1-9%5D%3F%5B0-9%5D)%7C%5Ba-z0-9-%5D*%5Ba-z0-9%5D%3A(%3F%3A%5B%5Cx01-%5Cx08%5Cx0b%5Cx0c%5Cx0e-%5Cx1f%5Cx21-%5Cx5a%5Cx53-%5Cx7f%5D%7C%5C%5C%5B%5Cx01-%5Cx09%5Cx0b%5Cx0c%5Cx0e-%5Cx7f%5D)%2B)%5C%5D)" rel="noreferrer">diagram</a> of <a href="https://en.wikipedia.org/wiki/Finite-state_machine" rel="noreferrer">finite state machine</a> for above regexp which is more clear than regexp itself <a href="https://i.stack.imgur.com/YI6KR.png" rel="noreferrer"><img src="https://i.stack.imgur.com/YI6KR.png" alt="enter image description here"></a></p>
     <p>The more sophisticated patterns in Perl and PCRE (regex library used e.g. in PHP) can <a href="https://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982">correctly parse RFC 5322 without a hitch</a>. Python and C# can do that too, but they use a different syntax from those first two. However, if you are forced to use one of the many less powerful pattern-matching languages, then it’s best to use a real parser.</p>
     <p>It's also important to understand that validating it per the RFC tells you absolutely nothing about whether that address actually exists at the supplied domain, or whether the person entering the address is its true owner. People sign others up to mailing lists this way all the time. Fixing that requires a fancier kind of validation that involves sending that address a message that includes a confirmation token meant to be entered on the same web page as was the address.</p>
     <p>Confirmation tokens are the only way to know you got the address of the person entering it. This is why most mailing lists now use that mechanism to confirm sign-ups. After all, anybody can put down <code>president@whitehouse.gov</code>, and that will even parse as legal, but it isn't likely to be the person at the other end.</p>
     <p>For PHP, you should <em>not</em> use the pattern given in <a href="http://www.linuxjournal.com/article/9585" rel="noreferrer">Validate an E-Mail Address with PHP, the Right Way</a> from which I quote:</p>
     <blockquote>
      <p>There is some danger that common usage and widespread sloppy coding will establish a de facto standard for e-mail addresses that is more restrictive than the recorded formal standard.</p>
     </blockquote>
     <p>That is no better than all the other non-RFC patterns. It isn’t even smart enough to handle even <a href="https://datatracker.ietf.org/doc/html/rfc822" rel="noreferrer">RFC 822</a>, let alone RFC 5322. <a href="https://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982">This one</a>, however, is.</p>
     <p>If you want to get fancy and pedantic, <a href="http://cubicspot.blogspot.com/2012/06/correct-way-to-validate-e-mail-address.html" rel="noreferrer">implement a complete state engine</a>. A regular expression can only act as a rudimentary filter. The problem with regular expressions is that telling someone that their perfectly valid e-mail address is invalid (a false positive) because your regular expression can't handle it is just rude and impolite from the user's perspective. A state engine for the purpose can both validate and even correct e-mail addresses that would otherwise be considered invalid as it disassembles the e-mail address according to each RFC. This allows for a potentially more pleasing experience, like</p>
     <blockquote>
      <p>The specified e-mail address 'myemail@address,com' is invalid. Did you mean 'myemail@address.com'?</p>
     </blockquote>
     <p>See also <a href="http://worsethanfailure.com/Articles/Validating_Email_Addresses.aspx" rel="noreferrer">Validating Email Addresses</a>, including the comments. Or <a href="http://fightingforalostcause.net/misc/2006/compare-email-regex.php" rel="noreferrer">Comparing E-mail Address Validating Regular Expressions</a>.</p>
     <p><a href="https://i.stack.imgur.com/SrUwP.png" rel="noreferrer"><img src="https://i.stack.imgur.com/SrUwP.png" alt="Regular expression visualization"></a></p>
     <p><a href="https://www.debuggex.com/r/aH_x42NflV8G-GS7" rel="noreferrer">Debuggex Demo</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>254</td>
        <td><span>You said "There is no good regular expression." Is this general or specific to e-mail address validation?</span> <span> - </span> <span class="display-name">Tomalak</span> <span> </span> <span class="date">14 Oct 2008 at 14:33</span></td>
       </tr>
       <tr>
        <td>57</td>
        <td><span>@Tomalak: only for email addresses. As bortzmeyer said, the RFC is extremely complicated</span> <span> - </span> <span class="display-name">Luk</span> <span> </span> <span class="date">14 Oct 2008 at 16:23</span></td>
       </tr>
       <tr>
        <td>46</td>
        <td><span>The linux journal article you mention is factually wrong in several respects. In particular Lovell clearly hasn't read the errata to RFC3696 and repeats some of the errors in the published version of the RFC. More here: <a href="http://www.dominicsayers.com/isemail" rel="nofollow noreferrer">dominicsayers.com/isemail</a></span> <span> - </span> <span class="display-name">Dominic Sayers</span> <span> </span> <span class="date">8 Apr 2009 at 15:56</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span>Note that <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#e-mail-state-(type=email)" rel="nofollow noreferrer">the current HTML5 spec</a> includes a regex and ABNF for email-type input validation that is deliberately more restrictive than the original RFCs.</span> <span> - </span> <span class="display-name">Synchro</span> <span> </span> <span class="date">9 Sep 2014 at 16:14</span></td>
       </tr>
       <tr>
        <td>16</td>
        <td><span>RFC 822, section 6.2.4. specifically and explicitly allows capital letters, but this answer does not. <a href="https://www.w3.org/Protocols/rfc822/#z26" rel="nofollow noreferrer">w3.org/Protocols/rfc822/#z26</a> Perhaps the author of this answer intended for their regex to be applied insensitively. If so, that should be made explicit in the body of the answer.</span> <span> - </span> <span class="display-name">Jared Beck</span> <span> </span> <span class="date">10 Apr 2019 at 22:36</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I use ^[a-zA-Z0-9+.-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9]{2,63}$</span> <span> - </span> <span class="display-name">Sandra</span> <span> </span> <span class="date">4 Aug 2021 at 17:22</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Tra@XDentalLab.com; and emariemcadams@Gmail.com; seem to fail</span> <span> - </span> <span class="display-name">Dan Krueger</span> <span> </span> <span class="date">14 Aug 2021 at 04:42</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Please re-check the ending part. I'm looking at this sub-string "\x21-\x5a\x53-\x7f" and it seems odd to me, because the first part overlaps with the second one. I checked it in the RFC and it is consistent, but it is still unclear.</span> <span> - </span> <span class="display-name">VitaliG</span> <span> </span> <span class="date">11 Oct 2021 at 10:20</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@DanKrueger You should have the <code>i</code> regex flag set for this to work.</span> <span> - </span> <span class="display-name">Makonede</span> <span> </span> <span class="date">27 Oct 2021 at 00:05</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This regex allows number as inicial email id and commas.</span> <span> - </span> <span class="display-name">Luis Alfredo Serrano Díaz</span> <span> </span> <span class="date">10 Jan 2022 at 18:59</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Emails in the format <code>email+TEST@example.com</code> fail. The <code>\+[a-zA-Z0-9]</code> fails.</span> <span> - </span> <span class="display-name">Charles Kornoelje</span> <span> </span> <span class="date">10 Jan 2022 at 22:04</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>My solution following the spec <a href="https://vquilon.github.io/beyond-regex/panels/visualizer#!embed=true&amp;flags=ig&amp;re=(%3F%3A%5E%7C%20)(%5B%5Cw!%23%24%25%26'%2A%2B%5C-%5C%2F%3D%3F%5E_%60%7B%7C%7D~%5D%2B%5C.%5B%5Cw!%23%24%25%26'%2A%2B%5C-%5C%2F%3D%3F%5E_%60%7B%7C%7D~%5D%2B%7C%22(%3F%3A%5B%5Cw!%23%24%25%26'%2A%2B%5C-%5C%2F%3D%3F%5E_%60%7B%7C%7D~()%2C%3A%3B%3C%3E%40%5B%5C%5D.%5D%7C%5C%5C%5B%22%5C%5C%5D)%2B%22)%40(%3F%3A(%3F%3A%5Ba-z0-9%5D(%3F%3A%5Ba-z0-9-%5D%2A%5Ba-z0-9%5D)%3F%5C.)%2B%5Ba-z0-9%5D(%3F%3A%5Ba-z0-9-%5D%2A%5Ba-z0-9%5D)%3F)" rel="nofollow noreferrer">Beyond Regex</a></span> <span> - </span> <span class="display-name">Víctor Quilón</span> <span> </span> <span class="date">18 Jan 2022 at 10:42</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>What does \x01-\x08 as part of the character class allowable in double-quotes signify? The \x08 appears to be a backspace. Is this allowed in an email address? Stumped!</span> <span> - </span> <span class="display-name">Sun Bee</span> <span> </span> <span class="date">2 Mar 2022 at 23:01</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@CharlesKornoelje in python you can use <code>re.IGNORECASE</code> to make match regardless of case</span> <span> - </span> <span class="display-name">Jonathan</span> <span> </span> <span class="date">11 May 2022 at 20:27</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Incidentally, these kinds of drawings are known as "railroad diagrams" or "<a href="https://en.wikipedia.org/wiki/Syntax_diagram" rel="nofollow noreferrer">syntax diagrams</a>." There is <a href="https://www.json.org/json-en.html" rel="nofollow noreferrer">a similar such drawing for JSON</a>.</span> <span> - </span> <span class="display-name">Tom</span> <span> </span> <span class="date">15 Jul 2022 at 22:13</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>the given regex allows emails with whitespace, according to regex101.com</span> <span> - </span> <span class="display-name">user391838</span> <span> </span> <span class="date">4 Aug 2022 at 09:12</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>Thanks to the post, I now have to go back to therapy for the trauma attempting to read and understand the diagrams and charts has given me. I now wake up in the middle of the night with a dark shadowy figure over my bed, and all I can hear is the screaming of the innocents harmed by regex. P̴L̸E̷A̵S̸E̵ ̴D̴E̸A̴R̵ ̵G̴O̶D̸ ̸M̸A̶K̶E̸ ̴I̵T̷ ̸S̷T̶O̷P̸ ̸P̴L̸E̵A̵S̵E̷</span> <span> - </span> <span class="display-name">unixandria</span> <span> </span> <span class="date">8 Aug 2022 at 15:33</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>"...can be understood if studied for a few minutes.." - which tells me the IQ of the poster in the 180+ range..</span> <span> - </span> <span class="display-name">Will Croxford</span> <span> </span> <span class="date">16 Aug 2022 at 10:12</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>If I use your regular expression in grep it gives errors, could you please post a working grep command line sample?</span> <span> - </span> <span class="display-name">sw.</span> <span> </span> <span class="date">24 Sep 2022 at 22:49</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The same issue happens in Perl.</span> <span> - </span> <span class="display-name">sw.</span> <span> </span> <span class="date">24 Sep 2022 at 23:08</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Your regex chokes on capital letters in an address. Just worth noting you should convert to all lowercase before doing the comparison</span> <span> - </span> <span class="display-name">Stephen R</span> <span> </span> <span class="date">12 Oct 2022 at 21:36</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Version that accepts uppercase: <code>(?:[a-zA-Z0-9!#$%&amp;'*+/=?^_</code>{|}~-]+(?:\.[a-zA-Z0-9!#$%&amp;'*+/=?^‌​_<code>{|}~-]+)*|"(?:[\x01‌​-\x08\x0b\x0c\x0e-\x‌​1f\x21\x23-\x5b\x5d-‌​\x7f]|\\[\x01-\x09\x‌​0b\x0c\x0e-\x7f])*")‌​@(?:(?:[a-zA-Z0-9](?‌​:[a-zA-Z0-9-]*[a-zA-‌​Z0-9])?\.)+[a-zA-Z0-‌​9](?:[a-zA-Z0-9-]*[a‌​-zA-Z0-9])?|\[(?:(?:‌​(2(5[0-5]|[0-4][0-9]‌​)|1[0-9][0-9]|[1-9]?‌​[0-9]))\.){3}(?:(2(5‌​[0-5]|[0-4][0-9])|1[‌​0-9][0-9]|[1-9]?[0-9‌​])|[a-zA-Z0-9-]*[a-z‌​A-Z0-9]:(?:[\x01-\x0‌​8\x0b\x0c\x0e-\x1f\x‌​21-\x5a\x53-\x7f]|\\‌​[\x01-\x09\x0b\x0c\x‌​0e-\x7f])+)\])</code></span> <span> - </span> <span class="display-name">Stephen R</span> <span> </span> <span class="date">12 Oct 2022 at 21:53</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Oddly email@email.io? seems to pass. I'm using DB2 REXEXP_LIKE so maybe it's flubbing up on this fairly complex regexp.</span> <span> - </span> <span class="display-name">David Bradley</span> <span> </span> <span class="date">26 Oct 2022 at 02:10</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>This does not work for email addresses with æ,ø or å in the domain name even though these are valid</span> <span> - </span> <span class="display-name">Metareven</span> <span> </span> <span class="date">28 Nov 2022 at 12:45</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Have tried this regex with Java? Doesn't work for me, even after escaping the " and \</span> <span> - </span> <span class="display-name">Michał Jabłoński</span> <span> </span> <span class="date">19 Jan 2023 at 17:49</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>php ready for preg_match <code>";(?:[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{‌​|}~-]+)*|\"(?:[\x01-‌​\x08\x0b\x0c\x0e-\x1‌​f\x21\x23-\x5b\x5d-\‌​x7f]|\\[\x01-\x09\x0‌​b\x0c\x0e-\x7f])*\")‌​@(?:(?:[a-z0-9](?:[a‌​-z0-9-]*[a-z0-9])?\.‌​)+[a-z0-9](?:[a-z0-9‌​-]*[a-z0-9])?|\[(?:(‌​?:(2(5[0-5]|[0-4][0-‌​9])|1[0-9][0-9]|[1-9‌​]?[0-9]))\.){3}(?:(2‌​(5[0-5]|[0-4][0-9])|‌​1[0-9][0-9]|[1-9]?[0‌​-9])|[a-z0-9-]*[a-z0‌​-9]:(?:[\x01-\x08\x0‌​b\x0c\x0e-\x1f\x21-\‌​x5a\x53-\x7f]|\\[\x0‌​1-\x09\x0b\x0c\x0e-\‌​x7f])+)\])\sRechnung‌​snummer;i"</code></span> <span> - </span> <span class="display-name">8ctopus</span> <span> </span> <span class="date">4 Apr 2023 at 12:05</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Why post a show regex making it sound RFC5322 complaint ? If you say its not, why post it ? A simple Google search shows RFC5322 email addresses character number limits: local part <code>^(?=.{1,64}@)</code> # 64 max chars, Domain part <code>(?=.{1,255}$)</code> # 255 max chars. Email addresses should have anchors or equivalent to confine its definition. Obviously you can't sit a length assertion in the middle after <code>@</code> for the domain without referencing an end anchor. This post is useless and not even a good example. It's Click-Bait.</span> <span> - </span> <span class="display-name">sln</span> <span> </span> <span class="date">11 May 2023 at 20:43</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span><a href="http://emailregex.com/" rel="nofollow noreferrer">emailregex.com</a> doesn't seem to be what it used to anymore... Seems like something completely irrelevant now</span> <span> - </span> <span class="display-name">brand5i2g</span> <span> </span> <span class="date">16 May 2023 at 19:58</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I've copied the content of emailregex.com here <a href="https://piotr.gg/regexp/email-address-regular-expression-that-99-99-works.html" rel="nofollow noreferrer">piotr.gg/regexp/…</a> if anyone interested.</span> <span> - </span> <span class="display-name">piotr.gradzinski</span> <span> </span> <span class="date">1 Jun 2023 at 07:36</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>849</span>
     </div>
     <div>
      <span>Answerer: </span> <span>SLaks</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Dec 2009 at 20:43</span>
     </div>
    </div>
    <div>
     <p>You should not use regular expressions to validate email addresses.</p>
     <p>Instead, in C# use the <a href="http://msdn.microsoft.com/en-us/library/system.net.mail.mailaddress.aspx" rel="noreferrer">MailAddress</a> class, like this:</p>
     <pre class="lang-csharp prettyprint-override"><code>try {
    address = new MailAddress(address).Address;
} catch(FormatException) {
    // address is invalid
}
</code></pre>
     <p>The <code>MailAddress</code> class uses a <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form" rel="noreferrer">BNF</a> parser to validate the address in full accordance with RFC822.</p>
     <p>If you plan to use the <code>MailAddress</code> to validate the e-mail address, be aware that this approach accepts the display name part of the e-mail address as well, and that may not be exactly what you want to achieve. For example, it accepts these strings as valid e-mail addresses:</p>
     <ul>
      <li>"user1@hotmail.com; user2@gmail.com"</li>
      <li>"user1@hotmail.com; user2@gmail.com; user3@company.com"</li>
      <li>"User Display Name user3@company.com"</li>
      <li>"user4 @company.com"</li>
     </ul>
     <p>In some of these cases, only the last part of the strings is parsed as the address; the rest before that is the display name. To get a plain e-mail address without any display name, you can check the normalized address against your original string.</p>
     <pre class="lang-csharp prettyprint-override"><code>bool isValid = false;

try
{
    MailAddress address = new MailAddress(emailAddress);
    isValid = (address.Address == emailAddress);
    // or
    // isValid = string.IsNullOrEmpty(address.DisplayName);
}
catch (FormatException)
{
    // address is invalid
}
</code></pre>
     <p>Furthermore, an address having a dot at the end, like <code>user@company.</code> is accepted by MailAddress as well.</p>
     <p>If you really want to use a regex, <a href="http://www.ex-parrot.com/%7Epdw/Mail-RFC822-Address.html" rel="noreferrer">here it is</a>:</p>
     <pre>(?:(?:\r\n)?[ \t])*(?:(?:(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t]
)+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:
\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(
?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ 
\t]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\0
31]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\
](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+
(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:
(?:\r\n)?[ \t])*))*|(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z
|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)
?[ \t])*)*\&lt;(?:(?:\r\n)?[ \t])*(?:@(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\
r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[
 \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)
?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t]
)*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[
 \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*
)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t]
)+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*)
*:(?:(?:\r\n)?[ \t])*)?(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+
|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r
\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:
\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t
]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031
]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](
?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?
:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?
:\r\n)?[ \t])*))*\&gt;(?:(?:\r\n)?[ \t])*)|(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?
:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?
[ \t]))*"(?:(?:\r\n)?[ \t])*)*:(?:(?:\r\n)?[ \t])*(?:(?:(?:[^()&lt;&gt;@,;:\\".\[\] 
\000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|
\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;

@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"
(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t]
)*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\
".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?
:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[
\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*|(?:[^()&lt;&gt;@,;:\\".\[\] \000-
\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(
?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)*\&lt;(?:(?:\r\n)?[ \t])*(?:@(?:[^()&lt;&gt;@,;
:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([
^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\"
.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\
]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\
[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\
r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] 
\000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]
|\\.)*\](?:(?:\r\n)?[ \t])*))*)*:(?:(?:\r\n)?[ \t])*)?(?:[^()&lt;&gt;@,;:\\".\[\] \0
00-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\
.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,
;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?
:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*
(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".
\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[
^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]
]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*\&gt;(?:(?:\r\n)?[ \t])*)(?:,\s*(
?:(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\
".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(
?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[
\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t
])*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t
])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?
:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|
\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*|(?:
[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\
]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)*\&lt;(?:(?:\r\n)
?[ \t])*(?:@(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["
()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)
?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;

@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*(?:,@(?:(?:\r\n)?[
 \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,
;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t]
)*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\
".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*)*:(?:(?:\r\n)?[ \t])*)?
(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".
\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:
\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[
"()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])
*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])
+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\
.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z
|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*\&gt;(?:(
?:\r\n)?[ \t])*))*)?;\s*)</pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>48</td>
        <td><span>You'll find that the MailAddress class in .NET 4.0 is far better at validating email addresses than in previous versions. I made some significant improvements to it.</span> <span> - </span> <span class="display-name">Jeff Tucker</span> <span> </span> <span class="date">15 Dec 2009 at 09:56</span></td>
       </tr>
       <tr>
        <td>10</td>
        <td><span>I think it sort of... doesn't work... for simpler ids. a@b doesn't validate. ar@b.com matches only till ar@b , the .com is not matched. However, something like "I am me"@[10.10.10.10] does work! :)</span> <span> - </span> <span class="display-name">Raze</span> <span> </span> <span class="date">15 Dec 2009 at 11:24</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>Are you sure it's correct? <a href="http://haacked.com/archive/2007/08/21/i-knew-how-to-validate-an-email-address-until-i.aspx" rel="nofollow noreferrer">haacked.com/archive/2007/08/21/…</a></span> <span> - </span> <span class="display-name">Joshua Drake</span> <span> </span> <span class="date">15 Dec 2009 at 16:09</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>To clarify, the part that I didn't write is the regex, not the <code>MailAddress</code> code.</span> <span> - </span> <span class="display-name">SLaks</span> <span> </span> <span class="date">23 Dec 2009 at 23:02</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Would have been nice from MS to put this in a MailAdress.Check()-method so normal people (not against you SLaks!) are able to realize this! @Slaks: Did you invent a time-stopping-machine for getting this knowledge? I'll buy one! Need 128-hour-days!</span> <span> - </span> <span class="display-name">Alexander Schmidt</span> <span> </span> <span class="date">8 Feb 2012 at 18:34</span></td>
       </tr>
       <tr>
        <td>11</td>
        <td><span>Be warned that these RFC compliant regex validators will let through a lot of email addresses that you probably wouldn't want to accept such as "a&lt;body/onload=alert('<a href="http://lol.com?'+document.cookies" rel="nofollow noreferrer">lol.com?'+document.cookies</a>) @a.a&gt;" which is a valid email address in perl's Email::Valid (which uses that huge regex), and can be exploited for XSS <a href="https://rt.cpan.org/Public/Bug/Display.html?id=75650" rel="nofollow noreferrer">rt.cpan.org/Public/Bug/Display.html?id=75650</a></span> <span> - </span> <span class="display-name">Matthew Lock</span> <span> </span> <span class="date">28 Sep 2012 at 06:03</span></td>
       </tr>
       <tr>
        <td>14</td>
        <td><span>@MatthewLock: That is no worse than <code>fake@not-a-real-domain.name</code>. You <b>must not</b> rely on email validation to prevent XSS.</span> <span> - </span> <span class="display-name">SLaks</span> <span> </span> <span class="date">28 Sep 2012 at 17:19</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>Just FYI: Microsoft does provide a "recommended" Regular Expression for this task at <a href="https://msdn.microsoft.com/en-us/library/01escwtf.aspx" rel="nofollow noreferrer">How to: Verify that Strings Are in Valid Email Format</a>. But, just after they explain how the RegEx works, they throw in "Instead of using a regular expression to validate an email address, you can use the System.Net.Mail.MailAddress class." :)</span> <span> - </span> <span class="display-name">Solomon Rutzky</span> <span> </span> <span class="date">18 Feb 2015 at 03:45</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@MatthewLock Why wouldn't you want to accept that?! What if that's actually someone's email address? Do you also reject surnames containing "null"?</span> <span> - </span> <span class="display-name">user253751</span> <span> </span> <span class="date">2 Mar 2016 at 01:38</span></td>
       </tr>
       <tr>
        <td>14</td>
        <td><span>@MatthewLock: <b>No.</b> You need to <i>escape</i> SQL queries (or, better yet, use parameters). Sanitization is not a proper defense.</span> <span> - </span> <span class="display-name">SLaks</span> <span> </span> <span class="date">2 Mar 2016 at 14:49</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>There are 3 trailing spaces in the (Markdown) source for the regular expression, and they are also in the rendered output. Some of them <i>apparently</i> due to lines not conforming to 84 characters. Are they significant? Or do they even ruin the regular expression? (Not rhetorical questions.)</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">13 Feb 2022 at 15:28</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Upvoting for the suggestion to use <code>MailAddress</code>, not for the regular expression. (Not that I think the RE is wrong, just that I would personally try really really hard to avoid using such a [admittedly clever] monstrosity in production code. It would be almost impossibly fragile, very very hard to inspect, and difficult to maintain.)</span> <span> - </span> <span class="display-name">Mark Meuer</span> <span> </span> <span class="date">8 Jul 2022 at 18:35</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Also, it's worth noting that in .NET 6 (not sure when it was introduced) there is now a <code>MailAddress.TryCreate</code> method, which allows you to avoid having to catch an exception just to test the address.</span> <span> - </span> <span class="display-name">Mark Meuer</span> <span> </span> <span class="date">8 Jul 2022 at 18:44</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I don't know if it's changed in .NET 6, but the old <code>MailAddress</code> parser <a href="https://stackoverflow.com/questions/7173401/why-does-mailaddress-think-johngmail-is-a-valid-email-address/7176931#comment105829115_7176931">could definitely be tricked</a>.</span> <span> - </span> <span class="display-name">Michael</span> <span> </span> <span class="date">17 Aug 2022 at 15:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This regex is dubious. Sections are blindly cut and pasted. There are 24 capture groups of this subsection verbatim <code>\[([^\[\]\r\\]|\\.)*\]</code> where most are enclosed in an outer group <code>(?: ...)*</code> that is quantified. Clearly this regex is for show and is meaningless.</span> <span> - </span> <span class="display-name">sln</span> <span> </span> <span class="date">11 May 2023 at 20:21</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>610</span>
     </div>
     <div>
      <span>Answerer: </span> <span>JacquesB</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Oct 2008 at 19:40</span>
     </div>
    </div>
    <div>
     <p>This question is asked a lot, but I think you should step back and ask yourself <em>why</em> you want to validate email adresses syntactically? What is the benefit really?</p>
     <ul>
      <li>It will not catch common typos.</li>
      <li>It does not prevent people from entering invalid or made-up email addresses, or entering someone else's address for that matter.</li>
     </ul>
     <p>If you want to validate that an email is correct, you have no choice than to send a confirmation email and have the user reply to that. In many cases you will <em>have</em> to send a confirmation mail anyway for security reasons or for ethical reasons (so you cannot e.g. sign someone up to a service against their will).</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>124</td>
        <td><span>It might be worth checking that they entered something@something into the field in a client side validation just to catch simple mistakes - but in general you are right.</span> <span> - </span> <span class="display-name">Martin Beckett</span> <span> </span> <span class="date">25 Aug 2009 at 16:25</span></td>
       </tr>
       <tr>
        <td>146</td>
        <td><span>@olavk: if someone enters a typo (eg: <code>me@hotmail</code>), they're obviously not going to get your confirmation email, and then where are they? They're not on your site any more and they're wondering why they couldn't sign up. Actually no they're not - they've completely forgotten about you. However, if you could just do a basic sanity check with a regex while they're still with you, then they can catch that error straight away and you've got a happy user.</span> <span> - </span> <span class="display-name">nickf</span> <span> </span> <span class="date">2 Jun 2010 at 13:53</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>@JacquesB: You make an excellent point. Just because it passes muster per the RFC doesn’t mean it is really that user’s address. Otherwise all those <code>president@whitehouse.gov</code> addresses indicate a very netbusy commander-in-chief. :)</span> <span> - </span> <span class="display-name">tchrist</span> <span> </span> <span class="date">7 Nov 2010 at 20:09</span></td>
       </tr>
       <tr>
        <td>56</td>
        <td><span>It doesn't have to be black or white. If the e-mail looks wrong, let the user know that. If the user still wants to proceed, let him. Don't force the user to conform to your regex, rather, use regex as a tool to help the user know that there might be a mistake.</span> <span> - </span> <span class="display-name">ninjaneer</span> <span> </span> <span class="date">18 Feb 2014 at 02:56</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Security. If you validate email addresses properly and only allow safe characters chances of the email address being used in some sort of malicious way reduces drastically. For example in email header exploits.</span> <span> - </span> <span class="display-name">Gellweiler</span> <span> </span> <span class="date">5 Nov 2021 at 10:49</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Quicker feedback to the user typing in the email address letting them know this has no chance of working is worth it. Especially if they're entering many. But yes, one of my pet peeves are lazy companies that don't even bother to send a confirmation email. I have a couple of dozen people around the world that constantly type my email address for things.</span> <span> - </span> <span class="display-name">David Bradley</span> <span> </span> <span class="date">26 Oct 2022 at 02:15</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>In my case I had only to match e-mail addresses in order to transform them to valid <code>mailto:</code> links. But you've got a point there!</span> <span> - </span> <span class="display-name">digijay</span> <span> </span> <span class="date">18 Mar 2023 at 23:56</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>541</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Andy Lester</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Oct 2008 at 14:42</span>
     </div>
    </div>
    <div>
     <p>It all depends on how accurate you want to be. For my purposes, where I'm just trying to keep out things like <code>bob @ aol.com</code> (spaces in emails) or <code>steve</code> (no domain at all) or <code>mary@aolcom</code> (no period before .com), I use</p>
     <pre><code>/^\S+@\S+\.\S+$/
</code></pre>
     <p>Sure, it will match things that aren't valid email addresses, but it's a matter of getting common simple errors.</p>
     <p>There are any number of changes that can be made to that regex (and some are in the comments for this answer), but it's simple, and easy to understand, and is a fine first attempt.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>9</td>
        <td><span>It does not match foobar@dk which is a valid and working email address (although probably most mail servers won't accept it or will add something.com.)</span> <span> - </span> <span class="display-name">bortzmeyer</span> <span> </span> <span class="date">14 Oct 2008 at 19:30</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Yes, that's right, it's not RFC-compliant, but that's usually not an issue.</span> <span> - </span> <span class="display-name">Andy Lester</span> <span> </span> <span class="date">15 Feb 2009 at 04:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>It won't match anything with a three part host name, e.g. .co.uk and .com.au domains).</span> <span> - </span> <span class="display-name">Richard</span> <span> </span> <span class="date">4 Mar 2009 at 18:26</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>Yes, it will. I suggest you try it yourself. $ perl -le'print q{foo@bar.co.uk} =~ /^\S+@\S+\.\S+$/ ? q{Y} : q{N}'</span> <span> - </span> <span class="display-name">Andy Lester</span> <span> </span> <span class="date">6 Mar 2009 at 04:51</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span>@Richard: <code>.</code> is included in <code>\S</code>.</span> <span> - </span> <span class="display-name">David Thornley</span> <span> </span> <span class="date">17 Dec 2009 at 18:48</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@bortzmeyer: Yeah, well. It doesn’t match <code>postmaster</code>, either, which I am pretty sure is going to be a deliverable address. :)</span> <span> - </span> <span class="display-name">tchrist</span> <span> </span> <span class="date">7 Nov 2010 at 20:16</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>\S includes @ so it will also match a@@b.c</span> <span> - </span> <span class="display-name">JJJ</span> <span> </span> <span class="date">16 Oct 2012 at 06:18</span></td>
       </tr>
       <tr>
        <td>64</td>
        <td><span>JJJ: Yes, it will match a lot of crap. It will match &amp;$*#$(@$0(%))$#.)&amp;*)(*$, too. For me, I'm more concerned with catching the odd fumble-finger typo like <code>mary@aolcom</code> than I am complete garbage. YMMV.</span> <span> - </span> <span class="display-name">Andy Lester</span> <span> </span> <span class="date">16 Oct 2012 at 16:03</span></td>
       </tr>
       <tr>
        <td>14</td>
        <td><span>Just to control for <code>@</code> signs: <code>/^[^\s@]+@[^\s@]+\.[^\s@]{2,}$/</code> <a href="http://jsfiddle.net/b9chris/mXB96/" rel="nofollow noreferrer">jsfiddle.net/b9chris/mXB96</a></span> <span> - </span> <span class="display-name">Chris Moschini</span> <span> </span> <span class="date">4 Aug 2014 at 21:32</span></td>
       </tr>
       <tr>
        <td>26</td>
        <td><span>And another common typo: two consecutive dots in domain name or a comma instead of a dot. <code>^[^\s@]+@([^\s@.,]+\.)+[^\s@.,]{2,}$</code></span> <span> - </span> <span class="display-name">Piskvor left the building</span> <span> </span> <span class="date">24 Sep 2015 at 09:12</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>We want explanation about this :) . People come here to see Why it is the way it is. Please consider Regex explanation too! Not everyone is advanced enough to know what you wrote there without explanation. Thanks</span> <span> - </span> <span class="display-name">Pratik Joshi</span> <span> </span> <span class="date">6 Dec 2015 at 10:47</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>Spaces are actually allowed in email addresses, provided they are backslash-escaped inside a quoted-pair. <code>"an\ inbox"@example.com</code> is a valid email address, and will deliver to an inbox named <code>an inbox</code>.</span> <span> - </span> <span class="display-name">awwright</span> <span> </span> <span class="date">11 Sep 2020 at 06:20</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@awwright Yes, spaces are allowed in email addresses. However, I suggest that it's far more likely that you'll stop someone from mistakenly entering a space in an email address than you'll find someone whose email address really is <code>"Bob\ Smith"@example.com</code>.</span> <span> - </span> <span class="display-name">Andy Lester</span> <span> </span> <span class="date">11 Sep 2020 at 13:51</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>I like this one, it covers all common cases, BUT, you need to change it to <code>^\S+@\S+\.\w+$</code> to avoid allowing e.g. <code>john@doe..</code> for example. With the <code>\w</code> instead we require an ending of <code>.[at least one letter or number]</code></span> <span> - </span> <span class="display-name">Anders</span> <span> </span> <span class="date">22 Dec 2021 at 08:55</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span><code>/.+@\S+\.\S+$/</code> since spaces are allowed in email addresses as long as they are wrapped in quotes. <a href="https://regex101.com/r/PUMajv/2" rel="nofollow noreferrer">regex101.com/r/PUMajv/2</a></span> <span> - </span> <span class="display-name">Caleb Taylor</span> <span> </span> <span class="date">28 Dec 2021 at 02:02</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Perhaps list some examples of <i>false positives</i> and some examples of <i>false negatives</i>, e.g., from the comments here (e.g. with some annotation as to why it is not bad thing, pros/cons, caveats, etc.)? Comments may be deleted at any time.</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">13 Feb 2022 at 14:39</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>373</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Good Person</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Apr 2009 at 19:39</span>
     </div>
    </div>
    <div>
     <p>It depends on what you mean by best: If you're talking about catching every valid email address use the following:</p>
     <pre class="lang-none prettyprint-override"><code>(?:(?:\r\n)?[ \t])*(?:(?:(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t]
)+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:
\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(
?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ 
\t]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\0
31]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\
](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+
(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:
(?:\r\n)?[ \t])*))*|(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z
|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)
?[ \t])*)*\&lt;(?:(?:\r\n)?[ \t])*(?:@(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\
r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[
 \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)
?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t]
)*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[
 \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*
)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t]
)+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*)
*:(?:(?:\r\n)?[ \t])*)?(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+
|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r
\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:
\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t
]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031
]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](
?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?
:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?
:\r\n)?[ \t])*))*\&gt;(?:(?:\r\n)?[ \t])*)|(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?
:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?
[ \t]))*"(?:(?:\r\n)?[ \t])*)*:(?:(?:\r\n)?[ \t])*(?:(?:(?:[^()&lt;&gt;@,;:\\".\[\] 
\000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|
\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;
@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"
(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t]
)*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\
".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?
:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[
\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*|(?:[^()&lt;&gt;@,;:\\".\[\] \000-
\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(
?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)*\&lt;(?:(?:\r\n)?[ \t])*(?:@(?:[^()&lt;&gt;@,;
:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([
^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\"
.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\
]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\
[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\
r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] 
\000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]
|\\.)*\](?:(?:\r\n)?[ \t])*))*)*:(?:(?:\r\n)?[ \t])*)?(?:[^()&lt;&gt;@,;:\\".\[\] \0
00-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\
.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,
;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?
:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*
(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".
\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[
^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]
]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*\&gt;(?:(?:\r\n)?[ \t])*)(?:,\s*(
?:(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\
".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(
?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[
\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t
])*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t
])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?
:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|
\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*|(?:
[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\
]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)*\&lt;(?:(?:\r\n)
?[ \t])*(?:@(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["
()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)
?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;
@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*(?:,@(?:(?:\r\n)?[
 \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,
;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t]
)*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\
".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*)*:(?:(?:\r\n)?[ \t])*)?
(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".
\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:
\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[
"()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])
*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])
+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\
.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z
|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*\&gt;(?:(
?:\r\n)?[ \t])*))*)?;\s*)
</code></pre>
     <p>(<a href="http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html" rel="noreferrer">http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html</a>) If you're looking for something simpler but that will catch most valid email addresses try something like:</p>
     <pre class="lang-php prettyprint-override"><code>"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$"
</code></pre>
     <p>EDIT: From the link:</p>
     <blockquote>
      <p>This regular expression will only validate addresses that have had any comments stripped and replaced with whitespace (this is done by the module).</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>63</td>
        <td><span>Can you give me an example of some <code>email address</code> that wrongly passes through the second one, but is caught by the longer regex?</span> <span> - </span> <span class="display-name">Lazer</span> <span> </span> <span class="date">15 May 2010 at 18:32</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>Much though I did once love it, that’s an RFC 822 validator, not <a href="http://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982">an RFC 5322</a> one.</span> <span> - </span> <span class="display-name">tchrist</span> <span> </span> <span class="date">7 Nov 2010 at 20:17</span></td>
       </tr>
       <tr>
        <td>27</td>
        <td><span>@Lazer in..valid@example.com would be a simple example. You aren't allowed to have two consecutive unquoted dots in the local-part.</span> <span> - </span> <span class="display-name">Randal Schwartz</span> <span> </span> <span class="date">6 Dec 2011 at 18:04</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>I tried to implement this but no parser is taking it. What was a target that was able to compile it?</span> <span> - </span> <span class="display-name">Mikhail</span> <span> </span> <span class="date">25 Jul 2012 at 06:17</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>@Mikhail perl but you shouldn't actually use it.</span> <span> - </span> <span class="display-name">Good Person</span> <span> </span> <span class="date">8 Jan 2013 at 18:48</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Also, a@a will pass on the first regex but fail in the second regex. Yes, some real emails don't have a . after @</span> <span> - </span> <span class="display-name">priomsrb</span> <span> </span> <span class="date">5 Jun 2013 at 01:24</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>you can also quote anything you want before the @, like: "something@gmail.com"@foo.com is an address with account name something@gmail.com stored in the domain foo.com</span> <span> - </span> <span class="display-name">chad</span> <span> </span> <span class="date">21 Jun 2013 at 18:43</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Just in case, if you want to know what that regular expression does, head here <a href="http://regex101.com/r/xU9bO0" rel="nofollow noreferrer">regex101.com/r/xU9bO0</a></span> <span> - </span> <span class="display-name">thefourtheye</span> <span> </span> <span class="date">26 Oct 2013 at 03:53</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span><a href="https://www.debuggex.com/i/kt6_PU2Sz2jP_K51.png" rel="nofollow noreferrer">This</a> makes it quite easier to understand... Haha!</span> <span> - </span> <span class="display-name">sp00m</span> <span> </span> <span class="date">14 Nov 2013 at 15:13</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>It is better not to use regex, than using such complex, non debuggable regex. You would be better off doing string parsing and enforcing rules than such long regex. <a href="http://www.codinghorror.com/blog/2008/06/regular-expressions-now-you-have-two-problems.html" rel="nofollow noreferrer">codinghorror.com/blog/2008/06/…</a></span> <span> - </span> <span class="display-name">iankit</span> <span> </span> <span class="date">26 Jan 2014 at 19:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This regex still validates: !!@192.168.0.555 (which is an invalid IP)</span> <span> - </span> <span class="display-name">Josue Alexander Ibarra</span> <span> </span> <span class="date">11 Apr 2014 at 21:09</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>The 2nd regex wrongly validates email@internet.com. (email with dot in the end)</span> <span> - </span> <span class="display-name">rsc</span> <span> </span> <span class="date">28 May 2014 at 09:05</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@RSC that is a FQDN which is fine</span> <span> - </span> <span class="display-name">Good Person</span> <span> </span> <span class="date">28 May 2014 at 23:16</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Your "simple" expression doesn't handle single quotes in the username portion. Eg brian.o'connor@domain.com (which is valid)</span> <span> - </span> <span class="display-name">NickG</span> <span> </span> <span class="date">30 Jul 2015 at 10:22</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Note that it's RFC 822, which is pretty outdated standard and doesn't cover a lot of new cases introduced by new versions.</span> <span> - </span> <span class="display-name">RReverser</span> <span> </span> <span class="date">21 Aug 2015 at 16:21</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Has anyone actually tried this "RFC822 compatible" regex? It does not work for me - <a href="https://regex101.com/r/gM6lE7/3" rel="nofollow noreferrer">regex101.com/r/gM6lE7/3</a></span> <span> - </span> <span class="display-name">user2610678</span> <span> </span> <span class="date">14 Nov 2015 at 19:26</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I have a compliant ajv validator... but on top of that, I don't want capital letters either... hence why I can use an even simpler version of this. I require my clients to send me lower case emails only.</span> <span> - </span> <span class="display-name">Ray Foss</span> <span> </span> <span class="date">9 Nov 2019 at 06:45</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This expression validates folding whitespace, which is part of the MIME message and not considered part of the email address. It is not useful, unless you are parsing an address out of a MIME message.</span> <span> - </span> <span class="display-name">awwright</span> <span> </span> <span class="date">31 Aug 2020 at 21:29</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>333</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Josh Stodola</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Jan 2012 at 02:24</span>
     </div>
    </div>
    <div>
     <p>Per <a href="http://www.w3.org/TR/html5/forms.html#valid-e-mail-address" rel="noreferrer">the W3C HTML5 specification</a>:</p>
     <pre class="lang-none prettyprint-override"><code>^[a-zA-Z0-9.!#$%&amp;'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$
</code></pre>
     <p>Context:</p>
     <blockquote>
      <p>A <strong>valid e-mail address</strong> is a string that matches the ABNF production […].</p>
      <p><i>Note: This requirement is a <a href="http://www.w3.org/TR/html5/introduction.html#willful-violation" rel="noreferrer">willful violation</a> of <a href="https://www.rfc-editor.org/rfc/rfc5322" rel="noreferrer">RFC 5322</a>, which defines a syntax for e-mail addresses that is simultaneously too strict (before the “@” character), too vague (after the “@” character), and too lax (allowing comments, whitespace characters, and quoted strings in manners unfamiliar to most users) to be of practical use here.</i></p>
      <p><i>The following JavaScript- and Perl-compatible regular expression is an implementation of the above definition.</i></p><i>
       <pre class="lang-none prettyprint-override"><code>/^[a-zA-Z0-9.!#$%&amp;'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
</code></pre></i>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>13</td>
        <td><span>This is interesting. It's a violation of RFC, but a willful one and it makes sesne. Real world example: gmail ignores dots in the part before @, so if your email is test@gmail.com you can send emails to test.@gmail.com or test....@gmail.com, both of those addresses are invalid according to RFC, but valid in real world.</span> <span> - </span> <span class="display-name">valentinas</span> <span> </span> <span class="date">16 Jan 2013 at 05:04</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>I think last part should be '+' instead of '*': ^[a-zA-Z0-9.!#$%&amp;'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0‌​-9-]+)+$</span> <span> - </span> <span class="display-name">mmmmmm</span> <span> </span> <span class="date">21 Jan 2013 at 12:12</span></td>
       </tr>
       <tr>
        <td>11</td>
        <td><span>@mmmmmm <code>john.doe@localhost</code> is valid. For sure, in a real world application (i.e. a community), I'd like your suggest to replace * by +</span> <span> - </span> <span class="display-name">rabudde</span> <span> </span> <span class="date">1 Feb 2013 at 10:03</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@valentinas Actually, the RFC does <i>not</i> preclude these local parts, but they have to be quoted. <code>"test...."@gmail.com</code> is perfectly valid according to the RFC and semantically equivalent to <code>test....@gmail.com</code>.</span> <span> - </span> <span class="display-name">Rinke</span> <span> </span> <span class="date">17 Nov 2014 at 09:01</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I get an error while trying to send email using python through my company's relay if I try to send to an address with a .@ or ..@. Actually that is also the case with a _@. I rather remove those before sending than trusting that the recipient will do it.</span> <span> - </span> <span class="display-name">ndvo</span> <span> </span> <span class="date">11 Feb 2016 at 11:31</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>hmmm..., phpstorm says: <code>(...+...)* might be exploited (ReDoS, Regular Expression Denial of Service)</code></span> <span> - </span> <span class="display-name">steven</span> <span> </span> <span class="date">27 Jul 2017 at 19:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>soo..... underscores can't be in domain names? i.e. this is considered invalid <code>joe@foo_bar.com</code>?</span> <span> - </span> <span class="display-name">AndyPerlitch</span> <span> </span> <span class="date">2 Nov 2018 at 21:11</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Perl errors with "Use of ?PATTERN? without explicit operator is deprecated"</span> <span> - </span> <span class="display-name">J. McNerney</span> <span> </span> <span class="date">24 Jun 2019 at 13:27</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>299</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Dominic Sayers</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Feb 2009 at 16:13</span>
     </div>
    </div>
    <div>
     <p>[UPDATED] I've collated everything I know about email address validation at <a href="http://isemail.info" rel="noreferrer">http://isemail.info</a>, which now not only validates, but it also diagnoses problems with email addresses. I agree with many of the comments here that validation is only part of the answer; see my essay <em><a href="http://isemail.info/about" rel="noreferrer">What is a valid email address?</a></em>.</p>
     <p>is_email() remains, as far as I know, the only validator that will tell you definitively whether a given string is a valid email address or not. I've uploaded a new version at <a href="http://isemail.info/" rel="noreferrer">http://isemail.info/</a></p>
     <p>I collated test cases from Cal Henderson, Dave Child, Phil Haack, Doug Lovell, <a href="https://en.wikipedia.org/wiki/Email#Message_format" rel="noreferrer">RFC&nbsp;5322</a> and <a href="https://en.wikipedia.org/wiki/Email_address#Syntax" rel="noreferrer">RFC&nbsp;3696</a>. 275 test addresses in all. I ran all these tests against all the free validators I could find.</p>
     <p>I'll try to keep this page up-to-date as people enhance their validators. Thanks to Cal, Michael, Dave, Paul and Phil for their help and cooperation in compiling these tests and constructive criticism of <a href="http://code.google.com/p/isemail" rel="noreferrer">my own validator</a>.</p>
     <p>People should be aware of the <a href="http://www.rfc-editor.org/errata_search.php?rfc=3696" rel="noreferrer">errata against RFC 3696</a> in particular. Three of the canonical examples are in fact invalid addresses. And the maximum length of an address is 254 or 256 characters, <strong>not</strong> 320.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span><a href="http://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982">This validator</a> also seems correct. [...time passes...] Hm, looks like it is just RFC 5322, not 3693 or errata thereto.</span> <span> - </span> <span class="display-name">tchrist</span> <span> </span> <span class="date">7 Nov 2010 at 20:11</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Very nice. Here we not only get a nice essay, we get a validation tester as well as a library to download. Nice answer!</span> <span> - </span> <span class="display-name">bgmCoder</span> <span> </span> <span class="date">9 Apr 2013 at 20:49</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Your validator doesn't support punycode (RFC 3492). name@öäü.at can be a valid address. (it translates to name@xn--4ca9at.at)</span> <span> - </span> <span class="display-name">Josef</span> <span> </span> <span class="date">25 Mar 2015 at 07:28</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Hi @Josef. You should try to validate <code>name@xn--4ca9at.at</code> since this code is about validation, not interpretation. If you'd like to add a punycode translator then I'm happy to accept a pull request at <a href="https://github.com/dominicsayers/isemail" rel="nofollow noreferrer">github.com/dominicsayers/isemail</a></span> <span> - </span> <span class="display-name">Dominic Sayers</span> <span> </span> <span class="date">27 Apr 2015 at 18:19</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>207</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Abigail</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Dec 2009 at 21:44</span>
     </div>
    </div>
    <div>
     <p>It’s easy in Perl 5.10 or newer:</p>
     <pre class="lang-none prettyprint-override"><code>/(?(DEFINE)
   (?&lt;address&gt;         (?&amp;mailbox) | (?&amp;group))
   (?&lt;mailbox&gt;         (?&amp;name_addr) | (?&amp;addr_spec))
   (?&lt;name_addr&gt;       (?&amp;display_name)? (?&amp;angle_addr))
   (?&lt;angle_addr&gt;      (?&amp;CFWS)? &lt; (?&amp;addr_spec) &gt; (?&amp;CFWS)?)
   (?&lt;group&gt;           (?&amp;display_name) : (?:(?&amp;mailbox_list) | (?&amp;CFWS))? ;
                                          (?&amp;CFWS)?)
   (?&lt;display_name&gt;    (?&amp;phrase))
   (?&lt;mailbox_list&gt;    (?&amp;mailbox) (?: , (?&amp;mailbox))*)

   (?&lt;addr_spec&gt;       (?&amp;local_part) \@ (?&amp;domain))
   (?&lt;local_part&gt;      (?&amp;dot_atom) | (?&amp;quoted_string))
   (?&lt;domain&gt;          (?&amp;dot_atom) | (?&amp;domain_literal))
   (?&lt;domain_literal&gt;  (?&amp;CFWS)? \[ (?: (?&amp;FWS)? (?&amp;dcontent))* (?&amp;FWS)?
                                 \] (?&amp;CFWS)?)
   (?&lt;dcontent&gt;        (?&amp;dtext) | (?&amp;quoted_pair))
   (?&lt;dtext&gt;           (?&amp;NO_WS_CTL) | [\x21-\x5a\x5e-\x7e])

   (?&lt;atext&gt;           (?&amp;ALPHA) | (?&amp;DIGIT) | [!#\$%&amp;'*+-/=?^_`{|}~])
   (?&lt;atom&gt;            (?&amp;CFWS)? (?&amp;atext)+ (?&amp;CFWS)?)
   (?&lt;dot_atom&gt;        (?&amp;CFWS)? (?&amp;dot_atom_text) (?&amp;CFWS)?)
   (?&lt;dot_atom_text&gt;   (?&amp;atext)+ (?: \. (?&amp;atext)+)*)

   (?&lt;text&gt;            [\x01-\x09\x0b\x0c\x0e-\x7f])
   (?&lt;quoted_pair&gt;     \\ (?&amp;text))

   (?&lt;qtext&gt;           (?&amp;NO_WS_CTL) | [\x21\x23-\x5b\x5d-\x7e])
   (?&lt;qcontent&gt;        (?&amp;qtext) | (?&amp;quoted_pair))
   (?&lt;quoted_string&gt;   (?&amp;CFWS)? (?&amp;DQUOTE) (?:(?&amp;FWS)? (?&amp;qcontent))*
                        (?&amp;FWS)? (?&amp;DQUOTE) (?&amp;CFWS)?)

   (?&lt;word&gt;            (?&amp;atom) | (?&amp;quoted_string))
   (?&lt;phrase&gt;          (?&amp;word)+)

   # Folding white space
   (?&lt;FWS&gt;             (?: (?&amp;WSP)* (?&amp;CRLF))? (?&amp;WSP)+)
   (?&lt;ctext&gt;           (?&amp;NO_WS_CTL) | [\x21-\x27\x2a-\x5b\x5d-\x7e])
   (?&lt;ccontent&gt;        (?&amp;ctext) | (?&amp;quoted_pair) | (?&amp;comment))
   (?&lt;comment&gt;         \( (?: (?&amp;FWS)? (?&amp;ccontent))* (?&amp;FWS)? \) )
   (?&lt;CFWS&gt;            (?: (?&amp;FWS)? (?&amp;comment))*
                       (?: (?:(?&amp;FWS)? (?&amp;comment)) | (?&amp;FWS)))

   # No whitespace control
   (?&lt;NO_WS_CTL&gt;       [\x01-\x08\x0b\x0c\x0e-\x1f\x7f])

   (?&lt;ALPHA&gt;           [A-Za-z])
   (?&lt;DIGIT&gt;           [0-9])
   (?&lt;CRLF&gt;            \x0d \x0a)
   (?&lt;DQUOTE&gt;          ")
   (?&lt;WSP&gt;             [\x20\x09])
 )

 (?&amp;address)/x
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>22</td>
        <td><span>Would love to see this in Python</span> <span> - </span> <span class="display-name">tdc</span> <span> </span> <span class="date">15 Dec 2011 at 16:36</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>I think that only a subset of the <code>addrspec</code> part is really relevant to the question. Accepting more than that and forwarding it though some other part of the system that is not ready to accept full RFC5822 addresses is like shooting is your own foot.</span> <span> - </span> <span class="display-name">dolmen</span> <span> </span> <span class="date">17 Dec 2011 at 13:53</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>Great (+1) but technically it's not a regex of course... (which would be impossible since the grammar is not regular).</span> <span> - </span> <span class="display-name">Rinke</span> <span> </span> <span class="date">3 Jan 2013 at 21:41</span></td>
       </tr>
       <tr>
        <td>12</td>
        <td><span>regexes stopped being regular some time ago. It is a valid Perl 'regex' though!</span> <span> - </span> <span class="display-name">rjh</span> <span> </span> <span class="date">10 Mar 2014 at 15:00</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>I set up a test for this regex on IDEone: <a href="http://ideone.com/2XFecH" rel="nofollow noreferrer">ideone.com/2XFecH</a> However, it doesn't fair "perfectly." Would anyone care to chime in? Am I missing something?</span> <span> - </span> <span class="display-name">Mike</span> <span> </span> <span class="date">30 Jul 2014 at 17:56</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I used to use this with preg_match in PHP and it always worked flawlessly. Unfortunately it now fails (for whatever reason) for all addresses with more than 13 characters before the @ in PHP 7.3.</span> <span> - </span> <span class="display-name">cgogolin</span> <span> </span> <span class="date">5 Aug 2020 at 19:58</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This includes FWS, CFWS, and comments, which are features of a MIME message–not part of the email address.</span> <span> - </span> <span class="display-name">awwright</span> <span> </span> <span class="date">31 Aug 2020 at 18:14</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>How is it possible? I can't find any @ in here?</span> <span> - </span> <span class="display-name">Thomas Weller</span> <span> </span> <span class="date">25 Sep 2020 at 11:44</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Why is it easier in Perl 5.10? What features are used? How is "@" covered? - a numeric code of some kind? How can we know it is correct near "<code>!#\$%&amp;'*+-/=?^_</code>"?</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">13 Feb 2022 at 15:41</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Unfortunally this doesnt work with PHP &gt;= 7.3 and more than 15 characters before @ because of 'catastrophic backtracking' as a regex tester says.</span> <span> - </span> <span class="display-name">Merilix2</span> <span> </span> <span class="date">11 Apr 2022 at 16:43</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I obtain an error in Perl 5.34.0: (?&lt;atext&gt; (?&amp;ALPHA) | (?&amp;DIGIT) | [ &lt;-- HERE !#\$%&amp;'*+-/ at parsing-test.pl</span> <span> - </span> <span class="display-name">sw.</span> <span> </span> <span class="date">25 Sep 2022 at 13:37</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>It seems you should replace it like this? (?&amp;ALPHA) | (?&amp;DIGIT) | [\!\#\$\%\&amp;\'*\+\-\/\=\?\^_`\{\|\}\~])</span> <span> - </span> <span class="display-name">sw.</span> <span> </span> <span class="date">25 Sep 2022 at 14:19</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@ThomasWeller: fwiw, it is on the addr_spec definition's line</span> <span> - </span> <span class="display-name">Olivier Dulac</span> <span> </span> <span class="date">3 Mar 2023 at 18:13</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>197</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Per Hornshøj-Schierbeck</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Oct 2008 at 14:17</span>
     </div>
    </div>
    <div>
     <p>I use</p>
     <pre class="lang-none prettyprint-override"><code>^\w+([-+.']\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
</code></pre>
     <p>Which is the one used in ASP.NET by the RegularExpressionValidator.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>37</td>
        <td><span>Boo! My (ill-advised) address of <code>!@mydomain.net</code> is rejected.</span> <span> - </span> <span class="display-name">Phrogz</span> <span> </span> <span class="date">19 Jan 2011 at 21:35</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>According to this page <a href="http://data.iana.org/TLD/tlds-alpha-by-domain.txt" rel="nofollow noreferrer">data.iana.org/TLD/tlds-alpha-by-domain.txt</a> there is no domains with just a single character in top level e.g. "something.c", "something.a", here is version that support at least 2 characters: "something.pl", "something.us": <code>^\\w+([-+.']\\w+)*@\\w+([-.]\\w+)*\\.\\w{2,}([-.]\\w+)*$</code></span> <span> - </span> <span class="display-name">Tomasz Szulc</span> <span> </span> <span class="date">19 Nov 2015 at 12:53</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>@Wayne Whitty. You have hit upon the primary issue of whether to cater for the vast majority of addresses, or ALL, including ones that nobody would use, except to test email validation.</span> <span> - </span> <span class="display-name">Patanjali</span> <span> </span> <span class="date">28 Nov 2015 at 03:13</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@TomaszSzulc extra back slash in your answer is confusing, I just corrected it and 2 chars domains names support is working, ^\w+([-+.']\w+)*@\w+([-.]\w+)*\.\w{2,}([-.]\w+)*$</span> <span> - </span> <span class="display-name">Aqib Mumtaz</span> <span> </span> <span class="date">30 Nov 2015 at 11:16</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>We want explanation about this :) . People come here to see Why it is the way it is. Please consider Regex explanation too! Not everyone is advanced enough to know what you wrote there without explanation. Thanks</span> <span> - </span> <span class="display-name">Pratik Joshi</span> <span> </span> <span class="date">6 Dec 2015 at 10:47</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span><code>^\w+([-+.']|\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</code> allows stuff like <code>shabadoo--morgen@gmail.com</code></span> <span> - </span> <span class="display-name">ganqqwerty</span> <span> </span> <span class="date">7 Dec 2015 at 14:25</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>this fails on <code>simon-@hotmail.com</code> which is in fact valid (a customer of ours had a similar address)`</span> <span> - </span> <span class="display-name">Simon_Weaver</span> <span> </span> <span class="date">10 Feb 2017 at 00:43</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Simon_Weaver: Yes, this fails on emails with local-part that ends in <code>-</code>, <code>+</code>, <code>.</code> and <code>'</code>.</span> <span> - </span> <span class="display-name">Voicu</span> <span> </span> <span class="date">4 Jan 2018 at 00:54</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>If people choose to provide a <code>+</code> sign at the end of their local-part (which is valid for Gmail for example), why would we restrict that by using this regex?</span> <span> - </span> <span class="display-name">Voicu</span> <span> </span> <span class="date">4 Jan 2018 at 00:57</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>149</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Chris Vest</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Oct 2008 at 14:17</span>
     </div>
    </div>
    <div>
     <p>I don't know about best, but <a href="http://ex-parrot.com/%7Epdw/Mail-RFC822-Address.html" rel="noreferrer">this one</a> is at least correct, as long as the addresses have their comments stripped and replaced with white space.</p>
     <p>Seriously. You should use an already-written library for validating emails. The best way is probably to just send a verification e-mail to that address.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span>As far as I know, some libraries are wrong, too. I vaguely remember that PHP PEAR had such a bug.</span> <span> - </span> <span class="display-name">bortzmeyer</span> <span> </span> <span class="date">14 Oct 2008 at 14:34</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>That page also has a disclaimer at the bottom about a couple of things from the spec. that the regexp does not support.</span> <span> - </span> <span class="display-name">Chris Vest</span> <span> </span> <span class="date">14 Oct 2008 at 14:37</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span>That’s an RFC 822 spec, not an <a href="http://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982">RFC 5322</a> spec.</span> <span> - </span> <span class="display-name">tchrist</span> <span> </span> <span class="date">7 Nov 2010 at 20:12</span></td>
       </tr>
       <tr>
        <td>14</td>
        <td><span>Ultimately, he's right in that the only way to truly <i>validate</i> an email address is to send an email to it and await a reply.</span> <span> - </span> <span class="display-name">Blazemonger</span> <span> </span> <span class="date">26 Oct 2011 at 19:43</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>140</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Rinke</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Dec 2012 at 21:07</span>
     </div>
    </div>
    <div>
     <h1>Quick answer</h1>
     <p>Use the following regex for input validation:</p>
     <p><code>([-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*|"([]!#-[^-~ \t]|(\\[\t -~]))+")@[0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?(\.[0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?)+</code></p>
     <p>Addresses matched by this regex:</p>
     <ul>
      <li>have a local part (i.e. the part before the @-sign) that is strictly compliant with RFC&nbsp;5321/5322,</li>
      <li>have a domain part (i.e. the part after the @-sign) that is a host name with at least two labels, each of which is at most 63 characters long.</li>
     </ul>
     <p>The second constraint is a restriction on RFC&nbsp;5321/5322.</p>
     <h1>Elaborate answer</h1>
     <p>Using a regular expression that recognizes email addresses could be useful in various situations: for example to scan for email addresses in a document, to validate user input, or as an integrity constraint on a data repository.</p>
     <p>It should however be noted that if you want to find out if the address actually refers to an existing mailbox, there's no substitute for sending a message to the address. If you only want to check if an address is grammatically correct then you could use a regular expression, but note that <code>""@[]</code> is a grammatically correct email address that certainly doesn't refer to an existing mailbox.</p>
     <p>The syntax of email addresses has been defined in various <a href="http://en.wikipedia.org/wiki/Request_for_Comments" rel="noreferrer">RFCs</a>, most notably <a href="https://www.rfc-editor.org/rfc/rfc822" rel="noreferrer">RFC&nbsp;822</a> and <a href="https://www.rfc-editor.org/rfc/rfc5322" rel="noreferrer">RFC&nbsp;5322</a>. RFC&nbsp;822 should be seen as the "original" standard and RFC&nbsp;5322 as the latest standard. The syntax defined in RFC&nbsp;822 is the most lenient and subsequent standards have restricted the syntax further and further, where newer systems or services should recognize obsolete syntax, but never produce it.</p>
     <p>In this answer I’ll take “email address” to mean <code>addr-spec</code> as defined in the RFCs (i.e. <code>jdoe@example.org</code>, but not <code>"John Doe"&lt;jdoe@example.org&gt;</code>, nor <code>some-group:jdoe@example.org,mrx@exampel.org;</code>).</p>
     <p>There's one problem with translating the RFC syntaxes into regexes: the syntaxes are not regular! This is because they allow for optional comments in email addresses that can be infinitely nested, while infinite nesting can't be described by a regular expression. To scan for or validate addresses containing comments you need a parser or more powerful expressions. (Note that languages like Perl have constructs to describe context free grammars in a regex-like way.) In this answer I'll disregard comments and only consider proper regular expressions.</p>
     <p>The RFCs define syntaxes for email messages, not for email addresses as such. Addresses may appear in various header fields and this is where they are primarily defined. When they appear in header fields addresses may contain (between lexical tokens) whitespace, comments and even linebreaks. Semantically this has no significance however. By removing this whitespace, etc. from an address you get a semantically equivalent <em>canonical representation</em>. Thus, the canonical representation of <code>first. last (comment) @ [3.5.7.9]</code> is <code>first.last@[3.5.7.9]</code>.</p>
     <p>Different syntaxes should be used for different purposes. If you want to scan for email addresses in a (possibly very old) document it may be a good idea to use the syntax as defined in RFC&nbsp;822. On the other hand, if you want to validate user input you may want to use the syntax as defined in RFC&nbsp;5322, probably only accepting canonical representations. You should decide which syntax applies to your specific case.</p>
     <p>I use POSIX "extended" regular expressions in this answer, assuming an ASCII compatible character set.</p>
     <h2>RFC 822</h2>
     <p>I arrived at the following regular expression. I invite everyone to try and break it. If you find any false positives or false negatives, please post them in a comment and I'll try to fix the expression as soon as possible.</p>
     <p><code>([^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|"(\n|(\\\r)*([^"\\\r\n]|\\[^\r]))*(\\\r)*")(\.([^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|"(\n|(\\\r)*([^"\\\r\n]|\\[^\r]))*(\\\r)*"))*@([^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|\[(\n|(\\\r)*([^][\\\r\n]|\\[^\r]))*(\\\r)*])(\.([^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|\[(\n|(\\\r)*([^][\\\r\n]|\\[^\r]))*(\\\r)*]))*</code></p>
     <p>I believe it's fully compliant with RFC 822 including the <a href="http://www.rfc-editor.org/errata_search.php?rfc=822" rel="noreferrer">errata</a>. It only recognizes email addresses in their canonical form. For a regex that recognizes (folding) whitespace see the derivation below.</p>
     <p>The derivation shows how I arrived at the expression. I list all the relevant grammar rules from the RFC exactly as they appear, followed by the corresponding regex. Where an erratum has been published I give a separate expression for the corrected grammar rule (marked "erratum") and use the updated version as a subexpression in subsequent regular expressions.</p>
     <p>As stated in paragraph 3.1.4. of RFC 822 optional linear white space may be inserted between lexical tokens. Where applicable I've expanded the expressions to accommodate this rule and marked the result with "opt-lwsp".</p>
     <pre class="lang-none prettyprint-override"><code>CHAR        =  &lt;any ASCII character&gt;
            =~ .

CTL         =  &lt;any ASCII control character and DEL&gt;
            =~ [\x00-\x1F\x7F]

CR          =  &lt;ASCII CR, carriage return&gt;
            =~ \r

LF          =  &lt;ASCII LF, linefeed&gt;
            =~ \n

SPACE       =  &lt;ASCII SP, space&gt;
            =~  

HTAB        =  &lt;ASCII HT, horizontal-tab&gt;
            =~ \t

&lt;"&gt;         =  &lt;ASCII quote mark&gt;
            =~ "

CRLF        =  CR LF
            =~ \r\n

LWSP-char   =  SPACE / HTAB
            =~ [ \t]

linear-white-space =  1*([CRLF] LWSP-char)
                   =~ ((\r\n)?[ \t])+

specials    =  "(" / ")" / "&lt;" / "&gt;" / "@" /  "," / ";" / ":" / "\" / &lt;"&gt; /  "." / "[" / "]"
            =~ [][()&lt;&gt;@,;:\\".]

quoted-pair =  "\" CHAR
            =~ \\.

qtext       =  &lt;any CHAR excepting &lt;"&gt;, "\" &amp; CR, and including linear-white-space&gt;
            =~ [^"\\\r]|((\r\n)?[ \t])+

dtext       =  &lt;any CHAR excluding "[", "]", "\" &amp; CR, &amp; including linear-white-space&gt;
            =~ [^][\\\r]|((\r\n)?[ \t])+

quoted-string  =  &lt;"&gt; *(qtext|quoted-pair) &lt;"&gt;
               =~ "([^"\\\r]|((\r\n)?[ \t])|\\.)*"
(erratum)      =~ "(\n|(\\\r)*([^"\\\r\n]|\\[^\r]|(\r\n)?[ \t]))*(\\\r)*"

domain-literal =  "[" *(dtext|quoted-pair) "]"
               =~ \[([^][\\\r]|((\r\n)?[ \t])|\\.)*]
(erratum)      =~ \[(\n|(\\\r)*([^][\\\r\n]|\\[^\r]|(\r\n)?[ \t]))*(\\\r)*]

atom        =  1*&lt;any CHAR except specials, SPACE and CTLs&gt;
            =~ [^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+

word        =  atom / quoted-string
            =~ [^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|"(\n|(\\\r)*([^"\\\r\n]|\\[^\r]|(\r\n)?[ \t]))*(\\\r)*"

domain-ref  =  atom

sub-domain  =  domain-ref / domain-literal
            =~ [^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|\[(\n|(\\\r)*([^][\\\r\n]|\\[^\r]|(\r\n)?[ \t]))*(\\\r)*]

local-part  =  word *("." word)
            =~ ([^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|"(\n|(\\\r)*([^"\\\r\n]|\\[^\r]|(\r\n)?[ \t]))*(\\\r)*")(\.([^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|"(\n|(\\\r)*([^"\\\r\n]|\\[^\r]|(\r\n)?[ \t]))*(\\\r)*"))*
(opt-lwsp)  =~ ([^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|"(\n|(\\\r)*([^"\\\r\n]|\\[^\r]|(\r\n)?[ \t]))*(\\\r)*")(((\r\n)?[ \t])*\.((\r\n)?[ \t])*([^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|"(\n|(\\\r)*([^"\\\r\n]|\\[^\r]|(\r\n)?[ \t]))*(\\\r)*"))*

domain      =  sub-domain *("." sub-domain)
            =~ ([^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|\[(\n|(\\\r)*([^][\\\r\n]|\\[^\r]|(\r\n)?[ \t]))*(\\\r)*])(\.([^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|\[(\n|(\\\r)*([^][\\\r\n]|\\[^\r]|(\r\n)?[ \t]))*(\\\r)*]))*
(opt-lwsp)  =~ ([^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|\[(\n|(\\\r)*([^][\\\r\n]|\\[^\r]|(\r\n)?[ \t]))*(\\\r)*])(((\r\n)?[ \t])*\.((\r\n)?[ \t])*([^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|\[(\n|(\\\r)*([^][\\\r\n]|\\[^\r]|(\r\n)?[ \t]))*(\\\r)*]))*

addr-spec   =  local-part "@" domain
            =~ ([^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|"(\n|(\\\r)*([^"\\\r\n]|\\[^\r]|(\r\n)?[ \t]))*(\\\r)*")(\.([^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|"(\n|(\\\r)*([^"\\\r\n]|\\[^\r]|(\r\n)?[ \t]))*(\\\r)*"))*@([^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|\[(\n|(\\\r)*([^][\\\r\n]|\\[^\r]|(\r\n)?[ \t]))*(\\\r)*])(\.([^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|\[(\n|(\\\r)*([^][\\\r\n]|\\[^\r]|(\r\n)?[ \t]))*(\\\r)*]))*
(opt-lwsp)  =~ ([^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|"(\n|(\\\r)*([^"\\\r\n]|\\[^\r]|(\r\n)?[ \t]))*(\\\r)*")((\r\n)?[ \t])*(\.((\r\n)?[ \t])*([^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|"(\n|(\\\r)*([^"\\\r\n]|\\[^\r]|(\r\n)?[ \t]))*(\\\r)*")((\r\n)?[ \t])*)*@((\r\n)?[ \t])*([^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|\[(\n|(\\\r)*([^][\\\r\n]|\\[^\r]|(\r\n)?[ \t]))*(\\\r)*])(((\r\n)?[ \t])*\.((\r\n)?[ \t])*([^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|\[(\n|(\\\r)*([^][\\\r\n]|\\[^\r]|(\r\n)?[ \t]))*(\\\r)*]))*
(canonical) =~ ([^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|"(\n|(\\\r)*([^"\\\r\n]|\\[^\r]))*(\\\r)*")(\.([^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|"(\n|(\\\r)*([^"\\\r\n]|\\[^\r]))*(\\\r)*"))*@([^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|\[(\n|(\\\r)*([^][\\\r\n]|\\[^\r]))*(\\\r)*])(\.([^][()&lt;&gt;@,;:\\". \x00-\x1F\x7F]+|\[(\n|(\\\r)*([^][\\\r\n]|\\[^\r]))*(\\\r)*]))*
</code></pre>
     <h2>RFC 5322</h2>
     <p>I arrived at the following regular expression. I invite everyone to try and break it. If you find any false positives or false negatives, please post them in a comment and I'll try to fix the expression as soon as possible.</p>
     <p><code>([-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*|"([]!#-[^-~ \t]|(\\[\t -~]))+")@([-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*|\[[\t -Z^-~]*])</code></p>
     <p>I believe it's fully compliant with RFC 5322 including the <a href="http://www.rfc-editor.org/errata_search.php?rfc=5322" rel="noreferrer">errata</a>. It only recognizes email addresses in their canonical form. For a regex that recognizes (folding) whitespace see the derivation below.</p>
     <p>The derivation shows how I arrived at the expression. I list all the relevant grammar rules from the RFC exactly as they appear, followed by the corresponding regex. For rules that include semantically irrelevant (folding) whitespace, I give a separate regex marked "(normalized)" that doesn't accept this whitespace.</p>
     <p>I ignored all the "obs-" rules from the RFC. This means that the regexes only match email addresses that are strictly RFC&nbsp;5322 compliant. If you have to match "old" addresses (as the looser grammar including the "obs-" rules does), you can use one of the RFC&nbsp;822 regexes from the previous paragraph.</p>
     <pre class="lang-none prettyprint-override"><code>VCHAR           =   %x21-7E
                =~  [!-~]

ALPHA           =   %x41-5A / %x61-7A
                =~  [A-Za-z]

DIGIT           =   %x30-39
                =~  [0-9]

HTAB            =   %x09
                =~  \t

CR              =   %x0D
                =~  \r

LF              =   %x0A
                =~  \n

SP              =   %x20
                =~  

DQUOTE          =   %x22
                =~  "

CRLF            =   CR LF
                =~  \r\n

WSP             =   SP / HTAB
                =~  [\t ]

quoted-pair     =   "\" (VCHAR / WSP)
                =~  \\[\t -~]

FWS             =   ([*WSP CRLF] 1*WSP)
                =~  ([\t ]*\r\n)?[\t ]+

ctext           =   %d33-39 / %d42-91 / %d93-126
                =~  []!-'*-[^-~]

("comment" is left out in the regex)
ccontent        =   ctext / quoted-pair / comment
                =~  []!-'*-[^-~]|(\\[\t -~])

(not regular)
comment         =   "(" *([FWS] ccontent) [FWS] ")"

(is equivalent to FWS when leaving out comments)
CFWS            =   (1*([FWS] comment) [FWS]) / FWS
                =~  ([\t ]*\r\n)?[\t ]+

atext           =   ALPHA / DIGIT / "!" / "#" / "$" / "%" / "&amp;" / "'" / "*" / "+" / "-" / "/" / "=" / "?" / "^" / "_" / "`" / "{" / "|" / "}" / "~"
                =~  [-!#-'*+/-9=?A-Z^-~]

dot-atom-text   =   1*atext *("." 1*atext)
                =~  [-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*

dot-atom        =   [CFWS] dot-atom-text [CFWS]
                =~  (([\t ]*\r\n)?[\t ]+)?[-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*(([\t ]*\r\n)?[\t ]+)?
(normalized)    =~  [-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*

qtext           =   %d33 / %d35-91 / %d93-126
                =~  []!#-[^-~]

qcontent        =   qtext / quoted-pair
                =~  []!#-[^-~]|(\\[\t -~])

(erratum)
quoted-string   =   [CFWS] DQUOTE ((1*([FWS] qcontent) [FWS]) / FWS) DQUOTE [CFWS]
                =~  (([\t ]*\r\n)?[\t ]+)?"(((([\t ]*\r\n)?[\t ]+)?([]!#-[^-~]|(\\[\t -~])))+(([\t ]*\r\n)?[\t ]+)?|(([\t ]*\r\n)?[\t ]+)?)"(([\t ]*\r\n)?[\t ]+)?
(normalized)    =~  "([]!#-[^-~ \t]|(\\[\t -~]))+"

dtext           =   %d33-90 / %d94-126
                =~  [!-Z^-~]

domain-literal  =   [CFWS] "[" *([FWS] dtext) [FWS] "]" [CFWS]
                =~  (([\t ]*\r\n)?[\t ]+)?\[((([\t ]*\r\n)?[\t ]+)?[!-Z^-~])*(([\t ]*\r\n)?[\t ]+)?](([\t ]*\r\n)?[\t ]+)?
(normalized)    =~  \[[\t -Z^-~]*]

local-part      =   dot-atom / quoted-string
                =~  (([\t ]*\r\n)?[\t ]+)?[-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*(([\t ]*\r\n)?[\t ]+)?|(([\t ]*\r\n)?[\t ]+)?"(((([\t ]*\r\n)?[\t ]+)?([]!#-[^-~]|(\\[\t -~])))+(([\t ]*\r\n)?[\t ]+)?|(([\t ]*\r\n)?[\t ]+)?)"(([\t ]*\r\n)?[\t ]+)?
(normalized)    =~  [-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*|"([]!#-[^-~ \t]|(\\[\t -~]))+"

domain          =   dot-atom / domain-literal
                =~  (([\t ]*\r\n)?[\t ]+)?[-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*(([\t ]*\r\n)?[\t ]+)?|(([\t ]*\r\n)?[\t ]+)?\[((([\t ]*\r\n)?[\t ]+)?[!-Z^-~])*(([\t ]*\r\n)?[\t ]+)?](([\t ]*\r\n)?[\t ]+)?
(normalized)    =~  [-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*|\[[\t -Z^-~]*]

addr-spec       =   local-part "@" domain
                =~  ((([\t ]*\r\n)?[\t ]+)?[-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*(([\t ]*\r\n)?[\t ]+)?|(([\t ]*\r\n)?[\t ]+)?"(((([\t ]*\r\n)?[\t ]+)?([]!#-[^-~]|(\\[\t -~])))+(([\t ]*\r\n)?[\t ]+)?|(([\t ]*\r\n)?[\t ]+)?)"(([\t ]*\r\n)?[\t ]+)?)@((([\t ]*\r\n)?[\t ]+)?[-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*(([\t ]*\r\n)?[\t ]+)?|(([\t ]*\r\n)?[\t ]+)?\[((([\t ]*\r\n)?[\t ]+)?[!-Z^-~])*(([\t ]*\r\n)?[\t ]+)?](([\t ]*\r\n)?[\t ]+)?)
(normalized)    =~  ([-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*|"([]!#-[^-~ \t]|(\\[\t -~]))+")@([-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*|\[[\t -Z^-~]*])
</code></pre>
     <p>Note that some sources (notably <a href="http://www.w3.org/TR/html5/forms.html#valid-e-mail-address" rel="noreferrer">W3C</a>) claim that RFC&nbsp;5322 is too strict on the local part (i.e. the part before the @-sign). This is because "..", "a..b" and "a." are <em>not</em> valid dot-atoms, while they may be used as mailbox names. The RFC, however, <em>does</em> allow for local parts like these, except that they have to be quoted. So instead of <code>a..b@example.net</code> you should write <code>"a..b"@example.net</code>, which is semantically equivalent.</p>
     <h2>Further restrictions</h2>
     <p>SMTP (as defined in <a href="https://www.rfc-editor.org/rfc/rfc5321" rel="noreferrer">RFC 5321</a>) further restricts the set of valid email addresses (or actually: mailbox names). It seems reasonable to impose this stricter grammar, so that the matched email address can actually be used to send an email.</p>
     <p>RFC 5321 basically leaves alone the "local" part (i.e. the part before the @-sign), but is stricter on the domain part (i.e. the part after the @-sign). It allows only host names in place of dot-atoms and address literals in place of domain literals.</p>
     <p>The grammar presented in RFC 5321 is too lenient when it comes to both host names and IP addresses. I took the liberty of "correcting" the rules in question, using <a href="https://tools.ietf.org/id/draft-main-ipaddr-text-rep-01.txt" rel="noreferrer">this draft</a> and <a href="https://www.rfc-editor.org/rfc/rfc1034" rel="noreferrer">RFC&nbsp;1034</a> as guidelines. Here's the resulting regex.</p>
     <p><code>([-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*|"([]!#-[^-~ \t]|(\\[\t -~]))+")@([0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?(\.[0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?)*|\[((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}|IPv6:((((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){6}|::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){5}|[0-9A-Fa-f]{0,4}::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){4}|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):)?(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){3}|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,2}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){2}|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,3}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,4}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::)((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3})|(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3})|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,5}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3})|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,6}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::)|(?!IPv6:)[0-9A-Za-z-]*[0-9A-Za-z]:[!-Z^-~]+)])</code></p>
     <p>Note that depending on the use case you may not want to allow for a "General-address-literal" in your regex. Also note that I used a negative lookahead <code>(?!IPv6:)</code> in the final regex to prevent the "General-address-literal" part to match malformed IPv6 addresses. Some regex processors don't support negative lookahead. Remove the substring <code>|(?!IPv6:)[0-9A-Za-z-]*[0-9A-Za-z]:[!-Z^-~]+</code> from the regex if you want to take the whole "General-address-literal" part out.</p>
     <p>Here's the derivation:</p>
     <pre class="lang-none prettyprint-override"><code>Let-dig         =   ALPHA / DIGIT
                =~  [0-9A-Za-z]

Ldh-str         =   *( ALPHA / DIGIT / "-" ) Let-dig
                =~  [0-9A-Za-z-]*[0-9A-Za-z]

(regex is updated to make sure sub-domains are max. 63 characters long - RFC 1034 section 3.5)
sub-domain      =   Let-dig [Ldh-str]
                =~  [0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?

Domain          =   sub-domain *("." sub-domain)
                =~  [0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?(\.[0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?)*

Snum            =   1*3DIGIT
                =~  [0-9]{1,3}

(suggested replacement for "Snum")
ip4-octet       =   DIGIT / %x31-39 DIGIT / "1" 2DIGIT / "2" %x30-34 DIGIT / "25" %x30-35
                =~  25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9]

IPv4-address-literal    =   Snum 3("."  Snum)
                        =~  [0-9]{1,3}(\.[0-9]{1,3}){3}

(suggested replacement for "IPv4-address-literal")
ip4-address     =   ip4-octet 3("." ip4-octet)
                =~  (25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}

(suggested replacement for "IPv6-hex")
ip6-h16         =   "0" / ( (%x49-57 / %x65-70 /%x97-102) 0*3(%x48-57 / %x65-70 /%x97-102) )
                =~  0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}

(not from RFC)
ls32            =   ip6-h16 ":" ip6-h16 / ip4-address
                =~  (0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3})|(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}

(suggested replacement of "IPv6-addr")
ip6-address     =                                      6(ip6-h16 ":") ls32
                    /                             "::" 5(ip6-h16 ":") ls32
                    / [                 ip6-h16 ] "::" 4(ip6-h16 ":") ls32
                    / [ *1(ip6-h16 ":") ip6-h16 ] "::" 3(ip6-h16 ":") ls32
                    / [ *2(ip6-h16 ":") ip6-h16 ] "::" 2(ip6-h16 ":") ls32
                    / [ *3(ip6-h16 ":") ip6-h16 ] "::"   ip6-h16 ":"  ls32
                    / [ *4(ip6-h16 ":") ip6-h16 ] "::"                ls32
                    / [ *5(ip6-h16 ":") ip6-h16 ] "::"   ip6-h16
                    / [ *6(ip6-h16 ":") ip6-h16 ] "::"
                =~  (((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){6}|::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){5}|[0-9A-Fa-f]{0,4}::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){4}|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):)?(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){3}|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,2}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){2}|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,3}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,4}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::)((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3})|(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3})|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,5}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3})|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,6}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::

IPv6-address-literal    =   "IPv6:" ip6-address
                        =~  IPv6:((((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){6}|::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){5}|[0-9A-Fa-f]{0,4}::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){4}|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):)?(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){3}|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,2}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){2}|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,3}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,4}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::)((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3})|(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3})|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,5}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3})|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,6}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::)

Standardized-tag        =   Ldh-str
                        =~  [0-9A-Za-z-]*[0-9A-Za-z]

dcontent        =   %d33-90 / %d94-126
                =~  [!-Z^-~]

General-address-literal =   Standardized-tag ":" 1*dcontent
                        =~  [0-9A-Za-z-]*[0-9A-Za-z]:[!-Z^-~]+

address-literal =   "[" ( IPv4-address-literal / IPv6-address-literal / General-address-literal ) "]"
                =~  \[((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}|IPv6:((((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){6}|::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){5}|[0-9A-Fa-f]{0,4}::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){4}|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):)?(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){3}|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,2}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){2}|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,3}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,4}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::)((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3})|(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3})|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,5}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3})|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,6}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::)|(?!IPv6:)[0-9A-Za-z-]*[0-9A-Za-z]:[!-Z^-~]+)]

Mailbox         =   Local-part "@" ( Domain / address-literal )
                =~  ([-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*|"([]!#-[^-~ \t]|(\\[\t -~]))+")@([0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?(\.[0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?)*|\[((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}|IPv6:((((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){6}|::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){5}|[0-9A-Fa-f]{0,4}::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){4}|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):)?(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){3}|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,2}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){2}|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,3}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,4}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::)((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3})|(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3})|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,5}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3})|(((0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}):){0,6}(0|[1-9A-Fa-f][0-9A-Fa-f]{0,3}))?::)|(?!IPv6:)[0-9A-Za-z-]*[0-9A-Za-z]:[!-Z^-~]+)])
</code></pre>
     <h2>User input validation</h2>
     <p>A common use case is user input validation, for example on an html form. In that case it's usually reasonable to preclude address-literals and to require at least two labels in the hostname. Taking the improved RFC&nbsp;5321 regex from the previous section as a basis, the resulting expression would be:</p>
     <p><code>([-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*|"([]!#-[^-~ \t]|(\\[\t -~]))+")@[0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?(\.[0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?)+</code></p>
     <p>I do not recommend restricting the local part further, e.g. by precluding quoted strings, since we don't know what kind of mailbox names some hosts allow (like <code>"a..b"@example.net</code> or even <code>"a b"@example.net</code>).</p>
     <p>I also do not recommend explicitly validating against a list of literal top-level domains or even imposing length-constraints (remember how ".museum" invalidated <code>[a-z]{2,4}</code>), but if you must:</p>
     <p><code>([-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*|"([]!#-[^-~ \t]|(\\[\t -~]))+")@([0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?\.)*(net|org|com|info|</code><em>etc...</em><code>)</code></p>
     <p>Make sure to keep your regex up-to-date if you decide to go down the path of explicit top-level domain validation.</p>
     <h2>Further considerations</h2>
     <p>When only accepting host names in the domain part (after the @-sign), the regexes above accept only labels with at most 63 characters, as they should. However, they don't enforce the fact that the entire host name must be at most 253 characters long (including the dots). Although this constraint is strictly speaking still regular, it's not feasible to make a regex that incorporates this rule.</p>
     <p>Another consideration, especially when using the regexes for input validation, is feedback to the user. If a user enters an incorrect address, it would be nice to give a little more feedback than a simple "syntactically incorrect address". With "vanilla" regexes this is not possible.</p>
     <p>These two considerations could be addressed by parsing the address. The extra length constraint on host names could in some cases also be addressed by using an extra regex that checks it, and matching the address against both expressions.</p>
     <p>None of the regexes in this answer are optimized for performance. If performance is an issue, you should see if (and how) the regex of your choice can be optimized.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span>RFC <a href="https://tools.ietf.org/html/rfc6532" rel="nofollow noreferrer">6532</a> updates <a href="https://tools.ietf.org/html/rfc5322" rel="nofollow noreferrer">5322</a> to allow and include full, clean UTF-8. Additional details <a href="http://stackoverflow.com/a/31066998/2350426">here</a>.</span> <span> - </span> <span class="display-name">user2350426</span> <span> </span> <span class="date">26 Jun 2015 at 17:30</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>According to wikipedia seems that the local part, when dotted, has a limitation of 64 chars per part, and also the RFC 5322 refers to the dotted local part to be interpretted with the restrictions of the domains. For example <code>arbitrary-long-email-address-should-be-invalid-arbitrary-lon‌​g-email-address-shou‌​ld-be-invalid.and-th‌​e-second-group-also-‌​should-not-be-so-lon‌​g-and-the-second-gro‌​up-also-should-not-b‌​e-so-long@example.co‌​m</code> should not validate. I suggest changing the "+" signs in the first group (name before the optional dot) and in the second group (name after the following dots) to <code>{1,64}</code></span> <span> - </span> <span class="display-name">Xavi Montero</span> <span> </span> <span class="date">22 May 2017 at 00:35</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>As the comments are limited in size, here is the resulting regex I plan to use, which is the one at the beginning of this answer, plus limitting the size in the local part, plus adding a back-slash prior to the "/" symbol as required by PHP and also in regex101.com: In PHP I use: <code>$emailRegex = '/^([-!#-\'*+\/-9=?A-Z^-~]{1,64}(\.[-!#-\'*+\/-9=?A-Z^-~]{1,‌​64})*|"([]!#-[^-~ \t]|(\\[\t -~]))+")@[0-9A-Za-z]([0-9A-Za-z-]{0,61}[0-9A-Za-z])?(\.[0-9A‌​-Za-z]([0-9A-Za-z-]{‌​0,61}[0-9A-Za-z])?)+‌​$/';</code></span> <span> - </span> <span class="display-name">Xavi Montero</span> <span> </span> <span class="date">22 May 2017 at 00:39</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>CAUTION: For some reason, StackOverflow adds hidden characters when copying from the rendered markdown. Copy it into the regex101.com and you'll see black dots there. You have to remove them and correct the string... Maybe if integrated in the answer, there they are correctly copiable. Sorry for the inconvenience. I don't want to add a new answer as this one is the proper one. Also I don't want to directly edit unless the community thinks this should be integrated into it.</span> <span> - </span> <span class="display-name">Xavi Montero</span> <span> </span> <span class="date">22 May 2017 at 00:48</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@XaviMontero Thaks for contributing Xavi! Do you have a reference to the RFC stating the 64 character limit on local part labels? If so, I would gladly adjust the answer.</span> <span> - </span> <span class="display-name">Rinke</span> <span> </span> <span class="date">22 May 2017 at 11:21</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Rinke, your longest regex accepts a@[a-a:::::aa:aa:aa:aa:aa:aa:aa:aa:aa:aa:aa:aa:aa:aa]. Could you (or anyone else) explain why it's valid? I also suggest these small improvements ^ and $ would be helpful, as well as (?=.{0,64}@.{0,255}$) just after the ^.</span> <span> - </span> <span class="display-name">ByteEater</span> <span> </span> <span class="date">30 Jul 2021 at 01:30</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>One more thing: the last ] isn't escaped, making it illegal in ECMAScript regexes with the u flag (and that's what e.g. the pattern attribute in HTML sets without the possibility to unset).</span> <span> - </span> <span class="display-name">ByteEater</span> <span> </span> <span class="date">30 Jul 2021 at 01:54</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Actually, this should be more performant than the above check without increasing length: (?=.{1,64}@.{1,255}$).</span> <span> - </span> <span class="display-name">ByteEater</span> <span> </span> <span class="date">30 Jul 2021 at 20:56</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>118</span>
     </div>
     <div>
      <span>Answerer: </span> <span>davcar</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Jan 2009 at 15:29</span>
     </div>
    </div>
    <div>
     <p>The email addresses I want to validate are going to be used by an ASP.NET web application using the <code>System.Net.Mail</code> namespace to send emails to a list of people.</p>
     <p>So, rather than using some very complex regular expression, I just try to create a <code>MailAddress</code> instance from the address. The <code>MailAddress</code> constructor will throw an exception if the address is not formed properly. This way, I know I can at least get the email out of the door. Of course this is server-side validation, but at a minimum you need that anyway.</p>
     <pre class="lang-cs prettyprint-override"><code>protected void emailValidator_ServerValidate(object source, ServerValidateEventArgs args)
{
    try
    {
        var a = new MailAddress(txtEmail.Text);
    }
    catch (Exception ex)
    {
        args.IsValid = false;
        emailValidator.ErrorMessage = "email: " + ex.Message;
    }
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>A good point. Even if this server validation rejects some valid address then it is not a problem since you will not be able to send to this address using this particular server technology anyway. Or you can try doing the same things using any third party emailing library you use instead of the default tools.</span> <span> - </span> <span class="display-name">User</span> <span> </span> <span class="date">16 Jun 2009 at 10:59</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>I really like how this leverages .Net framework code - no sense in reinventing the wheel. This is excellent. Simple, clean, and assures you can actually send the email. Great work.</span> <span> - </span> <span class="display-name">Cory House</span> <span> </span> <span class="date">15 Aug 2010 at 19:43</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>... yes and for the those interested in how it validates have a look at the code in Reflector - there's quite a bit of it - and it ain't a regular expression!</span> <span> - </span> <span class="display-name">Tom Carter</span> <span> </span> <span class="date">17 Sep 2010 at 08:07</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Just a note: the MailAddress class doesn't match RFC5322, if you just want to use it for validation (and not sending as well, in which case it's a moot point as mentioned above). See: <a href="http://stackoverflow.com/questions/6023589/how-to-make-regex-work-on-corner-case-email-address/6023604#6023604" title="how to make regex work on corner case email address">stackoverflow.com/questions/6023589/…</a></span> <span> - </span> <span class="display-name">porges</span> <span> </span> <span class="date">31 May 2011 at 05:06</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Just a minor issue: if you want to make your server side validator code more reusable (either in this case or generally), I suggest to use <code>args.Value</code> instead of referencing the field like <code>txtEmail.Text</code> hard-coded. The latter one will bound your validator to the single control instance, that may be OK, as long you have a single e-mail field, but not recommended otherwise.</span> <span> - </span> <span class="display-name">pholpar</span> <span> </span> <span class="date">21 Aug 2019 at 11:23</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Good answer, but basically a duplicate of <a href="https://stackoverflow.com/a/1903368/9117">stackoverflow.com/a/1903368/9117</a>. Also, it's worth noting that in .NET 6 (not sure when it was introduced) there is now a <code>MailAddress.TryCreate</code> method, which allows you to avoid having to catch an exception just to test the address.</span> <span> - </span> <span class="display-name">Mark Meuer</span> <span> </span> <span class="date">8 Jul 2022 at 18:44</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>78</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Draemon</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Oct 2008 at 14:18</span>
     </div>
    </div>
    <div>
     <p>There are plenty examples of this out on the Internet (and I think even one that fully validates the RFC - but it's tens/hundreds of lines long if memory serves).</p>
     <p>People tend to get carried away validating this sort of thing. Why not just check it has an @ and at least one <code>.</code> and meets some simple minimum length? It's trivial to enter a fake email and still match any valid regex anyway. I would guess that false positives are better than false negatives.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>Yes, but <b>which</b> RFC? :) This [RFC‐5322–validator ](<a href="http://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982" title="what is the best regular expression for validating email addresses">stackoverflow.com/questions/201323/…</a>) is only around forty lines long.</span> <span> - </span> <span class="display-name">tchrist</span> <span> </span> <span class="date">7 Nov 2010 at 20:20</span></td>
       </tr>
       <tr>
        <td>17</td>
        <td><span>A . is not required. A TLD can have email addresses, or there could be an IPv6 address</span> <span> - </span> <span class="display-name">Sijmen Mulder</span> <span> </span> <span class="date">15 Feb 2011 at 12:58</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>RFCs are not the end of the story: ICANN does not allow 'dotless' domains any more: <a href="https://www.icann.org/news/announcement-2013-08-30-en" rel="nofollow noreferrer">icann.org/news/announcement-2013-08-30-en</a></span> <span> - </span> <span class="display-name">Synchro</span> <span> </span> <span class="date">9 Sep 2014 at 16:28</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span> <span class="arrow"> <a href="#answer_15">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>64</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Evan Carroll</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Jan 2010 at 16:43</span>
     </div>
    </div>
    <div>
     <p>This regex is from Perl's <a href="https://metacpan.org/source/RJBS/Email-Valid-1.198/lib/Email/Valid.pm" rel="nofollow noreferrer">Email::Valid</a> library. I believe it to be the most accurate, and it matches all of <a href="https://en.wikipedia.org/wiki/Email" rel="nofollow noreferrer">RFC&nbsp;822</a>. And, it is based on the regular expression in the O'Reilly book:</p>
     <blockquote>
      <p>Regular expression built using Jeffrey Friedl's example in <em>Mastering Regular Expressions</em> (<a href="http://www.ora.com/catalog/regexp/" rel="nofollow noreferrer">http://www.ora.com/catalog/regexp/</a>).</p>
     </blockquote>
     <pre class="lang-none prettyprint-override"><code>$RFC822PAT = &lt;&lt;'EOF';
[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\
xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xf
f\n\015()]*)*\)[\040\t]*)*(?:(?:[^(\040)&lt;&gt;@,;:".\\\[\]\000-\037\x80-\x
ff]+(?![^(\040)&lt;&gt;@,;:".\\\[\]\000-\037\x80-\xff])|"[^\\\x80-\xff\n\015
"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015"]*)*")[\040\t]*(?:\([^\\\x80-\
xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80
-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*
)*(?:\.[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\
\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\
x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)&lt;&gt;@,;:".\\\[\]\000-\037\x8
0-\xff]+(?![^(\040)&lt;&gt;@,;:".\\\[\]\000-\037\x80-\xff])|"[^\\\x80-\xff\n
\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015"]*)*")[\040\t]*(?:\([^\\\x
80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^
\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040
\t]*)*)*@[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([
^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\
\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)&lt;&gt;@,;:".\\\[\]\000-\037\
x80-\xff]+(?![^(\040)&lt;&gt;@,;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-
\xff\n\015\[\]]|\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()
]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\
x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\04
0\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\
n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\
015()]*)*\)[\040\t]*)*(?:[^(\040)&lt;&gt;@,;:".\\\[\]\000-\037\x80-\xff]+(?!
[^(\040)&lt;&gt;@,;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\
]]|\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\
x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\01
5()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)*|(?:[^(\040)&lt;&gt;@,;:".
\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:".\\\[\]\000-\037\x80-\xff]
)|"[^\\\x80-\xff\n\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015"]*)*")[^
()&lt;&gt;@,;:".\\\[\]\x80-\xff\000-\010\012-\037]*(?:(?:\([^\\\x80-\xff\n\0
15()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][
^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)|"[^\\\x80-\xff\
n\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015"]*)*")[^()&lt;&gt;@,;:".\\\[\]\
x80-\xff\000-\010\012-\037]*)*&lt;[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?
:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-
\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:@[\040\t]*
(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015
()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()
]*)*\)[\040\t]*)*(?:[^(\040)&lt;&gt;@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\0
40)&lt;&gt;@,;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\
[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\
xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*
)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x80
-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x
80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t
]*)*(?:[^(\040)&lt;&gt;@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:".\\
\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])
*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x
80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80
-\xff\n\015()]*)*\)[\040\t]*)*)*(?:,[\040\t]*(?:\([^\\\x80-\xff\n\015(
)]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\
\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*@[\040\t
]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\0
15()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015
()]*)*\)[\040\t]*)*(?:[^(\040)&lt;&gt;@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(
\040)&lt;&gt;@,;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|
\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80
-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()
]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x
80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^
\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040
\t]*)*(?:[^(\040)&lt;&gt;@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:".
\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff
])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\
\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x
80-\xff\n\015()]*)*\)[\040\t]*)*)*)*:[\040\t]*(?:\([^\\\x80-\xff\n\015
()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\
\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)?(?:[^
(\040)&lt;&gt;@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:".\\\[\]\000-
\037\x80-\xff])|"[^\\\x80-\xff\n\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\
n\015"]*)*")[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|
\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))
[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x80-\xff
\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\x
ff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(
?:[^(\040)&lt;&gt;@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:".\\\[\]\
000-\037\x80-\xff])|"[^\\\x80-\xff\n\015"]*(?:\\[^\x80-\xff][^\\\x80-\
xff\n\015"]*)*")[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\x
ff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)
*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)*@[\040\t]*(?:\([^\\\x80-\x
ff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-
\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)
*(?:[^(\040)&lt;&gt;@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:".\\\[\
]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\]
)[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-
\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\x
ff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(
?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80
-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)&lt;
&gt;@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:".\\\[\]\000-\037\x8
0-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\])[\040\t]*(?:
\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]
*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)
*\)[\040\t]*)*)*&gt;)
EOF
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>16</td>
        <td><span>O_O you would also need to be a regex master to understand what it is doing</span> <span> - </span> <span class="display-name">Chris McGrath</span> <span> </span> <span class="date">30 Jan 2013 at 22:20</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This regular expression matches parts of the MIME syntax like folding whitespace and comments; and it also allows control characters that are not permitted to be used.</span> <span> - </span> <span class="display-name">awwright</span> <span> </span> <span class="date">13 Sep 2020 at 01:14</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The O'Reilly link is broken - <i>"Hrmm, we can’t find that page… Sorry for the inconvenience"</i></span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">13 Feb 2022 at 16:04</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_15"><span>Answer 15</span> <span class="arrow"> <a href="#answer_14">↑</a> </span> <span class="arrow"> <a href="#answer_16">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>49</span>
     </div>
     <div>
      <span>Answerer: </span> <span>SimonSimCity</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Dec 2011 at 08:40</span>
     </div>
    </div>
    <div>
     <p>As you're writing in PHP I'd advice you to use the PHP built-in validation for emails.</p>
     <pre><code>filter_var($value, FILTER_VALIDATE_EMAIL)
</code></pre>
     <p>If you're running a PHP version lower than 5.3.6, please be aware of this issue: <em><a href="https://bugs.php.net/bug.php?id=53091" rel="nofollow noreferrer">Bug #53091: Crashes when I try to filter a text of &gt; 2264 characters</a></em></p>
     <p>If you want more information how this built-in validation works, see here: <em><a href="https://stackoverflow.com/questions/3722831/does-phps-filter-var-filter-validate-email-actually-work">Does PHP's filter_var FILTER_VALIDATE_EMAIL actually work?</a></em></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>gets a vote up, exactly what I was going to say. Doesn't handle IDN's but converting to puny code beforehand solves this. PHP&gt;=5.3 has idn_to_ascii() for this. One of the best and easiest ways for validating an email.</span> <span> - </span> <span class="display-name">Taylor</span> <span> </span> <span class="date">25 Jan 2012 at 23:00</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_16"><span>Answer 16</span> <span class="arrow"> <a href="#answer_15">↑</a> </span> <span class="arrow"> <a href="#answer_17">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>46</span>
     </div>
     <div>
      <span>Answerer: </span> <span>adnam</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Oct 2008 at 16:35</span>
     </div>
    </div>
    <div>
     <p><a href="http://www.iamcal.com/" rel="nofollow noreferrer">Cal Henderson</a> (Flickr) wrote an article called <em><a href="http://www.iamcal.com/publish/articles/php/parsing_email/" rel="nofollow noreferrer">Parsing Email Addresses in PHP</a></em> and shows how to do proper RFC (2)822-compliant email address parsing.</p>
     <p>You can also get the source code in <a href="http://code.iamcal.com/php/rfc822/" rel="nofollow noreferrer">PHP</a>, Python, and Ruby which is <a href="http://creativecommons.org/licenses/by-sa/2.5/" rel="nofollow noreferrer">Creative Commons licensed</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>it told me that <code>a@b</code> was valid</span> <span> - </span> <span class="display-name">dsdsdsdsd</span> <span> </span> <span class="date">16 Apr 2014 at 11:44</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@dsdsdsdsd Because <code>a@b</code> is valid... in this case <code>b</code> is the top-level domain.</span> <span> - </span> <span class="display-name">rink.attendant.6</span> <span> </span> <span class="date">31 Jul 2015 at 21:19</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_17"><span>Answer 17</span> <span class="arrow"> <a href="#answer_16">↑</a> </span> <span class="arrow"> <a href="#answer_18">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>44</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Kon</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Oct 2008 at 14:23</span>
     </div>
    </div>
    <div>
     <p>I never bother creating with my own regular expression, because chances are that someone else has already come up with a better version. I always use <a href="http://regexlib.com/Search.aspx" rel="noreferrer">regexlib</a> to find one to my liking.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Nice site, however it's a bit weird that their built-in email spam protection partially hides some patterns. Especially those related to email matching. :D</span> <span> - </span> <span class="display-name">Tim Wißmann</span> <span> </span> <span class="date">9 Jul 2021 at 00:07</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>That link is a search query, e.g. <b><i>"Search Results: 4128 regular expressions found."</i></b>. Which one in particular? How do you choose?</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">13 Feb 2022 at 14:32</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_18"><span>Answer 18</span> <span class="arrow"> <a href="#answer_17">↑</a> </span> <span class="arrow"> <a href="#answer_19">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>43</span>
     </div>
     <div>
      <span>Answerer: </span> <span>spig</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Oct 2009 at 21:54</span>
     </div>
    </div>
    <div>
     <p>One simple regular expression which would at least not reject any valid email address would be checking for something, followed by an @ sign and then something followed by a period and at least 2 somethings. It won't reject anything, but after reviewing the spec I can't find any email that would be valid and rejected.</p>
     <p>email =~ <code>/.+@[^@]+\.[^@]{2,}$/</code></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>5</td>
        <td><span>This is what I was looking for. Not very restrictive, but makes sure there is only 1 @ (as we're parsing a list and want to make sure there are no missing commas). FYI, you can have an @ on the left if it's in quotes: <a href="http://en.wikipedia.org/wiki/Email_address#Valid_email_addresses" rel="nofollow noreferrer">Valid_email_addresses</a>, but it's pretty fringe.</span> <span> - </span> <span class="display-name">Josh</span> <span> </span> <span class="date">11 Nov 2011 at 06:16</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>After using it, realized it didn't work exactly. <code>/^[^@]+@[^@]+\.[^@]{2}[^@]*$/</code> actually checks for 1 @ sign. Your regex will let multiple through because of the .* at the end.</span> <span> - </span> <span class="display-name">Josh</span> <span> </span> <span class="date">11 Nov 2011 at 06:31</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Right. I'm not trying to reject all invalid, just keep from rejecting a valid email address.</span> <span> - </span> <span class="display-name">spig</span> <span> </span> <span class="date">14 Nov 2011 at 17:48</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>It would be far better to use this: <code>/^[^@]+@[^@]+\.[^@]{2,4}$/</code> making sure that it ends with 2 to 4 non @ characters. As @Josh pointed out it now allows an extra @ in the end. But you can also change that as well to: <code>/^[^@]+@[^@]+\.[^a-z-A-Z]{2,4}$/</code> since all top level domains are a-Z characters. you can replace the <code>4</code> with <code>5</code> or more allowing top level domain names to be longer in the future as well.</span> <span> - </span> <span class="display-name">FLY</span> <span> </span> <span class="date">14 Jan 2013 at 10:51</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@FLY, <b>ka@foo.</b> returns correct. Is it supposed to, by the standards?</span> <span> - </span> <span class="display-name">SexyBeast</span> <span> </span> <span class="date">22 Nov 2015 at 01:31</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Cupidvogel <code>\.[a-z-A-Z]{2,4}$</code> should make sure it ends with a . followed by 2, 3 or 4 a-Z characters. But this is also a simple check. This would also allow <code>ka@(*#&amp;foo.bar</code> Note the ^ is missing since the ^ add a check in a group to not match. Which is wrong in my previous comment.</span> <span> - </span> <span class="display-name">FLY</span> <span> </span> <span class="date">23 Nov 2015 at 11:19</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>What if non ASCII char would used where dozens of servers support only, though ... At least, <code>A-Za-z0-9</code> then ...</span> <span> - </span> <span class="display-name">Artfaith</span> <span> </span> <span class="date">1 Sep 2020 at 05:02</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_19"><span>Answer 19</span> <span class="arrow"> <a href="#answer_18">↑</a> </span> <span class="arrow"> <a href="#answer_20">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>39</span>
     </div>
     <div>
      <span>Answerer: </span> <span>PhiLho</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Oct 2008 at 15:38</span>
     </div>
    </div>
    <div>
     <p>There is not one which is really usable. I discuss some issues in my <a href="https://stackoverflow.com/questions/161342/is-there-a-php-library-for-email-address-validation#161582" title="Is there a PHP library for email address validation?">answer to <em>Is there a PHP library for email address validation?</em></a>, it is discussed also in <em><a href="https://stackoverflow.com/questions/156430/regexp-recognition-of-email-address-hard" title="Is regular expression recognition of an email address hard?">Is regular expression recognition of an email address hard?</a></em>.</p>
     <p>In short, don't expect a single, usable regex to do a proper job. And the best regex will validate the syntax, not the validity of an e-mail (<em>jhohn@example.com</em> is correct, but it will probably bounce...).</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Correct me if I’m wrong, but I believe that PHP uses PCRE patterns. If so, you should be able to craft something similar to <a href="http://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/1917982#1917982">Abigail’s RFC 5322 pattern</a>.</span> <span> - </span> <span class="display-name">tchrist</span> <span> </span> <span class="date">7 Nov 2010 at 20:24</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@tchrist: not sure if PCRE has caught up to this syntax (which I discover). If so, not sure if PHP's PCRE has caught up to this version of PCRE... Well, if I understand correctly this syntax, you can as well use a PEG parser, much clearer and complete than a regex anyway.</span> <span> - </span> <span class="display-name">PhiLho</span> <span> </span> <span class="date">10 Nov 2010 at 14:51</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>PCRE <i>has</i> caught up to it, but perhaps PHP has not caught up with PCRE. ☹</span> <span> - </span> <span class="display-name">tchrist</span> <span> </span> <span class="date">10 Nov 2010 at 15:09</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_20"><span>Answer 20</span> <span class="arrow"> <a href="#answer_19">↑</a> </span> <span class="arrow"> <a href="#answer_21">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>30</span>
     </div>
     <div>
      <span>Answerer: </span> <span>chaos</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 May 2009 at 18:22</span>
     </div>
    </div>
    <div>
     <p>You could use the one employed by the jQuery Validation plugin:</p>
     <pre><code>/^((([a-z]|\d|[!#\$%&amp;'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&amp;'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>this seems to be doing a good job. It allowed: <code>a-b'c_d.e@f-g.h</code> but was able to catch the inappropriate variations, such as <code>a-b'c_d.@f-g.h</code> and <code>a-b'c_d.e@f-.h</code></span> <span> - </span> <span class="display-name">dsdsdsdsd</span> <span> </span> <span class="date">16 Apr 2014 at 11:52</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Do you have some reference for it?</span> <span> - </span> <span class="display-name">norok2</span> <span> </span> <span class="date">1 Sep 2021 at 07:18</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_21"><span>Answer 21</span> <span class="arrow"> <a href="#answer_20">↑</a> </span> <span class="arrow"> <a href="#answer_22">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>29</span>
     </div>
     <div>
      <span>Answerer: </span> <span>BalusC</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Dec 2009 at 23:40</span>
     </div>
    </div>
    <div>
     <p><a href="http://en.wikipedia.org/wiki/Internationalized_domain_name" rel="nofollow noreferrer">Since May 2010</a>, non-Latin (Chinese, Arabic, Greek, Hebrew, Cyrillic and so on) domain names exist on the Internet. Everyone has to change the email regex used, because those characters are surely not to be covered by <code>[a-z]/i</code> nor <code>\w</code>. They will all fail.</p>
     <p>After all, the <strong>best</strong> way to validate the email address is still to actually <em>send</em> an email to the address in question to validate the address. If the email address is part of user authentication (register/login/etc), then you can perfectly combine it with the user activation system. I.e. send an email with a link with an unique activation key to the specified email address and only allow login when the user has activated the newly created account using the link in the email.</p>
     <p>If the purpose of the regex is just to quickly inform the user in the UI that the specified email address doesn't look like in the right format, best is still to check if it matches basically the following regex:</p>
     <pre><code>^([^.@]+)(\.[^.@]+)*@([^.@]+\.)+([^.@]+)$
</code></pre>
     <p>Simple as that. Why on earth would you care about the characters used in the name and domain? It's the client's responsibility to enter a valid email address, not the server's. Even when the client enters a <em>syntactically</em> valid email address like <code>aa@bb.cc</code>, this does not guarantee that it's a legit email address. No one regex can cover that.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>5</td>
        <td><span>I agree the sending an authentication message is usually the best way for this kind of stuff, syntactically correct and valid are not the same. I get frustrated when I get made to type my email address twice for "Confirmation" as if I can't look at what I typed. I only copy the first one to the second anyway, it seems to be becoming used more and more.</span> <span> - </span> <span class="display-name">PeteT</span> <span> </span> <span class="date">2 Feb 2010 at 15:05</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>agree! but this regex i don't think is valid because it allow <code>spaces</code> after the <code>@.</code> eg. <code>test@test.ca com net</code> is consider a valid email by using the above regex where as it should be returning invalid.</span> <span> - </span> <span class="display-name">CB4</span> <span> </span> <span class="date">8 Nov 2017 at 17:54</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_22"><span>Answer 22</span> <span class="arrow"> <a href="#answer_21">↑</a> </span> <span class="arrow"> <a href="#answer_23">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>27</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Eric Schoonover</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 May 2010 at 22:03</span>
     </div>
    </div>
    <div>
     <p>For the most comprehensive evaluation of the best regular expression for validating an email address please see this link; "<a href="http://fightingforalostcause.net/misc/2006/compare-email-regex.php" rel="noreferrer">Comparing E-mail Address Validating Regular Expressions</a>"</p>
     <p>Here is the current top expression for reference purposes:</p>
     <pre><code>/^([\w\!\#$\%\&amp;\'\*\+\-\/\=\?\^\`{\|\}\~]+\.)*[\w\!\#$\%\&amp;\'\*\+\-\/\=\?\^\`{\|\}\~]+@((((([a-z0-9]{1}[a-z0-9\-]{0,62}[a-z0-9]{1})|[a-z])\.)+[a-z]{2,6})|(\d{1,3}\.){3}\d{1,3}(\:\d{1,5})?)$/i
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>spoon16: That link isn’t really correct. Its statement that there can be no perfect pattern for validating email addresses is patently fault. You <b>can</b>, but you have to make sure that you follow the RFC right down to the letter. And you have to pick the right RFC, too.</span> <span> - </span> <span class="display-name">tchrist</span> <span> </span> <span class="date">7 Nov 2010 at 20:27</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>The "best" right now does not work with java regex - even after properly escaping and converting the string.</span> <span> - </span> <span class="display-name">Eric Chen</span> <span> </span> <span class="date">17 Apr 2012 at 20:57</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_23"><span>Answer 23</span> <span class="arrow"> <a href="#answer_22">↑</a> </span> <span class="arrow"> <a href="#answer_24">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>24</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Luna</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Aug 2015 at 12:30</span>
     </div>
    </div>
    <div>
     <p>The <a href="http://www.w3.org/TR/html5/forms.html#valid-e-mail-address" rel="nofollow noreferrer">HTML5 specification suggests</a> a simple regex for validating email addresses:</p>
     <pre class="lang-none prettyprint-override"><code>/^[a-zA-Z0-9.!#$%&amp;'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
</code></pre>
     <p>This intentionally doesn't comply with <a href="https://www.rfc-editor.org/rfc/rfc5322" rel="nofollow noreferrer">RFC 5322</a>.</p>
     <blockquote>
      <p><strong>Note:</strong> This requirement is a <a href="http://www.w3.org/TR/html5/introduction.html#willful-violation" rel="nofollow noreferrer">wilful violation</a> of <a href="https://www.rfc-editor.org/rfc/rfc5322" rel="nofollow noreferrer">RFC 5322</a>, which defines a syntax for e-mail addresses that is simultaneously too strict (before the <code>@</code> character), too vague (after the <code>@</code> character), and too lax (allowing comments, whitespace characters, and quoted strings in manners unfamiliar to most users) to be of practical use here.</p>
     </blockquote>
     <p>The total length could also be limited to 254 characters, per <a href="https://www.rfc-editor.org/errata_search.php?rfc=3696&amp;eid=1690" rel="nofollow noreferrer">RFC 3696 errata 1690</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>Best answer! Here's a link to the w3 recommendation: <a href="https://www.w3.org/TR/html5/forms.html#valid-e-mail-address" rel="nofollow noreferrer">w3.org/TR/html5/forms.html#valid-e-mail-address</a> This regex is adopted by many browsers.</span> <span> - </span> <span class="display-name">Ryan Taylor</span> <span> </span> <span class="date">6 Nov 2017 at 22:13</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>This is SO not the best answer! This pattern matches this wholly invalid address: <code>invalid@emailaddress</code>. I would urge caution and much testing before you use it!</span> <span> - </span> <span class="display-name">Sheridan</span> <span> </span> <span class="date">21 Mar 2018 at 11:47</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Sheridan, if you think there is an issue with the HTML5 spec you can raise an issue here: <a href="https://github.com/w3c/html/issues" rel="nofollow noreferrer">github.com/w3c/html/issues</a></span> <span> - </span> <span class="display-name">Luna</span> <span> </span> <span class="date">21 Mar 2018 at 12:56</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>This doesn't add much over <a href="https://stackoverflow.com/a/8829363">stackoverflow.com/a/8829363</a> and would IMHO be better as an edit of or comment on that.</span> <span> - </span> <span class="display-name">user743382</span> <span> </span> <span class="date">29 Apr 2018 at 21:50</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>example@localhost is valid, but for a real world application you may want to enforce a domain extension, all you need to do is change the final * to a + to achieve this (changing that part of the pattern from 0+ to 1+)</span> <span> - </span> <span class="display-name">Mitch Satchwell</span> <span> </span> <span class="date">16 May 2018 at 09:05</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span><code>invalid@emailaddress</code> is a valid email address... it just doesn't exist. (And actually, depending on your network configuration, it might even be deliverable inside your local network.) And the only way to tell if an address exists or not is to send it an email.</span> <span> - </span> <span class="display-name">awwright</span> <span> </span> <span class="date">31 Aug 2020 at 18:18</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>In case anybody wants to use the above in Perl, despite the HTML5 spec saying it is compatible, it actually needs the <code>$</code> to be escaped (make it <code>\$</code>), as <code>$%</code> is a special variable in perl, so addresses containing <code>$</code> or <code>%</code> will be rejected.</span> <span> - </span> <span class="display-name">Ecuador</span> <span> </span> <span class="date">22 Feb 2022 at 22:54</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>How can I make this to work in C#? It works fine in Javascript</span> <span> - </span> <span class="display-name">Morgs</span> <span> </span> <span class="date">18 May 2022 at 21:56</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_24"><span>Answer 24</span> <span class="arrow"> <a href="#answer_23">↑</a> </span> <span class="arrow"> <a href="#answer_25">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>16</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Greg Bacon</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Jun 2009 at 15:15</span>
     </div>
    </div>
    <div>
     <p>For a vivid demonstration, the following monster is pretty good, but it still does not correctly recognize all syntactically valid email addresses: it recognizes nested comments up to four levels deep.</p>
     <p>This is a job for a parser, but even if an address is syntactically valid, it still may not be deliverable. Sometimes you have to resort to the hillbilly method of "Hey, y'all, watch ee-us!"</p>
     <pre class="lang-none prettyprint-override"><code>// derivative of work with the following copyright and license:
// Copyright (c) 2004 Casey West.  All rights reserved.
// This module is free software; you can redistribute it and/or
// modify it under the same terms as Perl itself.

// see http://search.cpan.org/~cwest/Email-Address-1.80/

private static string gibberish = @"
(?-xism:(?:(?-xism:(?-xism:(?-xism:(?-xism:(?-xism:(?-xism:\
s*\((?:\s*(?-xism:(?-xism:(?&gt;[^()\\]+))|(?-xism:\\(?-xism:[^
\x0A\x0D]))|(?-xism:\s*\((?:\s*(?-xism:(?-xism:(?&gt;[^()\\]+))
|(?-xism:\\(?-xism:[^\x0A\x0D]))|)+)*\s*\)\s*))+)*\s*\)\s*)+
|\s+)*[^\x00-\x1F\x7F()&lt;&gt;\[\]:;@\,.&lt;DQ&gt;\s]+(?-xism:(?-xism:\
s*\((?:\s*(?-xism:(?-xism:(?&gt;[^()\\]+))|(?-xism:\\(?-xism:[^
\x0A\x0D]))|(?-xism:\s*\((?:\s*(?-xism:(?-xism:(?&gt;[^()\\]+))
|(?-xism:\\(?-xism:[^\x0A\x0D]))|)+)*\s*\)\s*))+)*\s*\)\s*)+
|\s+)*)|(?-xism:(?-xism:(?-xism:\s*\((?:\s*(?-xism:(?-xism:(
?&gt;[^()\\]+))|(?-xism:\\(?-xism:[^\x0A\x0D]))|(?-xism:\s*\((?
:\s*(?-xism:(?-xism:(?&gt;[^()\\]+))|(?-xism:\\(?-xism:[^\x0A\x
0D]))|)+)*\s*\)\s*))+)*\s*\)\s*)+|\s+)*&lt;DQ&gt;(?-xism:(?-xism:[
^\\&lt;DQ&gt;])|(?-xism:\\(?-xism:[^\x0A\x0D])))+&lt;DQ&gt;(?-xism:(?-xi
sm:\s*\((?:\s*(?-xism:(?-xism:(?&gt;[^()\\]+))|(?-xism:\\(?-xis
m:[^\x0A\x0D]))|(?-xism:\s*\((?:\s*(?-xism:(?-xism:(?&gt;[^()\\
]+))|(?-xism:\\(?-xism:[^\x0A\x0D]))|)+)*\s*\)\s*))+)*\s*\)\
s*)+|\s+)*))+)?(?-xism:(?-xism:(?-xism:\s*\((?:\s*(?-xism:(?
-xism:(?&gt;[^()\\]+))|(?-xism:\\(?-xism:[^\x0A\x0D]))|(?-xism:
\s*\((?:\s*(?-xism:(?-xism:(?&gt;[^()\\]+))|(?-xism:\\(?-xism:[
^\x0A\x0D]))|)+)*\s*\)\s*))+)*\s*\)\s*)+|\s+)*&lt;(?-xism:(?-xi
sm:(?-xism:(?-xism:(?-xism:\s*\((?:\s*(?-xism:(?-xism:(?&gt;[^(
)\\]+))|(?-xism:\\(?-xism:[^\x0A\x0D]))|(?-xism:\s*\((?:\s*(
?-xism:(?-xism:(?&gt;[^()\\]+))|(?-xism:\\(?-xism:[^\x0A\x0D]))
|)+)*\s*\)\s*))+)*\s*\)\s*)+|\s+)*(?-xism:[^\x00-\x1F\x7F()&lt;
&gt;\[\]:;@\,.&lt;DQ&gt;\s]+(?:\.[^\x00-\x1F\x7F()&lt;&gt;\[\]:;@\,.&lt;DQ&gt;\s]
+)*)(?-xism:(?-xism:\s*\((?:\s*(?-xism:(?-xism:(?&gt;[^()\\]+))
|(?-xism:\\(?-xism:[^\x0A\x0D]))|(?-xism:\s*\((?:\s*(?-xism:
(?-xism:(?&gt;[^()\\]+))|(?-xism:\\(?-xism:[^\x0A\x0D]))|)+)*\s
*\)\s*))+)*\s*\)\s*)+|\s+)*)|(?-xism:(?-xism:(?-xism:\s*\((?
:\s*(?-xism:(?-xism:(?&gt;[^()\\]+))|(?-xism:\\(?-xism:[^\x0A\x
0D]))|(?-xism:\s*\((?:\s*(?-xism:(?-xism:(?&gt;[^()\\]+))|(?-xi
sm:\\(?-xism:[^\x0A\x0D]))|)+)*\s*\)\s*))+)*\s*\)\s*)+|\s+)*
&lt;DQ&gt;(?-xism:(?-xism:[^\\&lt;DQ&gt;])|(?-xism:\\(?-xism:[^\x0A\x0D]
)))+&lt;DQ&gt;(?-xism:(?-xism:\s*\((?:\s*(?-xism:(?-xism:(?&gt;[^()\\
]+))|(?-xism:\\(?-xism:[^\x0A\x0D]))|(?-xism:\s*\((?:\s*(?-x
ism:(?-xism:(?&gt;[^()\\]+))|(?-xism:\\(?-xism:[^\x0A\x0D]))|)+
)*\s*\)\s*))+)*\s*\)\s*)+|\s+)*))\@(?-xism:(?-xism:(?-xism:(
?-xism:\s*\((?:\s*(?-xism:(?-xism:(?&gt;[^()\\]+))|(?-xism:\\(?
-xism:[^\x0A\x0D]))|(?-xism:\s*\((?:\s*(?-xism:(?-xism:(?&gt;[^
()\\]+))|(?-xism:\\(?-xism:[^\x0A\x0D]))|)+)*\s*\)\s*))+)*\s
*\)\s*)+|\s+)*(?-xism:[^\x00-\x1F\x7F()&lt;&gt;\[\]:;@\,.&lt;DQ&gt;\s]+(
?:\.[^\x00-\x1F\x7F()&lt;&gt;\[\]:;@\,.&lt;DQ&gt;\s]+)*)(?-xism:(?-xism:
\s*\((?:\s*(?-xism:(?-xism:(?&gt;[^()\\]+))|(?-xism:\\(?-xism:[
^\x0A\x0D]))|(?-xism:\s*\((?:\s*(?-xism:(?-xism:(?&gt;[^()\\]+)
)|(?-xism:\\(?-xism:[^\x0A\x0D]))|)+)*\s*\)\s*))+)*\s*\)\s*)
+|\s+)*)|(?-xism:(?-xism:(?-xism:\s*\((?:\s*(?-xism:(?-xism:
(?&gt;[^()\\]+))|(?-xism:\\(?-xism:[^\x0A\x0D]))|(?-xism:\s*\((
?:\s*(?-xism:(?-xism:(?&gt;[^()\\]+))|(?-xism:\\(?-xism:[^\x0A\
x0D]))|)+)*\s*\)\s*))+)*\s*\)\s*)+|\s+)*\[(?:\s*(?-xism:(?-x
ism:[^\[\]\\])|(?-xism:\\(?-xism:[^\x0A\x0D])))+)*\s*\](?-xi
sm:(?-xism:\s*\((?:\s*(?-xism:(?-xism:(?&gt;[^()\\]+))|(?-xism:
\\(?-xism:[^\x0A\x0D]))|(?-xism:\s*\((?:\s*(?-xism:(?-xism:(
?&gt;[^()\\]+))|(?-xism:\\(?-xism:[^\x0A\x0D]))|)+)*\s*\)\s*))+
)*\s*\)\s*)+|\s+)*)))&gt;(?-xism:(?-xism:\s*\((?:\s*(?-xism:(?-
xism:(?&gt;[^()\\]+))|(?-xism:\\(?-xism:[^\x0A\x0D]))|(?-xism:\
s*\((?:\s*(?-xism:(?-xism:(?&gt;[^()\\]+))|(?-xism:\\(?-xism:[^
\x0A\x0D]))|)+)*\s*\)\s*))+)*\s*\)\s*)+|\s+)*))|(?-xism:(?-x
ism:(?-xism:(?-xism:(?-xism:\s*\((?:\s*(?-xism:(?-xism:(?&gt;[^
()\\]+))|(?-xism:\\(?-xism:[^\x0A\x0D]))|(?-xism:\s*\((?:\s*
(?-xism:(?-xism:(?&gt;[^()\\]+))|(?-xism:\\(?-xism:[^\x0A\x0D])
)|)+)*\s*\)\s*))+)*\s*\)\s*)+|\s+)*(?-xism:[^\x00-\x1F\x7F()
&lt;&gt;\[\]:;@\,.&lt;DQ&gt;\s]+(?:\.[^\x00-\x1F\x7F()&lt;&gt;\[\]:;@\,.&lt;DQ&gt;\s
]+)*)(?-xism:(?-xism:\s*\((?:\s*(?-xism:(?-xism:(?&gt;[^()\\]+)
)|(?-xism:\\(?-xism:[^\x0A\x0D]))|(?-xism:\s*\((?:\s*(?-xism
:(?-xism:(?&gt;[^()\\]+))|(?-xism:\\(?-xism:[^\x0A\x0D]))|)+)*\
s*\)\s*))+)*\s*\)\s*)+|\s+)*)|(?-xism:(?-xism:(?-xism:\s*\((
?:\s*(?-xism:(?-xism:(?&gt;[^()\\]+))|(?-xism:\\(?-xism:[^\x0A\
x0D]))|(?-xism:\s*\((?:\s*(?-xism:(?-xism:(?&gt;[^()\\]+))|(?-x
ism:\\(?-xism:[^\x0A\x0D]))|)+)*\s*\)\s*))+)*\s*\)\s*)+|\s+)
*&lt;DQ&gt;(?-xism:(?-xism:[^\\&lt;DQ&gt;])|(?-xism:\\(?-xism:[^\x0A\x0D
])))+&lt;DQ&gt;(?-xism:(?-xism:\s*\((?:\s*(?-xism:(?-xism:(?&gt;[^()\
\]+))|(?-xism:\\(?-xism:[^\x0A\x0D]))|(?-xism:\s*\((?:\s*(?-
xism:(?-xism:(?&gt;[^()\\]+))|(?-xism:\\(?-xism:[^\x0A\x0D]))|)
+)*\s*\)\s*))+)*\s*\)\s*)+|\s+)*))\@(?-xism:(?-xism:(?-xism:
(?-xism:\s*\((?:\s*(?-xism:(?-xism:(?&gt;[^()\\]+))|(?-xism:\\(
?-xism:[^\x0A\x0D]))|(?-xism:\s*\((?:\s*(?-xism:(?-xism:(?&gt;[
^()\\]+))|(?-xism:\\(?-xism:[^\x0A\x0D]))|)+)*\s*\)\s*))+)*\
s*\)\s*)+|\s+)*(?-xism:[^\x00-\x1F\x7F()&lt;&gt;\[\]:;@\,.&lt;DQ&gt;\s]+
(?:\.[^\x00-\x1F\x7F()&lt;&gt;\[\]:;@\,.&lt;DQ&gt;\s]+)*)(?-xism:(?-xism
:\s*\((?:\s*(?-xism:(?-xism:(?&gt;[^()\\]+))|(?-xism:\\(?-xism:
[^\x0A\x0D]))|(?-xism:\s*\((?:\s*(?-xism:(?-xism:(?&gt;[^()\\]+
))|(?-xism:\\(?-xism:[^\x0A\x0D]))|)+)*\s*\)\s*))+)*\s*\)\s*
)+|\s+)*)|(?-xism:(?-xism:(?-xism:\s*\((?:\s*(?-xism:(?-xism
:(?&gt;[^()\\]+))|(?-xism:\\(?-xism:[^\x0A\x0D]))|(?-xism:\s*\(
(?:\s*(?-xism:(?-xism:(?&gt;[^()\\]+))|(?-xism:\\(?-xism:[^\x0A
\x0D]))|)+)*\s*\)\s*))+)*\s*\)\s*)+|\s+)*\[(?:\s*(?-xism:(?-
xism:[^\[\]\\])|(?-xism:\\(?-xism:[^\x0A\x0D])))+)*\s*\](?-x
ism:(?-xism:\s*\((?:\s*(?-xism:(?-xism:(?&gt;[^()\\]+))|(?-xism
:\\(?-xism:[^\x0A\x0D]))|(?-xism:\s*\((?:\s*(?-xism:(?-xism:
(?&gt;[^()\\]+))|(?-xism:\\(?-xism:[^\x0A\x0D]))|)+)*\s*\)\s*))
+)*\s*\)\s*)+|\s+)*))))(?-xism:\s*\((?:\s*(?-xism:(?-xism:(?
&gt;[^()\\]+))|(?-xism:\\(?-xism:[^\x0A\x0D]))|(?-xism:\s*\((?:
\s*(?-xism:(?-xism:(?&gt;[^()\\]+))|(?-xism:\\(?-xism:[^\x0A\x0
D]))|)+)*\s*\)\s*))+)*\s*\)\s*)*)"
  .Replace("&lt;DQ&gt;", "\"")
  .Replace("\t", "")
  .Replace(" ", "")
  .Replace("\r", "")
  .Replace("\n", "");

private static Regex mailbox =
  new Regex(gibberish, RegexOptions.ExplicitCapture);
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>What programming language? <a href="https://en.wikipedia.org/wiki/C_Sharp_%28programming_language%29" rel="nofollow noreferrer">C#</a>?</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">13 Feb 2022 at 15:04</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_25"><span>Answer 25</span> <span class="arrow"> <a href="#answer_24">↑</a> </span> <span class="arrow"> <a href="#answer_26">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>12</span>
     </div>
     <div>
      <span>Answerer: </span> <span>AZ_</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Dec 2010 at 12:58</span>
     </div>
    </div>
    <div>
     <p>According to the official standard, <a href="https://www.rfc-editor.org/rfc/rfc2822#section-3.4.1" rel="nofollow noreferrer">RFC 2822</a>, a valid email regex is:</p>
     <pre class="lang-none prettyprint-override"><code>(?:[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
</code></pre>
     <p>If you want to use it in Java, it's really very easy:</p>
     <pre><code>import java.util.regex.*;

class regexSample 
{
   public static void main(String args[]) 
   {
      //Input the string for validation
      String email = "xyz@hotmail.com";

      //Set the email pattern string
      Pattern p = Pattern.compile(" (?:[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*|"
              +"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")"
                     + "@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\]");

      //Match the given string with the pattern
      Matcher m = p.matcher(email);

      //Check whether match is found 
      boolean matchFound = m.matches();

      if (matchFound)
        System.out.println("Valid Email Id.");
      else
        System.out.println("Invalid Email Id.");
   }
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>Your regex does not include first uppercase letter for example <b>Leonardo.davinci@gmail.com</b> which could be annoying for some users. Use this one instead: <code>(?:[A-Za-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[A-Za-z0-9!#$%&amp;'*+/=?‌​^_`{|}~-]+)*|"(?:[\x‌​01-\x08\x0b\x0c\x0e-‌​\x1f\x21\x23-\x5b\x5‌​d-\x7f]|\\[\x01-\x09‌​\x0b\x0c\x0e-\x7f])*‌​")@(?:(?:[a-z0-9](?:‌​[a-z0-9-]*[a-z0-9])?‌​\.)+[a-z0-9](?:[a-z0‌​-9-]*[a-z0-9])?|\[(?‌​:(?:25[0-5]|2[0-4][0‌​-9]|[01]?[0-9][0-9]?‌​)\.){3}(?:25[0-5]|2[‌​0-4][0-9]|[01]?[0-9]‌​[0-9]?|[a-z0-9-]*[a-‌​z0-9]:(?:[\x01-\x08\‌​x0b\x0c\x0e-\x1f\x21‌​-\x5a\x53-\x7f]|\\[\‌​x01-\x09\x0b\x0c\x0e‌​-\x7f])+)\]) </code></span> <span> - </span> <span class="display-name">Kebab Krabby</span> <span> </span> <span class="date">17 Jul 2019 at 15:07</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@KebabKrabby Thanks, please edit the answer, I'll accept the change.</span> <span> - </span> <span class="display-name">AZ_</span> <span> </span> <span class="date">31 Jul 2019 at 07:55</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>If i add that change to your answer it wont be RFC 2822 anymore so i dont know if thats correct.</span> <span> - </span> <span class="display-name">Kebab Krabby</span> <span> </span> <span class="date">31 Jul 2019 at 22:06</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@KebabKrabby: I guess we would need to apply the pattern with case insensitivity somewhere in the matching options, not change the Regex itself.</span> <span> - </span> <span class="display-name">Thomas Weller</span> <span> </span> <span class="date">25 Sep 2020 at 11:46</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_26"><span>Answer 26</span> <span class="arrow"> <a href="#answer_25">↑</a> </span> <span class="arrow"> <a href="#answer_27">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>11</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Michael</span>
     </div>
     <div>
      <span> Answered: </span> <span>20 Nov 2009 at 16:05</span>
     </div>
    </div>
    <div>
     <p>RFC 5322 standard:</p>
     <p>Allows dot-atom local-part, quoted-string local-part, obsolete (mixed dot-atom and quoted-string) local-part, domain name domain, (IPv4, IPv6, and IPv4-mapped IPv6 address) domain literal domain, and (nested) CFWS.</p>
     <pre><code>'/^(?!(?&gt;(?1)"?(?&gt;\\\[ -~]|[^"])"?(?1)){255,})(?!(?&gt;(?1)"?(?&gt;\\\[ -~]|[^"])"?(?1)){65,}@)((?&gt;(?&gt;(?&gt;((?&gt;(?&gt;(?&gt;\x0D\x0A)?[\t ])+|(?&gt;[\t ]*\x0D\x0A)?[\t ]+)?)(\((?&gt;(?2)(?&gt;[\x01-\x08\x0B\x0C\x0E-\'*-\[\]-\x7F]|\\\[\x00-\x7F]|(?3)))*(?2)\)))+(?2))|(?2))?)([!#-\'*+\/-9=?^-~-]+|"(?&gt;(?2)(?&gt;[\x01-\x08\x0B\x0C\x0E-!#-\[\]-\x7F]|\\\[\x00-\x7F]))*(?2)")(?&gt;(?1)\.(?1)(?4))*(?1)@(?!(?1)[a-z0-9-]{64,})(?1)(?&gt;([a-z0-9](?&gt;[a-z0-9-]*[a-z0-9])?)(?&gt;(?1)\.(?!(?1)[a-z0-9-]{64,})(?1)(?5)){0,126}|\[(?:(?&gt;IPv6:(?&gt;([a-f0-9]{1,4})(?&gt;:(?6)){7}|(?!(?:.*[a-f0-9][:\]]){8,})((?6)(?&gt;:(?6)){0,6})?::(?7)?))|(?&gt;(?&gt;IPv6:(?&gt;(?6)(?&gt;:(?6)){5}:|(?!(?:.*[a-f0-9]:){6,})(?8)?::(?&gt;((?6)(?&gt;:(?6)){0,4}):)?))?(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])(?&gt;\.(?9)){3}))\])(?1)$/isD'
</code></pre>
     <p>RFC 5321 standard:</p>
     <p>Allows dot-atom local-part, quoted-string local-part, domain name domain, and (IPv4, IPv6, and IPv4-mapped IPv6 address) domain literal domain.</p>
     <pre><code>'/^(?!(?&gt;"?(?&gt;\\\[ -~]|[^"])"?){255,})(?!"?(?&gt;\\\[ -~]|[^"]){65,}"?@)(?&gt;([!#-\'*+\/-9=?^-~-]+)(?&gt;\.(?1))*|"(?&gt;[ !#-\[\]-~]|\\\[ -~])*")@(?!.*[^.]{64,})(?&gt;([a-z0-9](?&gt;[a-z0-9-]*[a-z0-9])?)(?&gt;\.(?2)){0,126}|\[(?:(?&gt;IPv6:(?&gt;([a-f0-9]{1,4})(?&gt;:(?3)){7}|(?!(?:.*[a-f0-9][:\]]){8,})((?3)(?&gt;:(?3)){0,6})?::(?4)?))|(?&gt;(?&gt;IPv6:(?&gt;(?3)(?&gt;:(?3)){5}:|(?!(?:.*[a-f0-9]:){6,})(?5)?::(?&gt;((?3)(?&gt;:(?3)){0,4}):)?))?(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])(?&gt;\.(?6)){3}))\])$/iD'
</code></pre>
     <p>Basic:</p>
     <p>Allows dot-atom local-part and domain name domain (requiring at least two domain name labels with the TLD limited to 2-6 alphabetic characters).</p>
     <pre><code>"/^(?!.{255,})(?!.{65,}@)([!#-'*+\/-9=?^-~-]+)(?&gt;\.(?1))*@(?!.*[^.]{64,})(?&gt;[a-z0-9](?&gt;[a-z0-9-]*[a-z0-9])?\.){1,126}[a-z]{2,6}$/iD"
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>What the devil language is that in?? I see a <code>/D</code> flag, and you’ve quoted it with single quotes yet also used slashes to delimit the pattern? It’s not Perl, and it can’t be PCRE. Is it therefore PHP? I believe those are the only three that allow recursion like <code>(?1)</code>.</span> <span> - </span> <span class="display-name">tchrist</span> <span> </span> <span class="date">7 Nov 2010 at 20:32</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>It's in PHP, which uses PCRE. The slashes are used only to delimit special characters like parentheses, square brackets, and of course slashes and single quotes. The /D flag, if you didn't know, is to prevent a newline being added to the end of the string, which would be allowed otherwise.</span> <span> - </span> <span class="display-name">Michael</span> <span> </span> <span class="date">19 Feb 2011 at 18:24</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_27"><span>Answer 27</span> <span class="arrow"> <a href="#answer_26">↑</a> </span> <span class="arrow"> <a href="#answer_28">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>11</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mac</span>
     </div>
     <div>
      <span> Answered: </span> <span>20 Jul 2011 at 03:37</span>
     </div>
    </div>
    <div>
     <p>Here's the PHP code I use. I've chosen this solution in the spirit of "false positives are better than false negatives" as declared by another commenter here <em>and</em> with regards to keeping your response time up and server load down ... there's really no need to waste server resources with a regular expression when this will weed out most simple user errors. You can always follow this up by sending a test email if you want.</p>
     <pre><code>function validateEmail($email) {
  return (bool) stripos($email,'@');
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>a) The "waste server resources" is infinitesimal, but if you are so inclined, you could do it client side with JS b) What is you need to send a registration mail and the user enters me@forgotthedotcom ? Your "solution" fails and you lose a user.</span> <span> - </span> <span class="display-name">johnjohn</span> <span> </span> <span class="date">3 Apr 2012 at 09:40</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>a) Relying on a JS validation that would fail when JavaScript is disabled doesn't sound like the best idea either (just btw)</span> <span> - </span> <span class="display-name">auco</span> <span> </span> <span class="date">6 Dec 2013 at 15:39</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>What do you mean by false positives? Rejecting email addresses that you shouldn't have rejected? Or accepting email addresses that you shouldn't have accepted?</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">13 Feb 2022 at 16:01</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_28"><span>Answer 28</span> <span class="arrow"> <a href="#answer_27">↑</a> </span> <span class="arrow"> <a href="#answer_29">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Joseph Yee</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Nov 2008 at 04:48</span>
     </div>
    </div>
    <div>
     <p>Strange that you "cannot" allow 4 characters TLDs. You are banning people from <em>.info</em> and <em>.name</em>, and the length limitation stop <em>.travel</em> and <em>.museum</em>, but yes, they are less common than 2 characters TLDs and 3 characters TLDs.</p>
     <p>You should allow uppercase alphabets too. Email systems will normalize the local part and domain part.</p>
     <p>For your regex of domain part, domain name cannot starts with '-' and cannot ends with '-'. Dash can only stays in between.</p>
     <p>If you used the <a href="https://en.wikipedia.org/wiki/PEAR" rel="nofollow noreferrer">PEAR</a> library, check out their mail function (I forgot the exact name/library). You can validate email address by calling one function, and it validates the email address according to definition in <a href="https://en.wikipedia.org/wiki/Email" rel="nofollow noreferrer">RFC&nbsp;822</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span>@Joseph Yee: Isn’t RFC 822 a bit dated?</span> <span> - </span> <span class="display-name">tchrist</span> <span> </span> <span class="date">7 Nov 2010 at 20:27</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Re <i>' "cannot" allow 4 characters TLDs'</i>: What you referring to?</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">13 Feb 2022 at 14:45</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_29"><span>Answer 29</span> <span class="arrow"> <a href="#answer_28">↑</a> </span> <span class="arrow"> <a href="#answer_30">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Prasad</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Apr 2012 at 09:45</span>
     </div>
    </div>
    <div>
     <p>If you are fine with accepting empty values (which is not an invalid email) and are running PHP&nbsp;5.2+, I would suggest:</p>
     <pre><code>static public function checkEmail($email, $ignore_empty = false) {
    if($ignore_empty &amp;&amp; (is_null($email) || $email == ''))
        return true;
    return filter_var($email, FILTER_VALIDATE_EMAIL);
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>What would be <b><i>an example</i></b> of an address with empty values? Please respond by <a href="https://stackoverflow.com/posts/10362389/edit">editing (changing) your answer</a>, not here in comments (<b><i>without</i></b> "Edit:", "Update:", or similar - the answer should appear as if it was written today).</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">13 Feb 2022 at 16:19</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_30"><span>Answer 30</span> <span class="arrow"> <a href="#answer_29">↑</a> </span> <span class="arrow"> <a href="#answer_31">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>TombMedia</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Dec 2012 at 06:15</span>
     </div>
    </div>
    <div>
     <p>I've been using this touched up version of the OP's regex for a while and it hasn't left me with too many surprises. <strike>I've never encountered an apostrophe in an email yet so it doesn't validate that</strike>. It does validate <code>Jean+François@anydomain.museum</code> and <code>试@例子.测试.مثال.آزمایشی</code>, but not weird abuse of those non alphanumeric characters <code>.+@you.com</code>.</p>
     <pre class="lang-none prettyprint-override"><code>(?!^[.+&amp;'_-]*@.*$)(^[_\w\d+&amp;'-]+(\.[_\w\d+&amp;'-]*)*@[\w\d-]+(\.[\w\d-]+)*\.(([\d]{1,3})|([\w]{2,}))$)
</code></pre>
     <p>It does support IP addresses <code>you@192.168.1.1</code>, but I haven't refined it enough to deal with bogus IP address ranges such as <code>999.999.999.1</code>.</p>
     <p><strike>It also supports all the TLDs over three characters which stops <code>asdf@asdf.asdf</code> which I think the original let through.</strike> <a href="http://data.iana.org/TLD/tlds-alpha-by-domain.txt" rel="nofollow noreferrer">I've been beat, there are too many TLDs now over 3 characters</a>.</p>
     <p>I know the OP has abandoned his regex, but this flavour lives on.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>For all: The regular expression in the question was removed in revision 10, in 2015 (about 7 years later).</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">13 Feb 2022 at 16:25</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Strikeout shouldn't be necessary. That is what the revision history is for. If something is no longer valid, it should be removed. The answer should be as if it was written today.</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">13 Feb 2022 at 16:27</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_31"><span>Answer 31</span> <span class="arrow"> <a href="#answer_30">↑</a> </span> <span class="arrow"> <a href="#answer_32">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Murthy Jeedigunta</span>
     </div>
     <div>
      <span> Answered: </span> <span>2 Aug 2011 at 06:50</span>
     </div>
    </div>
    <div>
     <pre><code>public bool ValidateEmail(string sEmail)
{
    if (sEmail == null)
    {
        return false;
    }

    int nFirstAT = sEmail.IndexOf('@');
    int nLastAT = sEmail.LastIndexOf('@');

    if ((nFirstAT &gt; 0) &amp;&amp; (nLastAT == nFirstAT) &amp;&amp; (nFirstAT &lt; (sEmail.Length - 1)))
    {
        return (Regex.IsMatch(sEmail, @"^[a-z|0-9|A-Z]*([_][a-z|0-9|A-Z]+)*([.][a-z|0-9|A-Z]+)*([.][a-z|0-9|A-Z]+)*(([_][a-z|0-9|A-Z]+)*)?@[a-z][a-z|0-9|A-Z]*\.([a-z][a-z|0-9|A-Z]*(\.[a-z][a-z|0-9|A-Z]*)?)$"));
    }
    else
    {
        return false;
    }
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>This will sometimes fail; a user in an email address may contain "@" characters if they are inside a quoted-string.</span> <span> - </span> <span class="display-name">awwright</span> <span> </span> <span class="date">11 Sep 2020 at 05:18</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_32"><span>Answer 32</span> <span class="arrow"> <a href="#answer_31">↑</a> </span> <span class="arrow"> <a href="#answer_33">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Cees Timmerman</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Jan 2013 at 14:30</span>
     </div>
    </div>
    <div>
     <p>I'm still using:</p>
     <pre class="lang-none prettyprint-override"><code>^[A-Za-z0-9._+\-\']+@[A-Za-z0-9.\-]+\.[A-Za-z]{2,}$
</code></pre>
     <p>But with IPv6 and Unicode coming up, perhaps this is best:</p>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
      <div class="snippet-code">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>console.log(/^[\p{L}!#-'*+\-/\d=?^-~]+(.[\p{L}!#-'*+\-/\d=?^-~])*@[^@\s]{2,}$/u.test("תה.בועות@😀.fm"))</code></pre>
      </div>
     </div>
     <p></p>
     <p>Gmail allows sequential dots, but Microsoft Exchange Server 2007 refuses them, which follows <a href="https://www.rfc-editor.org/rfc/rfc5322" rel="nofollow noreferrer">the most recent standard</a> afaik.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Doesn't allow <code>"John Smith"@example.com</code>.</span> <span> - </span> <span class="display-name">David Conrad</span> <span> </span> <span class="date">12 Feb 2013 at 23:27</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>True, but when is that actually needed?</span> <span> - </span> <span class="display-name">Cees Timmerman</span> <span> </span> <span class="date">20 Feb 2013 at 14:24</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Any time an email address has a space in it?</span> <span> - </span> <span class="display-name">David Conrad</span> <span> </span> <span class="date">20 Feb 2013 at 23:52</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I've never seen one of those actually being used, and i think the official specs say it is only for backwards compatibility.</span> <span> - </span> <span class="display-name">Cees Timmerman</span> <span> </span> <span class="date">21 Feb 2013 at 11:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Would you mind explaining what ^[A-Za-z0-9._+\-\']+@[A-Za-z0-9.\-]+\.[A-Za-z]{2,}$ does exactly ?</span> <span> - </span> <span class="display-name">me-me</span> <span> </span> <span class="date">15 Nov 2022 at 21:25</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>See <a href="https://regexr.com/72obr" rel="nofollow noreferrer">regexr.com/72obr</a></span> <span> - </span> <span class="display-name">Cees Timmerman</span> <span> </span> <span class="date">19 Nov 2022 at 00:05</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@DavidConrad You mean <code>"John\ Smith"@example.com</code> according to <a href="https://stackoverflow.com/questions/201323/how-can-i-validate-an-email-address-using-a-regular-expression/63841473?noredirect=1#comment131520624_63841473">this comment</a>.</span> <span> - </span> <span class="display-name">Cees Timmerman</span> <span> </span> <span class="date">20 Nov 2022 at 18:20</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_33"><span>Answer 33</span> <span class="arrow"> <a href="#answer_32">↑</a> </span> <span class="arrow"> <a href="#answer_34">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>awwright</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Sep 2020 at 05:53</span>
     </div>
    </div>
    <div>
     <p>The regular expression for an email address is:</p>
     <pre class="lang-none prettyprint-override"><code>/^("(?:[!#-\[\]-\u{10FFFF}]|\\[\t -\u{10FFFF}])*"|[!#-'*+\-/-9=?A-Z\^-\u{10FFFF}](?:\.?[!#-'*+\-/-9=?A-Z\^-\u{10FFFF}])*)@([!#-'*+\-/-9=?A-Z\^-\u{10FFFF}](?:\.?[!#-'*+\-/-9=?A-Z\^-\u{10FFFF}])*|\[[!-Z\^-\u{10FFFF}]*\])$/u
</code></pre>
     <p>This regular expression is 100% identical to the <code>addr-spec</code> <a href="https://en.wikipedia.org/wiki/Augmented_Backus%E2%80%93Naur_form" rel="nofollow noreferrer">ABNF</a> for non-obsolete email addresses, as specified across <a href="https://www.rfc-editor.org/rfc/rfc5321#section-4.5.3.1" rel="nofollow noreferrer">RFC 5321</a>, <a href="https://www.rfc-editor.org/rfc/rfc5322#section-3.4.1" rel="nofollow noreferrer">RFC 5322</a>, and <a href="https://www.rfc-editor.org/rfc/rfc6532#section-3.2" rel="nofollow noreferrer">RFC 6532</a>.</p>
     <p>Additionally, you must verify:</p>
     <ul>
      <li>The email address is well-formed UTF-8 (or ASCII, if you cannot send to internationalized email addresses)</li>
      <li>The address is not more than 320 UTF-8 bytes</li>
      <li>The user part (the first match group) is not more than 64 UTF-8 bytes</li>
      <li>The domain part (the second match group) is not more than 255 UTF-8 bytes</li>
     </ul>
     <p>The easiest way to do all of this is to use an existing function. In PHP, see the <a href="https://www.php.net/manual/en/function.filter-var" rel="nofollow noreferrer">filter_var</a> function using <code>FILTER_VALIDATE_EMAIL</code> and <code>FILTER_FLAG_EMAIL_UNICODE</code> (if you can send to internationalized email addresses):</p>
     <pre><code>$email_valid = filter_var($email_input, FILTER_VALIDATE_EMAIL, FILTER_FLAG_EMAIL_UNICODE);
</code></pre>
     <p>However, maybe you're building such a function—indeed the easiest way to implement this is to use a regular expression.</p>
     <p>Remember, this only verifies that the email address will not cause a syntax error. The only way to verify that the address can receive email is to <em>actually</em> send an email.</p>
     <p>Next, I will treat how you generate this regular expression.</p>
     <hr>
     <p>I write a new answer, because most of the answers here make the mistake of either specifying a pattern that is too restrictive (and so have not aged well); or they present a regular expression that's actually matching a header for a <a href="https://en.wikipedia.org/wiki/MIME" rel="nofollow noreferrer">MIME</a> message, and not the email address itself.</p>
     <p>It is entirely possible to make a regular expression from an ABNF, so long as there are no recursive parts.</p>
     <p>RFC 5322 specifies what is legal to send in a MIME message; consider this the upper bound on what is a legal email address.</p>
     <p>However, to follow this ABNF exactly would be a mistake: this pattern technically represents how you encode an email address <em>in a MIME message</em>, and allows strings not part of the email address, like folding whitespace and comments; and it includes support for obsolete forms that are not legal to generate (but that servers read for historical reasons). An email address does not include these.</p>
     <p>RFC 5322 explains:</p>
     <blockquote>
      <p>Both atom and dot-atom are interpreted as a single unit, comprising the string of characters that make it up. Semantically, the optional comments and FWS surrounding the rest of the characters are not part of the atom; the atom is only the run of atext characters in an atom, or the atext and "." characters in a dot-atom.</p>
     </blockquote>
     <blockquote>
      <p>In some of the definitions, there will be non-terminals whose names start with "obs-". These "obs-" elements refer to tokens defined in the obsolete syntax in section 4. In all cases, these productions are to be ignored for the purposes of generating legal Internet messages and MUST NOT be used as part of such a message.</p>
     </blockquote>
     <p>If you remove <code>CFWS</code>, <code>BWS</code>, and <code>obs-*</code> rules from the <code>addr-spec</code> in RFC 5322, and perform some optimization on the result (I used <a href="https://github.com/qntm/greenery" rel="nofollow noreferrer">"greenery"</a>), you can produce this regular expression, quoted with slashes and anchored (suitable for use in ECMAScript and compatible dialects, with added newline for clarity):</p>
     <pre class="lang-none prettyprint-override"><code>/^("(?:[!#-\[\]-~]|\\[\t -~])*"|[!#-'*+\-/-9=?A-Z\^-~](?:\.?[!#-'*+\-/-9=?A-Z\^-~])*)
@([!#-'*+\-/-9=?A-Z\^-~](?:\.?[!#-'*+\-/-9=?A-Z\^-~])*|\[[!-Z\^-~]*\])$/
</code></pre>
     <p>This only supports ASCII email addresses. To support <a href="https://www.rfc-editor.org/rfc/rfc6532#section-3.2" rel="nofollow noreferrer">RFC 6532 Internationalized Email Addresses</a>, replace the <code>~</code> character with <code>\u{10FFFF}</code> (PHP, ECMAScript with the <code>u</code> flag), or <code>\uFFFF</code> (for UTF-16 implementations, like <a href="https://en.wikipedia.org/wiki/.NET_Framework" rel="nofollow noreferrer">.NET</a> and older ECMAScript/JavaScript):</p>
     <pre class="lang-none prettyprint-override"><code>/^("(?:[!#-\[\]-\u{10FFFF}]|\\[\t -\u{10FFFF}])*"|[!#-'*+\-/-9=?A-Z\^-\u{10FFFF}](?:\.?[!#-'*+\-/-9=?A-Z\^-\u{10FFFF}])*)@([!#-'*+\-/-9=?A-Z\^-\u{10FFFF}](?:\.?[!#-'*+\-/-9=?A-Z\^-\u{10FFFF}])*|\[[!-Z\^-\u{10FFFF}]*\])$/u
</code></pre>
     <p>This works, because the ABNF we are using is not recursive, and so forms a non-recursive, regular grammar that can be converted into a regular expression.</p>
     <p>It breaks down like so:</p>
     <ul>
      <li>The user part (before the <code>@</code>) may be a dot-atom or a quoted-string</li>
      <li><code>"([!#-\[\]-~]|\\[\t -~])*"</code> specifies the quoted-string form of the user, e.g. <code>"root@home"@example.com</code>. It permits any non-control character inside double quotes; except that spaces, tabs, double quotes, and backslashes must be backslash-escaped.</li>
      <li><code>[!#-'*+\-/-9=?A-Z\^-~]</code> is the first character of the dot-atom of the user.</li>
      <li><code>(\.?[!#-'*+\-/-9=?A-Z\^-~])*</code> matches the rest of the dot-atom, allowing dots (except after another dot, or as the final character).</li>
      <li><code>@</code> denotes the domain.</li>
      <li>The domain part may be a dot-atom or a domain-literal.</li>
      <li><code>[!#-'*+\-/-9=?A-Z\^-~](\.?[!#-'*+\-/-9=?A-Z\^-~])*</code> is the same dot-atom form as above, but here it represents domain names and IPv4 addresses.</li>
      <li><code>\[[!-Z\^-~]*\]</code> will match IPv6 addresses and future definitions of host names.</li>
     </ul>
     <p>This regular expression allows all specification-compliant email addresses, and can be used verbatim in a MIME message (except for line length limits, in which case folding whitespace must be added).</p>
     <p>This also sets non-capturing groups such that <code>match[1]</code> will be the user, <code>match[2]</code> will be the host. (However if <code>match[1]</code> starts with a double quote, then filter out backslash escapes, and the start and end double quotes: <code>"root"@example.com</code> and <code>root@example.com</code> identify the same inbox.)</p>
     <p>Finally, note that <a href="https://www.rfc-editor.org/rfc/rfc5321#section-4.5.3.1" rel="nofollow noreferrer">RFC 5321</a> sets limits on how long an email address may be. The user part may be up to 64 bytes, and the domain part may be up to 255 bytes. Including the <code>@</code> character, the limit for the entire address is 320 bytes. This is measured in bytes after the address is UTF-8 encoded; not characters.</p>
     <p>Note that RFC 5322 ABNF defines a permissive syntax for domain names, allowing names currently known to be invalid. This also allows for domain names that could become legal in the future. This should not be a problem, as this should be handled the same way a non-existent domain name is.</p>
     <p>Always consider the possibility that a user typed in an email address that works, but that they do not have access to. <em>The only foolproof way to verify an email address is to send an email.</em></p>
     <p><sub>This is adapted from my article <em><a href="https://fullstack.wiki/mail/address" rel="nofollow noreferrer">E-Mail Addresses &amp; Syntax</a></em>.</sub></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>I can use this in javascript, but can't get it formatted for C# use. I've tried putting it into regex101 website and it says its invalid</span> <span> - </span> <span class="display-name">Post Impatica</span> <span> </span> <span class="date">12 May 2021 at 21:52</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@PostImpatica What is the error, exactly? Regex101 expects a regular expression that is slash-delimited. I don't know which dialect C# expects. If your dialect is slash-delimited, you'll need to escape the slashes with a backslash.</span> <span> - </span> <span class="display-name">awwright</span> <span> </span> <span class="date">17 May 2021 at 02:21</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span><code>"John Smith"@example.com</code> doesn't work with these on regexr.com</span> <span> - </span> <span class="display-name">Cees Timmerman</span> <span> </span> <span class="date">19 Nov 2022 at 00:32</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@CeesTimmerman Spaces must be escaped in the quoted form, see <a href="https://www.rfc-editor.org/rfc/rfc5322#section-3.2.4" rel="nofollow noreferrer">rfc-editor.org/rfc/rfc5322#section-3.2.4</a> This is mentioned in my post: "It permits any non-control character inside double quotes; except that spaces, tabs, double quotes, and backslashes must be backslash-escaped." Note that whitespace is not considered "printing" in ASCII, see the VCHAR production in <a href="https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1" rel="nofollow noreferrer">rfc-editor.org/rfc/rfc5234#appendix-B.1</a></span> <span> - </span> <span class="display-name">awwright</span> <span> </span> <span class="date">20 Nov 2022 at 02:13</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_34"><span>Answer 34</span> <span class="arrow"> <a href="#answer_33">↑</a> </span> <span class="arrow"> <a href="#answer_35">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Dimitris Andreou</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Aug 2009 at 16:19</span>
     </div>
    </div>
    <div>
     <p>I don't believe <a href="https://stackoverflow.com/questions/201323/how-can-i-validate-an-email-address-using-a-regular-expression/201378#201378">the claim made by bortzmeyer</a> that "The grammar (specified in <a href="https://en.wikipedia.org/wiki/Email#Message_format" rel="nofollow noreferrer">RFC&nbsp;5322</a>) is too complicated for that" (to be handled by a regular expression).</p>
     <p>Here is the grammar (from <em><a href="https://www.rfc-editor.org/rfc/rfc5322#section-3.4.1" rel="nofollow noreferrer">3.4.1. Addr-Spec Specification</a></em>):</p>
     <pre><code>addr-spec       =   local-part "@" domain
local-part      =   dot-atom / quoted-string / obs-local-part
domain          =   dot-atom / domain-literal / obs-domain
domain-literal  =   [CFWS] "[" *([FWS] dtext) [FWS] "]" [CFWS]
dtext           =   %d33-90 /          ; Printable US-ASCII
                    %d94-126 /         ;  characters not including
                    obs-dtext          ;  "[", "]", or "\"
</code></pre>
     <p>Assuming that dot-atom, quoted-string, obs-local-part, obs-domain are themselves regular languages, this is a very simple grammar. Just replace the local-part and domain in the addr-spec production with their respective productions, and you have a regular language, directly translatable to a regular expression.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>5</td>
        <td><span>You should investigate CFWS before you start making assumptions here. It's a nightmare.</span> <span> - </span> <span class="display-name">rjbs</span> <span> </span> <span class="date">16 Dec 2009 at 19:07</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>CFWS = (1*([FWS] comment) [FWS]) / FWS. Still, I see no rule that makes the language not regular. It's complicated, for sure, but a complicated regular expression could handle it nevertheless.</span> <span> - </span> <span class="display-name">Dimitris Andreou</span> <span> </span> <span class="date">3 Jan 2010 at 21:53</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>This doesn't answer the question. It's in response to another answer.</span> <span> - </span> <span class="display-name">Luna</span> <span> </span> <span class="date">5 Dec 2016 at 20:17</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>CFWS is not part of the email address, it's part of the MIME syntax. See my answer <a href="https://stackoverflow.com/a/63841473/7117939">stackoverflow.com/a/63841473/7117939</a> for why this is.</span> <span> - </span> <span class="display-name">awwright</span> <span> </span> <span class="date">12 Sep 2020 at 23:38</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_35"><span>Answer 35</span> <span class="arrow"> <a href="#answer_34">↑</a> </span> <span class="arrow"> <a href="#answer_36">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>auco</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Dec 2013 at 16:03</span>
     </div>
    </div>
    <div>
     <p>I know this question is about regular expressions, but I am guessing that 90% of all developers reading these solutions are trying to validate an email address in an HTML form displayed in a browser.</p>
     <p>If this is the case, I'd suggest checking out the new HTML5 <code>&lt;input type="email"&gt;</code> form element:</p>
     <p>HTML5:</p>
     <pre><code> &lt;input type="email" required /&gt;
</code></pre>
     <p>CSS 3:</p>
     <pre><code> input:required {
      background-color: rgba(255, 0, 0, 0.2);
 }

 input:focus:invalid {
     box-shadow: 0 0 1em red;
     border-color: red;
 }

 input:focus:valid {
     box-shadow: 0 0 1em green;
     border-color: green;
 }
</code></pre>
     <p>It is at <em><a href="http://jsfiddle.net/mYRe7/1/" rel="nofollow noreferrer">HTML5 Form Validation Without JS - JSFiddle - Code Playground</a></em>.</p>
     <p>This has a couple of advantages:</p>
     <ol>
      <li>Automatic validation and no custom solution needed: simple and easy to implement</li>
      <li>No JavaScript, and no problems if JavaScript has been disabled</li>
      <li>No server has to calculate anything for that</li>
      <li>The user has immediate feedback</li>
      <li>Old browsers should automatically fallback to input type "text"</li>
      <li>Mobile browsers can display a specialized keyboard (@-Keyboard)</li>
      <li>Form validation feedback is very easy with CSS 3</li>
     </ol>
     <p>The apparent downside might be missing validation for old browsers, but that'll change over time. I'd prefer this over any of these insane regular expression masterpieces.</p>
     <p>Also see:</p>
     <ul>
      <li><em><a href="http://jsfiddle.net/mYRe7/1/" rel="nofollow noreferrer">HTML5 Form Validation Without JS - JSFiddle - Code Playground</a></em></li>
      <li><em><a href="http://diveintohtml5.info/forms.html" rel="nofollow noreferrer">Web Forms - Dive Into HTML5. A Form of Madness</a></em></li>
      <li><em><a href="http://blog.mozilla.org/webdev/2011/03/14/html5-form-validation-on-sumo/" rel="nofollow noreferrer">HTML5 Form Validation on SUMO</a></em></li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>The other down side is that this is client-side only. Good for providing a smooth user experience, bad for validating data.</span> <span> - </span> <span class="display-name">acrosman</span> <span> </span> <span class="date">21 Jan 2014 at 21:44</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The problem with the default email validation is that it has <a href="http://jsbin.com/wizop/1/" rel="nofollow noreferrer">lots of false positives</a>. You'd need to use <a href="http://stackoverflow.com/a/24092435/1256925">my complete pattern</a> to eliminate all false positives while preventing false negatives from sneaking in. That pattern can be added <a href="http://jsbin.com/wizop/2/" rel="nofollow noreferrer">via the <code>pattern</code> attribute</a>. See <a href="http://stackoverflow.com/a/24092435/1256925">my post</a> for more info.</span> <span> - </span> <span class="display-name">Joeytje50</span> <span> </span> <span class="date">7 Jun 2014 at 01:51</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_36"><span>Answer 36</span> <span class="arrow"> <a href="#answer_35">↑</a> </span> <span class="arrow"> <a href="#answer_37">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Coder12345</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Feb 2014 at 19:13</span>
     </div>
    </div>
    <div>
     <p>I use multi-step validation. As there isn't any perfect way to validate an email address, a perfect one can't be made, but at least you can notify the user he/she is doing something wrong - here is my approach:</p>
     <ol>
      <li>
       <p>I first validate with the very basic regex which just checks if the email contains exactly one @ sign and it is not blank before or after that sign. e.g. <code>/^[^@\s]+@[^@\s]+$/</code></p></li>
      <li>
       <p>if the first validator does not pass (and for most addresses it should although it is not perfect), then warn the user the email is invalid and do not allow him/her to continue with the input</p></li>
      <li>
       <p>if it passes, then validate against a more strict regex - something which might disallow valid emails. If it does not pass, the user is warned about a possible error, but the user is allowed to continue. Unlike step (1) where the user is not allowed to continue because it is an obvious error.</p></li>
     </ol>
     <p>So in other words, the first liberal validation is just to strip obvious errors and it is treated as "error". People type a blank address, address without @ sign and so on. This should be treated as an error. The second one is more strict, but it is treated as a "warning" and the user is allowed to continue with the input, but warned to at least examine if he/she entered a valid entry. The key here is in the error/warning approach - the error being something that can't under 99.99% circumstances be a valid email.</p>
     <p>Of course, you can adjust what makes the first regex more liberal and the second one more strict.</p>
     <p>Depending on what you need, the above approach might work for you.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Technically, email can contain more than 1 @. It's an astonishing weird discovery i made recently. EG: "very.(),:;&lt;&gt;[]\".VERY.\"very@\\ \"very\".unusual"@strange.example.com</span> <span> - </span> <span class="display-name">Allan Deamon</span> <span> </span> <span class="date">18 Apr 2022 at 18:57</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Agreed, but I never claimed my method is 100% foolproof. It works in most cases. You gotta be realistic at some point and discard very unlikely cases. Most email addresses are something@something.something. If someone actually chooses to use an email address which is uses the most liberal syntax of all, he/she is in for a real treat of issues with various server/client programs not properly validating or allowing such email, or simply not working at all while sending/receiving. Where then such a user would be forced to use more "standard" syntax to ensure it works everywhere.</span> <span> - </span> <span class="display-name">Coder12345</span> <span> </span> <span class="date">18 Apr 2022 at 23:16</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_37"><span>Answer 37</span> <span class="arrow"> <a href="#answer_36">↑</a> </span> <span class="arrow"> <a href="#answer_38">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>grosser</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Aug 2011 at 10:26</span>
     </div>
    </div>
    <div>
     <p>This rule matches what our <a href="https://en.wikipedia.org/wiki/Postfix_(software)" rel="nofollow noreferrer">Postfix</a> server could not send to.</p>
     <p>Allow letters, numbers, -, _, +, ., &amp;, /, and !</p>
     <p>No -foo@bar.com</p>
     <p>No asd@-bar.com</p>
     <pre><code>/^([a-z0-9\+\._\/&amp;!][-a-z0-9\+\._\/&amp;!]*)@(([a-z0-9][-a-z0-9]*\.)([-a-z0-9]+\.)*[a-z]{2,})$/i
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_38"><span>Answer 38</span> <span class="arrow"> <a href="#answer_37">↑</a> </span> <span class="arrow"> <a href="#answer_39">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>FlameStorm</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 Dec 2016 at 20:12</span>
     </div>
    </div>
    <div>
     <p>For me the right way for checking email addresses is:</p>
     <ol>
      <li>Check that symbol @ exists, and before and after it there are some non-@ symbols: <code> /^[^@]+@[^@]+$/</code></li>
      <li>Try to send an email to this address with some "activation code".</li>
      <li>When the user "activated" his/her email address, we will see that all is right.</li>
     </ol>
     <p>Of course, you can show some warning or tooltip in front-end when the user typed a "strange" email to help him/her to avoid common mistakes, like no dot in the domain part or spaces in name without quoting and so on. But you must accept the address "hello@world" if user really want it.</p>
     <p>Also, you must remember that the email address standard was and can evolve, so you can't just type some "standard-valid" regexp once and for all times. And you must remember that some concrete internet servers can fail some details of common standard and in fact work with own "modified standard".</p>
     <p>So, just check @, hint user on frontend and send verification emails on the given address.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_39"><span>Answer 39</span> <span class="arrow"> <a href="#answer_38">↑</a> </span> <span class="arrow"> <a href="#answer_40">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>cbp</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Nov 2008 at 04:56</span>
     </div>
    </div>
    <div>
     <p>We have used <a href="http://www.aspnetmx.com/" rel="nofollow noreferrer">http://www.aspnetmx.com/</a> with a degree of success for a few years now. You can choose the level you want to validate at (e.g. syntax check, check for the domain, <a href="https://en.wikipedia.org/wiki/MX_record" rel="nofollow noreferrer">MX records</a> or the actual email).</p>
     <p>For front-end forms we generally verify that the domain exists and the syntax is correct, and then we do stricter verification to clean out our database before doing bulk mail-outs.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>The link is broken (it times out) - <i>"Unable to connect. An error occurred during a connection to www.aspnetmx.com."</i></span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">13 Feb 2022 at 14:53</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This was originally answered in the year 2008. :-) Where has the time gone....</span> <span> - </span> <span class="display-name">cbp</span> <span> </span> <span class="date">14 Feb 2022 at 07:03</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_40"><span>Answer 40</span> <span class="arrow"> <a href="#answer_39">↑</a> </span> <span class="arrow"> <a href="#answer_41">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Nazmul Hasan</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Jul 2009 at 10:29</span>
     </div>
    </div>
    <div>
     <p>This is one of the regexes for email:</p>
     <pre><code>^((([a-z]|\d|[!#\$%&amp;'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&amp;'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>It looks like line noise. Do you have an explanation and/or reference for it?</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">13 Feb 2022 at 15:06</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_41"><span>Answer 41</span> <span class="arrow"> <a href="#answer_40">↑</a> </span> <span class="arrow"> <a href="#answer_42">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Jay Zeng</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Dec 2009 at 00:37</span>
     </div>
    </div>
    <div>
     <p>No one mentioned the issue of localization (<a href="https://en.wikipedia.org/wiki/Internationalization_and_localization" rel="nofollow noreferrer">i18n</a>). What if you have clients coming from all over the world?</p>
     <p>You will need to then need to sub-categorize your regex per country/area, which I have seen developers ending up building a large dictionary or configuration. Detecting the users' browser language setting may be a good starting point.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_42"><span>Answer 42</span> <span class="arrow"> <a href="#answer_41">↑</a> </span> <span class="arrow"> <a href="#answer_43">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Suhaib Janjua</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Feb 2014 at 06:38</span>
     </div>
    </div>
    <div>
     <p>I always use the below regular expression to validate the email address. It covers all formats of email addresses based on English language characters.</p>
     <pre><code>"\A(?:[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?)\Z";
</code></pre>
     <p><strong>Given below is a C# example:</strong></p>
     <p>Add the assembly reference:</p>
     <pre><code>using System.Text.RegularExpressions;
</code></pre>
     <p>and use the below method to pass the email address and get a boolean in return</p>
     <pre><code>private bool IsValidEmail(string email) {
    bool isValid = false;
    const string pattern = @"\A(?:[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?)\Z";

    isValid = email != "" &amp;&amp; Regex.IsMatch(email, pattern);

    // Same above approach in multiple lines
    //
    //if (!email) {
    //    isValid = false;
    //} else {
    //    // email param contains a value; Pass it to the isMatch method
    //    isValid = Regex.IsMatch(email, pattern);
    //}
    return isValid;
}
</code></pre>
     <p>This method validates the email string passed in the parameter. It will return false for all cases where param is null, empty string, undefined or the param value is not a valid email address. It will only return true when the param contains a valid email address string.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>Does this code accept "Håkan.Söderström@malmö.se" or "试@例子.测试.مثال.آزمایشی" emails?</span> <span> - </span> <span class="display-name">Ivan Z</span> <span> </span> <span class="date">27 Mar 2014 at 23:07</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>It's for standard Email Servers with standard characters. In case of non English language one should have to make its own customized ReGex.</span> <span> - </span> <span class="display-name">Suhaib Janjua</span> <span> </span> <span class="date">28 Mar 2014 at 05:55</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Regex and email spec includes UTF-8, hence illogical response.</span> <span> - </span> <span class="display-name">rob2d</span> <span> </span> <span class="date">30 Nov 2019 at 03:05</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>In what way is it the best regular expression? Most comprehensive? Simplest? Fewest false negatives? Fewest false positives? The fastest? Fewest number of user complaints in actual real-world use? Some combination of these properties? Something else? Please respond by <a href="https://stackoverflow.com/posts/21595782/edit">editing (changing) your answer</a>, not here in comments (<b><i>without</i></b> "Edit:", "Update:", or similar - the answer should appear as if it was written today).</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">14 Feb 2022 at 21:05</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_43"><span>Answer 43</span> <span class="arrow"> <a href="#answer_42">↑</a> </span> <span class="arrow"> <a href="#answer_44">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ondřej Šotek</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Jul 2015 at 22:25</span>
     </div>
    </div>
    <div>
     <p>For PHP I'm using <a href="http://api.nette.org/2.3.3/source-Utils.Validators.php.html#234-247" rel="nofollow noreferrer">the email address validator from the Nette Framework</a>:</p>
     <pre class="lang-php prettyprint-override"><code>/* public static */ function isEmail($value)
{
    $atom = "[-a-z0-9!#$%&amp;'*+/=?^_`{|}~]"; // RFC 5322 unquoted characters in local-part
    $localPart = "(?:\"(?:[ !\\x23-\\x5B\\x5D-\\x7E]*|\\\\[ -~])+\"|$atom+(?:\\.$atom+)*)"; // Quoted or unquoted
    $alpha = "a-z\x80-\xFF"; // Superset of IDN
    $domain = "[0-9$alpha](?:[-0-9$alpha]{0,61}[0-9$alpha])?"; // RFC 1034 one domain component
    $topDomain = "[$alpha](?:[-0-9$alpha]{0,17}[$alpha])?";
    return (bool) preg_match("(^$localPart@(?:$domain\\.)+$topDomain\\z)i", $value);
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_44"><span>Answer 44</span> <span class="arrow"> <a href="#answer_43">↑</a> </span> <span class="arrow"> <a href="#answer_45">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Simon_Weaver</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Feb 2017 at 00:52</span>
     </div>
    </div>
    <div>
     <p>Just about every regular expression I've seen - including some used by Microsoft will not allow the following <em>valid</em> email to get through: <code>simon-@hotmail.com</code></p>
     <p>I just had a real customer with an email address in this format who couldn't place an order.</p>
     <p>Here's what I settled on:</p>
     <ul>
      <li>A minimal regular expression that won't have false negatives. Alternatively use the <code>MailAddress</code> constructor with some additional checks (see below):</li>
      <li>Checking for common typos <code>.cmo</code> or <code>.gmial.com</code> and asking for confirmation <em>"Are you sure this is your correct email address. It looks like there may be a mistake."</em> Allow the user to accept what they typed if they are sure.</li>
      <li>Handling bounces when the email is actually sent and manually verifying them to check for obvious mistakes.</li>
     </ul>
     <hr>
     <pre><code>try
{
    var email = new MailAddress(str);

    if (email.Host.EndsWith(".cmo"))
    {
        return EmailValidation.PossibleTypo;
    }

    if (!email.Host.EndsWith(".") &amp;&amp; email.Host.Contains("."))
    {
        return EmailValidation.OK;
    }
}
catch
{
    return EmailValidation.Invalid;
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>This answer is misleading and unrelated to question. Allowing users to enter wrong email is a business decision, question is about validating it with regex.</span> <span> - </span> <span class="display-name">Kerem Demirer</span> <span> </span> <span class="date">23 Mar 2017 at 21:36</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>The first answer to this post does pass simon-@hotmail.com just fine.</span> <span> - </span> <span class="display-name">Michael Sims</span> <span> </span> <span class="date">3 Jun 2021 at 05:33</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>What programming language? <a href="https://en.wikipedia.org/wiki/C_Sharp_%28programming_language%29" rel="nofollow noreferrer">C#</a>? <a href="https://en.wikipedia.org/wiki/Java_%28programming_language%29" rel="nofollow noreferrer">Java</a>? Something else?</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">14 Feb 2022 at 23:37</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The <code>.gmial.com</code> example is not in the example code.</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">14 Feb 2022 at 23:39</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I have <a href="https://pmortensen.eu/EditOverflow/_Wordlist/EditOverflowList_latest.html#Gmail" rel="nofollow noreferrer">never ever seen</a> "Gmail" misspelled as "Gmial".</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">14 Feb 2022 at 23:45</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_45"><span>Answer 45</span> <span class="arrow"> <a href="#answer_44">↑</a> </span> <span class="arrow"> <a href="#answer_46">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Dave Black</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 Jul 2018 at 20:27</span>
     </div>
    </div>
    <div>
     <p>According to <a href="http://tools.ietf.org/html/2821" rel="nofollow noreferrer">RFC 2821</a> and <a href="http://tools.ietf.org/html/2822" rel="nofollow noreferrer">RFC 2822</a>, the local-part of an email addresses may use any of these ASCII characters:</p>
     <ol>
      <li>Uppercase and lowercase letters</li>
      <li>The digits 0 through 9</li>
      <li>The characters, !#$%&amp;'*+-/=?^_`{|}~</li>
      <li>The character "." provided that it is not the first or last character in the local-part.</li>
     </ol>
     <p>Matches:</p>
     <ul>
      <li>a&amp;d@somedomain.com</li>
      <li>a*d@somedomain.com</li>
      <li>a/d@somedomain.com</li>
     </ul>
     <p>Non-Matches:</p>
     <ul>
      <li>.abc@somedomain.com</li>
      <li>abc.@somedomain.com</li>
      <li>a&gt;b@somedomain.com</li>
     </ul>
     <p>For one that is RFC 2821 and 2822 compliant, you can use:</p>
     <pre class="lang-none prettyprint-override"><code>^((([!#$%&amp;'*+\-/=?^_`{|}~\w])|([!#$%&amp;'*+\-/=?^_`{|}~\w][!#$%&amp;'*+\-/=?^_`{|}~\.\w]{0,}[!#$%&amp;'*+\-/=?^_`{|}~\w]))[@]\w+([-.]\w+)*\.\w+([-.]\w+)*)$
</code></pre>
     <p><a href="http://regexlib.com/REDetails.aspx?regexp_id=2558" rel="nofollow noreferrer">Email - RFC 2821, 2822 Compliant</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Why doesn't it work on Håkan.Söderström@malmö.se ?</span> <span> - </span> <span class="display-name">Cees Timmerman</span> <span> </span> <span class="date">19 Nov 2022 at 00:17</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_46"><span>Answer 46</span> <span class="arrow"> <a href="#answer_45">↑</a> </span> <span class="arrow"> <a href="#answer_47">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Asad Ali Choudhry</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Nov 2019 at 07:10</span>
     </div>
    </div>
    <div>
     <p>Although very detailed answers are already added, I think those are complex enough for a developer who is just looking for a simple method to validate an email address or to get all email addresses from a string in Java.</p>
     <pre><code>public static boolean isEmailValid(@NonNull String email) {
    return android.util.Patterns.EMAIL_ADDRESS.matcher(email).matches();
}
</code></pre>
     <p>As per the regular expression is concerned, I always use this regular expression, which works for my problems.</p>
     <pre class="lang-none prettyprint-override"><code>"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}"
</code></pre>
     <p>If you are looking to find all email addresses from a string by matching the email regular expression. You can find a method at <a href="https://handyopinion.com/utility-method-to-get-all-email-addresses-from-a-string-in-java/" rel="nofollow noreferrer">this link</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Re <i>"which works for my problems."</i>: What would those problems be? What are some examples of false positives and false negatives? How do you handle those?</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">15 Feb 2022 at 00:12</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>What programming language? <a href="https://en.wikipedia.org/wiki/Java_%28programming_language%29" rel="nofollow noreferrer">Java</a>? This was comment number 2 and question number 2.</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">15 Feb 2022 at 00:14</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_47"><span>Answer 47</span> <span class="arrow"> <a href="#answer_46">↑</a> </span> <span class="arrow"> <a href="#answer_48">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Dr. Hans-Peter Störr</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Nov 2011 at 18:32</span>
     </div>
    </div>
    <div>
     <p>I would not suggest to use an regex at all - email addresses are way too complicated for that. This is a common problem so I would guess there are many libraries that contain a validator - if you use Java the <a href="http://commons.apache.org/validator/apidocs/org/apache/commons/validator/EmailValidator.html" rel="nofollow">EmailValidator</a> of <a href="http://commons.apache.org/validator/" rel="nofollow">apache commons validator</a> is a good one.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_48"><span>Answer 48</span> <span class="arrow"> <a href="#answer_47">↑</a> </span> <span class="arrow"> <a href="#answer_49">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>FLY</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Jan 2013 at 15:09</span>
     </div>
    </div>
    <div>
     <p>Here is the one I've build. It is not a bulletproof version, but it is 'simple' and checks almost everything.</p>
     <pre class="lang-none prettyprint-override"><code>[\w+-]+(?:\.[\w+-]+)*@[\w+-]+(?:\.[\w+-]+)*(?:\.[a-zA-Z]{2,4})
</code></pre>
     <p>I think an explanation is in place so you can modify it if you want:</p>
     <p>(<strong>e</strong>) <code>[\w+-]+</code> matches a-z, A-Z, _, +, - at least one time</p>
     <p>(<strong>m</strong>) <code>(?:\.[\w+-]+)*</code> matches a-z, A-Z, _, +, - zero or more times but need to start with a . (dot)</p>
     <p><code>@</code> = <code>@</code></p>
     <p>(<strong>i</strong>) <code>[\w+-]+</code> matches a-z, A-Z, _, +, - at least one time</p>
     <p>(<strong>l</strong>) <code>(?:\.[\w+-]+)*</code> matches a-z, A-Z, _, +, - zero or more times but need to start with a . (dot)</p>
     <p>(<strong>com</strong>) <code>(?:\.[a-zA-Z]{2,4})</code> matches a-z, A-Z for 2 to 4 times starting with a . (dot)</p>
     <p>giving <code>e(.m)@i(.l).com</code> where <code>(.m)</code> and <code>(.l)</code> are optional but also can be repeated multiple times.</p>
     <p>I think this validates all valid email addresses, but blocks potential invalid without using an overcomplex regular expression which won't be necessary in most cases.</p>
     <p>Notice this will allow <code>+@-.com</code>, but that is the compromise for keeping it simple.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Thanks! This worked for me. Here is a tested C/C++ escaped version used with Qt5: QRegExp rx("[\\w+-]+(?:\\.[\\w+-]+)*@[\\w+-]+(?:\\.[\\w+-]+)*(?:\\.[‌​a-zA-Z]{2,})");</span> <span> - </span> <span class="display-name">Mr. Developerdude</span> <span> </span> <span class="date">17 Jun 2013 at 13:15</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_49"><span>Answer 49</span> <span class="arrow"> <a href="#answer_48">↑</a> </span> <span class="arrow"> <a href="#answer_50">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>mirabilos</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Dec 2013 at 23:58</span>
     </div>
    </div>
    <div>
     <p>I’ve had a similar desire: wanting a quick check for syntax in email addresses without going overboard (the <code>Mail::RFC822::Address</code> answer which is the obviously correct one) for <a href="https://www.mirbsd.org/cvs.cgi/contrib/hosted/tg/mailfrom.php?rev=HEAD" rel="nofollow noreferrer">an email send utility</a>. I went with this (I’m a <a href="https://en.wikipedia.org/wiki/POSIX" rel="nofollow noreferrer">POSIX</a> regular expression person, so I don’t normally use <code>\d</code> and such from <a href="https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions" rel="nofollow noreferrer">PCRE</a>, as they make things less legible to me):</p>
     <pre class="lang-php prettyprint-override"><code>preg_match("_^[-!#-'*+/-9=?A-Z^-~]+(\.[-!#-'*+/-9=?A-Z^-~]+)*@[0-9A-Za-z]([-0-9A-Za-z]{0,61}[0-9A-Za-z])?(\.[0-9A-Za-z]([-0-9A-Za-z]{0,61}[0-9A-Za-z])?)*\$_", $adr)
</code></pre>
     <p>This is RFC-correct, but it explicitly excludes the obsolete forms as well as direct IP addresses (IP addresses and legacy IP addresses both), which someone in the target group of that utility (mostly: people who bother us in #sendmail on <a href="https://en.wikipedia.org/wiki/Internet_Relay_Chat" rel="nofollow noreferrer">IRC</a>) would not normally want or need anyway.</p>
     <p><a href="https://en.wikipedia.org/wiki/Internationalized_domain_name" rel="nofollow noreferrer">IDNs</a> (internationalised domain names) are explicitly <em>not</em> in the scope of email: addresses like “foo@cäcilienchor-bonn.de” <em>must</em> be written “foo@xn--ccilienchor-bonn-vnb.de” on the wire instead (this includes <em>mailto:</em> links in HTML and such fun), only the GUI is allowed to display (and accept then convert) such names to (and from) the user.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Re <i>"legacy IP addresses"</i>: Do you mean <i><a href="https://en.wikipedia.org/wiki/IPv4" rel="nofollow noreferrer">IPv4</a> IP addresses</i>?</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">13 Feb 2022 at 18:14</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@PeterMortensen: (thanks for the syntax highlighting and English fixes, but something seems to be broken now, it says community wiki with you as author?) yes, legacy IP addresses is what IPv4 addresses have been called for a couple of years now, IP addresses are IPv6 addresses.</span> <span> - </span> <span class="display-name">mirabilos</span> <span> </span> <span class="date">14 Feb 2022 at 14:46</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_50"><span>Answer 50</span> <span class="arrow"> <a href="#answer_49">↑</a> </span> <span class="arrow"> <a href="#answer_51">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Alexey Ossikine</span>
     </div>
     <div>
      <span> Answered: </span> <span>19 Jul 2014 at 03:30</span>
     </div>
    </div>
    <div>
     <p>If you want to improve on a regex that has been working reasonably well over several years, then the answer depends on what exactly you want to achieve - what kinds of email addresses have been failing. Fine-tuning email regexes is very difficult, and I have yet to see a perfect solution.</p>
     <ul>
      <li>If your application involves something very technical in nature (or something internal to organizations), then maybe you need to support IP addresses instead of domain names, or comments in the "local" part of the email address.</li>
      <li>If your application is multinational, I would consider focusing on <a href="https://en.wikipedia.org/wiki/Unicode" rel="nofollow noreferrer">Unicode</a> and <a href="https://en.wikipedia.org/wiki/UTF-8" rel="nofollow noreferrer">UTF-8</a> support.</li>
     </ul>
     <p>The leading answer to your question currently links to a "fully RFC‑822–compliant regex". However, in spite of the complexity of that regex and its presumed attention to detail in RFC rules, it completely fails when it comes to Unicode support.</p>
     <p>The regex that I've written for most of my applications focuses on Unicode support, as well as <em>reasonably</em> good overall adherence to RFC standards:</p>
     <pre><code>/^(?!\.)((?!.*\.{2})[a-zA-Z0-9\u0080-\u00FF\u0100-\u017F\u0180-\u024F\u0250-\u02AF\u0300-\u036F\u0370-\u03FF\u0400-\u04FF\u0500-\u052F\u0530-\u058F\u0590-\u05FF\u0600-\u06FF\u0700-\u074F\u0750-\u077F\u0780-\u07BF\u07C0-\u07FF\u0900-\u097F\u0980-\u09FF\u0A00-\u0A7F\u0A80-\u0AFF\u0B00-\u0B7F\u0B80-\u0BFF\u0C00-\u0C7F\u0C80-\u0CFF\u0D00-\u0D7F\u0D80-\u0DFF\u0E00-\u0E7F\u0E80-\u0EFF\u0F00-\u0FFF\u1000-\u109F\u10A0-\u10FF\u1100-\u11FF\u1200-\u137F\u1380-\u139F\u13A0-\u13FF\u1400-\u167F\u1680-\u169F\u16A0-\u16FF\u1700-\u171F\u1720-\u173F\u1740-\u175F\u1760-\u177F\u1780-\u17FF\u1800-\u18AF\u1900-\u194F\u1950-\u197F\u1980-\u19DF\u19E0-\u19FF\u1A00-\u1A1F\u1B00-\u1B7F\u1D00-\u1D7F\u1D80-\u1DBF\u1DC0-\u1DFF\u1E00-\u1EFF\u1F00-\u1FFFu20D0-\u20FF\u2100-\u214F\u2C00-\u2C5F\u2C60-\u2C7F\u2C80-\u2CFF\u2D00-\u2D2F\u2D30-\u2D7F\u2D80-\u2DDF\u2F00-\u2FDF\u2FF0-\u2FFF\u3040-\u309F\u30A0-\u30FF\u3100-\u312F\u3130-\u318F\u3190-\u319F\u31C0-\u31EF\u31F0-\u31FF\u3200-\u32FF\u3300-\u33FF\u3400-\u4DBF\u4DC0-\u4DFF\u4E00-\u9FFF\uA000-\uA48F\uA490-\uA4CF\uA700-\uA71F\uA800-\uA82F\uA840-\uA87F\uAC00-\uD7AF\uF900-\uFAFF\.!#$%&amp;'*+-/=?^_`{|}~\-\d]+)@(?!\.)([a-zA-Z0-9\u0080-\u00FF\u0100-\u017F\u0180-\u024F\u0250-\u02AF\u0300-\u036F\u0370-\u03FF\u0400-\u04FF\u0500-\u052F\u0530-\u058F\u0590-\u05FF\u0600-\u06FF\u0700-\u074F\u0750-\u077F\u0780-\u07BF\u07C0-\u07FF\u0900-\u097F\u0980-\u09FF\u0A00-\u0A7F\u0A80-\u0AFF\u0B00-\u0B7F\u0B80-\u0BFF\u0C00-\u0C7F\u0C80-\u0CFF\u0D00-\u0D7F\u0D80-\u0DFF\u0E00-\u0E7F\u0E80-\u0EFF\u0F00-\u0FFF\u1000-\u109F\u10A0-\u10FF\u1100-\u11FF\u1200-\u137F\u1380-\u139F\u13A0-\u13FF\u1400-\u167F\u1680-\u169F\u16A0-\u16FF\u1700-\u171F\u1720-\u173F\u1740-\u175F\u1760-\u177F\u1780-\u17FF\u1800-\u18AF\u1900-\u194F\u1950-\u197F\u1980-\u19DF\u19E0-\u19FF\u1A00-\u1A1F\u1B00-\u1B7F\u1D00-\u1D7F\u1D80-\u1DBF\u1DC0-\u1DFF\u1E00-\u1EFF\u1F00-\u1FFF\u20D0-\u20FF\u2100-\u214F\u2C00-\u2C5F\u2C60-\u2C7F\u2C80-\u2CFF\u2D00-\u2D2F\u2D30-\u2D7F\u2D80-\u2DDF\u2F00-\u2FDF\u2FF0-\u2FFF\u3040-\u309F\u30A0-\u30FF\u3100-\u312F\u3130-\u318F\u3190-\u319F\u31C0-\u31EF\u31F0-\u31FF\u3200-\u32FF\u3300-\u33FF\u3400-\u4DBF\u4DC0-\u4DFF\u4E00-\u9FFF\uA000-\uA48F\uA490-\uA4CF\uA700-\uA71F\uA800-\uA82F\uA840-\uA87F\uAC00-\uD7AF\uF900-\uFAFF\-\.\d]+)((\.([a-zA-Z\u0080-\u00FF\u0100-\u017F\u0180-\u024F\u0250-\u02AF\u0300-\u036F\u0370-\u03FF\u0400-\u04FF\u0500-\u052F\u0530-\u058F\u0590-\u05FF\u0600-\u06FF\u0700-\u074F\u0750-\u077F\u0780-\u07BF\u07C0-\u07FF\u0900-\u097F\u0980-\u09FF\u0A00-\u0A7F\u0A80-\u0AFF\u0B00-\u0B7F\u0B80-\u0BFF\u0C00-\u0C7F\u0C80-\u0CFF\u0D00-\u0D7F\u0D80-\u0DFF\u0E00-\u0E7F\u0E80-\u0EFF\u0F00-\u0FFF\u1000-\u109F\u10A0-\u10FF\u1100-\u11FF\u1200-\u137F\u1380-\u139F\u13A0-\u13FF\u1400-\u167F\u1680-\u169F\u16A0-\u16FF\u1700-\u171F\u1720-\u173F\u1740-\u175F\u1760-\u177F\u1780-\u17FF\u1800-\u18AF\u1900-\u194F\u1950-\u197F\u1980-\u19DF\u19E0-\u19FF\u1A00-\u1A1F\u1B00-\u1B7F\u1D00-\u1D7F\u1D80-\u1DBF\u1DC0-\u1DFF\u1E00-\u1EFF\u1F00-\u1FFF\u20D0-\u20FF\u2100-\u214F\u2C00-\u2C5F\u2C60-\u2C7F\u2C80-\u2CFF\u2D00-\u2D2F\u2D30-\u2D7F\u2D80-\u2DDF\u2F00-\u2FDF\u2FF0-\u2FFF\u3040-\u309F\u30A0-\u30FF\u3100-\u312F\u3130-\u318F\u3190-\u319F\u31C0-\u31EF\u31F0-\u31FF\u3200-\u32FF\u3300-\u33FF\u3400-\u4DBF\u4DC0-\u4DFF\u4E00-\u9FFF\uA000-\uA48F\uA490-\uA4CF\uA700-\uA71F\uA800-\uA82F\uA840-\uA87F\uAC00-\uD7AF\uF900-\uFAFF]){2,63})+)$/i
</code></pre>
     <p>I'll avoid copy-pasting complete answers, so I'll just link this to a similar answer I provided here: <em><a href="https://stackoverflow.com/questions/19461943/how-to-validate-a-unicode-email/24817336#24817336">How to validate a unicode email?</a></em></p>
     <p>There is also a live demo available for the regex above at: <a href="http://jsfiddle.net/aossikine/qCLVH/3/" rel="nofollow noreferrer">http://jsfiddle.net/aossikine/qCLVH/3/</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_51"><span>Answer 51</span> <span class="arrow"> <a href="#answer_50">↑</a> </span> <span class="arrow"> <a href="#answer_52">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>McGaz</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Aug 2014 at 10:46</span>
     </div>
    </div>
    <div>
     <p>The regular expressions posted for this question are out of date now, because of the new generic <a href="https://en.wikipedia.org/wiki/Top-level_domain" rel="nofollow noreferrer">top-level domains</a> (gTLDs) coming in (e.g. .london, .basketball, .通販). To validate an email address there are two answers (that would be relevant to the vast majority).</p>
     <ol>
      <li>As the main answer says - don't use a regular expression. Just validate it by sending an email to the address (catch exceptions for invalid addresses)</li>
      <li>Use a very generic regex to at least make sure that they are using an email structure like <code>{something}@{something}.{something}</code>. There's no point in going for a detailed regex, because you won't catch them all and there'll be a new batch in a few years and you'll have to update your regular expression again.</li>
     </ol>
     <p>I have decided to use the regular expression because, unfortunately, some users don't read forms and put the wrong data in the wrong fields. This will at least alert them when they try to put something which isn't an email into the email input field and should save you some time supporting users on email issues.</p>
     <pre><code>(.+)@(.+){2,}\.(.+){2,}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>What is the difference between a gTLD and a <a href="https://en.wikipedia.org/wiki/Top-level_domain" rel="nofollow noreferrer">TLD</a>?</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">14 Feb 2022 at 21:59</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>They're all the same really, but just categorised differently. There are mainly Country Code TLDS (ccTLD), like .co.uk or .fr. These are assigned to each country and contribute as a factor for search engines understand the location/target audience. Sponsored TLDS (sTLD) are assigned to organisations or governments, e.g. .gov The generics (gTLD) cover the extensions which are generic, e.g. .com, .london, .mail, etc. There are some restrictions on which ones you can use, prices can be very different, but Google also says it doesn't matter too much whether you're on a .com or a .whatever.</span> <span> - </span> <span class="display-name">McGaz</span> <span> </span> <span class="date">16 Feb 2022 at 11:26</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_52"><span>Answer 52</span> <span class="arrow"> <a href="#answer_51">↑</a> </span> <span class="arrow"> <a href="#answer_53">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Prasad Bhosale</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Nov 2014 at 11:14</span>
     </div>
    </div>
    <div>
     <p>Following is the regular expression for validating an email address:</p>
     <pre class="lang-none prettyprint-override"><code>^.+@\w+(\.\w+)+$
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Given all the previous answers, such a simple regular expression requires an explanation (e.g., why weren't the huge complexity in the previous answers necessary?). What are its properties? What does it fail for? What are some examples that it does work for? What are some examples that it doesn't work for? Please respond by <a href="https://stackoverflow.com/posts/26800017/edit">editing (changing) your answer</a>, not here in comments (<b><i>without</i></b> "Edit:", "Update:", or similar - the answer should appear as if it was written today).</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">14 Feb 2022 at 22:55</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_53"><span>Answer 53</span> <span class="arrow"> <a href="#answer_52">↑</a> </span> <span class="arrow"> <a href="#answer_54">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>alejandro juarez</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 Feb 2021 at 15:21</span>
     </div>
    </div>
    <div>
     <p>If you need a simple form to validate, you can use the answer of <a href="https://regexr.com/3e48o" rel="nofollow noreferrer">https://regexr.com/3e48o</a></p>
     <pre class="lang-none prettyprint-override"><code>^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$
</code></pre>
     <p></p>
     <div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
      <div class="snippet-code snippet-currently-hidden">
       <pre class="snippet-code-js lang-js prettyprint-override"><code>let r = new RegExp(String.raw `^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$`);

//should be true
console.log(r.test('name@domain.tld'));
console.log(r.test('name@domain.co.tld'));
console.log(r.test('name@domain.co'));

//should be false
console.log(r.test('@domain.tld'));
console.log(r.test('name@.tld'));
console.log(r.test('name@domain.'));
console.log(r.test('namedomain.tld'));
console.log(r.test(''));

//now that basic client-side validation is done, send a token from the server side to validate the user actually has access to the email</code></pre>
      </div>
     </div>
     <p></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>6</td>
        <td><span>This regex is too simple and rejects ordinary valid emails. It incorrectly rejects the plus particle in the local part (<code>foo+bar@example.com</code>) and incorrectly rejects generic top-level domains with more than four letters (<code>foo@example.dance</code>).</span> <span> - </span> <span class="display-name">doppelgreener</span> <span> </span> <span class="date">15 Apr 2021 at 13:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This fails over validating <code>.academy</code> domains, for example</span> <span> - </span> <span class="display-name">Pavindu</span> <span> </span> <span class="date">23 Apr 2022 at 12:55</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_54"><span>Answer 54</span> <span class="arrow"> <a href="#answer_53">↑</a> </span> <span class="arrow"> <a href="#answer_55">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mohit Gupta</span>
     </div>
     <div>
      <span> Answered: </span> <span>31 Dec 2012 at 13:09</span>
     </div>
    </div>
    <div>
     <p>As per my understanding, it will most probably be covered by...</p>
     <pre><code>/^([a-z0-9_-]+)(@[a-z0-9-]+)(\.[a-z]+|\.[a-z]+\.[a-z]+)?$/is
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>improvement/suggestion always act as catalyst so pls be catalyzed and catalyzed me also.</span> <span> - </span> <span class="display-name">Mohit Gupta</span> <span> </span> <span class="date">31 Dec 2012 at 13:11</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Gmail users often use . and + in their email nick, and some comments on this page mention ' and !.</span> <span> - </span> <span class="display-name">Cees Timmerman</span> <span> </span> <span class="date">18 Jan 2013 at 14:42</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>This is too restrictive, and does not permit numbers in domain names, characters in the user part. <code>o'hare@example.com</code>, <code>me+alpha@example.com</code>, and <code>me@mail.s2.example.com</code> are all valid email addresses that this does not validate.</span> <span> - </span> <span class="display-name">awwright</span> <span> </span> <span class="date">15 Sep 2020 at 02:48</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_55"><span>Answer 55</span> <span class="arrow"> <a href="#answer_54">↑</a> </span> <span class="arrow"> <a href="#answer_56">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>mrswadge</span>
     </div>
     <div>
      <span> Answered: </span> <span>19 Jul 2013 at 09:27</span>
     </div>
    </div>
    <div>
     <p>I <a href="http://www.regular-expressions.info/email.html" rel="nofollow noreferrer">found a regular expression</a> that is compliant with <a href="https://en.wikipedia.org/wiki/Email#Message_format" rel="nofollow noreferrer">RFC 2822</a>. The preceding standard to <a href="https://en.wikipedia.org/wiki/Email#Message_format" rel="nofollow noreferrer">RFC&nbsp;5322</a>. This regular expression appears to perform fairly well and will cover most cases, however with RFC&nbsp;5322 becoming the standard there may be some holes that ought to be plugged.</p>
     <pre class="lang-none prettyprint-override"><code>^(?:[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$
</code></pre>
     <p>The documentation says you shouldn't use the above regular expression, but instead favour this flavour, which is a bit more manageable.</p>
     <pre class="lang-none prettyprint-override"><code>[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?
</code></pre>
     <p>I noticed this is case-sensitive, so I actually made an alteration to this landing.</p>
     <pre class="lang-none prettyprint-override"><code>^[a-zA-Z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?$
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_56"><span>Answer 56</span> <span class="arrow"> <a href="#answer_55">↑</a> </span> <span class="arrow"> <a href="#answer_57">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Joeytje50</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Jun 2014 at 00:25</span>
     </div>
    </div>
    <div>
     <p>A regex that does exactly what the standards say is allowed, according to what I've seen about them, is this:</p>
     <pre><code>/^(?!(^[.-].*|.*[.-]@|.*\.{2,}.*)|^.{254}.+@)([a-z\xC0-\xFF0-9!#$%&amp;'*+\/=?^_`{|}~.-]+@)(?!.{253}.+$)((?!-.*|.*-\.)([a-z0-9-]{1,63}\.)+[a-z]{2,63}|(([01]?[0-9]{2}|2([0-4][0-9]|5[0-5])|[0-9])\.){3}([01]?[0-9]{2}|2([0-4][0-9]|5[0-5])|[0-9]))$/gim
</code></pre>
     <p><a href="http://regex101.com/r/nO4jB0" rel="nofollow noreferrer"><strong>Demo</strong></a> / <a href="https://www.debuggex.com/i/JN4oFLSjtB5QMK4j.png" rel="nofollow noreferrer"><strong>Debuggex analysis</strong></a> (<a href="https://www.debuggex.com/r/JN4oFLSjtB5QMK4j" rel="nofollow noreferrer">interactive</a>)</p>
     <p>Split up:</p>
     <pre><code>^(?!(^[.-].*|.*[.-]@|.*\.{2,}.*)|^.{254}.+@)
([a-z\xC0-\xFF0-9!#$%&amp;'*+\/=?^_`{|}~.-]+@)
(?!.{253}.+$)
(
    (?!-.*|.*-\.)
    ([a-z0-9-]{1,63}\.)+
    [a-z]{2,63}
    |
    (([01]?[0-9]{2}|2([0-4][0-9]|5[0-5])|[0-9])\.){3}
    ([01]?[0-9]{2}|2([0-4][0-9]|5[0-5])|[0-9])
)$
</code></pre>
     <p>Analysis:</p>
     <pre><code>(?!(^[.-].*|.*[.-]@|.*\.{2,}.*)|^.{254}.+@)
</code></pre>
     <p>Negative lookahead for either <a href="https://stackoverflow.com/a/2049510/1256925">an address starting with a <code>.</code>, ending with one, having <code>..</code> in it</a>, or exceeding <a href="https://stackoverflow.com/a/574698/1256925">the 254 character max length</a></p>
     <hr>
     <pre><code>([a-z\xC0-\xFF0-9!#$%&amp;'*+\/=?^_`{|}~.-]+@)
</code></pre>
     <p>matching 1 or more of the <a href="https://stackoverflow.com/a/2049510/1256925">permitted characters</a>, with the negative look applying to it</p>
     <hr>
     <pre><code>(?!.{253}.+$)
</code></pre>
     <p>Negative lookahead for the domain name part, restricting it to <a href="https://webmasters.stackexchange.com/a/16997">253 characters in total</a></p>
     <hr>
     <pre><code>(?!-.*|.*-\.)
</code></pre>
     <p>Negative lookahead for each of the domain names, which are don't allow <a href="https://stackoverflow.com/a/7111947/1256925">starting or ending with <code>.</code></a></p>
     <hr>
     <pre><code>([a-z0-9-]{1,63}\.)+
</code></pre>
     <p>simple group match for the allowed characters in a domain name, which are limited to <a href="https://webmasters.stackexchange.com/a/16997">63 characters each</a></p>
     <hr>
     <pre><code>[a-zA-Z]{2,63}
</code></pre>
     <p>simple group match for the allowed top-level domain, which currently <a href="https://en.wikipedia.org/wiki/TLD#IDN_test_domains" rel="nofollow noreferrer">still</a> is restricted to letters only, but <a href="https://en.wikipedia.org/wiki/List_of_Internet_top-level_domains#ICANN-era_generic_top-level_domains" rel="nofollow noreferrer">does include &gt;4 letter TLDs</a>.</p>
     <hr>
     <pre><code>(([01]?[0-9]{2}|2([0-4][0-9]|5[0-5])|[0-9])\.){3}
([01]?[0-9]{2}|2([0-4][0-9]|5[0-5])|[0-9])
</code></pre>
     <p>the alternative for domain names: this matches the first 3 numbers in an IP address <em>with</em> a <code>.</code> behind it, and then the fourth number in the IP address without <code>.</code> behind it.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span>Don't use this. It's will reject international domains like "öåüñ". <a href="https://blog.cloudflare.com/non-latinutf8-domains-now-fully-supported/" rel="nofollow noreferrer">blog.cloudflare.com/non-latinutf8-domains-now-fully-supporte‌​d</a></span> <span> - </span> <span class="display-name">Albin</span> <span> </span> <span class="date">4 Mar 2018 at 17:23</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_57"><span>Answer 57</span> <span class="arrow"> <a href="#answer_56">↑</a> </span> <span class="arrow"> <a href="#answer_58">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Fragment</span>
     </div>
     <div>
      <span> Answered: </span> <span>31 Jul 2014 at 09:17</span>
     </div>
    </div>
    <div>
     <p>There has nearly been added a new domain, "yandex". Possible emails: test@job.yandex. And also uppercase letters are supported, so a bit modified version of acrosman's solution is:</p>
     <pre class="lang-none prettyprint-override"><code>^[_a-zA-Z0-9-]+(\.[_a-zA-Z0-9-]+)*@[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)*(\.[a-zA-Z]{2,6})$
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>This is too restrictive, and disallows valid email addresses like <code>o'hare@example.com</code></span> <span> - </span> <span class="display-name">awwright</span> <span> </span> <span class="date">12 Sep 2020 at 23:43</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Re <i>"acrosman's solution"</i>: User <i>acrosman</i> has <b><i>not</i></b> posted a solution or answer, only a question. What answer does this refer to?</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">14 Feb 2022 at 21:46</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_58"><span>Answer 58</span> <span class="arrow"> <a href="#answer_57">↑</a> </span> <span class="arrow"> <a href="#answer_59">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>sunleo</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Aug 2014 at 11:13</span>
     </div>
    </div>
    <div>
     <p><strong>Java Mail API does magic for us.</strong></p>
     <pre><code>try
{
    InternetAddress internetAddress = new InternetAddress(email);
    internetAddress.validate();
    return true;
}
catch(Exception ex)
{
    return false;
}
</code></pre>
     <p>I got this from <a href="http://crunchify.com/how-to-validate-email-address-using-java-mail-api/" rel="nofollow noreferrer">here</a>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>Java Mail API is an <i>optional package for use with Java SE</i> platform and is included in the Java EE platform.</span> <span> - </span> <span class="display-name">Developer Marius Žilėnas</span> <span> </span> <span class="date">11 Dec 2014 at 07:56</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_59"><span>Answer 59</span> <span class="arrow"> <a href="#answer_58">↑</a> </span> <span class="arrow"> <a href="#answer_60">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>SIslam</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Sep 2015 at 17:58</span>
     </div>
    </div>
    <div>
     <p>I did not find any that deals with a <a href="https://en.wikipedia.org/wiki/Top-level_domain" rel="nofollow noreferrer">top-level domain</a> name, but it should be considered.</p>
     <p>So for me the following worked:</p>
     <pre class="lang-none prettyprint-override"><code>[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+(?:[A-Z]{2}AAA|AARP|ABB|ABBOTT|ABOGADO|AC|ACADEMY|ACCENTURE|ACCOUNTANT|ACCOUNTANTS|ACO|ACTIVE|ACTOR|AD|ADAC|ADS|ADULT|AE|AEG|AERO|AF|AFL|AG|AGENCY|AI|AIG|AIRFORCE|AIRTEL|AL|ALIBABA|ALIPAY|ALLFINANZ|ALSACE|AM|AMICA|AMSTERDAM|ANALYTICS|ANDROID|AO|APARTMENTS|APP|APPLE|AQ|AQUARELLE|AR|ARAMCO|ARCHI|ARMY|ARPA|ARTE|AS|ASIA|ASSOCIATES|AT|ATTORNEY|AU|AUCTION|AUDI|AUDIO|AUTHOR|AUTO|AUTOS|AW|AX|AXA|AZ|AZURE|BA|BAIDU|BAND|BANK|BAR|BARCELONA|BARCLAYCARD|BARCLAYS|BARGAINS|BAUHAUS|BAYERN|BB|BBC|BBVA|BCN|BD|BE|BEATS|BEER|BENTLEY|BERLIN|BEST|BET|BF|BG|BH|BHARTI|BI|BIBLE|BID|BIKE|BING|BINGO|BIO|BIZ|BJ|BLACK|BLACKFRIDAY|BLOOMBERG|BLUE|BM|BMS|BMW|BN|BNL|BNPPARIBAS|BO|BOATS|BOEHRINGER|BOM|BOND|BOO|BOOK|BOOTS|BOSCH|BOSTIK|BOT|BOUTIQUE|BR|BRADESCO|BRIDGESTONE|BROADWAY|BROKER|BROTHER|BRUSSELS|BS|BT|BUDAPEST|BUGATTI|BUILD|BUILDERS|BUSINESS|BUY|BUZZ|BV|BW|BY|BZ|BZH|CA|CAB|CAFE|CAL|CALL|CAMERA|CAMP|CANCERRESEARCH|CANON|CAPETOWN|CAPITAL|CAR|CARAVAN|CARDS|CARE|CAREER|CAREERS|CARS|CARTIER|CASA|CASH|CASINO|CAT|CATERING|CBA|CBN|CC|CD|CEB|CENTER|CEO|CERN|CF|CFA|CFD|CG|CH|CHANEL|CHANNEL|CHAT|CHEAP|CHLOE|CHRISTMAS|CHROME|CHURCH|CI|CIPRIANI|CIRCLE|CISCO|CITIC|CITY|CITYEATS|CK|CL|CLAIMS|CLEANING|CLICK|CLINIC|CLINIQUE|CLOTHING|CLOUD|CLUB|CLUBMED|CM|CN|CO|COACH|CODES|COFFEE|COLLEGE|COLOGNE|COM|COMMBANK|COMMUNITY|COMPANY|COMPARE|COMPUTER|COMSEC|CONDOS|CONSTRUCTION|CONSULTING|CONTACT|CONTRACTORS|COOKING|COOL|COOP|CORSICA|COUNTRY|COUPONS|COURSES|CR|CREDIT|CREDITCARD|CREDITUNION|CRICKET|CROWN|CRS|CRUISES|CSC|CU|CUISINELLA|CV|CW|CX|CY|CYMRU|CYOU|CZ|DABUR|DAD|DANCE|DATE|DATING|DATSUN|DAY|DCLK|DE|DEALER|DEALS|DEGREE|DELIVERY|DELL|DELTA|DEMOCRAT|DENTAL|DENTIST|DESI|DESIGN|DEV|DIAMONDS|DIET|DIGITAL|DIRECT|DIRECTORY|DISCOUNT|DJ|DK|DM|DNP|DO|DOCS|DOG|DOHA|DOMAINS|DOOSAN|DOWNLOAD|DRIVE|DUBAI|DURBAN|DVAG|DZ|EARTH|EAT|EC|EDEKA|EDU|EDUCATION|EE|EG|EMAIL|EMERCK|ENERGY|ENGINEER|ENGINEERING|ENTERPRISES|EPSON|EQUIPMENT|ER|ERNI|ES|ESQ|ESTATE|ET|EU|EUROVISION|EUS|EVENTS|EVERBANK|EXCHANGE|EXPERT|EXPOSED|EXPRESS|FAGE|FAIL|FAIRWINDS|FAITH|FAMILY|FAN|FANS|FARM|FASHION|FAST|FEEDBACK|FERRERO|FI|FILM|FINAL|FINANCE|FINANCIAL|FIRESTONE|FIRMDALE|FISH|FISHING|FIT|FITNESS|FJ|FK|FLIGHTS|FLORIST|FLOWERS|FLSMIDTH|FLY|FM|FO|FOO|FOOTBALL|FORD|FOREX|FORSALE|FORUM|FOUNDATION|FOX|FR|FRESENIUS|FRL|FROGANS|FUND|FURNITURE|FUTBOL|FYI|GA|GAL|GALLERY|GAME|GARDEN|GB|GBIZ|GD|GDN|GE|GEA|GENT|GENTING|GF|GG|GGEE|GH|GI|GIFT|GIFTS|GIVES|GIVING|GL|GLASS|GLE|GLOBAL|GLOBO|GM|GMAIL|GMO|GMX|GN|GOLD|GOLDPOINT|GOLF|GOO|GOOG|GOOGLE|GOP|GOT|GOV|GP|GQ|GR|GRAINGER|GRAPHICS|GRATIS|GREEN|GRIPE|GROUP|GS|GT|GU|GUCCI|GUGE|GUIDE|GUITARS|GURU|GW|GY|HAMBURG|HANGOUT|HAUS|HEALTH|HEALTHCARE|HELP|HELSINKI|HERE|HERMES|HIPHOP|HITACHI|HIV|HK|HM|HN|HOCKEY|HOLDINGS|HOLIDAY|HOMEDEPOT|HOMES|HONDA|HORSE|HOST|HOSTING|HOTELES|HOTMAIL|HOUSE|HOW|HR|HSBC|HT|HU|HYUNDAI|IBM|ICBC|ICE|ICU|ID|IE|IFM|IINET|IL|IM|IMMO|IMMOBILIEN|IN|INDUSTRIES|INFINITI|INFO|ING|INK|INSTITUTE|INSURANCE|INSURE|INT|INTERNATIONAL|INVESTMENTS|IO|IPIRANGA|IQ|IR|IRISH|IS|ISELECT|IST|ISTANBUL|IT|ITAU|IWC|JAGUAR|JAVA|JCB|JE|JETZT|JEWELRY|JLC|JLL|JM|JMP|JO|JOBS|JOBURG|JOT|JOY|JP|JPRS|JUEGOS|KAUFEN|KDDI|KE|KFH|KG|KH|KI|KIA|KIM|KINDER|KITCHEN|KIWI|KM|KN|KOELN|KOMATSU|KP|KPN|KR|KRD|KRED|KW|KY|KYOTO|KZ|LA|LACAIXA|LAMBORGHINI|LAMER|LANCASTER|LAND|LANDROVER|LANXESS|LASALLE|LAT|LATROBE|LAW|LAWYER|LB|LC|LDS|LEASE|LECLERC|LEGAL|LEXUS|LGBT|LI|LIAISON|LIDL|LIFE|LIFEINSURANCE|LIFESTYLE|LIGHTING|LIKE|LIMITED|LIMO|LINCOLN|LINDE|LINK|LIVE|LIVING|LIXIL|LK|LOAN|LOANS|LOL|LONDON|LOTTE|LOTTO|LOVE|LR|LS|LT|LTD|LTDA|LU|LUPIN|LUXE|LUXURY|LV|LY|MA|MADRID|MAIF|MAISON|MAKEUP|MAN|MANAGEMENT|MANGO|MARKET|MARKETING|MARKETS|MARRIOTT|MBA|MC|MD|ME|MED|MEDIA|MEET|MELBOURNE|MEME|MEMORIAL|MEN|MENU|MEO|MG|MH|MIAMI|MICROSOFT|MIL|MINI|MK|ML|MM|MMA|MN|MO|MOBI|MOBILY|MODA|MOE|MOI|MOM|MONASH|MONEY|MONTBLANC|MORMON|MORTGAGE|MOSCOW|MOTORCYCLES|MOV|MOVIE|MOVISTAR|MP|MQ|MR|MS|MT|MTN|MTPC|MTR|MU|MUSEUM|MUTUELLE|MV|MW|MX|MY|MZ|NA|NADEX|NAGOYA|NAME|NAVY|NC|NE|NEC|NET|NETBANK|NETWORK|NEUSTAR|NEW|NEWS|NEXUS|NF|NG|NGO|NHK|NI|NICO|NINJA|NISSAN|NL|NO|NOKIA|NORTON|NOWRUZ|NP|NR|NRA|NRW|NTT|NU|NYC|NZ|OBI|OFFICE|OKINAWA|OM|OMEGA|ONE|ONG|ONL|ONLINE|OOO|ORACLE|ORANGE|ORG|ORGANIC|ORIGINS|OSAKA|OTSUKA|OVH|PA|PAGE|PAMPEREDCHEF|PANERAI|PARIS|PARS|PARTNERS|PARTS|PARTY|PE|PET|PF|PG|PH|PHARMACY|PHILIPS|PHOTO|PHOTOGRAPHY|PHOTOS|PHYSIO|PIAGET|PICS|PICTET|PICTURES|PID|PIN|PING|PINK|PIZZA|PK|PL|PLACE|PLAY|PLAYSTATION|PLUMBING|PLUS|PM|PN|POHL|POKER|PORN|POST|PR|PRAXI|PRESS|PRO|PROD|PRODUCTIONS|PROF|PROMO|PROPERTIES|PROPERTY|PROTECTION|PS|PT|PUB|PW|PY|QA|QPON|QUEBEC|RACING|RE|READ|REALTOR|REALTY|RECIPES|RED|REDSTONE|REDUMBRELLA|REHAB|REISE|REISEN|REIT|REN|RENT|RENTALS|REPAIR|REPORT|REPUBLICAN|REST|RESTAURANT|REVIEW|REVIEWS|REXROTH|RICH|RICOH|RIO|RIP|RO|ROCHER|ROCKS|RODEO|ROOM|RS|RSVP|RU|RUHR|RUN|RW|RWE|RYUKYU|SA|SAARLAND|SAFE|SAFETY|SAKURA|SALE|SALON|SAMSUNG|SANDVIK|SANDVIKCOROMANT|SANOFI|SAP|SAPO|SARL|SAS|SAXO|SB|SBS|SC|SCA|SCB|SCHAEFFLER|SCHMIDT|SCHOLARSHIPS|SCHOOL|SCHULE|SCHWARZ|SCIENCE|SCOR|SCOT|SD|SE|SEAT|SECURITY|SEEK|SELECT|SENER|SERVICES|SEVEN|SEW|SEX|SEXY|SFR|SG|SH|SHARP|SHELL|SHIA|SHIKSHA|SHOES|SHOW|SHRIRAM|SI|SINGLES|SITE|SJ|SK|SKI|SKIN|SKY|SKYPE|SL|SM|SMILE|SN|SNCF|SO|SOCCER|SOCIAL|SOFTBANK|SOFTWARE|SOHU|SOLAR|SOLUTIONS|SONY|SOY|SPACE|SPIEGEL|SPREADBETTING|SR|SRL|ST|STADA|STAR|STARHUB|STATEFARM|STATOIL|STC|STCGROUP|STOCKHOLM|STORAGE|STUDIO|STUDY|STYLE|SU|SUCKS|SUPPLIES|SUPPLY|SUPPORT|SURF|SURGERY|SUZUKI|SV|SWATCH|SWISS|SX|SY|SYDNEY|SYMANTEC|SYSTEMS|SZ|TAB|TAIPEI|TAOBAO|TATAMOTORS|TATAR|TATTOO|TAX|TAXI|TC|TCI|TD|TEAM|TECH|TECHNOLOGY|TEL|TELEFONICA|TEMASEK|TENNIS|TF|TG|TH|THD|THEATER|THEATRE|TICKETS|TIENDA|TIFFANY|TIPS|TIRES|TIROL|TJ|TK|TL|TM|TMALL|TN|TO|TODAY|TOKYO|TOOLS|TOP|TORAY|TOSHIBA|TOURS|TOWN|TOYOTA|TOYS|TR|TRADE|TRADING|TRAINING|TRAVEL|TRAVELERS|TRAVELERSINSURANCE|TRUST|TRV|TT|TUBE|TUI|TUSHU|TV|TW|TZ|UA|UBS|UG|UK|UNIVERSITY|UNO|UOL|US|UY|UZ|VA|VACATIONS|VANA|VC|VE|VEGAS|VENTURES|VERISIGN|VERSICHERUNG|VET|VG|VI|VIAJES|VIDEO|VILLAS|VIN|VIP|VIRGIN|VISION|VISTA|VISTAPRINT|VIVA|VLAANDEREN|VN|VODKA|VOLKSWAGEN|VOTE|VOTING|VOTO|VOYAGE|VU|WALES|WALTER|WANG|WANGGOU|WATCH|WATCHES|WEATHER|WEBCAM|WEBER|WEBSITE|WED|WEDDING|WEIR|WF|WHOSWHO|WIEN|WIKI|WILLIAMHILL|WIN|WINDOWS|WINE|WME|WORK|WORKS|WORLD|WS|WTC|WTF|XBOX|XEROX|XIN|XN--11B4C3D|XN--1QQW23A|XN--30RR7Y|XN--3BST00M|XN--3DS443G|XN--3E0B707E|XN--3PXU8K|XN--42C2D9A|XN--45BRJ9C|XN--45Q11C|XN--4GBRIM|XN--55QW42G|XN--55QX5D|XN--6FRZ82G|XN--6QQ986B3XL|XN--80ADXHKS|XN--80AO21A|XN--80ASEHDB|XN--80ASWG|XN--90A3AC|XN--90AIS|XN--9DBQ2A|XN--9ET52U|XN--B4W605FERD|XN--C1AVG|XN--C2BR7G|XN--CG4BKI|XN--CLCHC0EA0B2G2A9GCD|XN--CZR694B|XN--CZRS0T|XN--CZRU2D|XN--D1ACJ3B|XN--D1ALF|XN--ECKVDTC9D|XN--EFVY88H|XN--ESTV75G|XN--FHBEI|XN--FIQ228C5HS|XN--FIQ64B|XN--FIQS8S|XN--FIQZ9S|XN--FJQ720A|XN--FLW351E|XN--FPCRJ9C3D|XN--FZC2C9E2C|XN--G2XX48C|XN--GECRJ9C|XN--H2BRJ9C|XN--HXT814E|XN--I1B6B1A6A2E|XN--IMR513N|XN--IO0A7I|XN--J1AEF|XN--J1AMH|XN--J6W193G|XN--JLQ61U9W7B|XN--KCRX77D1X4A|XN--KPRW13D|XN--KPRY57D|XN--KPU716F|XN--KPUT3I|XN--L1ACC|XN--LGBBAT1AD8J|XN--MGB9AWBF|XN--MGBA3A3EJT|XN--MGBA3A4F16A|XN--MGBAAM7A8H|XN--MGBAB2BD|XN--MGBAYH7GPA|XN--MGBB9FBPOB|XN--MGBBH1A71E|XN--MGBC0A9AZCG|XN--MGBERP4A5D4AR|XN--MGBPL2FH|XN--MGBT3DHD|XN--MGBTX2B|XN--MGBX4CD0AB|XN--MK1BU44C|XN--MXTQ1M|XN--NGBC5AZD|XN--NGBE9E0A|XN--NODE|XN--NQV7F|XN--NQV7FS00EMA|XN--NYQY26A|XN--O3CW4H|XN--OGBPF8FL|XN--P1ACF|XN--P1AI|XN--PBT977C|XN--PGBS0DH|XN--PSSY2U|XN--Q9JYB4C|XN--QCKA1PMC|XN--QXAM|XN--RHQV96G|XN--S9BRJ9C|XN--SES554G|XN--T60B56A|XN--TCKWE|XN--UNUP4Y|XN--VERMGENSBERATER-CTB|XN--VERMGENSBERATUNG-PWB|XN--VHQUV|XN--VUQ861B|XN--WGBH1C|XN--WGBL6A|XN--XHQ521B|XN--XKC2AL3HYE2A|XN--XKC2DL3A5EE0H|XN--Y9A3AQ|XN--YFRO4I67O|XN--YGBI2AMMX|XN--ZFR164B|XPERIA|XXX|XYZ|YACHTS|YAMAXUN|YANDEX|YE|YODOBASHI|YOGA|YOKOHAMA|YOUTUBE|YT|ZA|ZARA|ZERO|ZIP|ZM|ZONE|ZUERICH|ZW)\b
</code></pre>
     <p>That easily discarded emails like <code>3c296rD3HNEE@d139c.a51, Sd@sd.dox</code>, etc.</p>
     <p>The domain name can be further edited if needed, e.g., specific country domain, etc.</p>
     <p>Another <a href="https://data.iana.org/TLD/tlds-alpha-by-domain.txt" rel="nofollow noreferrer">list</a> of top level domains that updates frequently.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Like pointed out in multiple comments to other answers here already, the list of valid TLDs is growing rapidly. Your "2-letter ccTLD or one of big-6, info, mobi, etc" would have been reasonable five years ago, but no longer works at all reliably.</span> <span> - </span> <span class="display-name">tripleee</span> <span> </span> <span class="date">15 Sep 2015 at 04:32</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Even at time of original writing, this was already invalid by a couple hundred TLD's. As of currently, you're missing a little under 1200 possibilities (and growing at a pretty regular rate) Current list of valid domains: <a href="http://data.iana.org/TLD/tlds-alpha-by-domain.txt" rel="nofollow noreferrer">data.iana.org/TLD/tlds-alpha-by-domain.txt</a></span> <span> - </span> <span class="display-name">user2366842</span> <span> </span> <span class="date">27 Jan 2016 at 19:38</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Nearly 8,000 characters in a regular expression? There is something seriously wrong. Can't it be layered, refactored, split into several pieces, or similar instead of one big regular expression? There is presumably a lot of redundancy in it.</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">14 Feb 2022 at 23:33</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_60"><span>Answer 60</span> <span class="arrow"> <a href="#answer_59">↑</a> </span> <span class="arrow"> <a href="#answer_61">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Prassd Nidode</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Dec 2016 at 10:17</span>
     </div>
    </div>
    <div>
     <p>List item</p>
     <p>I use this function</p>
     <pre class="lang-php prettyprint-override"><code>function checkmail($value) {
    $value = trim($value);
    if (stristr($value,"@") &amp;&amp;
        stristr($value,".") &amp;&amp;
        (strrpos($value, ".") - stripos($value, "@") &gt; 2) &amp;&amp;
        (stripos($value, "@") &gt; 1) &amp;&amp;
        (strlen($value) - strrpos($value, ".") &lt; 6) &amp;&amp;
        (strlen($value) - strrpos($value, ".") &gt; 2) &amp;&amp;
        ($value == preg_replace('/[ ]/', '', $value)) &amp;&amp;
        ($value == preg_replace('/[^A-Za-z0-9\-_.@!*]/', '', $value))
    )
    {

    }
    else {
        return "Invalid Mail-Id";
    }
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_61"><span>Answer 61</span> <span class="arrow"> <a href="#answer_60">↑</a> </span> <span class="arrow"> <a href="#answer_62">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>partoftheorigin</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Jun 2019 at 12:49</span>
     </div>
    </div>
    <div>
     <p>Writing a regular expression for all the things will take a lot of effort. Instead, you can use <a href="https://pypi.org/project/pyIsEmail/" rel="nofollow noreferrer">pyIsEmail</a> package.</p>
     <p>Below text is taken from <a href="https://pypi.org/project/pyIsEmail/" rel="nofollow noreferrer">pyIsEmail</a> website.</p>
     <p>pyIsEmail is a no-nonsense approach for checking whether that user-supplied email address could be real.</p>
     <p>Regular expressions are cheap to write, but often require maintenance when new top-level domains come out or don’t conform to email addressing features that come back into vogue. pyIsEmail allows you to validate an email address – and even check the domain, if you wish – with one simple call, making your code more readable and faster to write. When you want to know why an email address doesn’t validate, they even provide you with a diagnosis.</p>
     <h2>Usage</h2>
     <p>For the simplest usage, import and use the is_email function:</p>
     <pre><code>from pyisemail import is_email

address = "test@example.com"
bool_result = is_email(address)
detailed_result = is_email(address, diagnose=True)
</code></pre>
     <p>You can also check whether the domain used in the email is a valid domain and whether or not it has a valid <a href="https://en.wikipedia.org/wiki/MX_record" rel="nofollow noreferrer">MX record</a>:</p>
     <pre><code>from pyisemail import is_email

address = "test@example.com"
bool_result_with_dns = is_email(address, check_dns=True)
detailed_result_with_dns = is_email(address, check_dns=True, diagnose=True)
</code></pre>
     <p>These are primary indicators of whether an email address can even be issued at that domain. However, a valid response here is not a guarantee that the email exists, merely that is can exist.</p>
     <p>In addition to the base <em>is_email</em> functionality, you can also use the validators by themselves. Check the validator source doc to see how this works.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Re <i>"...when new top-level domains come out"</i>: Aren't there literally thousands by now?</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">15 Feb 2022 at 00:00</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This sounds more like an advert. What does it actually do? What is the gist? Does it go live over the Internet to do some lookups or checks (that involves some DNS stuff)? <i>Effectively</i> trying to send the email to see what happens? Or something else?</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">15 Feb 2022 at 00:05</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_62"><span>Answer 62</span> <span class="arrow"> <a href="#answer_61">↑</a> </span> <span class="arrow"> <a href="#answer_63">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>PrivateUser</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 May 2013 at 12:20</span>
     </div>
    </div>
    <div>
     <p>The world's most popular blogging platform <a href="https://en.wikipedia.org/wiki/WordPress" rel="nofollow noreferrer">WordPress</a> uses this function to validate email address...</p>
     <p>But they are doing it with multiple steps.</p>
     <p>You don't have to worry anymore when using the regex mentioned in this function...</p>
     <p>Here is the function...</p>
     <pre><code>/**
 * Verifies that an email is valid.
 *
 * Does not grok i18n domains. Not RFC compliant.
 *
 * @since 0.71
 *
 * @param string $email Email address to verify.
 * @param boolean $deprecated Deprecated.
 * @return string|bool Either false or the valid email address.
 */
function is_email( $email, $deprecated = false ) {
    if ( ! empty( $deprecated ) )
        _deprecated_argument( __FUNCTION__, '3.0' );

    // Test for the minimum length the email can be
    if ( strlen( $email ) &lt; 3 ) {
        return apply_filters( 'is_email', false, $email, 'email_too_short' );
    }

    // Test for an @ character after the first position
    if ( strpos( $email, '@', 1 ) === false ) {
        return apply_filters( 'is_email', false, $email, 'email_no_at' );
    }

    // Split out the local and domain parts
    list( $local, $domain ) = explode( '@', $email, 2 );

    // LOCAL PART
    // Test for invalid characters
    if ( !preg_match( '/^[a-zA-Z0-9!#$%&amp;\'*+\/=?^_`{|}~\.-]+$/', $local ) ) {
        return apply_filters( 'is_email', false, $email, 'local_invalid_chars' );
    }

    // DOMAIN PART
    // Test for sequences of periods
    if ( preg_match( '/\.{2,}/', $domain ) ) {
        return apply_filters( 'is_email', false, $email, 'domain_period_sequence' );
    }

    // Test for leading and trailing periods and whitespace
    if ( trim( $domain, " \t\n\r\0\x0B." ) !== $domain ) {
        return apply_filters( 'is_email', false, $email, 'domain_period_limits' );
    }

    // Split the domain into subs
    $subs = explode( '.', $domain );

    // Assume the domain will have at least two subs
    if ( 2 &gt; count( $subs ) ) {
        return apply_filters( 'is_email', false, $email, 'domain_no_periods' );
    }

    // Loop through each sub
    foreach ( $subs as $sub ) {
        // Test for leading and trailing hyphens and whitespace
        if ( trim( $sub, " \t\n\r\0\x0B-" ) !== $sub ) {
            return apply_filters( 'is_email', false, $email, 'sub_hyphen_limits' );
        }

        // Test for invalid characters
        if ( !preg_match('/^[a-z0-9-]+$/i', $sub ) ) {
            return apply_filters( 'is_email', false, $email, 'sub_invalid_chars' );
        }
    }

    // Congratulations your email made it!
    return apply_filters( 'is_email', $email, $email, null );
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>This is too restrictive, it does not permit a quoted user component, and it does not support internationalized email addresses. Also the <code>_deprecated_argument</code> function is not defined.</span> <span> - </span> <span class="display-name">awwright</span> <span> </span> <span class="date">12 Sep 2020 at 23:47</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_63"><span>Answer 63</span> <span class="arrow"> <a href="#answer_62">↑</a> </span> <span class="arrow"> <a href="#answer_64">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>zıəs uɐɟəʇs</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Sep 2014 at 14:22</span>
     </div>
    </div>
    <div>
     <p>As mentioned already, you can't validate an email with a regex. However, here's what we currently use to make sure user-input isn't totally bogus (forgetting the <a href="https://en.wikipedia.org/wiki/Top-level_domain" rel="nofollow noreferrer">TLD</a>, etc.).</p>
     <p>This regex will allow <a href="https://en.wikipedia.org/wiki/Internationalized_domain_name" rel="nofollow noreferrer">IDN</a> domains and special characters (like Umlauts) before and after the @ sign.</p>
     <pre class="lang-none prettyprint-override"><code>/^[\w.+-_]+@[^.][\w.-]*\.[\w-]{2,63}$/iu
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>What regular expression flavour and/or programming language? <a href="https://en.wikipedia.org/wiki/Perl" rel="nofollow noreferrer">Perl</a>? Something else?</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">14 Feb 2022 at 22:02</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_64"><span>Answer 64</span> <span class="arrow"> <a href="#answer_63">↑</a> </span> <span class="arrow"> <a href="#answer_65">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>syp_dino</span>
     </div>
     <div>
      <span> Answered: </span> <span>19 Sep 2015 at 14:13</span>
     </div>
    </div>
    <div>
     <p>I found a <a href="http://davidcel.is/posts/stop-validating-email-addresses-with-regex/" rel="nofollow noreferrer">nice article</a>, which says that the best way to validate e-mail address is the regular expression <code>/.+@.+\..+/i</code>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>It doesn't match valid addresses like: <code>me@localhost</code></span> <span> - </span> <span class="display-name">Toto</span> <span> </span> <span class="date">25 Sep 2015 at 08:13</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>It also matches invalid addresses like john doe@his domain.com.</span> <span> - </span> <span class="display-name">chukko</span> <span> </span> <span class="date">3 Feb 2016 at 11:22</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_65"><span>Answer 65</span> <span class="arrow"> <a href="#answer_64">↑</a> </span> <span class="arrow"> <a href="#answer_66">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Hany Sakr</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Sep 2017 at 10:41</span>
     </div>
    </div>
    <div>
     <p>I converted the code into Java to match the compiler:</p>
     <pre class="lang-java prettyprint-override"><code>String pattern = "(?:[a-zA-Z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\\.)+[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?|\\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-zA-Z0-9-]*[a-zA-Z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])";
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_66"><span>Answer 66</span> <span class="arrow"> <a href="#answer_65">↑</a> </span> <span class="arrow"> <a href="#answer_67">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Eggon</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Apr 2022 at 15:09</span>
     </div>
    </div>
    <div>
     <p>I'd like to propose my approach which is relatively simple while ensuring proper email structure and restricting forbidden characters. Valid for latin characters.</p>
     <pre><code>/^(?![\w\.@]*\.\.)(?![\w\.@]*\.@)(?![\w\.]*@\.)\w+[\w\.]*@[\w\.]+\.\w{2,}$/
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>This is the best one so far.</span> <span> - </span> <span class="display-name">Epic Speedy</span> <span> </span> <span class="date">19 May 2022 at 22:48</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>can you do this using golang?</span> <span> - </span> <span class="display-name">San</span> <span> </span> <span class="date">11 Jul 2022 at 12:51</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_67"><span>Answer 67</span> <span class="arrow"> <a href="#answer_66">↑</a> </span> <span class="arrow"> <a href="#answer_68">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Francisco Costa</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Oct 2013 at 14:19</span>
     </div>
    </div>
    <div>
     <pre><code>^[_a-zA-Z0-9-]+(\.[_a-zA-Z0-9-]+)*@[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)*\.(([0-9]{1,3})|([a-zA-Z]{2,3})|(aero|coop|info|museum|name))$
</code></pre>
     <p>This matches 99.99% of email addresses, including some of the newer top-level-domain extensions, such as info, museum, name, etc. It also allows for emails tied directly to IP addresses.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_68"><span>Answer 68</span> <span class="arrow"> <a href="#answer_67">↑</a> </span> <span class="arrow"> <a href="#answer_69">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ramesh Kotkar</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 Dec 2014 at 06:20</span>
     </div>
    </div>
    <div>
     <p>You can use following regular expression for any email address:</p>
     <pre><code>^(([^&lt;&gt;()[\]\\.,;:\s@\"]+(\.[^&lt;&gt;()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$
</code></pre>
     <h3>For PHP</h3>
     <pre><code>function checkEmailValidation($email)
{
    $expression = '/^(([^&lt;&gt;()[\]\\.,;:\s@\"]+(\.[^&lt;&gt;()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/';
    if(preg_match($expression, $email))
    {
        return true;
    }
    else
    {
        return false;
    }
}
</code></pre>
     <h3>For JavaScript</h3>
     <pre><code>function checkEmailValidation(email)
{
    var pattern = '/^(([^&lt;&gt;()[\]\\.,;:\s@\"]+(\.[^&lt;&gt;()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/';
    if(pattern.test(email))
    {
        return true;
    }
    else
    {
        return false;
    }
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span><code>if(preg_match($expression, $email)) { return true; } else { return false; }</code> can be simplified to <code>return (bool) preg_match($expression, $email);</code></span> <span> - </span> <span class="display-name">Luna</span> <span> </span> <span class="date">14 Aug 2015 at 12:33</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_69"><span>Answer 69</span> <span class="arrow"> <a href="#answer_68">↑</a> </span> <span class="arrow"> <a href="#answer_70">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Craig</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 May 2021 at 17:34</span>
     </div>
    </div>
    <div>
     <p>Yet another option we have is to use <code>DataAnnotations</code> which has an <code>EmailAddressAttribute</code>. This can not only be applied to the property of a class but can also leveraged at runtime.</p>
     <p><code>using System.ComponentModel.DataAnnotations;</code></p>
     <p><strong>Typical Usage</strong></p>
     <pre><code>public class Person
{
    public int Id { get; set; }

    [EmailAddress]
    public string Email { get; set; }
}
</code></pre>
     <p><strong>At Runtime</strong></p>
     <pre><code>var emailAddressAttribute = new EmailAddressAttribute();

if (emailAddressAttribute.IsValid("name@email.com"))
{
    //email is valid
}
else
{
    //email is invalid
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_70"><span>Answer 70</span> <span class="arrow"> <a href="#answer_69">↑</a> </span> <span class="arrow"> <a href="#answer_71">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Tim Wißmann</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Jul 2021 at 00:02</span>
     </div>
    </div>
    <div>
     <p>For my purpose, I needed a way to also extract a display name if provided.<br>
       Thanks to the other answers and the regex provided on <a href="https://emailregex.com/" rel="nofollow noreferrer">https://emailregex.com/</a> I came up with the following solution:</p>
     <pre class="lang-none prettyprint-override"><code>/^(?:([^&lt;]*?)\s*&lt;)?((?:[a-z0-9!#$%&amp;'*+\/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+\/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\]))&gt;?$/gi
</code></pre>
     <p>This matches <strong>Display name (=group 1)</strong> + <strong>email address (=group 2)</strong>.</p>
     <p>Examples of matches:</p>
     <pre class="lang-none prettyprint-override"><code>john.doe@example.com
john.o'doe@example.com
John &lt;john@doe.com&gt;
&lt;john@doe.com&gt;
This is &lt;john@127.0.0.1&gt;
</code></pre>
     <p><em>Tested with <a href="https://regex101.com/" rel="nofollow noreferrer">https://regex101.com/</a></em></p>
     <p>Of course, as also mentioned in other answers, additional validation of the length of display name and email address is required (shouldn't exceed 320 UTF-8 bytes).</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_71"><span>Answer 71</span> <span class="arrow"> <a href="#answer_70">↑</a> </span> <span class="arrow"> <a href="#answer_72">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>ThinkTrans</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Apr 2022 at 04:23</span>
     </div>
    </div>
    <div>
     <p>The question title is fairly generic, however the body of the question indicates that it is about the PHP based solution. Will try to address both.</p>
     <p><strong>Generically speaking, for all programming languages:</strong> Typically, validating" an e-mail address with a reg-ex is something that any internet based service provider should desist from. The possibilities of kinds of domain names and e-mail addresses have increased so much in terms of variety, any attempt at validation, which is not well thought may end up denying some valid users into your system. To avoid this, one of the best ways is to send an email to the user and verify it being received. The good folks at "<a href="https://uasg.tech/" rel="nofollow noreferrer">Universal Acceptance Steering Group</a>" have compiled a languagewise list of libraries which are found to be compliant/non-compliant with various parameters involving validations vis-a-vis Internationalized Domain Names and Internationalized Email addresses. Please find the links to those documents over <a href="https://uasg.tech/download/uasg-018a-ua-compliance-of-some-programming-language-libraries-and-frameworks-en/" rel="nofollow noreferrer">here</a> and <a href="https://uasg.tech/download/uasg-037-ua-readiness-of-some-programming-language-libraries-and-frameworks-en/" rel="nofollow noreferrer">here</a>.</p>
     <p><strong>Speaking specifically of PHP:</strong></p>
     <p>There is one good library available in PHP i.e. EmailValidator. It is an email address validator that includes many validation methods such as DNS validation. The validator specifically recommended is called RFCValidator and validates email addresses against several RFCs. It has good compliance when it comes to being inclusive towards IDNs and Internationalized Email addresses.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_72"><span>Answer 72</span> <span class="arrow"> <a href="#answer_71">↑</a> </span> <span class="arrow"> <a href="#answer_73">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>GooDeeJAY</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Mar 2021 at 12:20</span>
     </div>
    </div>
    <div>
     <p>The regular expression that I use:</p>
     <pre class="lang-none prettyprint-override"><code>[\w-+]+([.][\w]+)?@[\w-+]+([.][a-z]{2,})+
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_73"><span>Answer 73</span> <span class="arrow"> <a href="#answer_72">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Andriy B.</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Oct 2020 at 20:37</span>
     </div>
    </div>
    <div>
     <p>This simple pattern works for me:</p>
     <pre class="lang-none prettyprint-override"><code>^(?&lt;name&gt;[^&lt;&gt;#()\.,;\s@\"]{1,})@(?&lt;domain&gt;[^&lt;&gt;#()\.,;\s@\"]{2,}\.(?&lt;top&gt;[^&lt;&gt;#()\.,;:\s@\"]{2,}))$
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>Welcome to Stack Overflow. If you decide to answer an older question that has well established and correct answers, adding a new answer late in the day may not get you any credit. If you have some distinctive new information, or you're convinced the other answers are all wrong, by all means add a new answer, but 'yet another answer' giving the same basic information a long time after the question was asked usually won't earn you much credit. It also isn't entirely clear which dialect of regex you are using.</span> <span> - </span> <span class="display-name">Jonathan Leffler</span> <span> </span> <span class="date">1 Oct 2020 at 22:16</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>