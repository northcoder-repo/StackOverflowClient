<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>RegEx match open tags except XHTML self-contained tags</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>RegEx match open tags except XHTML self-contained tags</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>2183</span>
    </div>
    <div>
     <span>Asker: </span> <span>Jeff</span>
    </div>
    <div>
     <span>Asked: </span> <span>13 Nov 2009 at 22:38</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags">source</a>
    </div>
   </div>
   <div>
    <p>I need to match all of these opening tags:</p>
    <pre><code>&lt;p&gt;
&lt;a href="foo"&gt;
</code></pre>
    <p>But not these:</p>
    <pre><code>&lt;br /&gt;
&lt;hr class="foo" /&gt;
</code></pre>
    <p>I came up with this and wanted to make sure I've got it right. I am only capturing the <code>a-z</code>.</p>
    <pre><code>&lt;([a-z]+) *[^/]*?&gt;
</code></pre>
    <p>I believe it says:</p>
    <ul>
     <li>Find a less-than, then</li>
     <li>Find (and capture) a-z one or more times, then</li>
     <li>Find zero or more spaces, then</li>
     <li>Find any character zero or more times, greedy, except <code>/</code>, then</li>
     <li>Find a greater-than</li>
    </ul>
    <p>Do I have that right? And more importantly, what do you think?</p>
   </div>
   <div class="tags">
    <span class="tag">html</span><span class="tag">regex</span><span class="tag">xhtml</span>
   </div>
   <hr>
   <div class="comment">
    <table>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4408</span>
     </div>
     <div>
      <span>Answerer: </span> <span>bobince</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 Nov 2009 at 23:04</span>
     </div>
    </div>
    <div>
     <p>You can't parse [X]HTML with regex. Because HTML can't be parsed by regex. Regex is not a tool that can be used to correctly parse HTML. As I have answered in HTML-and-regex questions here so many times before, the use of regex will not allow you to consume HTML. Regular expressions are a tool that is insufficiently sophisticated to understand the constructs employed by HTML. HTML is not a regular language and hence cannot be parsed by regular expressions. Regex queries are not equipped to break down HTML into its meaningful parts. so many times but it is not getting to me. Even enhanced irregular regular expressions as used by Perl are not up to the task of parsing HTML. You will never make me crack. HTML is a language of sufficient complexity that it cannot be parsed by regular expressions. Even Jon Skeet cannot parse HTML using regular expressions. Every time you attempt to parse HTML with regular expressions, the unholy child weeps the blood of virgins, and Russian hackers pwn your webapp. Parsing HTML with regex summons tainted souls into the realm of the living. HTML and regex go together like love, marriage, and ritual infanticide. The &lt;center&gt; cannot hold it is too late. The force of regex and HTML together in the same conceptual space will destroy your mind like so much watery putty. If you parse HTML with regex you are giving in to Them and their blasphemous ways which doom us all to inhuman toil for the One whose Name cannot be expressed in the Basic Multilingual Plane, he comes. HTML-plus-regexp will liquify the n​erves of the sentient whilst you observe, your psyche withering in the onslaught of horror. Rege̿̔̉x-based HTML parsers are the cancer that is killing StackOverflow <i>it is too late it is too late we cannot be saved</i> the transgression of a chi͡ld ensures regex will consume all living tissue (except for HTML which it cannot, as previously prophesied) <i>dear lord help us how can anyone survive this scourge</i> using regex to parse HTML has doomed humanity to an eternity of dread torture and security holes <i>using rege</i>x as a tool to process HTML establishes a brea<i>ch between this world</i> and the dread realm of c͒ͪo͛ͫrrupt entities (like SGML entities, but <i>more corrupt) a mere glimp</i>se of the world of reg​<b>ex parsers for HTML will ins</b>​tantly transport a p<i>rogrammer's consciousness i</i>nto a w<i>orl</i>d of ceaseless screaming, he comes<strike>, the pestilent sl</strike>ithy regex-infection wil​<b>l devour your HT</b>​ML parser, application and existence for all time like Visual Basic only worse <i>he comes he com</i>es <i>do not fi</i>​ght h<b>e com̡e̶s, ̕h̵i</b>​s un̨ho͞ly radiańcé de<i>stro҉ying all enli̍̈́̂̈́ghtenment, HTML tags <b>lea͠ki̧n͘g fr̶ǫm ̡yo​͟ur eye͢s̸ ̛l̕ik͏e liq</b>​uid p</i>ain, the song of re̸gular exp​re<strike>ssion parsing </strike>will exti<i>​nguish the voices of mor​<b>tal man from the sp</b>​here I can see it can you see ̲͚̖͔̙î̩́t̲͎̩̱͔́̋̀ it is beautiful t​</i>he f<code>inal snuf</code>fing o<i>f the lie​<b>s of Man ALL IS LOŚ͖̩͇̗̪̏̈́T A</b></i><b>LL I​S L</b>OST th<i>e pon̷y he come</i>s he c̶̮om<strike>es he co</strike><b><strike>me</strike>s t<i>he</i> ich​</b>or permeat<i>es al</i>l MY FAC<i>E MY FACE ᵒh god n<b>o NO NOO̼</b></i><b>O​O N</b>Θ stop t<i>he an​*̶͑̾̾​̅ͫ͏̙̤g͇̫͛͆̾ͫ̑͆l͖͉̗̩̳̟̍ͫͥͨ</i>e̠̅s<code> ͎a̧͈͖r̽̾̈́͒͑e</code> n<b>​ot rè̑ͧ̌aͨl̘̝̙̃ͤ͂̾̆ ZA̡͊͠͝LGΌ ISͮ̂҉̯͈͕̹̘̱ T</b>O͇̹̺ͅƝ̴ȳ̳ TH̘<b>Ë͖́̉ ͠P̯͍̭O̚​N̐Y̡ H̸̡̪̯ͨ͊̽̅̾̎Ȩ̬̩̾͛ͪ̈́̀́͘ ̶̧̨̱̹̭̯ͧ̾ͬC̷̙̲̝͖ͭ̏ͥͮ͟Oͮ͏̮̪̝͍M̲̖͊̒ͪͩͬ̚̚͜Ȇ̴̟̟͙̞ͩ͌͝</b>S̨̥̫͎̭ͯ̿̔̀ͅ</p>
     <hr>
     <p>Have you tried using an XML parser instead?</p>
     <hr>
     <blockquote>
      <p><strong>Moderator's Note</strong></p>
      <p>This post is locked to prevent inappropriate edits to its content. The post looks exactly as it is supposed to look - there are no problems with its content. Please do not flag it for our attention.</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>179</td>
        <td><span>Kobi: I think it's time for me to quit the post of Assistant Don't Parse HTML With Regex Officer. No matter how many times we say it, they won't stop coming every day... every hour even. It is a lost cause, which someone else can fight for a bit. So go on, parse HTML with regex, if you must. It's only broken code, not life and death.</span> <span> - </span> <span class="display-name">bobince</span> <span> </span> <span class="date">13 Nov 2009 at 23:18</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>If you can't see this post, here's a screencapture of it in all its glory: <a href="http://imgur.com/gOPS2.png" rel="nofollow noreferrer">imgur.com/gOPS2.png</a></span> <span> - </span> <span class="display-name">Andrew Keeton</span> <span> </span> <span class="date">19 Nov 2009 at 14:37</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3552</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Kaitlin Duck Sherwood</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Nov 2009 at 06:27</span>
     </div>
    </div>
    <div>
     <p>While <em>arbitrary</em> HTML with only a regex is impossible, it's sometimes appropriate to use them for parsing a <em>limited, known</em> set of HTML.</p>
     <p>If you have a small set of HTML pages that you want to scrape data from and then stuff into a database, regexes might work fine. For example, I recently wanted to get the names, parties, and districts of Australian federal Representatives, which I got off of the Parliament's web site. This was a limited, one-time job.</p>
     <p>Regexes worked just fine for me, and were very fast to set up.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>158</td>
        <td><span>Also, scraping fairly regularly formatted data from large documents is going to be WAY faster with judicious use of scan &amp; regex than any generic parser. And if you are comfortable with coding regexes, way faster to code than coding xpaths. And almost certainly less fragile to changes in what you are scraping. So bleh.</span> <span> - </span> <span class="display-name">Michael Johnston</span> <span> </span> <span class="date">17 Apr 2012 at 20:47</span></td>
       </tr>
       <tr>
        <td>312</td>
        <td><span>@MichaelJohnston "Less fragile"? Almost certainly not. Regexes care about text-formatting details than an XML parser can silently ignore. Switching between <code>&amp;foo;</code> encodings and <code>CDATA</code> sections? Using an HTML minifier to remove all whitespace in your document that the browser doesn't render? An XML parser won't care, and neither will a well-written XPath statement. A regex-based "parser", on the other hand...</span> <span> - </span> <span class="display-name">Charles Duffy</span> <span> </span> <span class="date">11 Jul 2012 at 16:03</span></td>
       </tr>
       <tr>
        <td>46</td>
        <td><span>@CharlesDuffy for an one time job it's ok, and for spaces we use \s+</span> <span> - </span> <span class="display-name">quantum</span> <span> </span> <span class="date">12 Jul 2012 at 13:50</span></td>
       </tr>
       <tr>
        <td>78</td>
        <td><span>@xiaomao indeed, if having to know all the gotchas and workarounds to get an 80% solution that fails the rest of the time "works for you", I can't stop you. Meanwhile, I'm over on my side of the fence using parsers that work on 100% of syntactically valid XML.</span> <span> - </span> <span class="display-name">Charles Duffy</span> <span> </span> <span class="date">12 Jul 2012 at 16:07</span></td>
       </tr>
       <tr>
        <td>432</td>
        <td><span>I once had to pull some data off ~10k pages, all with the same HTML template. They were littered with HTML errors that caused parsers to choke, and all their styling was inline or with <code>&lt;font&gt;</code> etc.: no classes or IDs to help navigate the DOM. After fighting all day with the "right" approach, I finally switched to a regex solution and had it working in an hour.</span> <span> - </span> <span class="display-name">Paul A Jungwirth</span> <span> </span> <span class="date">7 Sep 2012 at 07:14</span></td>
       </tr>
       <tr>
        <td>42</td>
        <td><span>@CharlesDuffy: definitely less fragile. When the third-party changes their html, they are much more likely to change the structure (breaking your xpaths) than the leaf nodes you are scraping. Scraping is not parsing. Scraping is pulling specific bits of data from a puddle of designer contaminated crap you don't care about. You DO NOT WANT to parse that puddle. You want to do only the absolute minimum amount of "parsing" that will get you your data. You don't CARE about the structure. You care about your bits of data.</span> <span> - </span> <span class="display-name">Michael Johnston</span> <span> </span> <span class="date">19 Nov 2013 at 03:23</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2297</span>
     </div>
     <div>
      <span>Answerer: </span> <span>NealB</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Nov 2009 at 18:42</span>
     </div>
    </div>
    <div>
     <p>I think the flaw here is that HTML is a <a href="http://en.wikipedia.org/wiki/Context-free_grammar" rel="noreferrer">Chomsky Type 2 grammar (context free grammar)</a> and a regular expression is a <a href="http://en.wikipedia.org/wiki/Regular_grammar" rel="noreferrer">Chomsky Type 3 grammar (regular grammar)</a>. Since a Type 2 grammar is fundamentally more complex than a Type 3 grammar (see the <a href="http://en.wikipedia.org/wiki/Chomsky_hierarchy" rel="noreferrer">Chomsky hierarchy</a>), you can't possibly make this work.</p>
     <p>But many will try, and some will even claim success - but until others find the fault and totally mess you up.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>274</td>
        <td><span>The OP is asking to parse a very limited subset of XHTML: start tags. What makes (X)HTML a CFG is its potential to have elements between the start and end tags of other elements (as in a grammar rule <code>A -&gt; s A e</code>). (X)HTML does <i>not</i> have this property <i>within</i> a start tag: a start tag cannot contain other start tags. The subset that the OP is trying to parse is not a CFG.</span> <span> - </span> <span class="display-name">LarsH</span> <span> </span> <span class="date">2 Mar 2012 at 08:43</span></td>
       </tr>
       <tr>
        <td>127</td>
        <td><span>In CS theory, regular languages <i>are</i> a strict subset of context-free languages, but regular expression implementations in mainstream programming languages are more powerful. As <a href="http://www.noulakaz.net/weblog/2007/03/18/a-regular-expression-to-check-for-prime-numbers/" rel="nofollow noreferrer">noulakaz.net/weblog/2007/03/18/…</a> describes, so-called "regular expressions" can check for prime numbers in unary, which is certainly something that a regular expression from CS theory can't accomplish.</span> <span> - </span> <span class="display-name">Adam Mihalcin</span> <span> </span> <span class="date">19 Mar 2012 at 23:50</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@LarsH, that may be strictly true, but only if you can depend on well-formedness. To be able to reliably parse even start tags one would have to accommodate a number of workarounds for (X)HTML syntax errors implemented in real world user agents, and even then probably cross fingers and pray.</span> <span> - </span> <span class="display-name">eyelidlessness</span> <span> </span> <span class="date">21 May 2012 at 21:04</span></td>
       </tr>
       <tr>
        <td>18</td>
        <td><span>@eyelidlessness: the same "only if" applies to all CFGs, does it not? I.e. if the (X)HTML input is not well-formed, not even a full-blown XML parser will work reliably. Maybe if you give examples of the "(X)HTML syntax errors implemented in real world user agents" you're referring to, I'll understand what you're getting at better.</span> <span> - </span> <span class="display-name">LarsH</span> <span> </span> <span class="date">22 May 2012 at 05:09</span></td>
       </tr>
       <tr>
        <td>99</td>
        <td><span>@AdamMihalcin is exactly right. Most extant regex engines are more powerful than Chomsky Type 3 grammars (eg non-greedy matching, backrefs). Some regex engines (such as Perl's) are Turing complete. It's true that even those are poor tools for parsing HTML, but this oft-cited argument is not the reason why.</span> <span> - </span> <span class="display-name">dubiousjim</span> <span> </span> <span class="date">31 May 2012 at 13:44</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>You are correct, I just want to drop this: You can write a finite state-machine that is equivalent to any regex expression (finite state-machines are equivalent in power to Type 3 languages.) But to parse HTML you need memory, there is this thing called pushdown automaton that is basically an state-machine with a stack to store values. That can be used to parse HTML, unfortunately it is pretty hard to describe a pushdown automaton in text language (like you can represent state-machines in regex,) it is easier to program it yourself.</span> <span> - </span> <span class="display-name">Hoffmann</span> <span> </span> <span class="date">1 Aug 2014 at 14:03</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>I used regex for a long time before learning the theory and when I was first told you can't parse things with regex I said that was nonsense which is kind of true, it depends what you mean. Language is ambiguous. You can't parse HTML using <i>only</i> regex. I was using regex but additionally with functions that provided the higher level elements for parsing such as maintaining a stack of the current nesting. I wouldn't try using regex alone for parsing anything complex even if it had added features to make it possible.</span> <span> - </span> <span class="display-name">jgmjgm</span> <span> </span> <span class="date">6 Sep 2015 at 23:52</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span>To say the grammar of language A dictates it's parsing capabilities of another language B based on its grammar, is not valid. For example, just because HTML is Chomsky Type 2 language, doesn't mean you could write pure HTML which could parse any Chomsky Type 3 language. HTML itself is not a language with any features that give it the ability to parse other languages. Please don't say "Javascript", because javascript is not parsed by something written in HTML.</span> <span> - </span> <span class="display-name">AaronLS</span> <span> </span> <span class="date">24 Nov 2015 at 23:54</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span>However, you are on the right track. Since HTML is a Chomsky Type 2 language, then to parse a Chomsky Type 2 language you generally need a stack capability within the parsing language(to track context). Regex doesn't have stack management capability: not because it is a Chomsky Type 3, but simply because the language was not designed with that capability. With some support for some extended constructs like recursion, it is possible in Regex, but would not be easy. Just as HTML lacks any capabilities to parse other languages, Regex lacks a stack capability needed to parse HTML.</span> <span> - </span> <span class="display-name">AaronLS</span> <span> </span> <span class="date">25 Nov 2015 at 00:03</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>FWIW HTML is not context-free (although the ways in which it is not are not relevant to this problem). For example, you cannot have unique ids in a context-free grammar.</span> <span> - </span> <span class="display-name">Tgr</span> <span> </span> <span class="date">16 Jan 2017 at 05:00</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>RegEx hasn't been limited to regular languages for 30 years now.</span> <span> - </span> <span class="display-name">Erik Reppen</span> <span> </span> <span class="date">30 Oct 2017 at 20:37</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1161</span>
     </div>
     <div>
      <span>Answerer: </span> <span>itsadok</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Nov 2009 at 06:37</span>
     </div>
    </div>
    <div>
     <p><strong>Disclaimer</strong>: use a parser if you have the option. That said...</p>
     <p>This is the regex I use (!) to match HTML tags:</p>
     <pre><code>&lt;(?:"[^"]*"['"]*|'[^']*'['"]*|[^'"&gt;])+&gt;
</code></pre>
     <p>It may not be perfect, but I ran this code through a <em>lot</em> of HTML. Note that it even catches strange things like <code>&lt;a name="badgenerator""&gt;</code>, which show up on the web.</p>
     <p>I guess to make it not match self contained tags, you'd either want to use <a href="https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732395#1732395">Kobi</a>'s negative look-behind:</p>
     <pre><code>&lt;(?:"[^"]*"['"]*|'[^']*'['"]*|[^'"&gt;])+(?&lt;!/\s*)&gt;
</code></pre>
     <p>or just combine if and if not.</p>
     <p><strong>To downvoters:</strong> This is working code from an actual product. I doubt anyone reading this page will get the impression that it is socially acceptable to use regexes on HTML.</p>
     <p><strong>Caveat</strong>: I should note that this regex still breaks down in the presence of CDATA blocks, comments, and script and style elements. Good news is, you can get rid of those using a regex...</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>120</td>
        <td><span>I would go with something that works on sane things than weep about not being universally perfect :-)</span> <span> - </span> <span class="display-name">prajeesh kumar</span> <span> </span> <span class="date">10 May 2012 at 03:44</span></td>
       </tr>
       <tr>
        <td>23</td>
        <td><span>so you do not actually solve the parsing problem with regexp only but as a part of the parser this may work. PS: working product doesn't mean good code. No offence, but this is how industrial programming works and gets their money</span> <span> - </span> <span class="display-name">mishmashru</span> <span> </span> <span class="date">19 Apr 2013 at 12:18</span></td>
       </tr>
       <tr>
        <td>42</td>
        <td><span>Your regex starts fail on the very shortest possible, valid HTML: <code>&lt;!doctype html&gt;&lt;title&gt;&lt;&lt;/title&gt;</code>. Simple <code>'&lt;!doctype html&gt;&lt;title&gt;&lt;&lt;/title&gt;'.match(/&lt;(?:"[^"]*"['"]*|'[^']*'['"]*|‌​[^'"&gt;])+&gt;/g)</code> returns <code>["&lt;!doctype html&gt;", "&lt;title&gt;", "&lt;&lt;/title&gt;"]</code> while should <code>["&lt;title&gt;", "&lt;/title&gt;"]</code>.</span> <span> - </span> <span class="display-name">user1180790</span> <span> </span> <span class="date">1 May 2014 at 16:48</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>if we're just trying to match &amp; not match the examples given, /&lt;.([^r&gt;][^&gt;]*)?&gt;/g works :-) // javascript: '&lt;p&gt; &lt;a href="foo"&gt; &lt;br /&gt; &lt;hr class="foo" /&gt;'.match(/&lt;.([^r&gt;][^&gt;]*)?&gt;/g)</span> <span> - </span> <span class="display-name">imma</span> <span> </span> <span class="date">22 May 2014 at 16:14</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>There is a difference between pattern matching a fragment of html and pattern matching html while ensuring a valid structure is returned. Tokenising HTML is probably easy with regex but then try dealing with: &lt;a&gt;&lt;/b&gt;</span> <span> - </span> <span class="display-name">jgmjgm</span> <span> </span> <span class="date">6 Sep 2015 at 23:55</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>"Is someone using CDATA inside HTML?" - yes, I do. It takes less bytes if you show HTML source code in <code>&lt;pre&gt;</code> tags.</span> <span> - </span> <span class="display-name">cweiske</span> <span> </span> <span class="date">14 Oct 2015 at 10:56</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Your regex <a href="https://regex101.com/r/WfRjbO/2" rel="nofollow noreferrer">fails with three false positives</a> in the basic set (first group after the blank initial line). The <a href="https://regex101.com/r/GIzRty/18" rel="nofollow noreferrer">regex I use to detect <i>possible</i> HTML</a> (detection, <b>not</b> parsing!) does not suffer these failures, additionally covers DOCTYPE and encoded entities.</span> <span> - </span> <span class="display-name">amcgregor</span> <span> </span> <span class="date">8 Apr 2020 at 17:32</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>This one for Python <a href="https://regex101.com/r/6IbTnI/1" rel="nofollow noreferrer">regex101.com/r/6IbTnI/1</a> , this one for PCRE <a href="https://regex101.com/r/p0t1H8/1" rel="nofollow noreferrer">regex101.com/r/p0t1H8/1</a></span> <span> - </span> <span class="display-name">user13843220</span> <span> </span> <span class="date">1 Oct 2020 at 20:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This partially matches comments, but not the whole thing.</span> <span> - </span> <span class="display-name">Cody</span> <span> </span> <span class="date">18 Nov 2021 at 00:08</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>584</span>
     </div>
     <div>
      <span>Answerer: </span> <span>xanatos</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Mar 2011 at 13:30</span>
     </div>
    </div>
    <div>
     <p>There are people that will tell you that the Earth is round (or perhaps that the Earth is an oblate spheroid if they want to use strange words). They are lying.</p>
     <p>There are people that will tell you that Regular Expressions shouldn't be recursive. They are limiting you. They need to subjugate you, and they do it by keeping you in ignorance.</p>
     <p>You can live in their reality or take the red pill.</p>
     <p>Like Lord Marshal (is he a relative of the Marshal .NET class?), I have seen the <strike>Underverse</strike> Stack Based Regex-Verse and returned with <strike>powers</strike> knowledge you can't imagine. Yes, I think there were an Old One or two protecting them, but they were watching football on the TV, so it wasn't difficult.</p>
     <p>I think the XML case is quite simple. The RegEx (in the .NET syntax), deflated and coded in base64 to make it easier to comprehend by your feeble mind, should be something like this:</p>
     <pre><code>7L0HYBxJliUmL23Ke39K9UrX4HShCIBgEyTYkEAQ7MGIzeaS7B1pRyMpqyqBymVWZV1mFkDM7Z28
995777333nvvvfe6O51OJ/ff/z9cZmQBbPbOStrJniGAqsgfP358Hz8itn6Po9/3eIue3+Px7/3F
86enJ8+/fHn64ujx7/t7vFuUd/Dx65fHJ6dHW9/7fd/t7fy+73Ye0v+f0v+Pv//JnTvureM3b169
OP7i9Ogyr5uiWt746u+BBqc/8dXx86PP7tzU9mfQ9tWrL18d3UGnW/z7nZ9htH/y9NXrsy9fvPjq
i5/46ss3p4z+x3e8b452f9/x93a2HxIkH44PpgeFyPD6lMAEHUdbcn8ffTP9fdTrz/8rBPCe05Iv
p9WsWF788Obl9MXJl0/PXnwONLozY747+t7x9k9l2z/4vv4kqo1//993+/vf2kC5HtwNcxXH4aOf
LRw2z9/v8WEz2LTZcpaV1TL/4c3h66ex2Xv95vjF0+PnX744PbrOm59ZVhso5UHYME/dfj768H7e
Yy5uQUydDAH9+/4eR11wHbqdfPnFF6cv3ogq/V23t++4z4620A13cSzd7O1s/77rpw+ePft916c7
O/jj2bNnT7e/t/397//M9+ibA/7s6ZNnz76PP0/kT2rz/Ts/s/0NArvziYxVEZWxbm93xsrUfnlm
rASN7Hf93u/97vvf+2Lx/e89L7+/FSXiz4Bkd/hF5mVq9Yik7fcncft9350QCu+efkr/P6BfntEv
z+iX9c4eBrFz7wEwpB9P+d9n9MfuM3yzt7Nzss0/nuJfbra3e4BvZFR7z07pj3s7O7uWJM8eCkme
nuCPp88MfW6kDeH7+26PSTX8vu+ePAAiO4LVp4zIPWC1t7O/8/+pMX3rzo2KhL7+8s23T1/RhP0e
vyvm8HbsdmPXYDVhtpdnAzJ1k1jeufOtUAM8ffP06Zcnb36fl6dPXh2f/F6nRvruyHfMd9rgJp0Y
gvsRx/6/ZUzfCtX4e5hTndGzp5jQo9e/z+s3p1/czAUMlts+P3tz+uo4tISd745uJxvb3/v4ZlWs
mrjfd9SG/swGPD/6+nh+9MF4brTBRmh1Tl5+9eT52ckt5oR0xldPzp7GR8pfuXf5PWJv4nJIwvbH
W3c+GY3vPvrs9zj8Xb/147/n7/b7/+52DD2gsSH8zGDvH9+i9/fu/PftTfTXYf5hB+9H7P1BeG52
MTtu4S2cTAjDizevv3ry+vSNb8N+3+/1po2anj4/hZsGt3TY4GmjYbEKDJ62/pHB+3/LmL62wdsU
1J18+eINzTJr3dMvXr75fX7m+MXvY9XxF2e/9+nTgPu2bgwh5U0f7u/74y9Pnh6/OX4PlA2UlwTn
xenJG8L996VhbP3++PCrV68QkrjveITxr2TIt+lL+f3k22fPn/6I6f/fMqZvqXN/K4Xps6sazUGZ
GeQlar49xEvajzI35VRevDl78/sc/b7f6jkG8Va/x52N4L9lBe/kZSh1hr9fPj19+ebbR4AifyuY
12efv5CgGh9TroR6Pj2l748iYxYgN8Z7pr0HzRLg66FnRvcjUft/45i+pRP08vTV6TOe2N/9jv37
R9P0/5YxbXQDeK5E9R12XdDA/4zop+/9Ht/65PtsDVlBBUqko986WsDoWqvbPD2gH/T01DAC1NVn
3/uZ0feZ+T77fd/GVMkA4KjeMcg6RcvQLRl8HyPaWVStdv17PwHV0bOB9xUh7rfMp5Zu3icBJp25
D6f0NhayHyfI3HXHY6YYCw7Pz17fEFhQKzS6ZWChrX+kUf7fMqavHViEPPKjCf1/y5hukcyPTvjP
mHQCppRDN4nbVFPaT8+ekpV5/TP8g/79mVPo77PT1/LL7/MzL7548+XvdfritflFY00fxIsvSQPS
mvctdYZpbt7vxKRfj3018OvC/hEf/79lTBvM3debWj+b8KO0wP+3OeM2aYHumuCAGonmCrxw9cVX
X1C2d4P+uSU7eoBUMzI3/f9udjbYl/el04dI7s8fan8dWRjm6gFx+NrKeFP+WX0CxBdPT58df/X8
DaWLX53+xFdnr06f/szv++NnX7x8fnb6NAhIwsbPkPS7iSUQAFETvP2Tx8+/Og0Xt/yBvDn9vd/c
etno8S+81QKXptq/ffzKZFZ+4e/743e8zxino+8RX37/k595h5/H28+y7fPv490hQdJ349E+txB3
zPZ5J/jsR8bs/y1j2hh/2fkayOqEmYcej0cXUWMN7QrqBwjDrVZRfyQM3xjj/EgYvo4wfLTZrnVS
ebdKq0XSZJvzajKQDUv1/P3NwbEP7cN5+Odivv9/ysPfhHfkOP6b9Fl+91v7LD9aCvp/+Zi+7lLQ
j0zwNzYFP+/Y6r1NcFeDbfBIo8rug3zS3/3WPumPlN3/y8f0I2X3cz4FP+/Y6htSdr2I42fEuSPX
/ewpL4e9/n1evzn94hb+Plpw2+dnbyh79zx0CsPvbq0lb+UQ/h7xvqPq/Gc24PnR18fzVrp8I57d
mehj7ebk5VdPnp+d3GJOSP189eTsaXyk/JV7l98j4SAZgRxtf7x155PR+O6jz36Pw9/1Wz/+e/5u
v//vbsfQAxobws8M9v7xLXp/785/395ED4nO1wx5fsTeH4LnRva+eYY8rpZUBFb/j/jfm8XAvfEj
4/b/ljF1F9B/jx5PhAkp1nu/+y3n+kdZp/93jWmjJ/M11TG++VEG6puZn593PPejoOyHMQU/79jq
GwrKfpSB+tmcwZ93XPkjZffDmIKfd2z1DSm7bmCoPPmjBNT74XkrVf71I/Sf6wTU7XJA4RB+lIC6
mW1+xN5GWw1/683C5rnj/m364cmr45Pf6/SN9H4Us4LISn355vjN2ZcvtDGT6fHvapJcMISmxc0K
MAD4IyP6/5Yx/SwkP360FvD1VTH191mURr/HUY+2P3I9boPnz7Ju/pHrcWPnP3I9/r/L3sN0v52z
0fEgNrgbL8/Evfh9fw/q5Xf93u/97vvf+2Lx/e89L7+/Fe3iZ37f34P5h178kTfx/5YxfUs8vY26
7/d4/OWbb5++ogn7PX5XzOHtOP3GrsHmqobOVO/8Hh1Gk/TPl198QS6w+rLb23fcZ0fMaTfjsv29
7Zul7me2v0FgRoYVURnf9nZEkDD+H2VDf8hjeq8xff1s6GbButNLacEtefHm9VdPXp++CRTw7/v9
r6vW8b9eJ0+/PIHzs1HHdyKE/x9L4Y+s2f+PJPX/1dbsJn3wrY6wiqv85vjVm9Pnp+DgN8efM5va
j794+eb36Xz3mAf5+58+f3r68s230dRvJcxKn/l//oh3f+7H9K2O0r05PXf85s2rH83f/1vGdAvd
w+qBFqsoWvzspozD77EpXYeZ7yzdfxy0ec+l+8e/8FbR84+Wd78xbvn/qQQMz/J7L++GPB7N0MQa
2vTMBwjDrVI0PxKGb4xxfiQMX0cYPuq/Fbx2C1sU8yEF+F34iNsx1xOGa9t6l/yX70uqmxu+qBGm
AxlxWwVS11O97ULqlsFIUvUnT4/fHIuL//3f9/t9J39Y9m8W/Tuc296yUeX/b0PiHwUeP1801Y8C
j/9vz9+PAo8f+Vq35Jb/n0rAz7Kv9aPA40fC8P+RMf3sC8PP08DjR1L3DXHoj6SuIz/CCghZNZb8
fb/Hf/2+37tjvuBY9vu3jmRvxNeGgQAuaAF6Pwj8/+e66M8/7rwpRNj6uVwXZRl52k0n3FVl95Q+
+fz0KSu73/dtkGDYdvZgSP5uskadrtViRKyal2IKAiQfiW+FI+tET/9/Txj9SFf8SFf8rOuKzagx
+r/vD34mUADO1P4/AQAA//8=
</code></pre>
     <p>The options to set is <code>RegexOptions.ExplicitCapture</code>. The capture group you are looking for is <code>ELEMENTNAME</code>. If the capture group <code>ERROR</code> is not empty then there was a parsing error and the Regex stopped.</p>
     <p>If you have problems reconverting it to a human-readable regex, this should help:</p>
     <pre class="lang-csharp prettyprint-override"><code>static string FromBase64(string str)
{
    byte[] byteArray = Convert.FromBase64String(str);

    using (var msIn = new MemoryStream(byteArray))
    using (var msOut = new MemoryStream()) {
        using (var ds = new DeflateStream(msIn, CompressionMode.Decompress)) {
            ds.CopyTo(msOut);
        }

        return Encoding.UTF8.GetString(msOut.ToArray());
    }
}
</code></pre>
     <p>If you are unsure, no, I'm NOT kidding (but perhaps I'm lying). It WILL work. I've built tons of unit tests to test it, and I have even used (part of) the <a href="http://www.w3.org/XML/Test/" rel="noreferrer">conformance tests</a>. It's a tokenizer, not a full-blown parser, so it will only split the XML into its component tokens. It won't parse/integrate DTDs.</p>
     <p>Oh... if you want the source code of the regex, with some auxiliary methods:</p>
     <p><a href="http://pastebin.com/hzYazFVb" rel="noreferrer">regex to tokenize an xml</a> or <a href="https://topaz.github.io/paste/#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" rel="noreferrer">the full plain regex</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>71</td>
        <td><span>not-sure-if-serious.jpg -- hopefully this is brilliant satire</span> <span> - </span> <span class="display-name">Brad Mace</span> <span> </span> <span class="date">8 Mar 2011 at 14:53</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span>@bemace You can try it... In a VM... disconnected from the Internet and from your LAN... Using a 10 foot pole to run it! :-)</span> <span> - </span> <span class="display-name">xanatos</span> <span> </span> <span class="date">8 Mar 2011 at 14:58</span></td>
       </tr>
       <tr>
        <td>84</td>
        <td><span>Good Lord, it's massive. My biggest question is why? You realize that all modern languages have XML parsers, right? You can do all that in like 3 lines and be sure it'll work. Furthermore, do you also realize that pure regex is <b>provably</b> unable to do certain things? Unless you've created a hybrid regex/imperative code parser, but it doesn't look like you have. Can you compress random data as well?</span> <span> - </span> <span class="display-name">Justin Morgan - On strike</span> <span> </span> <span class="date">8 Mar 2011 at 15:23</span></td>
       </tr>
       <tr>
        <td>151</td>
        <td><span>@Justin I don't need a reason. It could be done (and it wasn't illegal/immoral), so I have done it. There are no limitations to the mind except those we acknowledge (Napoleon Hill)... Modern languages can parse XML? Really? And I thought that THAT was illegal! :-)</span> <span> - </span> <span class="display-name">xanatos</span> <span> </span> <span class="date">8 Mar 2011 at 15:31</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>Well, we're talking about the theoretical limits of the language; it's not like we just haven't figured out how to do it yet. If you use pure regex, there's always going to be some (X)HTML valid code that breaks it. Maybe it's <code>&lt;foo bar="baz &gt; quux"&gt;</code> or maybe it's a certain nesting depth. Not that I didn't find your post funny (Old Ones - hah!)</span> <span> - </span> <span class="display-name">Justin Morgan - On strike</span> <span> </span> <span class="date">8 Mar 2011 at 15:42</span></td>
       </tr>
       <tr>
        <td>10</td>
        <td><span>Don't try it! If you do, the entire internet will be compressed to a quantum singularity and sucked down the rabbit hole!</span> <span> - </span> <span class="display-name">Christian Hayter</span> <span> </span> <span class="date">8 Mar 2011 at 16:47</span></td>
       </tr>
       <tr>
        <td>94</td>
        <td><span>Sir, I'm convinced. I'm going to use this code as part of the kernel for my perpetual-motion machine--can you believe those fools at the patent office keep rejecting my application? Well, I'll show them. I'll show them all!</span> <span> - </span> <span class="display-name">Justin Morgan - On strike</span> <span> </span> <span class="date">8 Mar 2011 at 17:55</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>@Justin Unless there is a bug, or unless the memory becomes full, I'm pretty sure that any VALID XML can be tokenized. As @John-David Dalton noticed, the specifics of XML are given in Regex-like expressions, so it was quite easy (if not long and harduous)</span> <span> - </span> <span class="display-name">xanatos</span> <span> </span> <span class="date">8 Mar 2011 at 18:35</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>Does it work for <code>&lt;foo bar="baz &gt; quux"&gt;</code>? Because that is in fact valid. So is stuff like <code>&lt;foo bar='"baz" &gt; \'quux\''&gt;</code>. There's a LOT of stuff that looks "wrong" but is still valid XML.</span> <span> - </span> <span class="display-name">Justin Morgan - On strike</span> <span> </span> <span class="date">8 Mar 2011 at 21:51</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>@justin The second one is illegal, you can't escape the quotes with a \ . The first one will work if you close the foo.</span> <span> - </span> <span class="display-name">xanatos</span> <span> </span> <span class="date">9 Mar 2011 at 01:46</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>@justin And if you don't trust me, <a href="http://stackoverflow.com/questions/1222367/escape-quote-character-in-xml" title="escape quote character in xml">stackoverflow.com/questions/1222367/…</a></span> <span> - </span> <span class="display-name">xanatos</span> <span> </span> <span class="date">9 Mar 2011 at 01:54</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>Huh, looks like I stand corrected on that one. Fair enough. The basic point is more or less the same, though: Just because you haven't figured out how to break it yet, that doesn't mean it always works. And if it doesn't always work, what's the point? An HTML parser will be more practical AND catch everything.</span> <span> - </span> <span class="display-name">Justin Morgan - On strike</span> <span> </span> <span class="date">9 Mar 2011 at 15:06</span></td>
       </tr>
       <tr>
        <td>34</td>
        <td><span>@Justin So an Xml Parser is by definition bug free, while a Regex isn't? Because if an Xml Parser isn't bug free by definition there could be an xml that make it crash and we are back to step 0. Let say this: both the Xml Parser and this Regex try to be able to parse all the "legal" XML. They CAN parse some "illegal" XML. Bugs could crash both of them. C# XmlReader is surely more tested than this Regex.</span> <span> - </span> <span class="display-name">xanatos</span> <span> </span> <span class="date">9 Mar 2011 at 15:08</span></td>
       </tr>
       <tr>
        <td>43</td>
        <td><span>No, nothing is bug free: 1) All programs contain at least one bug. 2) All programs contain at least one line of unnecessary source code. 3) By #1 and #2 and using logical induction, it's a simple matter to prove that any program can be reduced to a single line of code with a bug. (from Learning Perl)</span> <span> - </span> <span class="display-name">Scott Weaver</span> <span> </span> <span class="date">16 Feb 2012 at 00:53</span></td>
       </tr>
       <tr>
        <td>24</td>
        <td><span>Nope, not all XML parsers are free of defects. Not all cars are free of defects, but it's a lot easier to buy one than it is to grow a mutant ant big enough to ride. You've spent hours constructing a mutant ant recipe which <i>may or may not</i> work at all, and may even be biologically impossible. Meanwhile, there's a perfectly good car sitting there.</span> <span> - </span> <span class="display-name">Justin Morgan - On strike</span> <span> </span> <span class="date">16 May 2012 at 19:41</span></td>
       </tr>
       <tr>
        <td>9</td>
        <td><span>The .NET regular language <i>does</i> span XML, and so you <i>can</i> tokenize XML with a .NET regular expression. Tokenization and parsing are very very far from the same. The above regex will accept &lt;A&gt;&lt;B&gt;&lt;C&gt;&lt;/B&gt;&lt;/C&gt;&lt;/A&gt; (I presume). It is a valid sequence of Xml tokens. This string is in the <i>language</i> of XML tokens. It is not in the language of XML, but that doesn't mean it cannot be tokenized. Just because you cannot parse something doesn't mean that it can't be tokenized. LR(0) parsers can't parse binary strings "00011", but the regex [01]* sure can tokenize them.</span> <span> - </span> <span class="display-name">Michael Graczyk</span> <span> </span> <span class="date">16 Jul 2012 at 02:51</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>LR(0) can't parse them because they are left recursive, btw.</span> <span> - </span> <span class="display-name">Michael Graczyk</span> <span> </span> <span class="date">16 Jul 2012 at 02:51</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@MichaelGraczyk I remember correctly, the above regex <i>won't</i> accept <code>&lt;A&gt;&lt;B&gt;&lt;C&gt;&lt;/B&gt;&lt;/C&gt;&lt;/A&gt;</code>. It is a stateful tokenizer, not a stateless tokenizer.</span> <span> - </span> <span class="display-name">xanatos</span> <span> </span> <span class="date">16 Jul 2012 at 04:32</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>In that case, it isn't a <i>regular</i> expression proper. If it uses backtracking at all, or for whatever reason cannot be expressed in terms of empty strings, literals, and the empty set with concatenations, alternations, Kleene stars thereof (inductive concatenations), then it isn't <i>formally</i> regular. A lot of people here seem to think that all "regular expressions" are true, formal <i>regular</i> expressions. It's true that Thompson NFA regular expressions are not true <i>regular expressions</i>, and are not recursive. However, PCRE regex is not truly <i>regular</i>, and hence can be recursive.</span> <span> - </span> <span class="display-name">Michael Graczyk</span> <span> </span> <span class="date">16 Jul 2012 at 05:00</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Of course, you never said that it was a proper regular expression. You just accurately stated that it would tokenize XML.</span> <span> - </span> <span class="display-name">Michael Graczyk</span> <span> </span> <span class="date">16 Jul 2012 at 05:00</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Actually, an algorithm <b>CAN</b> be made to compress random data. It would search through all seeds and compare them to the random data to find what seed was used, and find the algorithm used. Then all of that random data can be compressed down to a seed, length, and algorithm. <b>Only problem: it would take <i>days</i>.</b> :-)</span> <span> - </span> <span class="display-name">uınbɐɥs</span> <span> </span> <span class="date">2 Aug 2012 at 04:37</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>@ShaquinTrifonoff - Then it's not actually random. <a href="http://en.wikipedia.org/wiki/Lossless_data_compression#The_Million_Random_Number_Challenge" rel="nofollow noreferrer">I think your idea of random data is different from mine</a>.</span> <span> - </span> <span class="display-name">Justin Morgan - On strike</span> <span> </span> <span class="date">9 Aug 2012 at 19:38</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@JustinMorgan - You're right. I was thinking of 'normal' random numbers produced by the browser - see <a href="http://packetstorm.wowhacker.com/papers/general/Temporary_User_Tracking_in_Major_Browsers.pdf" rel="nofollow noreferrer">Temporary User Tracking In Major Browsers</a>. That document was originally <a href="http://www.trusteer.com/sites/default/files/Temporary_User_Tracking_in_Major_Browsers.pdf" rel="nofollow noreferrer">here</a>, but has since been removed.</span> <span> - </span> <span class="display-name">uınbɐɥs</span> <span> </span> <span class="date">9 Aug 2012 at 21:04</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>This isn't regex, this is full blown parser! While it's perfectly fine to tokenize bits of string by regex, you need some functions around that to make it into a real parser, and that's exactly what this is. By "parsing html with regex", I imagine regex-only-"parser", which is obviously impossible. This is just C# parser that uses regexes every now and then, not regex parser.</span> <span> - </span> <span class="display-name">enrey</span> <span> </span> <span class="date">1 Jun 2013 at 12:59</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This is certainly the second best answer here, particularly because the other top answers make fun of the idea of parsing HTML with regex while this one literally succeeds at just that. The only dispute is that PCRE is not <i>mathematically</i> considered a regular expression language: the naysayers hinge their argument on the opinion that regular expressions cannot be recursive. My response? The OP said nothing about regular expressions and only asked for a regex. And yes there is a difference, you just need to take the red pill to see it: <a href="http://www.rexegg.com/regex-vs-regular-expression.html" rel="nofollow noreferrer">rexegg.com/regex-vs-regular-expression.html</a></span> <span> - </span> <span class="display-name">Pluto</span> <span> </span> <span class="date">22 Apr 2021 at 15:36</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>If anyone wants to deflate the base64 string (saved in my case as xml-parser.b64) on the command prompt, you can try this: <code>printf "\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\x00" | cat - &lt;(base64 -d xml-regex.b64 ) | gunzip</code></span> <span> - </span> <span class="display-name">Alexander Stumpf</span> <span> </span> <span class="date">20 Jun 2022 at 09:35</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>316</span>
     </div>
     <div>
      <span>Answerer: </span> <span>dubiousjim</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Feb 2010 at 00:55</span>
     </div>
    </div>
    <div>
     <p>In shell, you can parse <a href="https://en.wikipedia.org/wiki/HTML" rel="noreferrer">HTML</a> using <a href="https://en.wikipedia.org/wiki/Sed" rel="noreferrer">sed</a>:</p>
     <ol>
      <li><a href="http://sed.sourceforge.net/grabbag/scripts/turing.sed" rel="noreferrer">Turing.sed</a></li>
      <li>Write HTML parser (homework)</li>
      <li>???</li>
      <li>Profit!</li>
     </ol>
     <hr>
     <p>Related (why you shouldn't use regex match):</p>
     <ul>
      <li><a href="https://blog.codinghorror.com/if-you-like-regular-expressions-so-much-why-dont-you-marry-them/" rel="noreferrer">If You Like Regular Expressions So Much, Why Don't You Marry Them?</a></li>
      <li><a href="https://blog.codinghorror.com/regular-expressions-now-you-have-two-problems/" rel="noreferrer">Regular Expressions: Now You Have Two Problems</a></li>
      <li><a href="http://danlec.com/blog/hacking-stackoverflow-com-s-html-sanitizer" rel="noreferrer">Hacking stackoverflow.com's HTML sanitizer</a></li>
     </ul>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>I’m afraid you did not get the joke, @kenorb. Please, read the question and the accepted answer once more. This is not about HTML parsing tools in general, nor about HTML parsing shell tools, it’s about parsing HTML via regexes.</span> <span> - </span> <span class="display-name">Palec</span> <span> </span> <span class="date">13 Oct 2015 at 08:12</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Palec I don't get the joke either. Is it nearly impossible to parse HTML with regex?</span> <span> - </span> <span class="display-name">Honinbo Shusaku</span> <span> </span> <span class="date">24 Mar 2017 at 11:49</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>No, @Abdul. It is completely, provably (in the mathematical sense) impossible.</span> <span> - </span> <span class="display-name">Palec</span> <span> </span> <span class="date">24 Mar 2017 at 13:24</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Palec Is that mathematical sense in relation to VladGudim's answer on the grammar types? Or something else?</span> <span> - </span> <span class="display-name">Honinbo Shusaku</span> <span> </span> <span class="date">24 Mar 2017 at 13:47</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>Yes, that answer summarizes it well, @Abdul. Note that, however, regex implementations are not really <i>regular</i> expressions in the mathematical sense -- they have constructs that make them stronger, often Turing-complete (equivalent to Type 0 grammars). The argument breaks with this fact, but is still somewhat valid in the sense that regexes were never meant to be capable of doing such a job, though.</span> <span> - </span> <span class="display-name">Palec</span> <span> </span> <span class="date">24 Mar 2017 at 14:24</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>And by the way, the joke I referred to was the content of this answer before kenorb's (radical) edits, specifically revision 4, @Abdul.</span> <span> - </span> <span class="display-name">Palec</span> <span> </span> <span class="date">24 Mar 2017 at 14:26</span></td>
       </tr>
       <tr>
        <td>12</td>
        <td><span>The funny thing is that OP never asked to parse html using regex. He asked to match text (which happens to be HTML) using regex. Which is perfectly reasonable.</span> <span> - </span> <span class="display-name">Paralife</span> <span> </span> <span class="date">29 Mar 2018 at 15:29</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>293</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Sam</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Sep 2011 at 04:01</span>
     </div>
    </div>
    <div>
     <p>I agree that the right tool to parse XML and <em>especially HTML</em> is a parser and not a regular expression engine. However, like others have pointed out, sometimes using a regex is quicker, easier, and gets the job done if you know the data format.</p>
     <p>Microsoft actually has a section of <a href="https://learn.microsoft.com/dotnet/standard/base-types/best-practices" rel="noreferrer">Best Practices for Regular Expressions in the .NET Framework</a> and specifically talks about <a href="https://learn.microsoft.com/dotnet/standard/base-types/best-practices#consider-the-input-source" rel="noreferrer">Consider[ing] the Input Source</a>.</p>
     <p>Regular Expressions do have limitations, but have you considered the following?</p>
     <p>The .NET framework is unique when it comes to regular expressions in that it supports <a href="https://learn.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition" rel="noreferrer">Balancing Group Definitions</a>.</p>
     <ul>
      <li>See <a href="https://weblogs.asp.net/whaggard/377025" rel="noreferrer">Matching Balanced Constructs with .NET Regular Expressions</a></li>
      <li>See <a href="https://learn.microsoft.com/archive/blogs/bclteam/net-regular-expressions-regex-and-balanced-matching-ryan-byington" rel="noreferrer">.NET Regular Expressions: Regex and Balanced Matching</a></li>
      <li>See Microsoft's docs on <a href="https://learn.microsoft.com/dotnet/standard/base-types/grouping-constructs-in-regular-expressions#balancing_group_definition" rel="noreferrer">Balancing Group Definitions</a></li>
     </ul>
     <p>For this reason, I believe you CAN parse XML using regular expressions. Note however, that it <strong>must be valid XML</strong> (<em>browsers are very forgiving of HTML and allow bad XML syntax inside HTML</em>). This is possible since the "Balancing Group Definition" will allow the regular expression engine to act as a PDA.</p>
     <p>Quote from article 1 cited above:</p>
     <blockquote>
      <p><strong>.NET Regular Expression Engine</strong></p>
      <p>As described above properly balanced constructs cannot be described by a regular expression. However, the .NET regular expression engine provides a few constructs that allow balanced constructs to be recognized.</p>
      <ul>
       <li><code>(?&lt;group&gt;)</code> - pushes the captured result on the capture stack with the name group.</li>
       <li><code>(?&lt;-group&gt;)</code> - pops the top most capture with the name group off the capture stack.</li>
       <li><code>(?(group)yes|no)</code> - matches the yes part if there exists a group with the name group otherwise matches no part.</li>
      </ul>
      <p>These constructs allow for a .NET regular expression to emulate a restricted PDA by essentially allowing simple versions of the stack operations: push, pop and empty. The simple operations are pretty much equivalent to increment, decrement and compare to zero respectively. This allows for the .NET regular expression engine to recognize a subset of the context-free languages, in particular the ones that only require a simple counter. This in turn allows for the non-traditional .NET regular expressions to recognize individual properly balanced constructs.</p>
     </blockquote>
     <p>Consider the following regular expression:</p>
     <pre class="lang-none prettyprint-override"><code>(?=&lt;ul\s+id="matchMe"\s+type="square"\s*&gt;)
(?&gt;
   &lt;!-- .*? --&gt;                  |
   &lt;[^&gt;]*/&gt;                      |
   (?&lt;opentag&gt;&lt;(?!/)[^&gt;]*[^/]&gt;)  |
   (?&lt;-opentag&gt;&lt;/[^&gt;]*[^/]&gt;)     |
   [^&lt;&gt;]*
)*
(?(opentag)(?!))
</code></pre>
     <p>Use the flags:</p>
     <ul>
      <li>Singleline</li>
      <li>IgnorePatternWhitespace (not necessary if you collapse regex and remove all whitespace)</li>
      <li>IgnoreCase (not necessary)</li>
     </ul>
     <h2>Regular Expression Explained (inline)</h2>
     <pre class="lang-none prettyprint-override"><code>(?=&lt;ul\s+id="matchMe"\s+type="square"\s*&gt;) # match start with &lt;ul id="matchMe"...
(?&gt;                                        # atomic group / don't backtrack (faster)
   &lt;!-- .*? --&gt;                 |          # match xml / html comment
   &lt;[^&gt;]*/&gt;                     |          # self closing tag
   (?&lt;opentag&gt;&lt;(?!/)[^&gt;]*[^/]&gt;) |          # push opening xml tag
   (?&lt;-opentag&gt;&lt;/[^&gt;]*[^/]&gt;)    |          # pop closing xml tag
   [^&lt;&gt;]*                                  # something between tags
)*                                         # match as many xml tags as possible
(?(opentag)(?!))                           # ensure no 'opentag' groups are on stack
</code></pre>
     <p>You can try this at <a href="http://derekslager.com/blog/posts/2007/09/a-better-dotnet-regular-expression-tester.ashx" rel="noreferrer">A Better .NET Regular Expression Tester</a>.</p>
     <p>I used the sample source of:</p>
     <pre><code>&lt;html&gt;
&lt;body&gt;
&lt;div&gt;
   &lt;br /&gt;
   &lt;ul id="matchMe" type="square"&gt;
      &lt;li&gt;stuff...&lt;/li&gt;
      &lt;li&gt;more stuff&lt;/li&gt;
      &lt;li&gt;
          &lt;div&gt;
               &lt;span&gt;still more&lt;/span&gt;
               &lt;ul&gt;
                    &lt;li&gt;Another &amp;gt;ul&amp;lt;, oh my!&lt;/li&gt;
                    &lt;li&gt;...&lt;/li&gt;
               &lt;/ul&gt;
          &lt;/div&gt;
      &lt;/li&gt;
   &lt;/ul&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
     <p>This found the match:</p>
     <pre><code>   &lt;ul id="matchMe" type="square"&gt;
      &lt;li&gt;stuff...&lt;/li&gt;
      &lt;li&gt;more stuff&lt;/li&gt;
      &lt;li&gt;
          &lt;div&gt;
               &lt;span&gt;still more&lt;/span&gt;
               &lt;ul&gt;
                    &lt;li&gt;Another &amp;gt;ul&amp;lt;, oh my!&lt;/li&gt;
                    &lt;li&gt;...&lt;/li&gt;
               &lt;/ul&gt;
          &lt;/div&gt;
      &lt;/li&gt;
   &lt;/ul&gt;
</code></pre>
     <p>although it actually came out like this:</p>
     <pre><code>&lt;ul id="matchMe" type="square"&gt;           &lt;li&gt;stuff...&lt;/li&gt;           &lt;li&gt;more stuff&lt;/li&gt;           &lt;li&gt;               &lt;div&gt;                    &lt;span&gt;still more&lt;/span&gt;                    &lt;ul&gt;                         &lt;li&gt;Another &amp;gt;ul&amp;lt;, oh my!&lt;/li&gt;                         &lt;li&gt;...&lt;/li&gt;                    &lt;/ul&gt;               &lt;/div&gt;           &lt;/li&gt;        &lt;/ul&gt;
</code></pre>
     <p>Lastly, I really enjoyed Jeff Atwood's article: <a href="https://blog.codinghorror.com/parsing-html-the-cthulhu-way/" rel="noreferrer">Parsing Html The Cthulhu Way</a>. Funny enough, it cites the answer to this question that currently has over 4k votes.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>19</td>
        <td><span><code>System.Text</code> is not part of C#. It's part of .NET.</span> <span> - </span> <span class="display-name">John Saunders</span> <span> </span> <span class="date">2 Feb 2012 at 19:07</span></td>
       </tr>
       <tr>
        <td>8</td>
        <td><span>In the first line of your regex (<code>(?=&lt;ul\s*id="matchMe"\s*type="square"\s*&gt;) # match start with &lt;ul id="matchMe"...</code>), in between "&lt;ul" and "id" should be <code>\s+</code>, not <code>\s*</code>, unless you want it to match &lt;ulid=... ;)</span> <span> - </span> <span class="display-name">C0deH4cker</span> <span> </span> <span class="date">6 Jul 2012 at 02:49</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@C0deH4cker You are correct, the expression should have <code>\s+</code> instead of <code>\s*</code>.</span> <span> - </span> <span class="display-name">Sam</span> <span> </span> <span class="date">6 Jul 2012 at 22:33</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>Not that I really understand it, but I think your regex fails on <code>&lt;img src="images/pic.jpg" /&gt;</code></span> <span> - </span> <span class="display-name">Scheintod</span> <span> </span> <span class="date">27 Sep 2013 at 17:05</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@Scheintod Thank you for the comment. I updated the code. The previous expression failed for self closing tags that had a <code>/</code> somewhere inside which failed for your <code>&lt;img src="images/pic.jpg" /&gt;</code> html.</span> <span> - </span> <span class="display-name">Sam</span> <span> </span> <span class="date">27 Sep 2013 at 19:00</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>It's an interesting regex approach! I just noticed that if you add <code>&lt;br / &gt;</code> (with a space after the slash) inside a child of the <code>&lt;ul&gt;</code> you are looking for, then the pattern will also match the closing <code>&lt;/div&gt;</code> because the self-closing tag pattern should be <code>&lt;[^&gt;]*/\s*&gt;</code>. Spaces are also allowed in closing tags. I came up with these minor corrections: <a href="https://regex101.com/r/tUtKXj/1" rel="nofollow noreferrer">regex101.com/r/tUtKXj/1</a> So this typically shows that even advanced regular expressions like your very nice one may break on valid HTML if we don't think at everything :-/</span> <span> - </span> <span class="display-name">Patrick Janser</span> <span> </span> <span class="date">2 Jun 2023 at 10:18</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>267</span>
     </div>
     <div>
      <span>Answerer: </span> <span>John Fiala</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 Nov 2009 at 23:44</span>
     </div>
    </div>
    <div>
     <p>I suggest using <a href="http://querypath.org/" rel="noreferrer">QueryPath</a> for parsing XML and HTML in PHP. It's basically much the same syntax as jQuery, only it's on the server side.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>9</td>
        <td><span>@Kyle—jQuery does not parse XML, it uses the client's built–in parser (if there is one). Therefore you do not need jQuery to do it, but as little as two lines of <a href="https://developer.mozilla.org/en-US/docs/Parsing_and_serializing_XML" rel="nofollow noreferrer">plain old JavaScript</a>. If there is no built–in parser, jQuery will not help.</span> <span> - </span> <span class="display-name">RobG</span> <span> </span> <span class="date">31 Oct 2013 at 06:25</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@RobG Actually jQuery uses the DOM, not the built-in parser.</span> <span> - </span> <span class="display-name">Qix - MONICA WAS MISTREATED</span> <span> </span> <span class="date">22 Sep 2014 at 03:49</span></td>
       </tr>
       <tr>
        <td>12</td>
        <td><span>@Qix—you'd better tell the authors of the documentation then: "<i>jQuery.parseXML uses the native parsing function of the browser…</i>". Source: <a href="http://api.jquery.com/jQuery.parseXML/" rel="nofollow noreferrer"><i>jQuery.parseXML()</i></a></span> <span> - </span> <span class="display-name">RobG</span> <span> </span> <span class="date">22 Sep 2014 at 05:01</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>Having come here from the meme question (<a href="http://meta.stackexchange.com/questions/19478/the-many-memes-of-meta/19479#19479" title="the many memes of meta">meta.stackexchange.com/questions/19478/the-many-memes-of-me‌​ta/…</a>), I love that one of the answers is 'Use jQuery'</span> <span> - </span> <span class="display-name">Jorn</span> <span> </span> <span class="date">1 Apr 2016 at 21:09</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>236</span>
     </div>
     <div>
      <span>Answerer: </span> <span>moritz</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Jan 2010 at 12:54</span>
     </div>
    </div>
    <div>
     <p>While the answers that you can't parse HTML with regexes are correct, they don't apply here. The OP just wants to parse one HTML tag with regexes, and that is something that can be done with a regular expression.</p>
     <p>The suggested regex is wrong, though:</p>
     <pre><code>&lt;([a-z]+) *[^/]*?&gt;
</code></pre>
     <p>If you add something to the regex, by backtracking it can be forced to match silly things like <code>&lt;a &gt;&gt;</code>, <code>[^/]</code> is too permissive. Also note that <code>&lt;space&gt;*[^/]*</code> is redundant, because the <code>[^/]*</code> can also match spaces.</p>
     <p>My suggestion would be</p>
     <pre><code>&lt;([a-z]+)[^&gt;]*(?&lt;!/)&gt;
</code></pre>
     <p>Where <code>(?&lt;! ... )</code> is (in Perl regexes) the negative look-behind. It reads "a &lt;, then a word, then anything that's not a &gt;, the last of which may not be a /, followed by &gt;".</p>
     <p>Note that this allows things like <code>&lt;a/ &gt;</code> (just like the original regex), so if you want something more restrictive, you need to build a regex to match attribute pairs separated by spaces.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>31</td>
        <td><span>+1 for noting that the question is not about parsing full (X)HTML, it's about matching (X)HTML open tags.</span> <span> - </span> <span class="display-name">LarsH</span> <span> </span> <span class="date">8 Sep 2012 at 02:26</span></td>
       </tr>
       <tr>
        <td>11</td>
        <td><span>Something else most of the answers seem to ignore, is that an HTML parser can very well use regular expressions in its implementation for parts of HTML, and I would be surprised if most parsers didn't do this.</span> <span> - </span> <span class="display-name">Thayne</span> <span> </span> <span class="date">26 Mar 2015 at 19:15</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@Thayne Exactly. When parsing individual tags, a regular expression is the right tool for the job. It is quite ridiculous that one has to scroll halfway down the page to find a reasonable answer. The accepted answer is incorrect because it mixes up lexing and parsing.</span> <span> - </span> <span class="display-name">kasperd</span> <span> </span> <span class="date">22 Nov 2015 at 10:26</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>The answer given here will fail when an attribute value contains a '&gt;' or '/' character.</span> <span> - </span> <span class="display-name">Martin L</span> <span> </span> <span class="date">21 Apr 2016 at 08:14</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>This will work incorrectly on HTML containing comments or CData sections. It will also not work correctly if a quoted attribute contains a <code>&gt;</code> character. I agree what OP suggest <i>can</i> be done with a regex, but the one presented here is far to simplistic.</span> <span> - </span> <span class="display-name">JacquesB</span> <span> </span> <span class="date">30 Jul 2017 at 10:14</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>The <code>&lt;h1&gt;</code> tag would like a word with you (easily fixed, I know, but still)...</span> <span> - </span> <span class="display-name">jimbobmcgee</span> <span> </span> <span class="date">7 May 2020 at 18:28</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>195</span>
     </div>
     <div>
      <span>Answerer: </span> <span>cytinus</span>
     </div>
     <div>
      <span> Answered: </span> <span>17 May 2012 at 10:13</span>
     </div>
    </div>
    <div>
     <p>Sun Tzu, an ancient Chinese strategist, general, and philosopher, said:</p>
     <blockquote>
      <p>It is said that if you know your enemies and know yourself, you can win a hundred battles without a single loss. If you only know yourself, but not your opponent, you may win or may lose. If you know neither yourself nor your enemy, you will always endanger yourself.</p>
     </blockquote>
     <p>In this case your enemy is HTML and you are either yourself or regex. You might even be Perl with irregular regex. Know HTML. Know yourself.</p>
     <p>I have composed a haiku describing the nature of HTML.</p>
     <pre><code>HTML has
complexity exceeding
regular language.
</code></pre>
     <p>I have also composed a haiku describing the nature of regex in Perl.</p>
     <pre><code>The regex you seek
is defined within the phrase
&lt;([a-zA-Z]+)(?:[^&gt;]*[^/]*)?&gt;
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>193</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Kobi</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 Nov 2009 at 22:50</span>
     </div>
    </div>
    <div>
     <p>Try:</p>
     <pre><code>&lt;([^\s]+)(\s[^&gt;]*?)?(?&lt;!/)&gt;
</code></pre>
     <p>It is similar to yours, but the last <code>&gt;</code> must not be after a slash, and also accepts <code>h1</code>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>115</td>
        <td><span>&lt;a href="foo" title="5&gt;3"&gt; Oops &lt;/a&gt;</span> <span> - </span> <span class="display-name">Gareth</span> <span> </span> <span class="date">13 Nov 2009 at 23:11</span></td>
       </tr>
       <tr>
        <td>67</td>
        <td><span><code>&gt;</code> is valid in an attribute value. Indeed, in the ‘canonical XML’ serialisation you must not use <code>&amp;gt;</code>. (Which isn't entirely relevant, except to emphasise that <code>&gt;</code> in an attribute value is not at all an unusual thing.)</span> <span> - </span> <span class="display-name">bobince</span> <span> </span> <span class="date">14 Nov 2009 at 00:15</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>@Kobi: what does the exlamation mark (the one you placed tpward the end) mean in a regexp?</span> <span> - </span> <span class="display-name">Marco Demaio</span> <span> </span> <span class="date">30 Apr 2011 at 17:16</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>@bobince: are u sure? I don't understand anymore, so is this valid HTML too: <code>&lt;div title="this tag is a &lt;div&gt;&lt;/div&gt;"&gt;hello&lt;/div&gt;</code></span> <span> - </span> <span class="display-name">Marco Demaio</span> <span> </span> <span class="date">30 Apr 2011 at 17:31</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@MarcoDemaio - <code>&gt;</code> does not have to be escaped in an attribute value, but <code>&lt;</code> does. So this is would be valid HTML: <code>&lt;div title="this tag is a &amp;lt;div&gt;&amp;lt;/div&gt;"&gt;hello&lt;/div&gt;</code></span> <span> - </span> <span class="display-name">Daniel Haley</span> <span> </span> <span class="date">12 Oct 2016 at 22:11</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This also matches <code>&lt;!-- some comment --&gt;</code>.</span> <span> - </span> <span class="display-name">fritzmg</span> <span> </span> <span class="date">3 Mar 2018 at 09:32</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>161</span>
     </div>
     <div>
      <span>Answerer: </span> <span>meder omuraliev</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Nov 2009 at 14:37</span>
     </div>
    </div>
    <div>
     <pre><code>&lt;?php
$selfClosing = explode(',', 'area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed');

$html = '
&lt;p&gt;&lt;a href="#"&gt;foo&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;br/&gt;
&lt;div&gt;name&lt;/div&gt;';

$dom = new DOMDocument();
$dom-&gt;loadHTML($html);
$els = $dom-&gt;getElementsByTagName('*');
foreach ( $els as $el ) {
    $nodeName = strtolower($el-&gt;nodeName);
    if ( !in_array( $nodeName, $selfClosing ) ) {
        var_dump( $nodeName );
    }
}
</code></pre>
     <p>Output:</p>
     <pre><code>string(4) "html"
string(4) "body"
string(1) "p"
string(1) "a"
string(3) "div"
</code></pre>
     <p>Basically just define the element node names that are self closing, load the whole html string into a DOM library, grab all elements, loop through and filter out ones which aren't self closing and operate on them.</p>
     <p>I'm sure you already know by now that you shouldn't use regex for this purpose.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>If you're dealing with real XHTML then append getElementsByTagName with <code>NS</code> and specify the namespace.</span> <span> - </span> <span class="display-name">meder omuraliev</span> <span> </span> <span class="date">15 Nov 2009 at 14:39</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>153</span>
     </div>
     <div>
      <span>Answerer: </span> <span>GONeale</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Nov 2009 at 23:15</span>
     </div>
    </div>
    <div>
     <p>I don't know your exact need for this, but if you are also using .NET, couldn't you use <a href="http://www.codeplex.com/htmlagilitypack" rel="noreferrer">Html Agility Pack</a>?</p>
     <p>Excerpt:</p>
     <blockquote>
      <p><em>It is a .NET code library that allows you to parse "out of the web" HTML files. The parser is very tolerant with "real world" malformed HTML.</em></p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>CodePlex closed down (but this one is in the CodePlex archive). Perhaps update?</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">14 Aug 2020 at 15:47</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span> <span class="arrow"> <a href="#answer_15">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>142</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Jherico</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 Nov 2009 at 22:47</span>
     </div>
    </div>
    <div>
     <p>You want the first <code>&gt;</code> not preceded by a <code>/</code>. Look <a href="http://www.regular-expressions.info/lookaround.html" rel="noreferrer">here</a> for details on how to do that. It's referred to as negative lookbehind.</p>
     <p>However, a naïve implementation of that will end up matching <code>&lt;bar/&gt;&lt;/foo&gt;</code> in this example document</p>
     <pre><code>&lt;foo&gt;&lt;bar/&gt;&lt;/foo&gt;
</code></pre>
     <p>Can you provide a little more information on the problem you're trying to solve? Are you iterating through tags programatically?</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_15"><span>Answer 15</span> <span class="arrow"> <a href="#answer_14">↑</a> </span> <span class="arrow"> <a href="#answer_16">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>110</span>
     </div>
     <div>
      <span>Answerer: </span> <span>SamGoody</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Nov 2009 at 19:02</span>
     </div>
    </div>
    <div>
     <p>If you need this for PHP:</p>
     <p>The <a href="http://www.php.net/manual/en/function.dom-import-simplexml.php" rel="noreferrer">PHP DOM</a> <a href="http://php.net/manual/en/class.domdocument.php" rel="noreferrer">functions</a> won't work properly unless it is properly formatted XML. No matter how much better their use is for the rest of mankind.</p>
     <p><a href="http://simplehtmldom.sourceforge.net/" rel="noreferrer">simplehtmldom</a> is good, but I found it a bit buggy, and it is is quite memory heavy [Will crash on large pages.]</p>
     <p>I have never used <a href="http://querypath.org/" rel="noreferrer">querypath</a>, so can't comment on its usefulness.</p>
     <p>Another one to try is my <a href="http://github.com/siteroller/domparser" rel="noreferrer">DOMParser</a> which is very light on resources and I've been using happily for a while. Simple to learn &amp; powerful.</p>
     <p>For Python and Java, similar links were posted.</p>
     <p>For the downvoters - I only wrote my class when the XML parsers proved unable to withstand real use. Religious downvoting just prevents useful answers from being posted - keep things within perspective of the question, please.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_16"><span>Answer 16</span> <span class="arrow"> <a href="#answer_15">↑</a> </span> <span class="arrow"> <a href="#answer_17">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>100</span>
     </div>
     <div>
      <span>Answerer: </span> <span>yodabar</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Jul 2011 at 14:35</span>
     </div>
    </div>
    <div>
     <p>Here's the solution:</p>
     <pre><code>&lt;?php
// here's the pattern:
$pattern = '/&lt;(\w+)(\s+(\w+)\s*\=\s*(\'|")(.*?)\\4\s*)*\s*(\/&gt;|&gt;)/';

// a string to parse:
$string = 'Hello, try clicking &lt;a href="#paragraph"&gt;here&lt;/a&gt;
    &lt;br/&gt;and check out.&lt;hr /&gt;
    &lt;h2&gt;title&lt;/h2&gt;
    &lt;a name ="paragraph" rel= "I\'m an anchor"&gt;&lt;/a&gt;
    Fine, &lt;span title=\'highlight the "punch"\'&gt;thanks&lt;span&gt;.
    &lt;div class = "clear"&gt;&lt;/div&gt;
    &lt;br&gt;';

// let's get the occurrences:
preg_match_all($pattern, $string, $matches, PREG_PATTERN_ORDER);

// print the result:
print_r($matches[0]);
?&gt;
</code></pre>
     <p>To test it deeply, I entered in the string auto-closing tags like:</p>
     <ol>
      <li>&lt;hr /&gt;</li>
      <li>&lt;br/&gt;</li>
      <li>&lt;br&gt;</li>
     </ol>
     <p>I also entered tags with:</p>
     <ol>
      <li>one attribute</li>
      <li>more than one attribute</li>
      <li>attributes which value is bound either into <strong>single quotes</strong> or into <strong>double quotes</strong></li>
      <li>attributes containing single quotes when the delimiter is a double quote and vice versa</li>
      <li>"unpretty" attributes with a space before the "=" symbol, after it and both before and after it.</li>
     </ol>
     <p>Should you find something which does not work in the proof of concept above, I am available in analyzing the code to improve my skills.</p>
     <p><strong>&lt;EDIT&gt;</strong> I forgot that the question from the user was to avoid the parsing of self-closing tags. In this case the pattern is simpler, turning into this:</p>
     <pre><code>$pattern = '/&lt;(\w+)(\s+(\w+)\s*\=\s*(\'|")(.*?)\\4\s*)*\s*&gt;/';
</code></pre>
     <p>The user @ridgerunner noticed that the pattern does not allow <strong>unquoted attributes</strong> or <strong>attributes with no value</strong>. In this case a fine tuning brings us the following pattern:</p>
     <pre><code>$pattern = '/&lt;(\w+)(\s+(\w+)(\s*\=\s*(\'|"|)(.*?)\\5\s*)?)*\s*&gt;/';
</code></pre>
     <p><strong>&lt;/EDIT&gt;</strong></p>
     <h1>Understanding the pattern</h1>
     <p>If someone is interested in learning more about the pattern, I provide some line:</p>
     <ol>
      <li>the first sub-expression (\w+) matches the tag name</li>
      <li>the second sub-expression contains the pattern of an attribute. It is composed by: 
       <ol>
        <li>one or more whitespaces \s+</li>
        <li>the name of the attribute (\w+)</li>
        <li>zero or more whitespaces \s* (it is possible or not, leaving blanks here)</li>
        <li>the "=" symbol</li>
        <li>again, zero or more whitespaces</li>
        <li>the delimiter of the attribute value, a single or double quote ('|"). In the pattern, the single quote is escaped because it coincides with the PHP string delimiter. This sub-expression is captured with the parentheses so it can be referenced again to parse the closure of the attribute, that's why it is very important.</li>
        <li>the value of the attribute, matched by <em>almost</em> anything: (.*?); in this specific syntax, using the <strong>greedy match</strong> (the question mark after the asterisk) the RegExp engine enables a "look-ahead"-like operator, which matches anything but what follows this sub-expression</li>
        <li>here comes the fun: the \4 part is a <strong>backreference operator</strong>, which refers to a sub-expression defined before in the pattern, in this case, I am referring to the fourth sub-expression, which is the first attribute delimiter found</li>
        <li>zero or more whitespaces \s*</li>
        <li>the attribute sub-expression ends here, with the specification of zero or more possible occurrences, given by the asterisk.</li>
       </ol></li>
      <li>Then, since a tag may end with a whitespace before the "&gt;" symbol, zero or more whitespaces are matched with the \s* subpattern.</li>
      <li>The tag to match may end with a simple "&gt;" symbol, or a possible XHTML closure, which makes use of the slash before it: (/&gt;|&gt;). The slash is, of course, escaped since it coincides with the regular expression delimiter.</li>
     </ol>
     <p>Small tip: to better analyze this code it is necessary looking at the source code generated since I did not provide any HTML special characters escaping.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>12</td>
        <td><span>Does not match valid tags having attributes with no value, i.e. <code>&lt;option selected&gt;</code>. Also does not match valid tags with unquoted attribute values, i.e. <code>&lt;p id=10&gt;</code>.</span> <span> - </span> <span class="display-name">ridgerunner</span> <span> </span> <span class="date">25 Jul 2011 at 15:01</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@ridgerunner: Thanks very much for your comment. In that case the pattern must change a bit: $pattern = '/&lt;(\w+)(\s+(\w+)(\s*\=\s*(\'|"|)(.*?)\\5\s*)?)*\s*&gt;/'; I tested it and works in case of non-quoted attributes or attributes with no value.</span> <span> - </span> <span class="display-name">yodabar</span> <span> </span> <span class="date">25 Jul 2011 at 16:41</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>How about a space before the tag name: <code>&lt; a href="http://wtf.org" &gt;</code> I'm pretty sure it is legal, but you don't match it.</span> <span> - </span> <span class="display-name">Floris</span> <span> </span> <span class="date">5 Oct 2013 at 04:58</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span>NO sorry, whitespaces before a tagname are illegal. Beyond being "pretty sure" why don't you provide some evidences of your objection? Here are mine, <a href="http://www.w3.org/TR/xml11/#sec-starttags" rel="nofollow noreferrer">w3.org/TR/xml11/#sec-starttags</a> referred to XML 1.1, and you can find the same for HTML 4, 5 and XHTML, as a W3C validation would also warn if you make a test. As a lot of other blah-blah-poets around here, I did not still receive any intelligent argumentation, apart some hundred of minus to my answers, to demonstrate where my code fails according to the <i>rules of contract</i> specified in the question. I would only welcome them.</span> <span> - </span> <span class="display-name">yodabar</span> <span> </span> <span class="date">6 Oct 2013 at 18:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>XML tags can contain colons, e.g. <code>&lt;namespace:name&gt;</code>, is that not so in HTML?</span> <span> - </span> <span class="display-name">Qwertie</span> <span> </span> <span class="date">17 Jul 2020 at 21:54</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_17"><span>Answer 17</span> <span class="arrow"> <a href="#answer_16">↑</a> </span> <span class="arrow"> <a href="#answer_18">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>94</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Sembiance</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 Nov 2009 at 14:50</span>
     </div>
    </div>
    <div>
     <p>Whenever I need to quickly extract something from an HTML document, I use Tidy to convert it to XML and then use XPath or XSLT to get what I need. In your case, something like this:</p>
     <pre><code>//p/a[@href='foo']
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_18"><span>Answer 18</span> <span class="arrow"> <a href="#answer_17">↑</a> </span> <span class="arrow"> <a href="#answer_19">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>91</span>
     </div>
     <div>
      <span>Answerer: </span> <span>wen</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Nov 2009 at 18:34</span>
     </div>
    </div>
    <div>
     <p>I used a open source tool called <a href="http://htmlparser.sourceforge.net/">HTMLParser</a> before. It's designed to parse HTML in various ways and serves the purpose quite well. It can parse HTML as different treenode and you can easily use its API to get attributes out of the node. Check it out and see if this can help you.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_19"><span>Answer 19</span> <span class="arrow"> <a href="#answer_18">↑</a> </span> <span class="arrow"> <a href="#answer_20">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>87</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Sam Watkins</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Jul 2011 at 17:13</span>
     </div>
    </div>
    <div>
     <p>I like to parse HTML with regular expressions. I don't attempt to parse idiot HTML that is deliberately broken. This code is my main parser (Perl edition):</p>
     <pre><code>$_ = join "",&lt;STDIN&gt;; tr/\n\r \t/ /s; s/&lt;/\n&lt;/g; s/&gt;/&gt;\n/g; s/\n ?\n/\n/g;
s/^ ?\n//s; s/ $//s; print
</code></pre>
     <p>It's called <em>htmlsplit</em>, splits the HTML into lines, with one tag or chunk of text on each line. The lines can then be processed further with other text tools and scripts, such as <a href="http://en.wikipedia.org/wiki/Grep" rel="nofollow noreferrer">grep</a>, <a href="http://en.wikipedia.org/wiki/Sed" rel="nofollow noreferrer">sed</a>, Perl, etc. I'm not even joking :) Enjoy.</p>
     <p>It is simple enough to rejig my slurp-everything-first Perl script into a nice streaming thing, if you wish to process enormous web pages. But it's not really necessary.</p>
     <p><a href="http://sam.nipl.net/code/nipl-tools/bin/htmlsplit" rel="nofollow noreferrer">HTML Split</a></p>
     <hr>
     <p>Some better regular expressions:</p>
     <pre><code>/(&lt;.*?&gt;|[^&lt;]+)\s*/g    # Get tags and text
/(\w+)="(.*?)"/g       # Get attibutes
</code></pre>
     <p>They are good for XML / XHTML.</p>
     <p>With minor variations, it can cope with messy HTML... or convert the HTML -&gt; XHTML first.</p>
     <hr>
     <p>The best way to write regular expressions is in the <a href="http://en.wikipedia.org/wiki/Lex_%28software%29" rel="nofollow noreferrer">Lex</a> / <a href="http://en.wikipedia.org/wiki/Yacc" rel="nofollow noreferrer">Yacc</a> style, not as opaque one-liners or commented multi-line monstrosities. I didn't do that here, yet; these ones barely need it.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>56</td>
        <td><span></span> <span> - </span> <span class="display-name">Kevin Panko</span> <span> </span> <span class="date">26 Jul 2011 at 20:38</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Sam Watkins</span> <span> </span> <span class="date">8 Mar 2012 at 03:22</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Sam Watkins</span> <span> </span> <span class="date">22 May 2012 at 08:00</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span></span> <span> - </span> <span class="display-name">David Andersson</span> <span> </span> <span class="date">11 Sep 2016 at 08:23</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span></span> <span> - </span> <span class="display-name">David Andersson</span> <span> </span> <span class="date">11 Sep 2016 at 08:28</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span></span> <span> - </span> <span class="display-name">David Andersson</span> <span> </span> <span class="date">11 Sep 2016 at 08:42</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span></span> <span> - </span> <span class="display-name">David Andersson</span> <span> </span> <span class="date">11 Sep 2016 at 09:09</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Sam Watkins</span> <span> </span> <span class="date">13 Sep 2016 at 04:52</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span></span> <span> - </span> <span class="display-name">David Andersson</span> <span> </span> <span class="date">13 Sep 2016 at 06:27</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_20"><span>Answer 20</span> <span class="arrow"> <a href="#answer_19">↑</a> </span> <span class="arrow"> <a href="#answer_21">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>71</span>
     </div>
     <div>
      <span>Answerer: </span> <span>sblom</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Apr 2010 at 16:38</span>
     </div>
    </div>
    <div>
     <p>There are some nice regexes for replacing HTML with BBCode <a href="http://www.garyshood.com/htmltobb/source.txt" rel="noreferrer">here</a>. For all you nay-sayers, note that he's not trying to fully parse HTML, just to sanitize it. He can probably afford to kill off tags that his simple "parser" can't understand.</p>
     <p>For example:</p>
     <pre><code>$store =~ s/http:/http:\/\//gi;
$store =~ s/https:/https:\/\//gi;
$baseurl = $store;

if (!$query-&gt;param("ascii")) {
    $html =~ s/\s\s+/\n/gi;
    $html =~ s/&lt;pre(.*?)&gt;(.*?)&lt;\/pre&gt;/\[code]$2\[\/code]/sgmi;
}

$html =~ s/\n//gi;
$html =~ s/\r\r//gi;
$html =~ s/$baseurl//gi;
$html =~ s/&lt;h[1-7](.*?)&gt;(.*?)&lt;\/h[1-7]&gt;/\n\[b]$2\[\/b]\n/sgmi;
$html =~ s/&lt;p&gt;/\n\n/gi;
$html =~ s/&lt;br(.*?)&gt;/\n/gi;
$html =~ s/&lt;textarea(.*?)&gt;(.*?)&lt;\/textarea&gt;/\[code]$2\[\/code]/sgmi;
$html =~ s/&lt;b&gt;(.*?)&lt;\/b&gt;/\[b]$1\[\/b]/gi;
$html =~ s/&lt;i&gt;(.*?)&lt;\/i&gt;/\[i]$1\[\/i]/gi;
$html =~ s/&lt;u&gt;(.*?)&lt;\/u&gt;/\[u]$1\[\/u]/gi;
$html =~ s/&lt;em&gt;(.*?)&lt;\/em&gt;/\[i]$1\[\/i]/gi;
$html =~ s/&lt;strong&gt;(.*?)&lt;\/strong&gt;/\[b]$1\[\/b]/gi;
$html =~ s/&lt;cite&gt;(.*?)&lt;\/cite&gt;/\[i]$1\[\/i]/gi;
$html =~ s/&lt;font color="(.*?)"&gt;(.*?)&lt;\/font&gt;/\[color=$1]$2\[\/color]/sgmi;
$html =~ s/&lt;font color=(.*?)&gt;(.*?)&lt;\/font&gt;/\[color=$1]$2\[\/color]/sgmi;
$html =~ s/&lt;link(.*?)&gt;//gi;
$html =~ s/&lt;li(.*?)&gt;(.*?)&lt;\/li&gt;/\[\*]$2/gi;
$html =~ s/&lt;ul(.*?)&gt;/\[list]/gi;
$html =~ s/&lt;\/ul&gt;/\[\/list]/gi;
$html =~ s/&lt;div&gt;/\n/gi;
$html =~ s/&lt;\/div&gt;/\n/gi;
$html =~ s/&lt;td(.*?)&gt;/ /gi;
$html =~ s/&lt;tr(.*?)&gt;/\n/gi;

$html =~ s/&lt;img(.*?)src="(.*?)"(.*?)&gt;/\[img]$baseurl\/$2\[\/img]/gi;
$html =~ s/&lt;a(.*?)href="(.*?)"(.*?)&gt;(.*?)&lt;\/a&gt;/\[url=$baseurl\/$2]$4\[\/url]/gi;
$html =~ s/\[url=$baseurl\/http:\/\/(.*?)](.*?)\[\/url]/\[url=http:\/\/$1]$2\[\/url]/gi;
$html =~ s/\[img]$baseurl\/http:\/\/(.*?)\[\/img]/\[img]http:\/\/$1\[\/img]/gi;

$html =~ s/&lt;head&gt;(.*?)&lt;\/head&gt;//sgmi;
$html =~ s/&lt;object&gt;(.*?)&lt;\/object&gt;//sgmi;
$html =~ s/&lt;script(.*?)&gt;(.*?)&lt;\/script&gt;//sgmi;
$html =~ s/&lt;style(.*?)&gt;(.*?)&lt;\/style&gt;//sgmi;
$html =~ s/&lt;title&gt;(.*?)&lt;\/title&gt;//sgmi;
$html =~ s/&lt;!--(.*?)--&gt;/\n/sgmi;

$html =~ s/\/\//\//gi;
$html =~ s/http:\//http:\/\//gi;
$html =~ s/https:\//https:\/\//gi;

$html =~ s/&lt;(?:[^&gt;'"]*|(['"]).*?\1)*&gt;//gsi;
$html =~ s/\r\r//gi;
$html =~ s/\[img]\//\[img]/gi;
$html =~ s/\[url=\//\[url=/gi;
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>20</td>
        <td><span></span> <span> - </span> <span class="display-name">maletor</span> <span> </span> <span class="date">3 Sep 2015 at 02:12</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_21"><span>Answer 21</span> <span class="arrow"> <a href="#answer_20">↑</a> </span> <span class="arrow"> <a href="#answer_22">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>71</span>
     </div>
     <div>
      <span>Answerer: </span> <span>yodabar</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 Jul 2010 at 14:16</span>
     </div>
    </div>
    <div>
     <p>About the question of the regular expression methods to parse (x)HTML, the answer to all of the ones who spoke about some limits is: you have not been trained enough to rule the force of this powerful weapon, since <strong>nobody</strong> here spoke about <strong>recursion</strong>.</p>
     <p>A regular expression-agnostic colleague notified me this discussion, which is not certainly the first on the web about this old and hot topic.</p>
     <p>After reading some posts, the first thing I did was looking for the "?R" string in this thread. The second was to search about "recursion".</p>
     <p>No, holy cow, no match found. Since nobody mentioned the main mechanism a parser is built onto, I was soon aware that nobody got the point.</p>
     <p>If an (x)HTML parser needs recursion, a regular expression parser without recursion is not enough for the purpose. It's a simple construct.</p>
     <p>The <strong>black art of regular expressions is hard to master</strong>, so maybe there are further possibilities we left out while trying and testing our personal solution to capture the whole web in one hand... Well, I am sure about it :)</p>
     <p>Here's the magic pattern:</p>
     <pre><code>$pattern = "/&lt;([\w]+)([^&gt;]*?)(([\s]*\/&gt;)|(&gt;((([^&lt;]*?|&lt;\!\-\-.*?\-\-&gt;)|(?R))*)&lt;\/\\1[\s]*&gt;))/s";
</code></pre>
     <p>Just try it. It's written as a PHP string, so the "s" modifier makes classes include newlines.</p>
     <p>Here's a <strong>sample note on the PHP manual</strong> I wrote in January: <a href="http://php.net/manual/en/regexp.reference.recursive.php" rel="nofollow noreferrer">Reference</a></p>
     <p>(Take care. In that note I wrongly used the "m" modifier; it should be erased, notwithstanding it is discarded by the regular expression engine, since no <code>^</code> or <code>$</code> anchoring was used).</p>
     <p>Now, we could speak about the limits of this method from a more informed point of view:</p>
     <ol>
      <li>according to the specific implementation of the regular expression engine, recursion may have a limit in the <strong>number of nested patterns parsed</strong>, but it depends on the language used</li>
      <li>although corrupted, (x)HTML does not drive into severe errors. It is not <em>sanitized</em>.</li>
     </ol>
     <p>Anyhow, it is only a regular expression pattern, but it discloses the possibility to develop of a lot of powerful implementations.</p>
     <p>I wrote this pattern to power the <em>recursive descent parser</em> of a template engine I built in my framework, and performances are really great, both in execution times or in memory usage (nothing to do with other template engines which use the same syntax).</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>40</td>
        <td><span></span> <span> - </span> <span class="display-name">Gareth</span> <span> </span> <span class="date">5 Jul 2010 at 16:24</span></td>
       </tr>
       <tr>
        <td>74</td>
        <td><span></span> <span> - </span> <span class="display-name">aehiilrs</span> <span> </span> <span class="date">5 Jul 2010 at 16:33</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">yodabar</span> <span> </span> <span class="date">5 Jul 2010 at 17:40</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">yodabar</span> <span> </span> <span class="date">6 Jul 2010 at 08:20</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">yodabar</span> <span> </span> <span class="date">6 Jul 2010 at 16:13</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span></span> <span> - </span> <span class="display-name">yodabar</span> <span> </span> <span class="date">6 Jul 2010 at 16:16</span></td>
       </tr>
       <tr>
        <td>32</td>
        <td><span></span> <span> - </span> <span class="display-name">Welbog</span> <span> </span> <span class="date">6 Jul 2010 at 18:38</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span></span> <span> - </span> <span class="display-name">mirod</span> <span> </span> <span class="date">7 Jul 2010 at 04:55</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">yodabar</span> <span> </span> <span class="date">9 Jul 2010 at 08:14</span></td>
       </tr>
       <tr>
        <td>20</td>
        <td><span></span> <span> - </span> <span class="display-name">Oorang</span> <span> </span> <span class="date">10 Jul 2010 at 15:11</span></td>
       </tr>
       <tr>
        <td>17</td>
        <td><span></span> <span> - </span> <span class="display-name">Oorang</span> <span> </span> <span class="date">10 Jul 2010 at 15:17</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_22"><span>Answer 22</span> <span class="arrow"> <a href="#answer_21">↑</a> </span> <span class="arrow"> <a href="#answer_23">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>66</span>
     </div>
     <div>
      <span>Answerer: </span> <span>daghan</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 May 2012 at 13:53</span>
     </div>
    </div>
    <div>
     <pre><code>&lt;\s*(\w+)[^/&gt;]*&gt;
</code></pre>
     <p>The parts explained:</p>
     <p><code>&lt;</code>: Starting character</p>
     <p><code>\s*</code>: It may have whitespaces before the tag name (ugly, but possible).</p>
     <p><code>(\w+)</code>: tags can contain letters and numbers (h1). Well, <code>\w</code> also matches '_', but it does not hurt I guess. If curious, use ([a-zA-Z0-9]+) instead.</p>
     <p><code>[^/&gt;]*</code>: Anything except <code>&gt;</code> and <code>/</code> until closing <code>&gt;</code></p>
     <p><code>&gt;</code>: Closing <code>&gt;</code></p>
     <h3>UNRELATED</h3>
     <p>And to the fellows, who underestimate regular expressions, saying they are only as powerful as regular languages:</p>
     <p>a<sup>n</sup>ba<sup>n</sup>ba<sup>n</sup> which is not regular and not even context free, can be matched with <code>^(a+)b\1b\1$</code></p>
     <p>Backreferencing <a href="http://en.wiktionary.org/wiki/FTW" rel="noreferrer">FTW</a>!</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">alanaktion</span> <span> </span> <span class="date">2 Feb 2013 at 15:45</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span></span> <span> - </span> <span class="display-name">Konrad Borowski</span> <span> </span> <span class="date">14 Feb 2013 at 16:52</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span></span> <span> - </span> <span class="display-name">Qwertie</span> <span> </span> <span class="date">17 Jul 2020 at 21:59</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span></span> <span> - </span> <span class="display-name">Rohìt Jíndal</span> <span> </span> <span class="date">18 Oct 2022 at 11:07</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_23"><span>Answer 23</span> <span class="arrow"> <a href="#answer_22">↑</a> </span> <span class="arrow"> <a href="#answer_24">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>63</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Corey Sanders</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Feb 2010 at 16:22</span>
     </div>
    </div>
    <div>
     <p>As many people have already pointed out, HTML is not a regular language which can make it very difficult to parse. My solution to this is to turn it into a regular language using a tidy program and then to use an XML parser to consume the results. There are a lot of good options for this. My program is written using Java with the <a href="http://jtidy.sourceforge.net/" rel="noreferrer">jtidy</a> library to turn the HTML into XML and then Jaxen to xpath into the result.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_24"><span>Answer 24</span> <span class="arrow"> <a href="#answer_23">↑</a> </span> <span class="arrow"> <a href="#answer_25">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>56</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Lonnie Best</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Jun 2012 at 05:13</span>
     </div>
    </div>
    <div>
     <p>If you're simply trying to find those tags (without ambitions of parsing) try this regular expression:</p>
     <pre><code>/&lt;[^/]*?&gt;/g
</code></pre>
     <p>I wrote it in 30 seconds, and tested here: <a href="http://gskinner.com/RegExr/">http://gskinner.com/RegExr/</a></p>
     <p>It matches the types of tags you mentioned, while ignoring the types you said you wanted to ignore.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span></span> <span> - </span> <span class="display-name">Alan Moore</span> <span> </span> <span class="date">29 May 2016 at 07:47</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Lonnie Best</span> <span> </span> <span class="date">31 May 2016 at 07:23</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_25"><span>Answer 25</span> <span class="arrow"> <a href="#answer_24">↑</a> </span> <span class="arrow"> <a href="#answer_26">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>54</span>
     </div>
     <div>
      <span>Answerer: </span> <span>manixrock</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Nov 2009 at 17:13</span>
     </div>
    </div>
    <div>
     <p>It seems to me you're trying to match tags without a "/" at the end. Try this:</p>
     <pre><code>&lt;([a-zA-Z][a-zA-Z0-9]*)[^&gt;]*(?&lt;!/)&gt;
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>10</td>
        <td><span></span> <span> - </span> <span class="display-name">ceving</span> <span> </span> <span class="date">4 May 2011 at 16:33</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_26"><span>Answer 26</span> <span class="arrow"> <a href="#answer_25">↑</a> </span> <span class="arrow"> <a href="#answer_27">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>54</span>
     </div>
     <div>
      <span>Answerer: </span> <span>slevithan</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 May 2012 at 23:27</span>
     </div>
    </div>
    <div>
     <p>It's true that when programming it's usually best to use dedicated parsers and APIs instead of regular expressions when dealing with HTML, especially if accuracy is paramount (e.g., if your processing might have security implications). However, I don’t ascribe to a dogmatic view that XML-style markup should never be processed with regular expressions. There are cases when regular expressions are a great tool for the job, such as when making one-time edits in a text editor, fixing broken XML files, or dealing with file formats that look like but aren’t quite XML. There are some issues to be aware of, but they're not insurmountable or even necessarily relevant.</p>
     <p>A simple regex like <code>&lt;([^&gt;"']|"[^"]*"|'[^']*')*&gt;</code> is usually good enough, in cases such as those I just mentioned. It's a naive solution, all things considered, but it does correctly allow unencoded <code>&gt;</code> symbols in attribute values. If you're looking for, e.g., a <code>table</code> tag, you could adapt it as <code>&lt;/?table\b([^&gt;"']|"[^"]*"|'[^']*')*&gt;</code>.</p>
     <p>Just to give a sense of what a more "advanced" HTML regex would look like, the following does a fairly respectable job of emulating real-world browser behavior and the HTML5 parsing algorithm:</p>
     <pre><code>&lt;/?([A-Za-z][^\s&gt;/]*)(?:=\s*(?:"[^"]*"|'[^']*'|[^\s&gt;]+)|[^&gt;])*(?:&gt;|$)
</code></pre>
     <p>The following matches a fairly strict definition of XML tags (although it doesn't account for the full set of Unicode characters allowed in XML names):</p>
     <pre><code>&lt;(?:([_:A-Z][-.:\w]*)(?:\s+[_:A-Z][-.:\w]*\s*=\s*(?:"[^"]*"|'[^']*'))*\s*/?|/([_:A-Z][-.:\w]*)\s*)&gt;
</code></pre>
     <p>Granted, these don't account for surrounding context and a few edge cases, but even such things could be dealt with if you really wanted to (e.g., by searching between the matches of another regex).</p>
     <p>At the end of the day, use the most appropriate tool for the job, even in the cases when that tool happens to be a regex.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_27"><span>Answer 27</span> <span class="arrow"> <a href="#answer_26">↑</a> </span> <span class="arrow"> <a href="#answer_28">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>51</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Emre Yazici</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Feb 2010 at 03:59</span>
     </div>
    </div>
    <div>
     <p>Although it's not suitable and effective to use regular expressions for that purpose sometimes regular expressions provide quick solutions for simple match problems and in my view it's not that horrbile to use regular expressions for trivial works.</p>
     <p>There is a <a href="http://blog.stevenlevithan.com/archives/match-innermost-html-element" rel="noreferrer">definitive blog post</a> about matching innermost HTML elements written by Steven Levithan.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_28"><span>Answer 28</span> <span class="arrow"> <a href="#answer_27">↑</a> </span> <span class="arrow"> <a href="#answer_29">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>43</span>
     </div>
     <div>
      <span>Answerer: </span> <span>morja</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Nov 2010 at 10:11</span>
     </div>
    </div>
    <div>
     <p>If you only want the tag names, it should be possible to do this via a regular expression.</p>
     <pre><code>&lt;([a-zA-Z]+)(?:[^&gt;]*[^/] *)?&gt;
</code></pre>
     <p>should do what you need. But I think the solution of "moritz" is already fine. I didn't see it in the beginning.</p>
     <p>For all downvoters: In some cases it just makes sense to use a regular expression, because it can be the easiest and quickest solution. I agree that in general you should not parse HTML with regular expressions.</p>
     <p>But regular expressions can be a very powerful tool when you have a subset of HTML where you know the format and you just want to extract some values. I did that hundreds of times and almost always achieved what I wanted.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_29"><span>Answer 29</span> <span class="arrow"> <a href="#answer_28">↑</a> </span> <span class="arrow"> <a href="#answer_30">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>39</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Jonathan Wood</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Mar 2011 at 12:38</span>
     </div>
    </div>
    <div>
     <p>The OP doesn't seem to say what he needs to do with the tags. For example, does he need to extract inner text, or just examine the tags?</p>
     <p>I'm firmly in the camp that says a regular expression is not the be-all, end-all text parser. I've written a large amount of text-parsing code including <a href="http://www.blackbeltcoder.com/Articles/strings/parsing-html-tags-in-c" rel="nofollow noreferrer">this code to parse HTML tags</a>.</p>
     <p>While it's true I'm not all that great with regular expressions, I consider regular expressions just too rigid and hard to maintain for this sort of parsing.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_30"><span>Answer 30</span> <span class="arrow"> <a href="#answer_29">↑</a> </span> <span class="arrow"> <a href="#answer_31">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>33</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Paul</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Apr 2010 at 06:38</span>
     </div>
    </div>
    <div>
     <p>This may do:</p>
     <pre><code>&lt;.*?[^/]&gt;
</code></pre>
     <p>Or without the ending tags:</p>
     <pre><code>&lt;[^/].*?[^/]&gt;
</code></pre>
     <p>What's with the flame wars on HTML parsers? HTML parsers must parse (and rebuild!) the entire document before it can categorize your search. Regular expressions may be a faster / elegant in certain circumstances. My 2 cents...</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span></span> <span> - </span> <span class="display-name">Qwertie</span> <span> </span> <span class="date">17 Jul 2020 at 22:06</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_31"><span>Answer 31</span> <span class="arrow"> <a href="#answer_30">↑</a> </span> <span class="arrow"> <a href="#answer_32">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>20</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Cylian</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 May 2012 at 13:25</span>
     </div>
    </div>
    <div>
     <p><strong>I think this might work</strong></p>
     <pre><code>&lt;[a-z][^&lt;&gt;]*(?:(?:[^/]\s*)|(?:\s*[^/]))&gt;
</code></pre>
     <p>And that could be tested <a href="http://regexr.com?312s9" rel="nofollow noreferrer">here</a>.</p>
     <hr>
     <h2><a href="http://www.w3schools.com/xml/xml_elements.asp" rel="nofollow noreferrer">As per W3Schools</a>...</h2>
     <h2>XML Naming Rules</h2>
     <p>XML elements must follow these naming rules:</p>
     <ul>
      <li>Names can contain letters, numbers, and other characters</li>
      <li>Names cannot start with a number or punctuation character</li>
      <li>Names cannot start with the letters <em>xml</em> (or <em>XML</em>, <em>Xml</em>, etc.)</li>
      <li>Names cannot contain spaces</li>
      <li>Any name can be used, and no words are reserved.</li>
     </ul>
     <hr>
     <p>And the pattern I used is going to adhere these rules.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>80</td>
        <td><span></span> <span> - </span> <span class="display-name">Alan Moore</span> <span> </span> <span class="date">1 Jun 2012 at 07:25</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span></span> <span> - </span> <span class="display-name">JamieSee</span> <span> </span> <span class="date">24 Aug 2012 at 16:20</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span></span> <span> - </span> <span class="display-name">Solomon Ucko</span> <span> </span> <span class="date">20 Mar 2018 at 16:18</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_32"><span>Answer 32</span> <span class="arrow"> <a href="#answer_31">↑</a> </span> <span class="arrow"> <a href="#answer_33">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>b7kich</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Jun 2020 at 02:20</span>
     </div>
    </div>
    <div>
     <p>Here's a <a href="https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions" rel="nofollow noreferrer">PCRE</a> regular expression for XML/XHTML, built from a simplified <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form" rel="nofollow noreferrer">EBNF</a> syntax definition:</p>
     <pre><code>/
(?(DEFINE)
(?&lt;tag&gt; (?&amp;tagempty) | (?&amp;tagopen) ((?&amp;textnode) | (?&amp;tag) | (?&amp;comment))* (?&amp;tagclose))
(?&lt;tagunnested&gt; (?&amp;tagempty) | (?&amp;tagopen) ((?&amp;textnode) | (?&amp;comment))* (?&amp;tagclose))
(?&lt;textnode&gt; [^&lt;&gt;]+)
(?&lt;comment&gt; &lt;!--([\s\S]*?)--&gt;)
(?&lt;tagopen&gt; &lt; (?&amp;tagname) (?&amp;attrlist)? (?&amp;ws)* &gt;)
(?&lt;tagempty&gt; &lt; (?&amp;tagname) (?&amp;ws)* (?&amp;attrlist)? (?&amp;ws)* \/&gt;)
(?&lt;tagclose&gt; &lt;\/ (?&amp;tagname) (?&amp;ws)* &gt;)
(?&lt;attrlist&gt; ((?&amp;ws)+ (?&amp;attr))+)
(?&lt;attr&gt; (?&amp;attrunquoted) | (?&amp;attrsinglequoted) | (?&amp;attrdoublequoted) | (?&amp;attrempty))
(?&lt;attrempty&gt; (?&amp;attrname))
(?&lt;attrunquoted&gt; (?&amp;attrname) (?&amp;ws)* = (?&amp;ws)* (?&amp;attrunquotedvalue))
(?&lt;attrsinglequoted&gt; (?&amp;attrname) (?&amp;ws)* = (?&amp;ws)* ' (?&amp;attrsinglequotedvalue) ')
(?&lt;attrdoublequoted&gt; (?&amp;attrname) (?&amp;ws)* = (?&amp;ws)* " (?&amp;attrdoublequotedvalue) ")
(?&lt;tagname&gt; (?&amp;alphabets) ((?&amp;alphabets) | (?&amp;digits))*)
(?&lt;attrname&gt;(?&amp;alphabets)+((?&amp;alphabets)|(?&amp;digits)|[:-]) )
(?&lt;attrunquotedvalue&gt; [^\s"'=&lt;&gt;`]+)
(?&lt;attrsinglequotedvalue&gt; [^']+)
(?&lt;attrdoublequotedvalue&gt; [^"]+)
(?&lt;alphabets&gt; [a-zA-Z])
(?&lt;digits&gt; [0-9])
(?&lt;ws&gt; \s)
)
(?&amp;tagopen)
/x
</code></pre>
     <p>This illustrates how to build <a href="https://nikic.github.io/2012/06/15/The-true-power-of-regular-expressions.html" rel="nofollow noreferrer">regular expressions for context-free grammars</a>. You can match other parts of the definition by changing the match on the last line from <code>(?&amp;tagopen)</code> to e.g. <code>(?&amp;tagunnested)</code></p>
     <h2>The real question is: Should you do it?</h2>
     <p>For XML/XHTML the consensus is <strong>no</strong>!</p>
     <p>Credits to <a href="https://nikic.github.io/2012/06/15/The-true-power-of-regular-expressions.html" rel="nofollow noreferrer">nikic</a> for supplying the idea.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_33"><span>Answer 33</span> <span class="arrow"> <a href="#answer_32">↑</a> </span> <span class="arrow"> <a href="#answer_34">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>JacquesB</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 May 2021 at 07:50</span>
     </div>
    </div>
    <div>
     <p>First, to answer the direct question: Your regex has a bug since it will exclude a tag with a slash anywhere, not just at the end. For example it would exclude this valid opening tag: <code>&lt;a href="foo/bar.html"&gt;</code> because it has a slash in an attribute value.</p>
     <p>We can fix that, but more seriously, this regex will lead to <em>false positives</em>, because it will also match inside comments and cdata sections, where the same characters doesn't represent a valid tag. For example:</p>
     <pre><code>&lt;!-- &lt;foo&gt; --&gt;
</code></pre>
     <p>or</p>
     <pre><code>&lt;![CDATA[ &lt;foo&gt; ]]&gt;
</code></pre>
     <p>Especially html strings embedded in scripts is likely to trigger false positives, and so is the regular use of <code>&lt;</code> and <code>&gt;</code> as comparison operators in JavaScript. And of course sections of html which is commented-out with <code>&lt;!-- --&gt;</code>.</p>
     <p>So to only match actual tags, you also need to be able to skip past comments and cdata sections. So you need the regex to also <em>match</em> comments and cdata, but only <em>capture</em> the opening tags. This is still possible using a rexep, but it becomes significantly more complex, for example:</p>
     <pre><code>(  
    &lt;!-- .*? --&gt; # comment   
  | &lt;!\[CDATA\[ .*? \]\]&gt; # CData section
  | &lt; \w+ ( "" [^""]* "" | ' [^']* ' | [^&gt;/'""] )* /&gt; # self-closing tag  
  | (?&lt;tag&gt; &lt; \w+ ( "" [^""]* "" | ' [^']* ' | [^&gt;/'""] )* &gt; ) # opening tag - captured  
  | &lt;/ \w+ \s* &gt; # end tag  
)
</code></pre>
     <p>And this just for XHTML conforming to the HTML compatibility guidelines. If you want to handle arbitrary XHTML you should also handle processing instructions and internal DTD's, since they can also embed false positives. If you also want to handle HTML there are additional complexities like the <code>&lt;script&gt;</code>-tag. And if you also want to handle <em>invalid</em> HTML it gets yet more complex.</p>
     <p>Given the complexity, I would not recommend going down that road. Instead, look for an off-the-shelf (X)HTML parsing library which can solve your problem.</p>
     <p>A parser typically uses regular expressions (or similar) under the hood to split the document into "tokens" (doctype, start tags, end tags, text content etc.). But someone else will have debugged and tested these regexes for you! Depending on the type of parser it may further build a tree structure of elements by matching start tags to end tags. This will almost certainly save you a lot of time.</p>
     <p>The exact parser library to use depend on your language and platform and the task you are solving. If you need access to the actual tag-substrings (e.g. if you are writing a syntax highlighter for HTML) you need to use a SAX-style parser which exposes the syntax tokens directly.</p>
     <p>If you are only performing the tag-matching in order to manually build a syntax tree of elements, then a DOM parser does this work for you. But a DOM parser does not expose the underlying tag syntax, so does not solve the exact problem you describe.</p>
     <p>You should also consider if you need to to parse <em>invalid</em> HTML. This is a much more complex task, but on the wild web most of the HTML is actually invalid. Something like Pytons html5lib can parse invalid HTML.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_34"><span>Answer 34</span> <span class="arrow"> <a href="#answer_33">↑</a> </span> <span class="arrow"> <a href="#answer_35">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user13843220</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Oct 2020 at 18:55</span>
     </div>
    </div>
    <div>
     <p><strong><em>RegEx match open tags except XHTML self-contained tags</em></strong><br>
       All other tags (and content) are skipped.</p>
     <hr>
     <p>This regex does that. If you need to match only specific <em>Open</em> tags, make a list<br>
       in an alternation <code>(?:p|br|&lt;whatever tags you want&gt;)</code> and replace the <code>[\w:]+</code> construct<br>
       in the appropriate place below.</p>
     <p><code>&lt;(?:(?:(?:(script|style|object|embed|applet|noframes|noscript|noembed)(?:\s+(?&gt;"[\S\s]*?"|'[\S\s]*?'|(?:(?!/&gt;)[^&gt;])?)+)?\s*&gt;)[\S\s]*?&lt;/\1\s*(?=&gt;)(*SKIP)(*FAIL))|(?:[\w:]+\b(?=((?:"[\S\s]*?"|'[\S\s]*?'|[^&gt;]?)*)&gt;)\2(?&lt;!/))|(?:(?:/?[\w:]+\s*/?)|(?:[\w:]+\s+(?:"[\S\s]*?"|'[\S\s]*?'|[^&gt;]?)+\s*/?)|\?[\S\s]*?\?|(?:!(?:(?:DOCTYPE[\S\s]*?)|(?:\[CDATA\[[\S\s]*?\]\])|(?:--[\S\s]*?--)|(?:ATTLIST[\S\s]*?)|(?:ENTITY[\S\s]*?)|(?:ELEMENT[\S\s]*?))))(*SKIP)(*FAIL))&gt;</code></p>
     <p><a href="https://regex101.com/r/uMvJn0/1" rel="nofollow noreferrer">https://regex101.com/r/uMvJn0/1</a></p>
     <pre><code> # Mix html/xml     
 # https://regex101.com/r/uMvJn0/1     
 
 &lt;
 (?:
    
    # Invisible content gets failed
    
    (?:
       (?:
                               # Invisible content; end tag req'd
          (                    # (1 start)
             script
           | style
           | object
           | embed
           | applet
           | noframes
           | noscript
           | noembed 
          )                    # (1 end)
          (?:
             \s+ 
             (?&gt;
                " [\S\s]*? "
              | ' [\S\s]*? '
              | (?:
                   (?! /&gt; )
                   [^&gt;] 
                )?
             )+
          )?
          \s* &gt;
       )
       
       [\S\s]*? &lt;/ \1 \s* 
       (?= &gt; )
       (*SKIP)(*FAIL)
    )
    
  | 
    
    # This is any open html tag we will match
    
    (?:
       [\w:]+ \b 
       (?=
          (                    # (2 start)
             (?:
                " [\S\s]*? " 
              | ' [\S\s]*? ' 
              | [^&gt;]? 
             )*
          )                    # (2 end)
          &gt;
       )
       \2 
       (?&lt;! / )
    )
    
  | 
    # All other tags get failed
    
    (?:
       (?: /? [\w:]+ \s* /? )
     | (?:
          [\w:]+ 
          \s+ 
          (?:
             " [\S\s]*? " 
           | ' [\S\s]*? ' 
           | [^&gt;]? 
          )+
          \s* /?
       )
     | \? [\S\s]*? \?
     | (?:
          !
          (?:
             (?: DOCTYPE [\S\s]*? )
           | (?: \[CDATA\[ [\S\s]*? \]\] )
           | (?: -- [\S\s]*? -- )
           | (?: ATTLIST [\S\s]*? )
           | (?: ENTITY [\S\s]*? )
           | (?: ELEMENT [\S\s]*? )
          )
       )
    )
    (*SKIP)(*FAIL)
 )
 &gt;
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_35"><span>Answer 35</span> <span class="arrow"> <a href="#answer_34">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ahmed Kolsi</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Dec 2022 at 11:39</span>
     </div>
    </div>
    <div>
     <pre><code>&lt;([a-z][^&gt;\s]*)(?:\s+[^&gt;]+)?&gt;
</code></pre>
     <p>This regular expression will match opening tags that consist of a single word (e.g. &lt;p&gt;, &lt;a&gt;, etc.), followed by zero or more spaces and any number of characters (except &gt; or whitespace) before the closing &gt; character. It will also match tags with attributes, and will not match tags with names that contain characters other than a-z. However, it will still not match self-closing tags.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>