<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>What does if __name__ == "__main__": do?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>What does if __name__ == "__main__": do?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>8024</span>
    </div>
    <div>
     <span>Asker: </span> <span>Devoted</span>
    </div>
    <div>
     <span>Asked: </span> <span>7 Jan 2009 at 04:11</span>
    </div>
    <div>
     <a href="https://stackoverflow.com/questions/419163">source</a>
    </div>
   </div>
   <div>
    <p>What does this do, and why should one include the <code>if</code> statement?</p>
    <pre class="lang-py prettyprint-override"><code>if __name__ == "__main__":
    print("Hello, World!")
</code></pre>
    <hr>
    <p><sub>If you are trying to close a question where someone should be using this idiom and isn't, consider closing as a duplicate of <a href="https://stackoverflow.com/questions/6523791">Why is Python running my module when I import it, and how do I stop it?</a> instead. For questions where someone simply hasn't called any functions, or incorrectly expects a function named <code>main</code> to be used as an entry point automatically, use <a href="https://stackoverflow.com/questions/17257631">Why doesn't the main() function run when I start a Python script? Where does the script start running?</a>.</sub></p>
   </div>
   <div class="tags">
    <span class="tag">python</span><span class="tag">namespaces</span><span class="tag">program-entry-point</span><span class="tag">python-module</span><span class="tag">idioms</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>36</td>
       <td><span>Just for the record - what is "<b>main</b>": <a href="https://docs.python.org/3/reference/toplevel_components.html#complete-python-programs" rel="nofollow noreferrer">docs.python.org/3/reference/…</a> and what is "<b>name</b>": <a href="https://docs.python.org/3/reference/import.html?highlight=__name__#__name__" rel="nofollow noreferrer">docs.python.org/3/reference/…</a></span> <span> - </span> <span class="display-name">Konstantin Burlachenko</span> <span> </span> <span class="date">2 Apr 2021 at 09:17</span></td>
      </tr>
      <tr>
       <td>22</td>
       <td><span>How many of y'all have come here 'cause you wanna copy-paste 'if __name__ == "__main__":'? :-P</span> <span> - </span> <span class="display-name">Aaron John Sabu</span> <span> </span> <span class="date">6 Sep 2022 at 23:17</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>It's useful if you want to write Python code which is intended to be "imported" but can also be run as a standalone shell script. The code protected by the <code>if __name__</code> check only runs when it's invoked as a command, not when imported. It's also useful if you want to debug a Python script using an interactive Python session. You can "import" code that's normally run as a command in an interactive session, then manually enter code to run functions/classes in the script as you like.</span> <span> - </span> <span class="display-name">cnamejj</span> <span> </span> <span class="date">8 Jan 2023 at 02:06</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>To anyone ending up here, <a href="https://www.youtube.com/watch?v=g_wlZ9IhbTs" rel="nofollow noreferrer">[7:32] <i>You should put this in all your Python scripts | if __name__ == '__main__': ...</i> by YouTube channel mCoding</a> provides a great explanation and discussion of the consequences of this idiom. The title is probably too prescriptive for SO, but the explanation is good.</span> <span> - </span> <span class="display-name">eccentricOrange</span> <span> </span> <span class="date">30 Jan 2023 at 14:21</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8676</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mr Fooz</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Jan 2009 at 04:26</span>
     </div>
    </div>
    <div>
     <h1>Short Answer</h1>
     <p>It's boilerplate code that protects users from accidentally invoking the script when they didn't intend to. Here are some common problems when the guard is omitted from a script:</p>
     <ul>
      <li>
       <p>If you import the guardless script in another script (e.g. <code>import my_script_without_a_name_eq_main_guard</code>), then the latter script will trigger the former to run <em>at import time</em> and <em>using the second script's command line arguments</em>. This is almost always a mistake.</p></li>
      <li>
       <p>If you have a custom class in the guardless script and save it to a pickle file, then unpickling it in another script will trigger an import of the guardless script, with the same problems outlined in the previous bullet.</p></li>
     </ul>
     <h1>Long Answer</h1>
     <p>To better understand why and how this matters, we need to take a step back to understand how Python initializes scripts and how this interacts with its module import mechanism.</p>
     <p>Whenever the Python interpreter reads a source file, it does two things:</p>
     <ul>
      <li>
       <p>it sets a few special variables like <code>__name__</code>, and then</p></li>
      <li>
       <p>it executes all of the code found in the file.</p></li>
     </ul>
     <p>Let's see how this works and how it relates to your question about the <code>__name__</code> checks we always see in Python scripts.</p>
     <h2>Code Sample</h2>
     <p>Let's use a slightly different code sample to explore how imports and scripts work. Suppose the following is in a file called <code>foo.py</code>.</p>
     <pre><code># Suppose this is foo.py.

print("before import")
import math

print("before function_a")
def function_a():
    print("Function A")

print("before function_b")
def function_b():
    print("Function B {}".format(math.sqrt(100)))

print("before __name__ guard")
if __name__ == '__main__':
    function_a()
    function_b()
print("after __name__ guard")
</code></pre>
     <h2>Special Variables</h2>
     <p>When the Python interpreter reads a source file, it first defines a few special variables. In this case, we care about the <code>__name__</code> variable.</p>
     <p><strong>When Your Module Is the Main Program</strong></p>
     <p>If you are running your module (the source file) as the main program, e.g.</p>
     <pre><code>python foo.py
</code></pre>
     <p>the interpreter will assign the hard-coded string <code>"__main__"</code> to the <code>__name__</code> variable, i.e.</p>
     <pre><code># It's as if the interpreter inserts this at the top
# of your module when run as the main program.
__name__ = "__main__" 
</code></pre>
     <p><strong>When Your Module Is Imported By Another</strong></p>
     <p>On the other hand, suppose some other module is the main program and it imports your module. This means there's a statement like this in the main program, or in some other module the main program imports:</p>
     <pre><code># Suppose this is in some other main program.
import foo
</code></pre>
     <p>The interpreter will search for your <code>foo.py</code> file (along with searching for a few other variants), and prior to executing that module, it will assign the name <code>"foo"</code> from the import statement to the <code>__name__</code> variable, i.e.</p>
     <pre><code># It's as if the interpreter inserts this at the top
# of your module when it's imported from another module.
__name__ = "foo"
</code></pre>
     <h2>Executing the Module's Code</h2>
     <p>After the special variables are set up, the interpreter executes all the code in the module, one statement at a time. You may want to open another window on the side with the code sample so you can follow along with this explanation.</p>
     <p><strong>Always</strong></p>
     <ol>
      <li>
       <p>It prints the string <code>"before import"</code> (without quotes).</p></li>
      <li>
       <p>It loads the <code>math</code> module and assigns it to a variable called <code>math</code>. This is equivalent to replacing <code>import math</code> with the following (note that <code>__import__</code> is a low-level function in Python that takes a string and triggers the actual import):</p></li>
     </ol>
     <pre><code># Find and load a module given its string name, "math",
# then assign it to a local variable called math.
math = __import__("math")
</code></pre>
     <ol start="3">
      <li>
       <p>It prints the string <code>"before function_a"</code>.</p></li>
      <li>
       <p>It executes the <code>def</code> block, creating a function object, then assigning that function object to a variable called <code>function_a</code>.</p></li>
      <li>
       <p>It prints the string <code>"before function_b"</code>.</p></li>
      <li>
       <p>It executes the second <code>def</code> block, creating another function object, then assigning it to a variable called <code>function_b</code>.</p></li>
      <li>
       <p>It prints the string <code>"before __name__ guard"</code>.</p></li>
     </ol>
     <p><strong>Only When Your Module Is the Main Program</strong></p>
     <ol start="8">
      <li>If your module is the main program, then it will see that <code>__name__</code> was indeed set to <code>"__main__"</code> and it calls the two functions, printing the strings <code>"Function A"</code> and <code>"Function B 10.0"</code>.</li>
     </ol>
     <p><strong>Only When Your Module Is Imported by Another</strong></p>
     <ol start="8">
      <li>(<strong>instead</strong>) If your module is not the main program but was imported by another one, then <code>__name__</code> will be <code>"foo"</code>, not <code>"__main__"</code>, and it'll skip the body of the <code>if</code> statement.</li>
     </ol>
     <p><strong>Always</strong></p>
     <ol start="9">
      <li>It will print the string <code>"after __name__ guard"</code> in both situations.</li>
     </ol>
     <p><em><strong>Summary</strong></em></p>
     <p>In summary, here's what'd be printed in the two cases:</p>
     <pre class="lang-none prettyprint-override"><code># What gets printed if foo is the main program
before import
before function_a
before function_b
before __name__ guard
Function A
Function B 10.0
after __name__ guard
</code></pre>
     <pre class="lang-none prettyprint-override"><code># What gets printed if foo is imported as a regular module
before import
before function_a
before function_b
before __name__ guard
after __name__ guard
</code></pre>
     <h2>Why Does It Work This Way?</h2>
     <p>You might naturally wonder why anybody would want this. Well, sometimes you want to write a <code>.py</code> file that can be both used by other programs and/or modules as a module, and can also be run as the main program itself. Examples:</p>
     <ul>
      <li>
       <p>Your module is a library, but you want to have a script mode where it runs some unit tests or a demo.</p></li>
      <li>
       <p>Your module is only used as a main program, but it has some unit tests, and the testing framework works by importing <code>.py</code> files like your script and running special test functions. You don't want it to try running the script just because it's importing the module.</p></li>
      <li>
       <p>Your module is mostly used as a main program, but it also provides a programmer-friendly API for advanced users.</p></li>
     </ul>
     <p>Beyond those examples, it's elegant that running a script in Python is just setting up a few magic variables and importing the script. "Running" the script is a side effect of importing the script's module.</p>
     <h2>Food for Thought</h2>
     <ul>
      <li>
       <p>Question: Can I have multiple <code>__name__</code> checking blocks? Answer: it's strange to do so, but the language won't stop you.</p></li>
      <li>
       <p>Suppose the following is in <code>foo2.py</code>. What happens if you say <code>python foo2.py</code> on the command-line? Why?</p></li>
     </ul>
     <pre class="lang-py prettyprint-override"><code># Suppose this is foo2.py.
import os, sys; sys.path.insert(0, os.path.dirname(__file__)) # needed for some interpreters

def function_a():
    print("a1")
    from foo2 import function_b
    print("a2")
    function_b()
    print("a3")

def function_b():
    print("b")

print("t1")
if __name__ == "__main__":
    print("m1")
    function_a()
    print("m2")
print("t2")
      
</code></pre>
     <ul>
      <li>Now, figure out what will happen if you remove the <code>__name__</code> check in <code>foo3.py</code>:</li>
     </ul>
     <pre class="lang-py prettyprint-override"><code># Suppose this is foo3.py.
import os, sys; sys.path.insert(0, os.path.dirname(__file__)) # needed for some interpreters

def function_a():
    print("a1")
    from foo3 import function_b
    print("a2")
    function_b()
    print("a3")

def function_b():
    print("b")

print("t1")
print("m1")
function_a()
print("m2")
print("t2")
</code></pre>
     <ul>
      <li>What will this do when used as a script? When imported as a module?</li>
     </ul>
     <pre class="lang-py prettyprint-override"><code># Suppose this is in foo4.py
__name__ = "__main__"

def bar():
    print("bar")
    
print("before __name__ guard")
if __name__ == "__main__":
    bar()
print("after __name__ guard")
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>48</td>
        <td><span>Out of curiosity: What hapens if I run <code>subprocess.run('foo_bar.py')</code> in a python script? I suppose that <code>foo_bar</code> will be started with <code>__name__ = '__main__'</code> just like when I tipe <code>foo_bar.py</code> in cmd manually. Is that the case? Taking @MrFooz' Answer into account there should not be any problem doing this and having as many "main" modules at a time as I like. Even changing the <code>__name__</code> value or having several independantly creates instances (or instances that created each other by <code>subprocess</code>) interact with each other should be business as usual for Python. Do I miss something?</span> <span> - </span> <span class="display-name">hajef</span> <span> </span> <span class="date">18 Feb 2019 at 16:09</span></td>
       </tr>
       <tr>
        <td>40</td>
        <td><span>@hajef You're correct about how things would work with <code>subprocess.run</code>. That said, a generally better way of sharing code between scripts is to create modules and have the scripts call the shared modules instead of invoking each other as scripts. It's hard to debug <code>subprocess.run</code> calls since most debuggers don't jump across process boundaries, it can add non-trivial system overhead to create and destroy the extra processes, etc.</span> <span> - </span> <span class="display-name">Mr Fooz</span> <span> </span> <span class="date">19 Feb 2019 at 16:16</span></td>
       </tr>
       <tr>
        <td>11</td>
        <td><span>i have a doubt in foo2.py example in the food for thought section.what does from foo2.py import functionB do? In my view it just imports foo2.py from functionB</span> <span> - </span> <span class="display-name">user471651</span> <span> </span> <span class="date">24 Feb 2019 at 13:47</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@MrFooz I never intended to do anything like this xD It just came to my mind and I realized that it was strange enought to possibly help ppl. wrapping their minds around this sort of stuff. @user471651 Why should <code>from foo2 import functionB</code> import foo2 from functionB? That's a semantic contortion. <code>from module import method</code> imports the method from the modul.</span> <span> - </span> <span class="display-name">hajef</span> <span> </span> <span class="date">25 Feb 2019 at 15:51</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span>One of the modules that may import your code is <code>multiprocessing</code>, in particular making this test necessary on Windows.</span> <span> - </span> <span class="display-name">Yann Vernier</span> <span> </span> <span class="date">17 Sep 2019 at 15:51</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span>Extremely minor point, but I believe python actually determines the <code>__name__</code> of an imported module from the import statement, not from stripping ".py" off the filename. Because python identifiers are case sensitive but file names may not be (e.g. on windows), there isn't necessarily enough information in the filename to determine the correct python module name.</span> <span> - </span> <span class="display-name">Ben</span> <span> </span> <span class="date">4 Feb 2020 at 20:43</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Ben Thanks. Post updated. I didn't bother finding the actual code for the logic you describe, but it rings true.</span> <span> - </span> <span class="display-name">Mr Fooz</span> <span> </span> <span class="date">6 Feb 2020 at 15:30</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@user471651 In the food for thought section, <code>from foo2 import functionB</code> will trigger the Python interpreter to reload <code>foo2.py</code> a second time, but this second time it'll have <code>__name__='foo2'</code> instead of <code>__name__='__main__'</code>. There will be <i>two</i> copies of <code>functionB</code> in RAM. <code>functionA</code> in <code>__main__</code> will call the version loaded as <code>foo2.functionB</code>, not the <code>__main__.functionB</code> copy.</span> <span> - </span> <span class="display-name">Mr Fooz</span> <span> </span> <span class="date">30 Mar 2020 at 22:49</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Then, how does this relate to <code>__main__.py</code>.</span> <span> - </span> <span class="display-name">BAKE ZQ</span> <span> </span> <span class="date">12 Jun 2020 at 04:19</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@VaibhavGupta You're probably using an interpreter that doesn't automatically add the script's directory to <code>sys.path</code>. The auto-add feature has been around a long time (forever?) and makes Python easier to use, but it's insecure. To improve security, some people disable that feature. I'm having trouble finding a public record of it, but there have been recent discussions about removing the auto-add feature from Python 3. Maybe it's actually happened now. Regardless, I've added a line that should make <code>foo2.py</code> and <code>foo3.py</code> work for the safer interpreter setup.</span> <span> - </span> <span class="display-name">Mr Fooz</span> <span> </span> <span class="date">23 Jun 2020 at 17:15</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>I loved how subtly this line solved my confusion: " "Running" the script is a side effect of importing the script's module."</span> <span> - </span> <span class="display-name">Abhimanyu Shekhawat</span> <span> </span> <span class="date">9 Sep 2020 at 10:39</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>For those who are wondering about an infinite loop, see <a href="https://stackoverflow.com/q/3558842/6361923">this</a></span> <span> - </span> <span class="display-name">vbenara</span> <span> </span> <span class="date">8 Mar 2021 at 08:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@V.ben Indeed. If you're curious, the way Python enforces single-loading of modules is to memoize the module objects in <code>sys.modules</code>. Near the start of importing, it checks if the module is registered there; if so, it stops. If not, it creates a blank module object and injects it into <code>sys.modules</code>, immediately. After that, it starts executing the module's code as discussed in this post.</span> <span> - </span> <span class="display-name">Mr Fooz</span> <span> </span> <span class="date">9 Mar 2021 at 16:33</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>What if my imported module file is <code>'__main__.py'</code>? is it gonna break this guard check?</span> <span> - </span> <span class="display-name">Oleksandr Novik</span> <span> </span> <span class="date">25 Nov 2021 at 10:16</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@AleksandrNovik Unless you use some low-level import tricks, <code>import __main__</code> from a script, say <code>script.py</code>, won't load <code>__main__.py</code>. Quick example (note that "importing <b>main</b>.py" is not printed by running <code>script.py</code>). Put a newline between each gray block. <code>% cat script.py</code> <code>print("in script.py")</code> <code>if __name__ == "__main__":</code> ` import <b>main__` ` print("done with script.py __main</b> guard")` <code>% cat __main__.py</code> <code>print("importing __main__.py")</code> <code>% python3 script.py</code> <code>in script.py</code> <code>done with script.py __main__ guard</code> <code>% python3 __main__.py</code> <code>importing __main__.py</code></span> <span> - </span> <span class="display-name">Mr Fooz</span> <span> </span> <span class="date">30 Nov 2021 at 19:29</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Mr Fooz <b><i>"then the second script will trigger the first to run at import time and using the second script's command line arguments. "</i></b> What's the first/second script?</span> <span> - </span> <span class="display-name">John</span> <span> </span> <span class="date">12 May 2022 at 08:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@John In that bullet, the "first script" is the "guardless script" (<code>my_script_without_a_name_eq_main_guard.py</code>) and the "second script is the "another script" (the one that contains the <code>import my_script_without_a_name_eq_main_guard</code> statement). I've change "first" and "second" to "former" and "latter", respectively. Hopefully that'll be clearer for people reading the bullet quickly.</span> <span> - </span> <span class="display-name">Mr Fooz</span> <span> </span> <span class="date">16 May 2022 at 16:24</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@MrFooz I see. Thank you for the clarification. Suggest to modify it like this: <i>If you import the guardless script(e.g. <code>my_script_without_a_name_eq_main_guard.py</code>) in another script...</i> <b><i>And</i></b>, what do you mean by <b>If you have a custom class in the guardless script and ==*save it to a pickle file*==, then ==*unpickling it in another script*== will trigger an import of the guardless script,</b>? Could you please explain that in more detail for me?</span> <span> - </span> <span class="display-name">John</span> <span> </span> <span class="date">17 May 2022 at 01:36</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@MrFooz I have a doubt in the example named as <code>foo2.py</code> in section named 'the food for thought '. When <code>from foo3 import functionB</code> is actually called at the first time, before the main section or after after? How many times it has been called, whether <code>from foo3 import functionB</code> would be invoked every time that <code>functionA()</code> is called?</span> <span> - </span> <span class="display-name">John</span> <span> </span> <span class="date">17 May 2022 at 02:56</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>A question for discussion: is it a good practice to use "<b>main</b>"? Why not separate the executable script and import functions into two separate files, and never import the executable file?</span> <span> - </span> <span class="display-name">mercury0114</span> <span> </span> <span class="date">4 Jul 2022 at 15:45</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@mercury0114: It's not discussed in this post, but another reason to use <code>"__main__"</code> checks is that it allows you to embed doctests in your scripts. The doctest runner needs to import whatever it's testing, and that's only safe to do if the script has a <code>"__main__"</code> check.</span> <span> - </span> <span class="display-name">Mr Fooz</span> <span> </span> <span class="date">4 Jul 2022 at 19:08</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@MrFooz Not just doctests. It lets you import a script to test its functions without triggering its entry point.</span> <span> - </span> <span class="display-name">chepner</span> <span> </span> <span class="date">6 Sep 2022 at 12:55</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2158</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Adam Rosenfield</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Jan 2009 at 04:28</span>
     </div>
    </div>
    <div>
     <p>When your script is run by passing it as a command to the Python interpreter,</p>
     <pre><code>python myscript.py
</code></pre>
     <p>all of the code that is at indentation level 0 gets executed. Functions and classes that are defined are, well, defined, but none of their code gets run. Unlike other languages, there's no <code>main()</code> function that gets run automatically - the <code>main()</code> function is implicitly all the code at the top level.</p>
     <p>In this case, the top-level code is an <code>if</code> block. <code>__name__</code> is a built-in variable which evaluates to the name of the current module. However, if a module is being run directly (as in <code>myscript.py</code> above), then <code>__name__</code> instead is set to the string <code>"__main__"</code>. Thus, you can test whether your script is being run directly or being imported by something else by testing</p>
     <pre><code>if __name__ == "__main__":
    ...
</code></pre>
     <p>If your script is being imported into another module, its various function and class definitions will be imported and its top-level code will be executed, but the code in the then-body of the <code>if</code> clause above won't get run as the condition is not met. As a basic example, consider the following two scripts:</p>
     <pre><code># file one.py
def func():
    print("func() in one.py")

print("top-level in one.py")

if __name__ == "__main__":
    print("one.py is being run directly")
else:
    print("one.py is being imported into another module")
</code></pre>
     <pre><code># file two.py
import one

print("top-level in two.py")
one.func()

if __name__ == "__main__":
    print("two.py is being run directly")
else:
    print("two.py is being imported into another module")
</code></pre>
     <p>Now, if you invoke the interpreter as</p>
     <pre><code>python one.py
</code></pre>
     <p>The output will be</p>
     <pre><code>top-level in one.py
one.py is being run directly
</code></pre>
     <p>If you run <code>two.py</code> instead:</p>
     <pre><code>python two.py
</code></pre>
     <p>You get</p>
     <pre><code>top-level in one.py
one.py is being imported into another module
top-level in two.py
func() in one.py
two.py is being run directly
</code></pre>
     <p>Thus, when module <code>one</code> gets loaded, its <code>__name__</code> equals <code>"one"</code> instead of <code>"__main__"</code>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>16</td>
        <td><span>So, <code>if __name__ == "__main__":</code> basically checks if you are running your python script itself, and not importing it or something?</span> <span> - </span> <span class="display-name">Merp</span> <span> </span> <span class="date">18 Feb 2021 at 18:20</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Adam Rosenfield <i>If your script is being imported into another module, its various function and class definitions will be imported and <b>its top-level code</b> will be executed...</i>. What's the top-level code? The code with the indentation of zero?</span> <span> - </span> <span class="display-name">John</span> <span> </span> <span class="date">17 May 2022 at 03:27</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>874</span>
     </div>
     <div>
      <span>Answerer: </span> <span>pi.</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Jan 2009 at 11:35</span>
     </div>
    </div>
    <div>
     <p>Create the following two files:</p>
     <pre class="lang-py prettyprint-override"><code># a.py

import b
</code></pre>
     <pre class="lang-py prettyprint-override"><code># b.py

print("__name__ equals " + __name__)

if __name__ == '__main__':
    print("if-statement was executed")
</code></pre>
     <p>Now run each file individually.</p>
     <hr>
     <p><strong>Running <code>python a.py</code>:</strong></p>
     <pre><code>$ python a.py
__name__ equals b
</code></pre>
     <p>When <code>a.py</code> is executed, it imports the module <code>b</code>. This causes all the code inside <code>b</code> to run. Python sets <code>globals()['__name__']</code> in the <code>b</code> module to the module's name, <code>b</code>.</p>
     <br>
     <p><strong>Running <code>python b.py</code>:</strong></p>
     <pre><code>$ python b.py
__name__ equals __main__
if-statement was executed
</code></pre>
     <p>When only the file <code>b.py</code> is executed, Python sets <code>globals()['__name__']</code> in this file to <code>"__main__"</code>. Therefore, the <code>if</code> statement evaluates to <code>True</code> this time.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>613</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Russia Must Remove Putin</span>
     </div>
     <div>
      <span> Answered: </span> <span>23 Nov 2013 at 04:38</span>
     </div>
    </div>
    <div>
     <blockquote>
      <h2>What does the <code>if __name__ == "__main__":</code> do?</h2>
     </blockquote>
     <p>To outline the basics:</p>
     <ul>
      <li>
       <p>The global variable, <code>__name__</code>, in the module that is the entry point to your program, is <code>'__main__'</code>. Otherwise, it's the name you import the module by.</p></li>
      <li>
       <p>So, code under the <code>if</code> block will only run if the module is the entry point to your program.</p></li>
      <li>
       <p>It allows the code in the module to be importable by other modules, without executing the code block beneath on import.</p></li>
     </ul>
     <hr>
     <p>Why do we need this?</p>
     <h2>Developing and Testing Your Code</h2>
     <p>Say you're writing a Python script designed to be used as a module:</p>
     <pre><code>def do_important():
    """This function does something very important"""
</code></pre>
     <p>You <em>could</em> test the module by adding this call of the function to the bottom:</p>
     <pre><code>do_important()
</code></pre>
     <p>and running it (on a command prompt) with something like:</p>
     <pre><code>~$ python important.py
</code></pre>
     <h2>The Problem</h2>
     <p>However, if you want to import the module to another script:</p>
     <pre><code>import important
</code></pre>
     <p>On import, the <code>do_important</code> function would be called, so you'd probably comment out your function call, <code>do_important()</code>, at the bottom.</p>
     <pre><code># do_important() # I must remember to uncomment to execute this!
</code></pre>
     <p>And then you'll have to remember whether or not you've commented out your test function call. And this extra complexity would mean you're likely to forget, making your development process more troublesome.</p>
     <h2>A Better Way</h2>
     <p>The <code>__name__</code> variable points to the namespace wherever the Python interpreter happens to be at the moment.</p>
     <p>Inside an imported module, it's the name of that module.</p>
     <p>But inside the primary module (or an interactive Python session, i.e. the interpreter's Read, Eval, Print Loop, or REPL) you are running everything from its <code>"__main__"</code>.</p>
     <p>So if you check before executing:</p>
     <pre><code>if __name__ == "__main__":
    do_important()
</code></pre>
     <p>With the above, your code will only execute when you're running it as the primary module (or intentionally call it from another script).</p>
     <h2>An Even Better Way</h2>
     <p>There's a Pythonic way to improve on this, though.</p>
     <p>What if we want to run this business process from outside the module?</p>
     <p>If we put the code we want to exercise as we develop and test in a function like this and then do our check for <code>'__main__'</code> immediately after:</p>
     <pre><code>def main():
    """business logic for when running this module as the primary one!"""
    setup()
    foo = do_important()
    bar = do_even_more_important(foo)
    for baz in bar:
        do_super_important(baz)
    teardown()

# Here's our payoff idiom!
if __name__ == '__main__':
    main()
</code></pre>
     <p>We now have a final function for the end of our module that will run if we run the module as the primary module.</p>
     <p>It will allow the module and its functions and classes to be imported into other scripts without running the <code>main</code> function, and will also allow the module (and its functions and classes) to be called when running from a different <code>'__main__'</code> module, i.e.</p>
     <pre><code>import important
important.main()
</code></pre>
     <p><a href="https://docs.python.org/2/library/__main__.html" rel="noreferrer">This idiom can also be found in the Python documentation in an explanation of the <code>__main__</code> module.</a> That text states:</p>
     <blockquote>
      <p>This module represents the (otherwise anonymous) scope in which the interpreter’s main program executes — commands read either from standard input, from a script file, or from an interactive prompt. It is this environment in which the idiomatic “conditional script” stanza causes a script to run:</p>
      <pre><code>if __name__ == '__main__':
    main()
</code></pre>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Sorry, I can't there be any difference between the method mentioned in the section named <code>A Better Way</code> and the method mentioned in the section named <code>An Even Better Way</code>. Could you please point out it?</span> <span> - </span> <span class="display-name">John</span> <span> </span> <span class="date">17 May 2022 at 05:15</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@John I don't think there's a difference. He used <code>A Better Way</code> to illustrate how we can run the module as a script and <code>An Even Better Way</code> to illustrate how we can import the module elsewhere and still run it.</span> <span> - </span> <span class="display-name">BtLutz</span> <span> </span> <span class="date">1 Aug 2022 at 19:24</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>175</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Harley Holcombe</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Jan 2009 at 04:14</span>
     </div>
    </div>
    <div>
     <p><code>if __name__ == "__main__"</code> is the part that runs when the script is run from (say) the command line using a command like <code>python myscript.py</code>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>5</td>
        <td><span>Why does a file <code>helloworld.py</code> with just <code>print("hello world")</code> in it can run with command <code>python helloworld.py</code> even when there is no <code>if __name__ == "__main__"</code>?</span> <span> - </span> <span class="display-name">hi15</span> <span> </span> <span class="date">22 Aug 2019 at 16:39</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>When you run <code>python helloworld.py</code> it will run the whole script file (whether you specify <code>if __name__ == "__main__"</code> or not ) . There is only a difference in execution when you are importing <code>helloworld.py</code> from a different script. In that case the <code>if __name__ == "__main__"</code> codeblock does not execute at all.</span> <span> - </span> <span class="display-name">Nihal Sangeeth</span> <span> </span> <span class="date">29 Dec 2020 at 14:09</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>113</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Russia Must Remove Putin</span>
     </div>
     <div>
      <span> Answered: </span> <span>14 Oct 2014 at 20:22</span>
     </div>
    </div>
    <div>
     <blockquote>
      <h2>What does <code>if __name__ == "__main__":</code> do?</h2>
     </blockquote>
     <p><code>__name__</code> is a global variable (in Python, global actually means on the <a href="https://docs.python.org/tutorial/modules.html#modules" rel="noreferrer">module level</a>) that exists in all namespaces. It is typically the module's name (as a <code>str</code> type).</p>
     <p>As the only special case, however, in whatever Python process you run, as in mycode.py:</p>
     <pre><code>python mycode.py
</code></pre>
     <p>the otherwise anonymous global namespace is assigned the value of <code>'__main__'</code> to its <code>__name__</code>.</p>
     <p>Thus, including <a href="https://docs.python.org/library/__main__.html" rel="noreferrer">the final lines</a></p>
     <pre><code>if __name__ == '__main__':
    main()
</code></pre>
     <ul>
      <li>at the end of your mycode.py script,</li>
      <li>when it is the primary, entry-point module that is run by a Python process,</li>
     </ul>
     <p>will cause your script's uniquely defined <code>main</code> function to run.</p>
     <p>Another benefit of using this construct: you can also import your code as a module in another script and then run the main function if and when your program decides:</p>
     <pre><code>import mycode
# ... any amount of other code
mycode.main()
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>97</span>
     </div>
     <div>
      <span>Answerer: </span> <span>joechoj</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Sep 2016 at 04:33</span>
     </div>
    </div>
    <div>
     <p>There are lots of different takes here on the mechanics of the code in question, the "How", but for me none of it made sense until I understood the "Why". This should be especially helpful for new programmers.</p>
     <p>Take file "ab.py":</p>
     <pre><code>def a():
    print('A function in ab file');
a()
</code></pre>
     <p>And a second file "xy.py":</p>
     <pre><code>import ab
def main():
    print('main function: this is where the action is')
def x():
    print ('peripheral task: might be useful in other projects')
x()
if __name__ == "__main__":
    main()
</code></pre>
     <blockquote>
      <p>What is this code actually doing?</p>
     </blockquote>
     <p>When you execute <code>xy.py</code>, you <code>import ab</code>. The import statement runs the module immediately on import, so <code>ab</code>'s operations get executed before the remainder of <code>xy</code>'s. Once finished with <code>ab</code>, it continues with <code>xy</code>.</p>
     <p>The interpreter keeps track of which scripts are running with <code>__name__</code>. When you run a script - no matter what you've named it - the interpreter calls it <code>"__main__"</code>, making it the master or 'home' script that gets returned to after running an external script.</p>
     <p>Any other script that's called from this <code>"__main__"</code> script is assigned its filename as its <code>__name__</code> (e.g., <code>__name__ == "ab.py"</code>). Hence, the line <code>if __name__ == "__main__":</code> is the interpreter's test to determine if it's interpreting/parsing the 'home' script that was initially executed, or if it's temporarily peeking into another (external) script. This gives the programmer flexibility to have the script behave differently if it's executed directly vs. called externally.</p>
     <p>Let's step through the above code to understand what's happening, focusing first on the unindented lines and the order they appear in the scripts. Remember that function - or <code>def</code> - blocks don't do anything by themselves until they're called. What the interpreter might say if mumbled to itself:</p>
     <ul>
      <li>Open xy.py as the 'home' file; call it <code>"__main__"</code> in the <code>__name__</code> variable.</li>
      <li>Import and open file with the <code>__name__ == "ab.py"</code>.</li>
      <li>Oh, a function. I'll remember that.</li>
      <li>Ok, function <code>a()</code>; I just learned that. Printing '<em>A function in ab file</em>'.</li>
      <li>End of file; back to <code>"__main__"</code>!</li>
      <li>Oh, a function. I'll remember that.</li>
      <li>Another one.</li>
      <li>Function <code>x()</code>; ok, printing '<em>peripheral task: might be useful in other projects</em>'.</li>
      <li>What's this? An <code>if</code> statement. Well, the condition has been met (the variable <code>__name__</code> has been set to <code>"__main__"</code>), so I'll enter the <code>main()</code> function and print '<em>main function: this is where the action is</em>'.</li>
     </ul>
     <p>The bottom two lines mean: "If this is the <code>"__main__"</code> or 'home' script, execute the function called <code>main()</code>". That's why you'll see a <code>def main():</code> block up top, which contains the main flow of the script's functionality.</p>
     <blockquote>
      <p>Why implement this?</p>
     </blockquote>
     <p>Remember what I said earlier about import statements? When you import a module it doesn't just 'recognize' it and wait for further instructions - it actually runs all the executable operations contained within the script. So, putting the meat of your script into the <code>main()</code> function effectively quarantines it, putting it in isolation so that it won't immediately run when imported by another script.</p>
     <p>Again, there will be exceptions, but common practice is that <code>main()</code> doesn't usually get called externally. So you may be wondering one more thing: if we're not calling <code>main()</code>, why are we calling the script at all? It's because many people structure their scripts with standalone functions that are built to be run independent of the rest of the code in the file. They're then later called somewhere else in the body of the script. Which brings me to this:</p>
     <blockquote>
      <p>But the code works without it</p>
     </blockquote>
     <p>Yes, that's right. These separate functions <strong>can</strong> be called from an in-line script that's not contained inside a <code>main()</code> function. If you're accustomed (as I am, in my early learning stages of programming) to building in-line scripts that do exactly what you need, and you'll try to figure it out again if you ever need that operation again ... well, you're not used to this kind of internal structure to your code, because it's more complicated to build and it's not as intuitive to read.</p>
     <p>But that's a script that probably can't have its functions called externally, because if it did it would immediately start calculating and assigning variables. And chances are if you're trying to re-use a function, your new script is related closely enough to the old one that there will be conflicting variables.</p>
     <p>In splitting out independent functions, you gain the ability to re-use your previous work by calling them into another script. For example, "example.py" might import "xy.py" and call <code>x()</code>, making use of the 'x' function from "xy.py". (Maybe it's capitalizing the third word of a given text string; creating a NumPy array from a list of numbers and squaring them; or detrending a 3D surface. The possibilities are limitless.)</p>
     <p>(As an aside, <a href="https://stackoverflow.com/questions/23000075/purpose-of-if-name-main">this question</a> contains an answer by @kindall that finally helped me to understand - the why, not the how. Unfortunately it's been marked as a duplicate of <a href="https://stackoverflow.com/questions/419163/what-does-if-name-main-do">this one</a>, which I think is a mistake.)</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>94</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Giorgos Myrianthous</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Feb 2020 at 13:26</span>
     </div>
    </div>
    <div>
     <p>The code under <code>if __name__ == '__main__':</code> will <em>only</em> be executed if the module is invoked as a script.</p>
     <p>As an example, consider the following module <code>my_test_module.py</code>:</p>
     <pre><code># my_test_module.py

print('This is going to be printed out, no matter what')

if __name__ == '__main__':
    print('This is going to be printed out, only if user invokes the module as a script')
</code></pre>
     <hr>
     <p><strong>First possibility: Import <code>my_test_module.py</code> in another module</strong></p>
     <pre><code># main.py

import my_test_module

if __name__ == '__main__':
    print('Hello from main.py')
</code></pre>
     <p>Now if you invoke <code>main.py</code>:</p>
     <pre><code>python main.py

&gt;&gt; 'This is going to be printed out, no matter what'
&gt;&gt; 'Hello from main.py'
</code></pre>
     <p>Note that only the top-level <code>print()</code> statement in <code>my_test_module</code> is executed.</p>
     <hr>
     <p><strong>Second possibility: Invoke <code>my_test_module.py</code> as a script</strong></p>
     <p>Now if you run <code>my_test_module.py</code> as a Python script, both <code>print()</code> statements will be executed:</p>
     <pre><code>python my_test_module.py

&gt;&gt;&gt; 'This is going to be printed out, no matter what'
&gt;&gt;&gt; 'This is going to be printed out, only if user invokes the module as a script'
</code></pre>
     <hr>
     <p>For a more comprehensive explanation, you can read <em><a href="https://towardsdatascience.com/python-main-b729fab7a8c3" rel="noreferrer">What does <code>if __name__ == '__main__'</code> do in Python</a></em>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span>Short and clear!</span> <span> - </span> <span class="display-name">Scott</span> <span> </span> <span class="date">30 Sep 2022 at 03:59</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>72</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Nabeel Ahmed</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Apr 2013 at 14:09</span>
     </div>
    </div>
    <div>
     <p>When there are certain statements in our module (<code>M.py</code>) we want to be executed when it'll be running as main (not imported), we can place those statements (test-cases, print statements) under this <code>if</code> block.</p>
     <p>As by default (when module running as main, not imported) the <code>__name__</code> variable is set to <code>"__main__"</code>, and when it'll be imported the <code>__name__</code> variable will get a different value, most probably the name of the module (<code>'M'</code>). This is helpful in running different variants of a modules together, and separating their specific input &amp; output statements and also if there are any test-cases.</p>
     <p><strong>In short</strong>, use this '<code>if __name__ == "main"</code> ' block to prevent (certain) code from being run when the module is imported.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>+1 Sometimes, it's good to just get a short one-liner like mentioned in this answer: "In short, use this 'if <b>name</b> == "main" ' block to prevent (certain) code from being run when the module is imported.". This is useful. Thanks!</span> <span> - </span> <span class="display-name">ZeZNiQ</span> <span> </span> <span class="date">14 Sep 2021 at 15:17</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>67</span>
     </div>
     <div>
      <span>Answerer: </span> <span>redbandit</span>
     </div>
     <div>
      <span> Answered: </span> <span>15 Oct 2016 at 09:07</span>
     </div>
    </div>
    <div>
     <p>Put simply, <code>__name__</code> is a variable defined for each script that defines whether the script is being run as the main module or it is being run as an imported module.</p>
     <p>So if we have two scripts;</p>
     <pre><code>#script1.py
print "Script 1's name: {}".format(__name__)
</code></pre>
     <p>and</p>
     <pre><code>#script2.py
import script1
print "Script 2's name: {}".format(__name__)
</code></pre>
     <p>The output from executing script1 is</p>
     <pre><code>Script 1's name: __main__
</code></pre>
     <p>And the output from executing script2 is:</p>
     <pre><code>Script1's name is script1
Script 2's name: __main__
</code></pre>
     <p>As you can see, <code>__name__</code> tells us which code is the 'main' module. This is great, because you can just write code and not have to worry about structural issues like in C/C++, where, if a file does not implement a 'main' function then it cannot be compiled as an executable and if it does, it cannot then be used as a library.</p>
     <p>Say you write a Python script that does something great and you implement a boatload of functions that are useful for other purposes. If I want to use them I can just import your script and use them without executing your program (given that your code only executes within the <code>if __name__ == "__main__":</code> context). Whereas in C/C++ you would have to portion out those pieces into a separate module that then includes the file. Picture the situation below;</p>
     <p><a href="https://i.stack.imgur.com/hWLqr.png" rel="noreferrer"><img src="hWLqr.png" alt="Complicated importing in C"></a></p>
     <p>The arrows are import links. For three modules each trying to include the previous modules code there are six files (nine, counting the implementation files) and five links. This makes it difficult to include other code into a C project unless it is compiled specifically as a library. Now picture it for Python:</p>
     <p><a href="https://i.stack.imgur.com/Eql0u.png" rel="noreferrer"><img src="Eql0u.png" alt="Elegant importing in Python"></a></p>
     <p>You write a module, and if someone wants to use your code they just import it and the <code>__name__</code> variable can help to separate the executable portion of the program from the library part.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>The C/C++ illustration is wrong: 3 times the same unit name (<i>file1</i>).</span> <span> - </span> <span class="display-name">Wolf</span> <span> </span> <span class="date">11 Jan 2018 at 12:59</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>59</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Alisa</span>
     </div>
     <div>
      <span> Answered: </span> <span>20 Jan 2015 at 17:48</span>
     </div>
    </div>
    <div>
     <p>Let's look at the answer in a more abstract way:</p>
     <p>Suppose we have this code in <code>x.py</code>:</p>
     <pre><code>...
&lt;Block A&gt;
if __name__ == '__main__':
    &lt;Block B&gt;
...
</code></pre>
     <p>Blocks A and B are run when we are running <code>x.py</code>.</p>
     <p>But just block A (and not B) is run when we are running another module, <code>y.py</code> for example, in which <code>x.py</code> is imported and the code is run from there (like when a function in <code>x.py</code> is called from <code>y.py</code>).</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>59</span>
     </div>
     <div>
      <span>Answerer: </span> <span>jack</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Jun 2018 at 15:48</span>
     </div>
    </div>
    <div>
     <p>To be short, you need to know several points:</p>
     <ol>
      <li>
       <p><code>import a</code> action actually runs all that can be run in <code>a.py</code>, meaning each line in <code>a.py</code></p></li>
      <li>
       <p>Because of point 1, you may not want everything to be run in <code>a.py</code> when importing it</p></li>
      <li>
       <p>To solve the problem in point 2, Python allows you to use a condition check</p></li>
      <li>
       <p><code>__name__</code> is an implicit variable in all <code>.py</code> modules:</p></li>
     </ol>
     <ul>
      <li>when <code>a.py</code> is <code>import</code>ed, the value of <code>__name__</code> of <code>a.py</code> module is set to its file name "<code>a</code>"</li>
      <li>when <code>a.py</code> is run directly using "<code>python a.py</code>", the value of <code>__name__</code> is set to a string <code>__main__</code></li>
     </ul>
     <ol start="5">
      <li>Based on the mechanism how Python sets the variable <code>__name__</code> for each module, do you know how to achieve point 3? The answer is fairly easy, right? Use an <em>if</em> condition: <code>if __name__ == "__main__": // do A</code></li>
     </ol>
     <ul>
      <li>then <code>python a.py</code> will run the part <code>// do A</code></li>
      <li>and <code>import a</code> will skip the part <code>// do A</code></li>
     </ul>
     <ol start="6">
      <li>You can even put if <code>__name__ == "a"</code> depending on your functional need, but rarely do</li>
     </ol>
     <p>The important thing that Python is special at is point 4! The rest is just basic logic.</p>
     <p><sub>I've been reading so much throughout the answers on this page. I would say, if you know the thing, for sure you will understand those answers, otherwise, you are still confused.</sub></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>5</td>
        <td><span>Yes, point 1 is vital to understand. From that, the need for this mechanism become clear.</span> <span> - </span> <span class="display-name">ProfDFrancis</span> <span> </span> <span class="date">24 Mar 2019 at 21:16</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span> <span class="arrow"> <a href="#answer_14">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>47</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Zain</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Dec 2013 at 11:23</span>
     </div>
    </div>
    <div>
     <p>When you run Python interactively the local <code>__name__</code> variable is assigned a value of <code>__main__</code>. Likewise, when you execute a Python module from the command line, rather than importing it into another module, its <code>__name__</code> attribute is assigned a value of <code>__main__</code>, rather than the actual name of the module. In this way, modules can look at their own <code>__name__</code> value to determine for themselves how they are being used, whether as support for another program or as the main application executed from the command line. Thus, the following idiom is quite common in Python modules:</p>
     <pre><code>if __name__ == '__main__':
    # Do something appropriate here, like calling a
    # main() function defined elsewhere in this module.
    main()
else:
    # Do nothing. This module has been imported by another
    # module that wants to make use of the functions,
    # classes and other useful bits it has defined.
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_14"><span>Answer 14</span> <span class="arrow"> <a href="#answer_13">↑</a> </span> <span class="arrow"> <a href="#answer_15">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>45</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Larry</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Aug 2017 at 18:53</span>
     </div>
    </div>
    <div>
     <p>Consider:</p>
     <pre><code>if __name__ == "__main__":
    main()
</code></pre>
     <p>It checks if the <code>__name__</code> attribute of the Python script is <code>"__main__"</code>. In other words, if the program itself is executed, the attribute will be <code>__main__</code>, so the program will be executed (in this case the <code>main()</code> function).</p>
     <p>However, if your Python script is used by a module, any code outside of the <code>if</code> statement will be executed, so <code>if __name__ == "__main__"</code> is used just to check if the program is used as a module or not, and therefore decides whether to run the code.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_15"><span>Answer 15</span> <span class="arrow"> <a href="#answer_14">↑</a> </span> <span class="arrow"> <a href="#answer_16">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>43</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Xantium</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Apr 2018 at 19:32</span>
     </div>
    </div>
    <div>
     <p><em>Before explaining anything about <code>if __name__ == '__main__'</code> it is important to understand what <code>__name__</code> is and what it does.</em></p>
     <h2>What is <code>__name__</code>?</h2>
     <p><code>__name__</code> is a <a href="https://wiki.python.org/moin/DunderAlias" rel="noreferrer">DunderAlias</a> - can be thought of as a global variable (accessible from modules) and works in a similar way to <a href="https://stackoverflow.com/questions/13881395/in-python-what-is-a-global-statement"><code>global</code></a>.</p>
     <p>It is a string (global as mentioned above) as indicated by <code>type(__name__)</code> (yielding <code>&lt;class 'str'&gt;</code>), and is an inbuilt standard for both <a href="https://docs.python.org/3/library/__main__.html" rel="noreferrer">Python 3</a> and <a href="https://docs.python.org/2/library/__main__.html" rel="noreferrer">Python 2</a> versions.</p>
     <h2>Where</h2>
     <p>It can not only be used in scripts but can also be found in both the interpreter and modules/packages.</p>
     <h3>Interpreter:</h3>
     <pre><code>&gt;&gt;&gt; print(__name__)
__main__
&gt;&gt;&gt;
</code></pre>
     <h3>Script:</h3>
     <p><em>test_file.py</em>:</p>
     <pre><code>print(__name__)
</code></pre>
     <p>Resulting in <code>__main__</code></p>
     <h3>Module or package:</h3>
     <p><em>somefile.py:</em></p>
     <pre><code>def somefunction():
    print(__name__)
</code></pre>
     <p><em>test_file.py:</em></p>
     <pre><code>import somefile
somefile.somefunction()
</code></pre>
     <p>Resulting in <code>somefile</code></p>
     <p>Notice that when used in a package or module, <code>__name__</code> takes the name of the file. The path of the actual module or package path is not given, but has its own DunderAlias <code>__file__</code>, that allows for this.</p>
     <p>You should see that, where <code>__name__</code>, where it is the main file (or program) will <em>always</em> return <code>__main__</code>, and if it is a module/package, or anything that is running off some other Python script, will return the name of the file where it has originated from.</p>
     <h2>Practice</h2>
     <p>Being a variable means that it's value <em>can</em> be overwritten ("can" does not mean "should"), overwriting the value of <code>__name__</code> will result in a lack of readability. So do not do it, for any reason. If you need a variable define a new variable.</p>
     <p>It is always assumed that the value of <code>__name__</code> to be <code>__main__</code> or the name of the file. Once again changing this default value will cause more confusion that it will do good, causing problems further down the line.</p>
     <h3>Example:</h3>
     <pre><code>&gt;&gt;&gt; __name__ = 'Horrify' # Change default from __main__
&gt;&gt;&gt; if __name__ == 'Horrify': print(__name__)
...
&gt;&gt;&gt; else: print('Not Horrify')
...
Horrify
&gt;&gt;&gt;
</code></pre>
     <p>It is considered good practice in general to include the <code>if __name__ == '__main__'</code> in scripts.</p>
     <h2>Now to answer <code>if __name__ == '__main__'</code>:</h2>
     <p><em>Now we know the behaviour of <code>__name__</code> things become clearer:</em></p>
     <p>An <a href="https://docs.python.org/3/tutorial/controlflow.html#if-statements" rel="noreferrer"><code>if</code></a> is a flow control statement that contains the block of code will execute if the value given is true. We have seen that <code>__name__</code> can take either <code>__main__</code> or the file name it has been imported from.</p>
     <p>This means that if <code>__name__</code> is equal to <code>__main__</code> then the file must be the main file and must actually be running (or it is the interpreter), not a module or package imported into the script.</p>
     <p>If indeed <code>__name__</code> does take the value of <code>__main__</code> then whatever is in that block of code will execute.</p>
     <p>This tells us that if the file running is the main file (or you are running from the interpreter directly) then that condition must execute. If it is a package then it should not, and the value will not be <code>__main__</code>.</p>
     <h3>Modules</h3>
     <p><code>__name__</code> can also be used in modules to define the name of a module</p>
     <h3>Variants</h3>
     <p>It is also possible to do other, less common but useful things with <code>__name__</code>, some I will show here:</p>
     <h3>Executing only if the file is a module or package</h3>
     <pre><code>if __name__ != '__main__':
    # Do some useful things 
</code></pre>
     <h3>Running one condition if the file is the main one and another if it is not</h3>
     <pre><code>if __name__ == '__main__':
    # Execute something
else:
    # Do some useful things
</code></pre>
     <p>You can also use it to provide runnable help functions/utilities on packages and modules without the elaborate use of libraries.</p>
     <p>It also allows modules to be run from the command line as main scripts, which can be also very useful.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_16"><span>Answer 16</span> <span class="arrow"> <a href="#answer_15">↑</a> </span> <span class="arrow"> <a href="#answer_17">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>37</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Prof. Falken</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Jan 2013 at 13:48</span>
     </div>
    </div>
    <div>
     <p>It is a special for when a Python file is called from the command line. This is typically used to call a "main()" function or execute other appropriate startup code, like commandline arguments handling for instance.</p>
     <p>It could be written in several ways. Another is:</p>
     <pre><code>def some_function_for_instance_main():
    dosomething()


__name__ == '__main__' and some_function_for_instance_main()
</code></pre>
     <p>I am not saying you should use this in production code, but it serves to illustrate that there is nothing "magical" about <code>if __name__ == '__main__'</code>.</p>
     <p>It just a convention for invoking a main function in Python files.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>7</td>
        <td><span>I would consider this bad form as you're 1) relying on side effects and 2) abusing <code>and</code>. <code>and</code> is used for checking if two boolean statements are both true. Since you're not interested in the result of the <code>and</code>, an <code>if</code> statement more clearly communicates your intentions.</span> <span> - </span> <span class="display-name">jpmc26</span> <span> </span> <span class="date">26 Dec 2013 at 18:07</span></td>
       </tr>
       <tr>
        <td>9</td>
        <td><span>Leaving aside the question of whether exploiting the short-circuit behaviour of boolean operators as a flow control mechanism is bad style or not, the bigger problem is that this <i>doesn't answer the question at all</i>.</span> <span> - </span> <span class="display-name">Mark Amery</span> <span> </span> <span class="date">10 Jul 2015 at 15:33</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@jpmc26 Anyone with a background in Perl or Javascript is totally comfortable with this idiom, using <code>and</code> as a control statement. I don't have any issue with it. Another similar idiom is using <code>or</code> to set default values. For example, <code>x = input("what is your name? ") or "Nameless Person"</code>.</span> <span> - </span> <span class="display-name">John Henckel</span> <span> </span> <span class="date">9 Jul 2021 at 16:04</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@JohnHenckel This is not Perl or JavaScript. This is not a Python idiom. It is considered bad form to use a function with side effects in the middle of a Boolean statement in Python. Particularly in this case, there is absolutely no benefit to using <code>and</code> here; the function doesn't even return a value. It just makes the code less obvious.</span> <span> - </span> <span class="display-name">jpmc26</span> <span> </span> <span class="date">9 Jul 2021 at 18:51</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@jpmc26 I'm trying to find an authoritative source that agrees with you. Is this mentioned somewhere? For example in PEP8 does it say that we should avoid using <code>and</code> for control purposes, or using <code>or</code> to assign a default value? I tried to google it, but I could not find anything.</span> <span> - </span> <span class="display-name">John Henckel</span> <span> </span> <span class="date">20 Jul 2021 at 18:23</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@JohnHenckel See PEP 20. "Explicit is better than implicit," "Readability counts," and "There should be one-- and preferably only one --obvious way to do it." You shouldn't need someone saying to avoid burying an invocation in an <code>and</code> statement. Python has constructs that make such behavior more apparent to a reader. The usage pattern here (execute the following code if the condition is true) is <b>the</b> single purpose for which <code>if</code> was designed; <code>and</code> was designed to compute whether two conditions are true simultaneously. The second operand of this <code>and</code> statement isn't even used.</span> <span> - </span> <span class="display-name">jpmc26</span> <span> </span> <span class="date">21 Jul 2021 at 00:15</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_17"><span>Answer 17</span> <span class="arrow"> <a href="#answer_16">↑</a> </span> <span class="arrow"> <a href="#answer_18">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>37</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Taufiq Rahman</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Nov 2016 at 06:47</span>
     </div>
    </div>
    <div>
     <p>I think it's best to break the answer in depth and in simple words:</p>
     <p><code>__name__</code>: Every module in Python has a special attribute called <code>__name__</code>. It is a built-in variable that returns the name of the module.</p>
     <p><code>__main__</code>: Like other programming languages, Python too has an execution entry point, i.e., main. <code>'__main__'</code> <em>is the name of the scope in which top-level code executes</em>. Basically you have two ways of using a Python module: Run it directly as a script, or import it. When a module is run as a script, its <code>__name__</code> is set to <code>__main__</code>.</p>
     <p>Thus, the value of the <code>__name__</code> attribute is set to <code>__main__</code> when the module is run as the main program. Otherwise the value of <code>__name__</code> is set to contain the name of the module.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_18"><span>Answer 18</span> <span class="arrow"> <a href="#answer_17">↑</a> </span> <span class="arrow"> <a href="#answer_19">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>30</span>
     </div>
     <div>
      <span>Answerer: </span> <span>codewizard</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Nov 2015 at 12:26</span>
     </div>
    </div>
    <div>
     <p>There are a number of variables that the system (Python interpreter) provides for source files (modules). You can get their values anytime you want, so, let us focus on the <strong>__name__</strong> variable/attribute:</p>
     <p>When Python loads a source code file, it executes all of the code found in it. (Note that it doesn't call all of the methods and functions defined in the file, but it does define them.)</p>
     <p>Before the interpreter executes the source code file though, it defines a few special variables for that file; <strong>__name__</strong> is one of those special variables that Python automatically defines for each source code file.</p>
     <p>If Python is loading this source code file as the main program (i.e. the file you run), then it sets the special <strong>__name__</strong> variable for this file to have a value <strong>"__main__"</strong>.</p>
     <p>If this is being imported from another module, <strong>__name__</strong> will be set to that module's name.</p>
     <p>So, in your example in part:</p>
     <pre><code>if __name__ == "__main__":
   lock = thread.allocate_lock()
   thread.start_new_thread(myfunction, ("Thread #: 1", 2, lock))
   thread.start_new_thread(myfunction, ("Thread #: 2", 2, lock))
</code></pre>
     <p>means that the code block:</p>
     <pre><code>lock = thread.allocate_lock()
thread.start_new_thread(myfunction, ("Thread #: 1", 2, lock))
thread.start_new_thread(myfunction, ("Thread #: 2", 2, lock))
</code></pre>
     <p>will be executed only when you run the module directly; the code block will not execute if another module is calling/importing it because the value of <strong>__name__</strong> will not equal to "<strong>main</strong>" in that particular instance.</p>
     <p>Hope this helps out.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Hi, you are one of the few that addressed the question referring to the multithreaded aspect. May I ask you this, what happens if I have code outside of "main" and not encapsulated inside a function? Will this code get executed again and again by every new thread started from main?</span> <span> - </span> <span class="display-name">Welsige</span> <span> </span> <span class="date">10 Jan 2022 at 17:24</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_19"><span>Answer 19</span> <span class="arrow"> <a href="#answer_18">↑</a> </span> <span class="arrow"> <a href="#answer_20">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>28</span>
     </div>
     <div>
      <span>Answerer: </span> <span>The Gr8 Adakron</span>
     </div>
     <div>
      <span> Answered: </span> <span>24 Apr 2016 at 08:23</span>
     </div>
    </div>
    <div>
     <p><code>if __name__ == "__main__":</code> is basically the top-level script environment, and it specifies the interpreter that ('I have the highest priority to be executed first').</p>
     <p><code>'__main__'</code> is the name of the scope in which top-level code executes. A module’s <code>__name__</code> is set equal to <code>'__main__'</code> when read from standard input, a script, or from an interactive prompt.</p>
     <pre><code>if __name__ == "__main__":
    # Execute only if run as a script
    main()
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_20"><span>Answer 20</span> <span class="arrow"> <a href="#answer_19">↑</a> </span> <span class="arrow"> <a href="#answer_21">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>27</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Janarthanan Ramu</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Jun 2016 at 10:47</span>
     </div>
    </div>
    <div>
     <p>Consider:</p>
     <pre><code>print __name__
</code></pre>
     <p>The output for the above is <code>__main__</code>.</p>
     <pre><code>if __name__ == "__main__":
  print "direct method"
</code></pre>
     <p>The above statement is true and prints <em>"direct method"</em>. Suppose if they imported this class in another class it doesn't print <em>"direct method"</em> because, while importing, it will set <code>__name__ equal to "first model name"</code>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_21"><span>Answer 21</span> <span class="arrow"> <a href="#answer_20">↑</a> </span> <span class="arrow"> <a href="#answer_22">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>26</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Babatunde Mustapha</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Oct 2020 at 18:01</span>
     </div>
    </div>
    <div>
     <p>In simple words:</p>
     <p>The code you see under <code>if __name__ == "__main__":</code> will only get called upon when your Python file is executed as <code>python example1.py</code></p>
     <p>However, if you wish to import your Python file <code>example1.py</code> as a module to work with another Python file, say <code>example2.py</code>, the code under <code>if __name__ == "__main__":</code> will not run or take any effect.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_22"><span>Answer 22</span> <span class="arrow"> <a href="#answer_21">↑</a> </span> <span class="arrow"> <a href="#answer_23">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>22</span>
     </div>
     <div>
      <span>Answerer: </span> <span>kgf3JfUtW</span>
     </div>
     <div>
      <span> Answered: </span> <span>13 Mar 2017 at 21:44</span>
     </div>
    </div>
    <div>
     <blockquote>
      <p>You can make the file usable as a <strong>script</strong> as well as an <strong>importable module</strong>.</p>
     </blockquote>
     <p><strong>fibo.py (a module named <code>fibo</code>)</strong></p>
     <pre><code># Other modules can IMPORT this MODULE to use the function fib
def fib(n):    # write Fibonacci series up to n
    a, b = 0, 1
    while b &lt; n:
        print(b, end=' ')
        a, b = b, a+b
    print()

# This allows the file to be used as a SCRIPT
if __name__ == "__main__":
    import sys
    fib(int(sys.argv[1]))
</code></pre>
     <p>Reference: <a href="https://docs.python.org/3.5/tutorial/modules.html" rel="noreferrer">https://docs.python.org/3.5/tutorial/modules.html</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_23"><span>Answer 23</span> <span class="arrow"> <a href="#answer_22">↑</a> </span> <span class="arrow"> <a href="#answer_24">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>22</span>
     </div>
     <div>
      <span>Answerer: </span> <span>personal_cloud</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 Sep 2017 at 18:32</span>
     </div>
    </div>
    <div>
     <p>The reason for</p>
     <pre><code>if __name__ == "__main__":
    main()
</code></pre>
     <p>is primarily to avoid the <a href="https://docs.python.org/2/library/threading.html#importing-in-threaded-code" rel="noreferrer">import lock</a> problems that would arise from <a href="https://stackoverflow.com/questions/46326059/">having code directly imported</a>. You want <code>main()</code> to run if your file was directly invoked (that's the <code>__name__ == "__main__"</code> case), but if your code was imported then the importer has to enter your code from the true main module to avoid import lock problems.</p>
     <p>A side-effect is that you automatically sign on to a methodology that supports multiple entry points. You can run your program using <code>main()</code> as the entry point, <em>but you don't have to</em>. While <code>setup.py</code> expects <code>main()</code>, other tools use alternate entry points. For example, to run your file as a <code>gunicorn</code> process, you define an <code>app()</code> function instead of a <code>main()</code>. Just as with <code>setup.py</code>, <code>gunicorn</code> imports your code so you don't want it do do anything while it's being imported (because of the import lock issue).</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_24"><span>Answer 24</span> <span class="arrow"> <a href="#answer_23">↑</a> </span> <span class="arrow"> <a href="#answer_25">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>21</span>
     </div>
     <div>
      <span>Answerer: </span> <span>tripleee</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Oct 2021 at 09:46</span>
     </div>
    </div>
    <div>
     <p>If you are a beginner, probably the only answer you need right now is that <em>this code is unnecessary</em> for a simple script. It is only useful if you want to be able to <code>import</code> your script (or <code>unpickle</code> etc; see the other answers here for some other non-beginner scenarios).</p>
     <p>In slightly different words, the <code>if __name__</code> guard is a mechanism for hiding code from other code. If you don't have a specific reason to hide something, don't: If you don't need to hide some code from <code>import</code>, don't put it behind this guard, and if you do, hide as little as possible.</p>
     <p>In slightly more detail, let's say you have a simple script <code>fib.py</code> (adapted from <a href="https://stackoverflow.com/a/42773985/874188">this answer</a>):</p>
     <pre class="lang-py prettyprint-override"><code># XXX FIXME: useless (see below)
if __name__ == "__main__":
    n = int(input('Write a number: '))
    a, b = 0, 1
    while b &lt; n:
        a, b = b, a+b
    print('Fibonacci number %i: %i' % (n, b))
</code></pre>
     <p>Now, if you simply run <code>python fib.py</code> it works fine. But <code>__name__</code> will always be <code>"__main__"</code> in this scenario, so the condition is actually unnecessary. The script could be simplified to just</p>
     <pre class="lang-py prettyprint-override"><code>n = int(input('Write a number: '))
a, b = 0, 1
while b &lt; n:
    a, b = b, a+b
print('Fibonacci number %i: %i' % (n, b))
</code></pre>
     <p>Now, you can't <code>import fib</code> with the new version, but if you didn't plan to do that in the first place, this version is actually better, because it's simpler and clearer.</p>
     <p>If you <em>do</em> want to be able to <code>import fib</code>, the first version is useless, too, because the useful code is in a section which will not run when you <code>import</code> this file (in which case <code>__name__</code> will not be <code>"__main__"</code>). The proper design in that case would be to refactor the code so that the useful parts are in a function you can run when you want to after you have <code>import</code>ed it.</p>
     <pre class="lang-py prettyprint-override"><code>def main():
    n = int(input('Write a number: '))
    a, b = 0, 1
    while b &lt; n:
        a, b = b, a+b
    print('Fibonacci number %i: %i' % (n, b))

if __name__ == "__main__":
    main()
</code></pre>
     <p>Now, if you <code>import fib</code>, the call to <code>main()</code> will not be executed; but when you run <code>python fib.py</code>, it will.</p>
     <p>Actually, a better design still would be to isolate the reusable part (the actual calculation) from the user-visible input/output:</p>
     <pre class="lang-py prettyprint-override"><code>def fibn(n: int) -&gt; int:
    a, b = 0, 1
    while b &lt; n:
        a, b = b, a+b
    return b

def main() -&gt; None:
    n = int(input('Write a number: '))
    print('Fibonacci number %i: %i' % (n, fibn(n)))

if __name__ == "__main__":
    main()
</code></pre>
     <p>Now, you can <code>from fib import fibn</code> and call the <code>fibn()</code> function from the code which performs this <code>import</code>.</p>
     <p>(I called the function <code>fibn()</code> just to make it clearer what is what in this example. In real life, you might call it <code>fib()</code> and do <code>from fib import fib</code>.)</p>
     <p>Similarly, you could <code>import</code> and call the <code>main</code> function if you wanted to reuse it.</p>
     <p>Returning to the code in the question, I would similarly move the code from the <code>if</code> into a function as well, so that callers can invoke that function if they want to.</p>
     <pre class="lang-py prettyprint-override"><code>def main():
    lock = thread.allocate_lock()
    thread.start_new_thread(myfunction, ("Thread #: 1", 2, lock))
    thread.start_new_thread(myfunction, ("Thread #: 2", 2, lock))

if __name__ == "__main__":
    main()
</code></pre>
     <p>This changes the scope of the <code>lock</code> variable; if the surrounding code needs access to it, you will need to make it <code>global</code> (or, perhaps, better, refactor <code>main</code> to <code>return lock</code>, and have the caller capture the value in a local variable of its own).</p>
     <p>(Unlike in languages like C, the name <code>main</code> has no specific meaning to Python; but it's a common convention to use it as the name of the thing which will be run. You still have to actually explicitly call it, like <code>main()</code>, unlike in C.)</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>I kept the example code simple to avoid distractions; in real life, you need to cope with <code>input</code> returning something which isn't a number, and of course, a real-life Fibonacci function should perhaps be optimized to avoid recalculating the beginning of the sequence every time you call it.</span> <span> - </span> <span class="display-name">tripleee</span> <span> </span> <span class="date">30 Oct 2021 at 09:49</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The <code>n: int</code> and <code>-&gt; int</code> type annotations require Python &gt;= 3.6</span> <span> - </span> <span class="display-name">tripleee</span> <span> </span> <span class="date">30 Oct 2021 at 09:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The convention for the ordering of Fibonacci numbers is not entirely set in stone. The usual convention is that the first number is 0, but mathematically this is conventionally <code>F(0)</code>. You might regard the simple script's result as an off-by-one error, and fix it accordingly.</span> <span> - </span> <span class="display-name">tripleee</span> <span> </span> <span class="date">30 Oct 2021 at 10:12</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_25"><span>Answer 25</span> <span class="arrow"> <a href="#answer_24">↑</a> </span> <span class="arrow"> <a href="#answer_26">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>20</span>
     </div>
     <div>
      <span>Answerer: </span> <span>LOrD_ARaGOrN</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Jun 2019 at 09:28</span>
     </div>
    </div>
    <div>
     <p>Every module in Python has an attribute called <code>__name__</code>. The value of <code>__name__</code> attribute is <code>__main__</code> when the module is run directly, like <code>python my_module.py</code>. Otherwise (like when you say <code>import my_module</code>) the value of <code>__name__</code> is the name of the module.</p>
     <p>Small example to explain in short.</p>
     <h3>Script <em>test.py</em></h3>
     <pre><code>apple = 42

def hello_world():
    print("I am inside hello_world")

if __name__ == "__main__":
    print("Value of __name__ is: ", __name__)
    print("Going to call hello_world")
    hello_world()
</code></pre>
     <p>We can execute this directly as</p>
     <pre class="lang-none prettyprint-override"><code>python test.py
</code></pre>
     <p>Output</p>
     <pre class="lang-none prettyprint-override"><code>Value of __name__ is: __main__
Going to call hello_world
I am inside hello_world
</code></pre>
     <p>Now suppose we call the above script from another script:</p>
     <h3>Script <em>external_calling.py</em></h3>
     <pre><code>import test

print(test.apple)
test.hello_world()

print(test.__name__)
</code></pre>
     <p>When you execute this,</p>
     <pre class="lang-none prettyprint-override"><code>python external_calling.py
</code></pre>
     <p>Output</p>
     <pre class="lang-none prettyprint-override"><code>42
I am inside hello_world
test
</code></pre>
     <p>So, the above is self-explanatory that when you call <em>test</em> from another script, if loop <code>__name__</code> in <code>test.py</code> will not execute.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_26"><span>Answer 26</span> <span class="arrow"> <a href="#answer_25">↑</a> </span> <span class="arrow"> <a href="#answer_27">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>16</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Raja</span>
     </div>
     <div>
      <span> Answered: </span> <span>7 Oct 2018 at 04:52</span>
     </div>
    </div>
    <div>
     <p>This answer is for Java programmers learning Python. Every Java file typically contains one public class. You can use that class in two ways:</p>
     <ol>
      <li>
       <p>Call the class from other files. You just have to import it in the calling program.</p></li>
      <li>
       <p>Run the class stand alone, for testing purposes.</p></li>
     </ol>
     <p>For the latter case, the class should contain a public static void main() method. In Python this purpose is served by the globally defined label <code>'__main__'</code>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_27"><span>Answer 27</span> <span class="arrow"> <a href="#answer_26">↑</a> </span> <span class="arrow"> <a href="#answer_28">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>14</span>
     </div>
     <div>
      <span>Answerer: </span> <span>pah8J</span>
     </div>
     <div>
      <span> Answered: </span> <span>19 Jun 2018 at 11:44</span>
     </div>
    </div>
    <div>
     <p>If this .py file are imported by other .py files, the code under the <code>if</code> statement will not be executed.</p>
     <p>If this .py are run by <code>python this_py.py</code> under shell, or double clicked in Windows. the code under the <code>if</code> statement will be executed.</p>
     <p>It is usually written for testing.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_28"><span>Answer 28</span> <span class="arrow"> <a href="#answer_27">↑</a> </span> <span class="arrow"> <a href="#answer_29">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>13</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ali Hallaji</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Apr 2018 at 14:32</span>
     </div>
    </div>
    <div>
     <p>We see if <code>__name__ == '__main__':</code> quite often.</p>
     <p>It checks if a module is being imported or not.</p>
     <p>In other words, the code within the <code>if</code> block will be executed only when the code runs directly. Here <code>directly</code> means <code>not imported</code>.</p>
     <p>Let's see what it does using a simple code that prints the name of the module:</p>
     <pre><code># test.py
def test():
   print('test module name=%s' %(__name__))

if __name__ == '__main__':
   print('call test()')
   test()
</code></pre>
     <p>If we run the code directly via <code>python test.py</code>, the module name is <code>__main__</code>:</p>
     <pre><code>call test()
test module name=__main__
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_29"><span>Answer 29</span> <span class="arrow"> <a href="#answer_28">↑</a> </span> <span class="arrow"> <a href="#answer_30">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>13</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Nikil Munireddy</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Jul 2019 at 16:22</span>
     </div>
    </div>
    <div>
     <p>If the Python interpreter is running a particular module then the <code>__name__</code> global variable will have the value <code>"__main__"</code>:</p>
     <pre class="lang-py prettyprint-override"><code>def a():
    print("a")

def b():
    print("b")

if __name__ == "__main__":

        print ("you can see me")
        a()
else:

        print ("You can't see me")
        b()
</code></pre>
     <p>When you run this script, it prints:</p>
     <pre><code>you can see me
a
</code></pre>
     <p>If you import this file, say <strong><code>A</code></strong> to file <strong><code>B</code></strong>, and execute the file <strong><code>B</code></strong> then <code>if __name__ == "__main__"</code> in file <strong><code>A</code></strong> becomes <em>False</em>, so it prints:</p>
     <pre><code>You can't see me
b
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_30"><span>Answer 30</span> <span class="arrow"> <a href="#answer_29">↑</a> </span> <span class="arrow"> <a href="#answer_31">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>12</span>
     </div>
     <div>
      <span>Answerer: </span> <span>preetika mondal</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 May 2018 at 08:25</span>
     </div>
    </div>
    <div>
     <p>All the answers have pretty much explained the functionality. But I will provide one example of its usage which might help clearing out the concept further.</p>
     <p>Assume that you have two Python files, a.py and b.py. Now, <code>a.py</code> imports <code>b.py</code>. We run the <code>a.py</code> file, where the <code>import b.py</code> code is executed first. Before the rest of the <code>a.py</code> code runs, the code in the file <code>b.py</code> must run completely.</p>
     <p>In the b.py code, there is some code that is exclusive to that file <code>b.py</code> and we don't want any other file (other than the <code>b.py</code> file), that has imported the b.py file, to run it.</p>
     <p>So that is what this line of code checks. If it is the main file (i.e., <code>b.py</code>) running the code, which in this case it is not (<code>a.py</code> is the main file running), then only the code gets executed.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_31"><span>Answer 31</span> <span class="arrow"> <a href="#answer_30">↑</a> </span> <span class="arrow"> <a href="#answer_32">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>10</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Raymond Hettinger</span>
     </div>
     <div>
      <span> Answered: </span> <span>22 May 2022 at 01:18</span>
     </div>
    </div>
    <div>
     <h2>Only facts you need to know</h2>
     <p>The other answers to this question are way too long. The actual mechanics are quite simple and there are only two essential facts:</p>
     <ol>
      <li>
       <p>Pure Python modules are always created with the variable <code>__name__</code> set to the string <code>"__main__"</code>.</p></li>
      <li>
       <p>Importing a module has the side-effect of changing the <code>__name__</code> variable to the base filename without the <code>.py</code> extension.</p></li>
     </ol>
     <h2>How this information is used</h2>
     <p>People write <code>__name__ == '__main__'</code> to test whether a module has been imported.</p>
     <p>It is common to have some code that shouldn't run when an import occurs: Test code, one-time use code, a command-line front-end, or a web server front-end.</p>
     <p>The idea is that person running a module directly wants these actions to happen, but a person importing the module just wants direct access to the functions, classes, and variables.</p>
     <p>As you can see from the other answers, people seem to be able to talk endlessly about this topic, but it really is a simple thing and is easily mastered. The Python tutorial <a href="https://docs.python.org/3/tutorial/modules.html#executing-modules-as-scripts" rel="noreferrer">covers this</a> in about two minutes worth of reading. Don't let the other answers drown you with overexplaining :-)</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>This should be the accepted answer. It needs to be moved to the top!</span> <span> - </span> <span class="display-name">Rich Lysakowski PhD</span> <span> </span> <span class="date">5 Sep 2022 at 21:48</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_32"><span>Answer 32</span> <span class="arrow"> <a href="#answer_31">↑</a> </span> <span class="arrow"> <a href="#answer_33">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>9</span>
     </div>
     <div>
      <span>Answerer: </span> <span>DARK_C0D3R</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Jan 2018 at 15:24</span>
     </div>
    </div>
    <div>
     <p>Create a file, <strong>a.py</strong>:</p>
     <pre><code>print(__name__) # It will print out __main__
</code></pre>
     <p><code>__name__</code> is always equal to <code>__main__</code> whenever that file is <strong>run directly</strong> showing that this is the main file.</p>
     <p>Create another file, <strong>b.py</strong>, in the same directory:</p>
     <pre><code>import a  # Prints a
</code></pre>
     <p>Run it. It will print <strong>a</strong>, i.e., the name of the file which <strong>is imported</strong>.</p>
     <p>So, to show <strong>two different behavior of the same file</strong>, this is a commonly used trick:</p>
     <pre><code># Code to be run when imported into another python file

if __name__ == '__main__':
    # Code to be run only when run directly
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_33"><span>Answer 33</span> <span class="arrow"> <a href="#answer_32">↑</a> </span> <span class="arrow"> <a href="#answer_34">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>9</span>
     </div>
     <div>
      <span>Answerer: </span> <span>monkey</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Apr 2020 at 12:12</span>
     </div>
    </div>
    <div>
     <p>Every module in Python has a special attribute called <code>__name__</code>. The value of the <code>__name__</code> attribute is set to <code>'__main__'</code> when the module is executed as the main program (e.g., running <code>python foo.py</code>).</p>
     <p>Otherwise, the value of <code>__name__</code> is set to the name of the module that it was called from.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>Re <i>"...the name of the module that it was called from"</i>: Not the module itself? That doesn't sound plausible. If it <i>is</i> the case, can you <a href="https://stackoverflow.com/posts/61458664/edit">elaborate</a> in your answer? (But <b><i>without</i></b> "Edit:", "Update:", or similar - the answer should appear as if it was written today.)</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">15 Jan 2022 at 21:11</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_34"><span>Answer 34</span> <span class="arrow"> <a href="#answer_33">↑</a> </span> <span class="arrow"> <a href="#answer_35">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Igor Micev</span>
     </div>
     <div>
      <span> Answered: </span> <span>31 Jan 2020 at 17:53</span>
     </div>
    </div>
    <div>
     <p>You can check up on the special variable <code>__name__</code> with this simple example:</p>
     <p>Create <em>file1.py</em></p>
     <pre><code>if __name__ == "__main__":
    print("file1 is being run directly")
else:
    print("file1 is being imported")
</code></pre>
     <p>Create *file2.<em>py</em></p>
     <pre><code>import file1 as f1

print("__name__ from file1: {}".format(f1.__name__))
print("__name__ from file2: {}".format(__name__))

if __name__ == "__main__":
    print("file2 is being run directly")
else:
    print("file2 is being imported")
</code></pre>
     <p>Execute file2.py</p>
     <p><em>Output</em>:</p>
     <pre class="lang-none prettyprint-override"><code>file1 is being imported
__name__ from file1: file1
__name__ from file2: __main__
file2 is being run directly
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_35"><span>Answer 35</span> <span class="arrow"> <a href="#answer_34">↑</a> </span> <span class="arrow"> <a href="#answer_36">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>random_hooman</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Apr 2021 at 05:12</span>
     </div>
    </div>
    <div>
     <p>When a Python file is executed it creates many special variables such as <code>__name__</code>. The variable <code>__name__</code> holds the name of the file. And the answer to your question is that</p>
     <pre><code>if __name__ == "__main__":
       # Do something
</code></pre>
     <p>This means that if the name of the file being executed is running as the source file and <strong>not a module</strong> then it will run the code inside it. This can be proved with a simple example. Create two Python files, <code>foo.py</code> and <code>second.py</code>. Then in the <code>foo.py</code>, type this:</p>
     <pre><code>if __name__ == "__main__":
       print("file is not imported")
else:
       print("file is imported")
</code></pre>
     <p>And in the <code>second.py</code>, type this:</p>
     <pre><code>import foo

if foo.__name__ == "__main__":
       print("file is not imported")
else:
       print("file is imported")
</code></pre>
     <p>In addition to this, if you will do this <code>print(__name__)</code> then it will print <code>__main__</code>. Why?</p>
     <p>Because the file is running as the <strong>main</strong> source and if you'll do <code>print(foo.__name__)</code> it will print <em>foo</em> because the default value of the <code>__name__</code> variable is the name of the file and by default I mean you can change it too. To do this, just go to the <code>foo.py</code> file and do this: <code>__name__ = "name"</code>. Then when you'll run the file, for example,</p>
     <pre><code>__name__ = "Hello, World!"
print(__name__)
</code></pre>
     <p>then the output will be:</p>
     <pre><code>Hello, World!
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_36"><span>Answer 36</span> <span class="arrow"> <a href="#answer_35">↑</a> </span> <span class="arrow"> <a href="#answer_37">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>mamal</span>
     </div>
     <div>
      <span> Answered: </span> <span>21 Apr 2020 at 11:48</span>
     </div>
    </div>
    <div>
     <p>The <strong>Python main function</strong> is the starting point of any program. When the program is run, the Python interpreter runs the code sequentially. The main function is executed only when it is run as a Python program...</p>
     <pre><code>def main():
    print("I am in the function")

print("I am out of the function")
</code></pre>
     <p>when you run the script shows:</p>
     <pre class="lang-none prettyprint-override"><code>I am out of the function
</code></pre>
     <p>And not the code "I am in the function".</p>
     <p>It is because we did not declare the call function "if__name__== "<strong>main</strong>".</p>
     <p>If you use from it:</p>
     <pre><code>def main():
    print("I am in the function")

if __name__ == "__main__":
    main()

print("I am out of the function")
</code></pre>
     <p>The output is equal to</p>
     <pre class="lang-none prettyprint-override"><code>I am in the function
I am out of the function
</code></pre>
     <p>In Python, <code>if__name__== "__main__"</code> allows you to run the Python files either as reusable modules or stand-alone programs.</p>
     <p>When Python interpreter reads a source file, it will execute all the code found in it. When Python runs the "source file" as the main program, it sets the special variable <code>__name__</code> to have a value <code>"__main__"</code>.</p>
     <p>When you execute the main function, it will then read the <code>if</code> statement which checks whether <code>__name__</code> is equal to <code>__main__</code>.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>I can't help but think this is more confusing than helpful.</span> <span> - </span> <span class="display-name">tripleee</span> <span> </span> <span class="date">20 May 2022 at 07:46</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_37"><span>Answer 37</span> <span class="arrow"> <a href="#answer_36">↑</a> </span> <span class="arrow"> <a href="#answer_38">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user14492304</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Jul 2021 at 12:56</span>
     </div>
    </div>
    <div>
     <p>Suppose I wrote functions and classes for web scraping on Wikipedia. Of course, this may not be a good example.</p>
     <p>I want to use those functions in another program without rewriting it.</p>
     <p>Well, I import them, but at the end of that file I put <code>__name__ == '__main__'</code></p>
     <p>When we <code>import</code> a module, all the code inside it is executed from start to end. But when it reaches the condition, it does not run <em>func</em>, <em>func2</em>, etc., which is the Wikipedia <code>__scrape__</code>.</p>
     <p>Well, in the global scope a Python <code>__name__</code> is defined to <code>'__main__'</code> for the current program.</p>
     <p>When we <code>import</code> a module, it is defined as a variable in the name space of our current program and current program <code>__name__</code> is <code>'__main__'</code>:</p>
     <h3>File <em>test.py</em></h3>
     <pre><code>def func():
    # Do something
    pass

def func2():
    # Do something
    pass

print('The program name is set to ', globals()['__name__'])

if __name__=='__main__':
    # In the current program, __name__ is equal to '__main__'
    func('https://www.wikipedia.org')
    func2('https://www.wikipedia.org')
    # Or do more jobs

</code></pre>
     <pre><code>import test1
print('inside of current program')
print('name is current program', __name__)
print(globals()['test1'])
test1.func('another site')
test1.func2('another site')
</code></pre>
     <h3>Output</h3>
     <pre class="lang-none prettyprint-override"><code>inside of test 1
name of program is set to test1
end of module
inside of current
__main__
&lt;module 'test1' from 'C:\\users\\ir\\appdata\\local\\programs\\python\\python38\\lib\\test1.py'&gt;
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>The listed output is very much out of sync compared to the listed code. Can't you copy-paste <a href="https://stackoverflow.com/posts/68244934/edit">it in</a> instead of introducing typos?</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">15 Jan 2022 at 20:54</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>You do not need permission to write here, but for your own sake and for the sake of your readers, <b><i>please</i></b> capitalise sentences and don't leave out punctuation. <b><i>This doesn't require any skills</i></b>, only the willingness to change habits. And don't <a href="https://www.youtube.com/watch?v=1Dax90QyXgI&amp;t=17m54s" rel="nofollow noreferrer">leave out articles</a> - this require some skills, but is it really that difficult? You disadvantage yourself right from the beginning by not doing it. Making this change will also greatly enhance your chances on the job market. Thanks in advance.</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">28 Jan 2022 at 19:39</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_38"><span>Answer 38</span> <span class="arrow"> <a href="#answer_37">↑</a> </span> <span class="arrow"> <a href="#answer_39">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Michael Mintz</span>
     </div>
     <div>
      <span> Answered: </span> <span>31 Dec 2022 at 17:21</span>
     </div>
    </div>
    <div>
     <p>In addition to the information already provided, the <code>if __name__ == "__main__":</code> technique is also a great way to make sure your <code>pytest</code> and <code>unittest</code> scripts still run if you accidentally call them with <code>python</code> instead of <code>pytest</code> (or <code>python -m unittest</code>). Here's an example of that:</p>
     <pre class="lang-py prettyprint-override"><code>def test_assert():
    assert 1 + 2 == 3

if __name__ == "__main__":
    import pytest
    pytest.main([__file__])
</code></pre>
     <p>Now your test will run regardless of calling it with <code>pytest</code> or <code>python</code>. Here's the <code>unittest</code> version:</p>
     <pre class="lang-py prettyprint-override"><code>import unittest

class Tests(unittest.TestCase):
    def test_assert(self):
        self.assertTrue(1 + 2 == 3)

if __name__ == "__main__":
    unittest.main()
</code></pre>
     <p>Then your script runs the same with a <code>python</code> call as it would with a <code>python -m unittest</code> call.</p>
     <p>Now, what if you also want to make sure that all your args gets passed to <code>pytest</code> if called with <code>python</code>? Or, what if you also want to include additional args? Here's an example of how to do that:</p>
     <pre class="lang-py prettyprint-override"><code>def test_assert():
    assert 1 + 2 == 3

if __name__ == "__main__":
    from pytest import main
    from sys import argv
    main([*argv, "-s"])
</code></pre>
     <p>Now, your <code>python -v --html=report.html</code> will have the same effect as <code>pytest -v --html=report.html</code>, etc. It's a great way to make sure that scripts still run as intended, even if not run with the expected <code>pytest</code> or <code>python -m unittest</code> calls.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_39"><span>Answer 39</span> <span class="arrow"> <a href="#answer_38">↑</a> </span> <span class="arrow"> <a href="#answer_40">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>PythonBeginner</span>
     </div>
     <div>
      <span> Answered: </span> <span>10 May 2023 at 15:36</span>
     </div>
    </div>
    <div>
     <p>Do the following in your project.</p>
     <p>Make a python file and simply print the <code>__name__</code>. Run this python file</p>
     <p>Now, import this python file in another python file. Do not, touch the <code>__name__</code> print statement.</p>
     <p>After importing, the <code>print(__name__)</code> will still execute.</p>
     <p>First, the output will be <code>__main__</code>. But in the second scenario, the output will be different (according to the name of the python file).</p>
     <p>Therefore, if you add an if check <code>if __name__ == "__main__"</code> it will return True if the python file is being run without importing as a standalone script. But if it is being imported, this will evaluate to False. Why would you need all this?</p>
     <p>Maybe your python file is class based or function based. You might want to reuse these classes or functions in a different python file. But, you might not want to execute the python script which is to be executed when that python script is executed as a standalone script.</p>
     <p>Therefore, make sure to add this in almost every python file.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_40"><span>Answer 40</span> <span class="arrow"> <a href="#answer_39">↑</a> </span> <span class="arrow"> <a href="#answer_41">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Shilpa Shinde</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Dec 2022 at 12:58</span>
     </div>
    </div>
    <div>
     <blockquote>
      <p><code>If __name__=='__main__'</code> then we have a option to run the script directly</p>
      <p>if the script does not contain <code>if __name__ == '__main__'</code> (or any other name) you can not run that script directly</p>
     </blockquote>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_41"><span>Answer 41</span> <span class="arrow"> <a href="#answer_40">↑</a> </span> <span class="arrow"> <a href="#answer_42">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>OpenSaned</span>
     </div>
     <div>
      <span> Answered: </span> <span>9 Feb 2021 at 09:57</span>
     </div>
    </div>
    <div>
     <p><code>if __name__ == "__main__"</code> means that if you are running the Python file normally like <code>python foo.py</code>, it will assign the special variable <code>__name__</code> to <code>"__main__"</code>.</p>
     <p>But if you are importing the file like "import foo", it will assign <code>__name__</code> to <code>"foo"</code> and will not run the function.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_42"><span>Answer 42</span> <span class="arrow"> <a href="#answer_41">↑</a> </span> <span class="arrow"> <a href="#answer_43">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Super Kai - Kazuya Ito</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 Oct 2022 at 14:33</span>
     </div>
    </div>
    <div>
     <p><strong><code>if __name__ == "__main__":</code> prevents to run unwanted code when imported its file.</strong></p>
     <p>For example, this is <strong><code>test1.py</code></strong> without <strong><code>if __name__ == "__main__":</code></strong>:</p>
     <pre class="lang-py prettyprint-override"><code># "test1.py"

def hello()
    print("Hello")

hello()
</code></pre>
     <p>And <strong><code>test2.py</code></strong> just imports <strong><code>test1.py</code></strong>:</p>
     <pre class="lang-py prettyprint-override"><code># "test2.py"

import test1 # Here


</code></pre>
     <p>Then, when running <strong><code>test2.py</code></strong>, <strong>one <code>Hello</code></strong> is printed because <strong>the unwanted code <code>hello()</code></strong> in <strong><code>test1.py</code></strong> is also run:</p>
     <pre class="lang-none prettyprint-override"><code>python test2.py
Hello
</code></pre>
     <p>Of course, you can call <strong><code>test1.hello()</code></strong> in <strong><code>test2.py</code></strong>:</p>
     <pre class="lang-py prettyprint-override"><code># "test2.py"

import test1

test1.hello() # Here
</code></pre>
     <p>Then, when running <strong><code>test2</code></strong>, <strong>two <code>Hello</code></strong> is printed:</p>
     <pre class="lang-none prettyprint-override"><code>python test2.py
Hello
Hello
</code></pre>
     <p>Now, add <strong><code>if __name__ == "__main__":</code></strong> to <strong><code>test1.py</code></strong> and put <strong><code>hello()</code></strong> under it:</p>
     <pre class="lang-py prettyprint-override"><code># "test1.py"

def hello()
    print("Hello")

if __name__ == "__main__":
    hello()
</code></pre>
     <p>And, this is <strong><code>test2.py</code></strong>:</p>
     <pre class="lang-py prettyprint-override"><code># "test2.py"

import test1

test1.hello()
</code></pre>
     <p>Then, when running <strong><code>test2.py</code></strong>, <strong>only one <code>Hello</code></strong> is printed because <strong><code>if __name__ == "__main__":</code></strong> prevents to run <strong>the unwanted code <code>hello()</code></strong> when <strong><code>test2.py</code></strong> imports <strong><code>test1.py</code></strong>:</p>
     <pre class="lang-none prettyprint-override"><code>python test2.py
Hello
</code></pre>
     <p>In addition, whether <strong><code>test1.py</code></strong> has <strong><code>if __name__ == "__main__":</code></strong> or not:</p>
     <pre class="lang-py prettyprint-override"><code># "test1.py"

def hello()
    print("Hello")

if __name__ == "__main__":
    hello()
</code></pre>
     <pre class="lang-py prettyprint-override"><code># "test1.py"

def hello()
    print("Hello")

hello()
</code></pre>
     <p><strong>One <code>Hello</code></strong> is printed properly when running <strong><code>test1.py</code></strong>:</p>
     <pre class="lang-none prettyprint-override"><code>python test1.py
Hello
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_43"><span>Answer 43</span> <span class="arrow"> <a href="#answer_42">↑</a> </span> <span class="arrow"> <a href="#answer_44">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Sindhukumari P</span>
     </div>
     <div>
      <span> Answered: </span> <span>5 May 2021 at 17:52</span>
     </div>
    </div>
    <div>
     <p>When you execute the module (the source file), the <em>if</em> condition checks whether the module is called directly or it is called from another source file. Here directly means not imported.</p>
     <p>If it is directly called to execute, the module name is set to "main" and then the code within the <em>if</em> block will be executed.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span>Isn't that already in an existing answer?</span> <span> - </span> <span class="display-name">Peter Mortensen</span> <span> </span> <span class="date">15 Jan 2022 at 20:57</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_44"><span>Answer 44</span> <span class="arrow"> <a href="#answer_43">↑</a> </span> <span class="arrow"> <a href="#answer_45">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user19856475</span>
     </div>
     <div>
      <span> Answered: </span> <span>6 Sep 2022 at 12:53</span>
     </div>
    </div>
    <div>
     <p>When you <code>import</code> some code that has this condition, it will return <code>False</code> (inside the imported code), but will return <code>True</code> for the code that will be run.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_45"><span>Answer 45</span> <span class="arrow"> <a href="#answer_44">↑</a> </span> <span class="arrow"> <a href="#answer_46">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mohammed Awney</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Feb 2019 at 19:36</span>
     </div>
    </div>
    <div>
     <p>Simply, it is the entry point to run the file, like the <code>main</code> function in the <em>C</em> programming language.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>15</td>
        <td><span>This answer makes the assumption that the OP (or any user with a similar question) is both familiar with <i>C</i> <i>and</i> knows what an entry point is.</span> <span> - </span> <span class="display-name">arredond</span> <span> </span> <span class="date">22 Feb 2019 at 12:44</span></td>
       </tr>
       <tr>
        <td>8</td>
        <td><span>This answer also assumes that no code (other than definitions without side effects) take place before the <code>if __name__ == "__main__"</code> block. Technically the top of the script executed is the entry point of the program.</span> <span> - </span> <span class="display-name">Charlie Harding</span> <span> </span> <span class="date">9 Apr 2019 at 21:35</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>This is incorrect, and probably contributes to the many, many beginner scripts which uselessly put all the code inside this block.</span> <span> - </span> <span class="display-name">tripleee</span> <span> </span> <span class="date">30 Oct 2021 at 09:20</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_46"><span>Answer 46</span> <span class="arrow"> <a href="#answer_45">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-7</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ultron</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Mar 2022 at 13:33</span>
     </div>
    </div>
    <div>
     <p>The simple answer is the code that is written under <em>if <strong>name</strong> == "<strong>main</strong>":</em> will not execute if you import it in another file.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>This has already been covered by other answers, can you include additional information to provide more value to the discussion? Thanks!</span> <span> - </span> <span class="display-name">aaossa</span> <span> </span> <span class="date">30 Mar 2022 at 14:35</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>