<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>When are Getters and Setters Justified?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>When are Getters and Setters Justified?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>200</span>
    </div>
    <div>
     <span>Asker: </span> <span>Winston Ewert</span>
    </div>
    <div>
     <span>Asked: </span> <span>26 Nov 2010 at 22:24</span>
    </div>
    <div>
     <a href="https://softwareengineering.stackexchange.com/questions/21802/when-are-getters-and-setters-justified">source</a>
    </div>
   </div>
   <div>
    <p>Getters and setters are often criticized as being not proper OO. On the other hand, most OO code I've seen has extensive getters and setters.</p>
    <p>When are getters and setters justified? Do you try to avoid using them? Are they overused in general?</p>
    <p>If your favorite language has properties (mine does) then such things are also considered getters and setters for this question. They are the same thing from an OO methodology perspective. They just have nicer syntax.</p>
    <p>Sources for Getter/Setter Criticism (some taken from comments to give them better visibility):</p>
    <ul>
     <li><a href="http://www.javaworld.com/javaworld/jw-09-2003/jw-0905-toolbox.html" rel="noreferrer">http://www.javaworld.com/javaworld/jw-09-2003/jw-0905-toolbox.html</a></li>
     <li><a href="http://typicalprogrammer.com/?p=23" rel="noreferrer">http://typicalprogrammer.com/?p=23</a></li>
     <li><a href="http://c2.com/cgi/wiki?AccessorsAreEvil" rel="noreferrer">http://c2.com/cgi/wiki?AccessorsAreEvil</a></li>
     <li><a href="http://www.darronschall.com/weblog/2005/03/no-brain-getter-and-setters.cfm" rel="noreferrer">http://www.darronschall.com/weblog/2005/03/no-brain-getter-and-setters.cfm</a></li>
     <li><a href="http://www.adam-bien.com/roller/abien/entry/encapsulation_violation_with_getters_and" rel="noreferrer">http://www.adam-bien.com/roller/abien/entry/encapsulation_violation_with_getters_and</a></li>
     <li><a href="http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html" rel="noreferrer">http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html</a></li>
    </ul>
    <p>To state the criticism simply: Getters and Setters allow you to manipulate the internal state of objects from outside of the object. This violates encapsulation. Only the object itself should care about its internal state.</p>
    <p>And an example<br>
      Procedural version of code:</p>
    <pre><code>struct Fridge
{
    int cheese;
}

void go_shopping(Fridge fridge)
{
     fridge.cheese += 5;
}
</code></pre>
    <p>Mutator version of code:</p>
    <pre><code>class Fridge
{
     int cheese;
      
     void set_cheese(int _cheese) { cheese = _cheese; }
     int get_cheese() { return cheese; }
 }

void go_shopping(Fridge fridge)
{
     fridge.set_cheese(fridge.get_cheese() + 5);        
}
</code></pre>
    <p>The getters and setters made the code much more complicated without affording proper encapsulation. Because the internal state is accessible to other objects we don't gain a whole lot by adding these getters and setters.</p>
    <p>The question has been previously discussed on Stack Overflow:</p>
    <ul>
     <li><a href="https://stackoverflow.com/questions/565095/java-are-getters-and-setters-evil">https://stackoverflow.com/questions/565095/java-are-getters-and-setters-evil</a></li>
     <li><a href="https://stackoverflow.com/questions/996179">https://stackoverflow.com/questions/996179</a></li>
    </ul>
   </div>
   <div class="tags">
    <span class="tag">java</span><span class="tag">object-oriented</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>24</td>
       <td><span><code>Getters and setters are often criticized as being not proper OO</code> - Citation, please.</span> <span> - </span> <span class="display-name">Robert Harvey</span> <span> </span> <span class="date">26 Nov 2010 at 22:43</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>Here is a citation for the question: <a href="http://www.javaworld.com/javaworld/jw-09-2003/jw-0905-toolbox.html" rel="nofollow noreferrer">javaworld.com/javaworld/jw-09-2003/jw-0905-toolbox.html</a></span> <span> - </span> <span class="display-name">Josh</span> <span> </span> <span class="date">26 Nov 2010 at 22:52</span></td>
      </tr>
      <tr>
       <td>37</td>
       <td><span>@Robert Harvey: <a href="http://typicalprogrammer.com/?p=23" rel="nofollow noreferrer">typicalprogrammer.com/?p=23</a> | <a href="http://www.javaworld.com/javaworld/jw-09-2003/jw-0905-toolbox.html" rel="nofollow noreferrer">javaworld.com/javaworld/jw-09-2003/jw-0905-toolbox.html</a> | <a href="http://www.darronschall.com/weblog/2005/03/no-brain-getter-and-setters.cfm" rel="nofollow noreferrer">darronschall.com/weblog/2005/03/no-brain-getter-and-setters.‌​cfm</a> | <a href="http://www.adam-bien.com/roller/abien/entry/encapsulation_violation_with_getters_and" rel="nofollow noreferrer">adam-bien.com/roller/abien/entry/…</a></span> <span> - </span> <span class="display-name">greyfade</span> <span> </span> <span class="date">26 Nov 2010 at 22:53</span></td>
      </tr>
      <tr>
       <td>46</td>
       <td><span>@Job, why because it has code? It's a good question and reeks of holy war if taken seriously.</span> <span> - </span> <span class="display-name">Peter Turner</span> <span> </span> <span class="date">26 Nov 2010 at 23:55</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>The code doesn't even make sense, why is set_cheese() using +=</span> <span> - </span> <span class="display-name">alternative</span> <span> </span> <span class="date">10 Apr 2011 at 17:09</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@mathepic, good catch. That was a typo. Now I see why I need unit tests.</span> <span> - </span> <span class="display-name">Winston Ewert</span> <span> </span> <span class="date">10 Apr 2011 at 17:35</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@Winston Ewert better is for the language to easily support such constructs, like ruby or C# does. I especially like ruby's metaprogramming creation of getters/setters that make unit tests pretty useless for just testing getting/setting (certainly they are useful for other things)</span> <span> - </span> <span class="display-name">alternative</span> <span> </span> <span class="date">10 Apr 2011 at 18:44</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>@mathepic, yes its better when the language has cleaner support. But the question is if you should be accessing the data inside the class at all.</span> <span> - </span> <span class="display-name">Winston Ewert</span> <span> </span> <span class="date">11 Apr 2011 at 02:36</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@Winston Ewert of course you should, if you couldn't access any data then the class is useless. However obviously you shouldn't be able to access all its data, just what is crucial to the client. If the client has to work with the data it gets back, then its not crucial and should be abstracted.</span> <span> - </span> <span class="display-name">alternative</span> <span> </span> <span class="date">11 Apr 2011 at 19:48</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>@mathepic, right. It's just that a lot of people use getters/setters to manipulate data inside objects when they should be abstracting.</span> <span> - </span> <span class="display-name">Winston Ewert</span> <span> </span> <span class="date">11 Apr 2011 at 21:53</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@Winston Ewert I think a lot of the problem occurs due to libraries - they can't possible provide every function you might need so they often have to have setters and getters. Languages that don't support inheriting protectedly make this far worse.</span> <span> - </span> <span class="display-name">alternative</span> <span> </span> <span class="date">11 Apr 2011 at 23:23</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@mathepic, I hadn't thought of that but yeah.</span> <span> - </span> <span class="display-name">Winston Ewert</span> <span> </span> <span class="date">11 Apr 2011 at 23:47</span></td>
      </tr>
      <tr>
       <td>4</td>
       <td><span>@Winston Ewert: "... the question is if you should be accessing the data inside the class at all.": well, noone forces you to implement getters and setters for all member variables, you only implement those you need. That's why you use getters and setters instead of public member variables.</span> <span> - </span> <span class="display-name">Giorgio</span> <span> </span> <span class="date">19 Nov 2011 at 14:07</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>@Giorgio, of course nobody is forcing you. The problem is that many people automatically implement getters and setters for every member variable and then access them just like if they had been public.</span> <span> - </span> <span class="display-name">Winston Ewert</span> <span> </span> <span class="date">19 Nov 2011 at 15:39</span></td>
      </tr>
      <tr>
       <td>3</td>
       <td><span>@Winston Ewert: I do not see how the absence of getters / setters would solve this problem: there must be a way to access every piece of data otherwise it is useless; it is the task of a good design to decide which part of the data is accessible to which part of the code. If one is a bad designer he or she will be such with or without getters and setters. Just my 2 cents.</span> <span> - </span> <span class="display-name">Giorgio</span> <span> </span> <span class="date">19 Nov 2011 at 16:55</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@Giorgio, I'm claiming that you should never have getters and setters, that's why the question is titled "when are Getters and Setters justified." I do claim that getters and setters are overused, because many programmers have failed to grasp the concept of data hiding and think that getters/setters provide it.</span> <span> - </span> <span class="display-name">Winston Ewert</span> <span> </span> <span class="date">19 Nov 2011 at 18:37</span></td>
      </tr>
      <tr>
       <td>2</td>
       <td><span>Try not using them at all. See what happens. IMO, critical thought happens. DTO? Nah. Data object wrapper that knows how to map itself, how to update itself in the DB, etc... with a basic generic data structure at the core. That's a lot more appealing to me than contemporary accepted thought on the matter.</span> <span> - </span> <span class="display-name">Erik Reppen</span> <span> </span> <span class="date">22 Jun 2013 at 06:08</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>I realize this is an old post, but I have to comment. I'm seeing a lot of getters and setters in some Java code I've recently been asked to review. I don't have much experience with Java, so I wanted to verify whether it was a better programming practice than I thought. I believe the accepted answer has a flaw. We don't have to add a <code>setSalary()</code> method. Instead, we should have something like: public void acceptNewJob(Job newJob) { salary = newJob.getSalary(); } This way the salary is set from an object that makes sense, instead of any old piece of code. That's my 2 cents.</span> <span> - </span> <span class="display-name">dbc60</span> <span> </span> <span class="date">22 Nov 2013 at 20:29</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@Job — Programmers.SE is the perfect site for this question. It doesn't belong on SO because it's not a specific problem with a specific solution; it's more of a general coding style/architecture problem. Even if it does tend to bring up debate.</span> <span> - </span> <span class="display-name">chharvey</span> <span> </span> <span class="date">15 Jul 2015 at 17:59</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>"you only implement those you need. That's why you use getters and setters instead of public member variables." -- There's no design difference between public setters and public member variables ... you can make member variables public only as needed. Both are poor design for the same reason globals are bad designe -- because control of the value of the property is not localized. Use immutable objects instead -- their properties are only set at time of construction.</span> <span> - </span> <span class="display-name">Jim Balter</span> <span> </span> <span class="date">27 Jul 2015 at 21:08</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>I'm wondering if there is value in adding a getter and setter for a static field in java. Just had a code review where this was done and it stood out a little. Guess I'm not used to seeing that.</span> <span> - </span> <span class="display-name">simgineer</span> <span> </span> <span class="date">10 Mar 2021 at 23:33</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@simgineer I'd avoid static mutable fields in the first place as undesirable global state. But if you have them I'd treat them the same as fields on objects.</span> <span> - </span> <span class="display-name">Winston Ewert</span> <span> </span> <span class="date">12 Mar 2021 at 15:27</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>180</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Dima</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Nov 2010 at 23:16</span>
     </div>
    </div>
    <div>
     <p>Having getters and setters does not in itself break encapsulation. What does break encapsulation is automatically adding a getter and a setter for every data member (every <em>field</em>, in java lingo), without giving it any thought. While this is better than making all data members public, it is only a small step away.</p>
     <p>The point of encapsulation is not that you should not be able to know or to change the object's state from outside the object, but that you should have a reasonable <em>policy</em> for doing it.</p>
     <ul>
      <li>
       <p>Some data members may be entirely internal to the object, and should have neither getters nor setters.</p></li>
      <li>
       <p>Some data members should be read-only, so they may need getters but not setters.</p></li>
      <li>
       <p>Some data members may need to be kept consistent with each other. In such a case you would not provide a setter for each one, but a single method for setting them at the same time, so that you can check the values for consistency.</p></li>
      <li>
       <p>Some data members may only need to be changed in a certain way, such as incremented or decremented by a fixed amount. In this case, you would provide an <code>increment()</code> and/or <code>decrement()</code> method, rather than a setter.</p></li>
      <li>
       <p>Yet others may actually need to be read-write, and would have both a getter and a setter.</p></li>
     </ul>
     <p>Consider an example of a <code>class Person</code>. Let's say a person has a name, a social security number, and an age. Let's say that we do not allow people to ever change their names or social security numbers. However, the person's age should be incremented by 1 every year. In this case, you would provide a constructor that would initialize the name and the SSN to the given values, and which would initialize the age to 0. You would also provide a method <code>incrementAge()</code>, which would increase the age by 1. You would also provide getters for all three. No setters are required in this case.</p>
     <p>In this design you allow the state of the object to be inspected from outside the class, and you allow it to be changed from outside the class. However, you do not allow the state to be changed arbitrarily. There is a policy, which effectively states that the name and the SSN cannot be changed at all, and that the age can be incremented by 1 year at a time.</p>
     <p>Now let's say a person also has a salary. And people can change jobs at will, which means their salary will also change. To model this situation we have no other way but to provide a <code>setSalary()</code> method! Allowing the salary to be changed at will is a perfectly reasonable policy in this case.</p>
     <p>By the way, in your example, I would give the class <code>Fridge</code> the <code>putCheese()</code> and <code>takeCheese()</code> methods, instead of <code>get_cheese()</code> and <code>set_cheese()</code>. Then you would still have encapsulation.</p>
     <hr>
     <pre><code>public class Fridge {
  private List objects;
  private Date warranty;

  /** How the warranty is stored internally is a detail. */
  public Fridge( Date warranty ) {
    // The Fridge can set its internal warranty, but it is not re-exposed.
    setWarranty( warranty );
  }

  /** Doesn't expose how the fridge knows it is empty. */
  public boolean isEmpty() {
    return getObjects().isEmpty();
  }

  /** When the fridge has no more room... */
  public boolean isFull() {
  }

  /** Answers whether the given object will fit. */
  public boolean canStore( Object o ) {
    boolean result = false;

    // Clients may not ask how much room remains in the fridge.
    if( o instanceof PhysicalObject ) {
      PhysicalObject po = (PhysicalObject)o;

      // How the fridge determines its remaining usable volume is a detail.
      // How a physical object determines whether it fits within a specified
      // volume is also a detail.
      result = po.isEnclosedBy( getUsableVolume() );
    }

     return result;
  }

  /** Doesn't expose how the fridge knows its warranty has expired. */
  public boolean isPastWarranty() {
    return getWarranty().before( new Date() );
  }

  /** Doesn't expose how objects are stored in the fridge. */
  public synchronized void store( Object o ) {
    validateExpiration( o );

    // Can the object fit?
    if( canStore( o ) ) {
      getObjects().add( o );
    }
    else {
      throw FridgeFullException( o );
    }
  }

  /** Doesn't expose how objects are removed from the fridge. */
  public synchronized void remove( Object o ) {
    if( !getObjects().contains( o ) ) {
      throw new ObjectNotFoundException( o );
    }

    getObjects().remove( o );

    validateExpiration( o );
  }

  /** Lazily initialized list, an implementation detail. */
  private synchronized List getObjects() {
    if( this.list == null ) { this.list = new List(); }
    return this.list;
  }

  /** How object expiration is determined is also a detail. */
  private void validateExpiration( Object o ) {
    // Objects can answer whether they have gone past a given
    // expiration date. How each object "knows" it has expired
    // is a detail. The Fridge might use a scanner and
    // items might have embedded RFID chips. It's a detail hidden
    // by proper encapsulation.
    if( o implements Expires &amp;&amp; ((Expires)o).expiresBefore( today ) ) {
      throw new ExpiredObjectException( o );
    }
  }

  /** This creates a copy of the warranty for immutability purposes. */
  private void setWarranty( Date warranty ) {
    assert warranty != null;
    this.warranty = new Date( warranty.getTime() )
  }
}
</code></pre>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>Please don't take my Fridge example too seriously. :) A real fridge ought to be a container object, I'd expect it to know how to hold objects without worrying about what exactly they were. I.E. it would be like an ArrayList. As for what makes it a Fridge, let's say it serializes objects to disk when stored so that they will survive system failure. Ok. Enough taking my fridge example over seriously.</span> <span> - </span> <span class="display-name">Winston Ewert</span> <span> </span> <span class="date">26 Nov 2010 at 23:40</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>On the contrary, I think a smart fridge should know what it contains and how much. This way, if you call <code>takeCheese()</code> and there is no cheese left, the fridge would throw an exception. :) The point is that you want to create abstractions, and the class interface is what lets you do that. So you want your interface to represent the things you want your object to do, not its internal structure. Sometimes the two are essentially the same, but more often they are not.</span> <span> - </span> <span class="display-name">Dima</span> <span> </span> <span class="date">26 Nov 2010 at 23:47</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>oh, the fridge knows what it contains. But it doesn't understand the nature of what it contains. The interface would be something like take(Cheese, 5) to remove 5 units of cheese from the fridge. The fridge has no knowledge of actual cheese, milk, or anything else. It just stores what is put into it.</span> <span> - </span> <span class="display-name">Winston Ewert</span> <span> </span> <span class="date">27 Nov 2010 at 00:02</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>But shouldn't the fridge know the expiration dates, so that it can tell you that the cheese has gone bad and should be thrown out? :) Ok, we have to stop this! :)</span> <span> - </span> <span class="display-name">Dima</span> <span> </span> <span class="date">27 Nov 2010 at 00:10</span></td>
       </tr>
       <tr>
        <td>10</td>
        <td><span>Quite an interesting discussion of <a href="http://tvtropes.org/pmwiki/pmwiki.php/Main/FridgeLogic" rel="nofollow noreferrer">Fridge Logic</a> you've got going on here...</span> <span> - </span> <span class="display-name">Mason Wheeler</span> <span> </span> <span class="date">27 Nov 2010 at 06:27</span></td>
       </tr>
       <tr>
        <td>35</td>
        <td><span>Haha, I'd like to see the ad for that: <b>"It's a brand new kind of fridge: It throws things at you when trying to grab something that isn't there! This way you will only try that once! You worry about stuffing the fridge, and let the fridge worry about illegal behaviour!"</b></span> <span> - </span> <span class="display-name">gablin</span> <span> </span> <span class="date">27 Nov 2010 at 09:13</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>+1 This explanantion is better than any I found in books.</span> <span> - </span> <span class="display-name">Oliver Weiler</span> <span> </span> <span class="date">11 Apr 2011 at 07:40</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Ah, but what happens when the person's data is just wrong. The customer calls up and says "you've enterd my age incorrectly, it says I'm 76 when I'm actually 22". Suddenly you have to tell them to get used to it, or whip out an SQL editor and directly modify the DB. However, I understand what you're saying - getters and setters are bad; give an object methods that perform defined actions on it.</span> <span> - </span> <span class="display-name">gbjbaanb</span> <span> </span> <span class="date">4 Aug 2011 at 14:08</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@gbjbaanb, this really depends on how the whole system is implemented. Maybe there is a class called PersonParams, which is plain old data with public fields or getters/setters for everything, and it is this object that is used to initialize Person. Or maybe you just delete the person's record and create a new one. This is not the point. And no, I am not saying that getters/setters are bad. I am saying that you need to look at your class and decide which data members should be read-only, which should be read-write, and which should be completely hidden.</span> <span> - </span> <span class="display-name">Dima</span> <span> </span> <span class="date">4 Aug 2011 at 14:20</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@gablin: Beware <a href="http://cs.nyu.edu/~jml414/ui/assign3/smart_refrig.html" rel="nofollow noreferrer">cs.nyu.edu/~jml414/ui/assign3/smart_refrig.html</a> !</span> <span> - </span> <span class="display-name">Matthieu M.</span> <span> </span> <span class="date">3 Oct 2011 at 18:09</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>"By the way, in your example, I would give the class Fridge the putCheese() and takeCheese() methods, instead of get_cheese() and set_cheese(). Then you would still have encapsulation." This explains a lot! Credits should be shared between you both as, Winston Ewert : For putting it as get_cheese() and set_cheese() Dima : For putCheese() and takeCheese() Before I came here I went through <a href="http://programmers.stackexchange.com/questions/187886/how-important-is-encapsulation/187894#187894" title="how important is encapsulation">programmers.stackexchange.com/questions/187886/…</a> and after reading this part of your answer, I understood most of the things there were in that answer too.</span> <span> - </span> <span class="display-name">Chathura Kulasinghe</span> <span> </span> <span class="date">19 May 2014 at 21:41</span></td>
       </tr>
       <tr>
        <td>49</td>
        <td><span>The example has it all wrong. There should not be an Age field nor a setAge() method. Age is a function of the Person birthDate as compared to some point in time. While seemingly trivial, this is exactly what is wrong with the modern practice of full mutability of objects and other bad designs, as seen by get/set methods for private fields versus carefully considering what is really mutable, what is a field, what the object should know about its behaviors and what state changes are actually valid (which setX methods completely destroy).</span> <span> - </span> <span class="display-name">Darrell Teague</span> <span> </span> <span class="date">21 Jul 2014 at 18:49</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>+1. But for the salary, shouldn't the job be its own object, complete with its own salary field, and shouldn't the person's salary be determined by the salary field inside of their job object?</span> <span> - </span> <span class="display-name">Panzercrisis</span> <span> </span> <span class="date">8 Sep 2014 at 12:50</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>+1 for Darrell and getting the underlying design right to minimise the need for mutability. Of course one may be hamstrung by a poor database design and "just make it work, now" attitudes from above...</span> <span> - </span> <span class="display-name">Julia Hayward</span> <span> </span> <span class="date">8 Sep 2014 at 13:57</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>what about having no getter and setter for some variables, and having them public, does that "break encapsulation" and does it matter?</span> <span> - </span> <span class="display-name">barlop</span> <span> </span> <span class="date">1 Feb 2015 at 04:12</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Yes, public data members do break encapsulation, and are generally a bad idea, because they create tight coupling between classes. Getters and setters provide a better degree of separation between the implementation and the interface of your class, and give you more wiggle room to change the implementation without changing the interface.</span> <span> - </span> <span class="display-name">Dima</span> <span> </span> <span class="date">2 Feb 2015 at 13:34</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>"Having getters and setters does not in itself break encapsulation. What does break encapsulation is having a getter and a setter for every data member (every field, in java lingo)." -- This is obviously nonsense; the percentage of an object's properties that are externally changeable has no bearing on whether encapsulation is broken. The plain fact is that public setters break encapsulation of the <i>value</i> of the property ... any piece of code anywhere can change it at any time. Darrell Teague gets it right ... public setters are bad design.</span> <span> - </span> <span class="display-name">Jim Balter</span> <span> </span> <span class="date">27 Jul 2015 at 21:12</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>All I get from that and your answer is that you don't understand the concept of encapsulation. it also contradicts your <i>assertion</i> that "Having getters and setters does not in itself break encapsulation". That claim is quite different from "they only break encapsulation a little if you only have a few of them". Again, Darrell Teague got it right. You have no response to that because of your lack of expertise in this area.</span> <span> - </span> <span class="display-name">Jim Balter</span> <span> </span> <span class="date">28 Jul 2015 at 00:56</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Immutability is not the arbiter of good design. The reason Age shouldn't be a field has little to do with immutability and everything to do with avoiding a fragile, costly, and potentially bug-ridden nightmare going forward. While there is a correlation between immutability and good design in this case, correlation is not causation. Private fields may commonly be of no concern to the outside world, but that's by no means the only reason to make a field private. Contrary to what trendy Functional Programming purists say, merely changing state from outside doesn't violate encapsulation.</span> <span> - </span> <span class="display-name">Syndog</span> <span> </span> <span class="date">22 Mar 2018 at 22:11</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@dave-jarvis Can you give some creditable citation for this, "What does break encapsulation is automatically adding a getter and a setter for every data member" as I am facing very hard time explaining this to the people and already been rejected from few interviews as more than half dev population defines encapsulation as creating getter setter of fields/member. Thanks</span> <span> - </span> <span class="display-name">foxt7ot</span> <span> </span> <span class="date">24 Mar 2018 at 11:35</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@foxt7ot I learned this from "Effective C++" by Scott Meyers. Also, a word of advice: an interview is a bad time to argue about programming philosophy.</span> <span> - </span> <span class="display-name">Dima</span> <span> </span> <span class="date">24 Mar 2018 at 12:13</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Dima Thanks for citation and your valuable advice</span> <span> - </span> <span class="display-name">foxt7ot</span> <span> </span> <span class="date">24 Mar 2018 at 12:45</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>The salary example is misleading. In that case, the method should be <code>changeJob(newSalary)</code> or <code>getRaise(newSalary)</code>, etc. (with possible additional parameters). See <a href="https://softwareengineering.stackexchange.com/a/255679/158474">Cormac's answer</a>.</span> <span> - </span> <span class="display-name">Utku</span> <span> </span> <span class="date">16 Oct 2018 at 02:01</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Well, "Age" isn't mutable with the current state of medical art, but it is "changing". All the time.</span> <span> - </span> <span class="display-name">gnasher729</span> <span> </span> <span class="date">12 Oct 2021 at 18:04</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>45</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user1249</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Nov 2010 at 22:28</span>
     </div>
    </div>
    <div>
     <p>The basic reason for getters and setters in Java is very simple:</p>
     <ul>
      <li>You can only specify <em>methods</em>, not fields, in an interface.</li>
     </ul>
     <p>Hence, if you want to allow a field to pass across the interface, you will need a reader and a writer method. These are traditionally called getX and setX for the field x.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>49</td>
        <td><span>That is a language limitation. The real question is whether we should be allowing other objects to manipulate that state.</span> <span> - </span> <span class="display-name">Winston Ewert</span> <span> </span> <span class="date">26 Nov 2010 at 23:05</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@winston, I'm not sure that's a language limitation, that is the nature of an abstract class (or a Delphi Interface) common to lots of languages I think.</span> <span> - </span> <span class="display-name">Peter Turner</span> <span> </span> <span class="date">26 Nov 2010 at 23:52</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@Peter Turner, clearly nothing prevents a language from having interfaces that include properties. Under the covers that may well be implemented as getter/setter but it would be easy enough to add support to interface definitions for properties.</span> <span> - </span> <span class="display-name">Winston Ewert</span> <span> </span> <span class="date">26 Nov 2010 at 23:54</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@Winston, you will eventually need to allow classes to pass information back and forth between each other to actually get work done. What would you suggest instead?</span> <span> - </span> <span class="display-name">user1249</span> <span> </span> <span class="date">27 Nov 2010 at 06:38</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>An object is supposed to provide a higher level interface to it innards. Getters and Setters tend to be a low level interface. For example, suppose you have a class that implements a binary tree. You could have functions like GetLeft(), GetRight(), GetValue(), and GetKey() in order to navigate the tree. But that is the completely wrong approach. Your binary tree class should provide operations like Find, Insert, Delete.</span> <span> - </span> <span class="display-name">Winston Ewert</span> <span> </span> <span class="date">27 Nov 2010 at 14:51</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>To take another example, consider a tetris piece. The tetris piece has some internal state like block_type, rotation, position. You could have getters like GetBlockType(), GetRotation(), GetPosition(). But you really shouldn't. What you should have is a GetSquares() method which returns a list of all of the squares occupied by this piece. You also shouldn't have stuff like SetPosition() or SetRotation(). Instead, you should have operations like MoveLeft(), MoveRight(), Rotate(), Fall().</span> <span> - </span> <span class="display-name">Winston Ewert</span> <span> </span> <span class="date">27 Nov 2010 at 14:55</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>So its not about refusing to pass information between objects or even not having methods named Get*/Set*. However, if you are providing access to all your object's innards to the entire world via getters and setters, it looks like your object is nothing but a data storage unit. Thus its not really an object. Instead, you should consider the higher level operations on the object.</span> <span> - </span> <span class="display-name">Winston Ewert</span> <span> </span> <span class="date">27 Nov 2010 at 14:58</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Winston, so you basically argue that "proper OO" does not allow getters and setters. How will you provide an interface to a data transfer object then?</span> <span> - </span> <span class="display-name">user1249</span> <span> </span> <span class="date">8 Aug 2011 at 06:51</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Thorbjørn Ravn Andersen, it's not an absolute. Higher level operations are to be preferred to Get/Set operations, but I don't know of any that could apply to a DTO.</span> <span> - </span> <span class="display-name">Winston Ewert</span> <span> </span> <span class="date">8 Aug 2011 at 15:49</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Winston, so your "An object is supposed to provide a higher level interface to its innards" is perhaps a bit too broad?</span> <span> - </span> <span class="display-name">user1249</span> <span> </span> <span class="date">8 Aug 2011 at 17:02</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Thorbjørn Ravn Andersen, it looks like I've got a typo in that. I meant to say that it is supposed to provide a <i>high-level</i> interface to its innards. That is, the interface to an object should be defined by the role of an object not the internal data members inside the object. A DTO is deliberately a dumb container of data fields, as a result getters and setters make sense they are the high-level interface for that field.</span> <span> - </span> <span class="display-name">Winston Ewert</span> <span> </span> <span class="date">8 Aug 2011 at 17:56</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>"How will you provide an interface to a data transfer object then? " -- Such objects should be immutable.</span> <span> - </span> <span class="display-name">Jim Balter</span> <span> </span> <span class="date">27 Jul 2015 at 21:18</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Also DTOs probably shouldn't exist as they are in, say, Java. The structure of the object comes from the database anyway, so why are we re-stating all the fields in a transfer object, and then again in a mapping object? The language just doesn't have the concept of a "Data Object" built in, so we fake one out of code objects and use cumbersome libraries like Hibernate.</span> <span> - </span> <span class="display-name">Bill K</span> <span> </span> <span class="date">17 Jan 2020 at 17:26</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>25</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Robert Harvey</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Nov 2010 at 02:42</span>
     </div>
    </div>
    <div>
     <p>From <a href="http://www.adam-bien.com/roller/abien/entry/encapsulation_violation_with_getters_and">http://www.adam-bien.com/roller/abien/entry/encapsulation_violation_with_getters_and</a></p>
     <p>JavaBean style:</p>
     <pre><code>connection.setUser("dukie");
connection.setPwd("duke");
connection.initialize();
</code></pre>
     <p>OO-style:</p>
     <pre><code>connection.connect("dukie","duke");
</code></pre>
     <p>Well, clearly I prefer the latter approach; it doesn't bleed implementation details, it's simpler and more concise, and all of the needed information is included with the method call, so it's easier to get it right. I also prefer setting private members using parameters in the constructor, whenever possible.</p>
     <p>Your question is, when is a getter/setter justified? Perhaps when a mode change is needed, or you need to interrogate an object for some information.</p>
     <pre><code>myObject.GetStatus();
myObject.SomeCapabilitySwitch = true;
</code></pre>
     <p>In thinking about it, when I first started coding in C#, I wrote a lot of code in the Javabeans style illustrated above. But as I gained experience in the language, I began doing more setting of members in the constructor, and using methods that looked more like the above OO style.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>6</td>
        <td><span>Why is the "give all arguments as parameters" OO-style?</span> <span> - </span> <span class="display-name">user1249</span> <span> </span> <span class="date">27 Nov 2010 at 06:39</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>While your "OO-style" is fine for 2 or 3 options, I would prefer JavaBean style once you get above that. Having 20 overloaded methods for every possible combination of parameters just looks terrible</span> <span> - </span> <span class="display-name">TheLQ</span> <span> </span> <span class="date">27 Nov 2010 at 19:38</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@TheLQ: C# 4.0 makes this easier by allowing optional and named parameters in constructor and method calls.</span> <span> - </span> <span class="display-name">Robert Harvey</span> <span> </span> <span class="date">27 Nov 2010 at 22:40</span></td>
       </tr>
       <tr>
        <td>9</td>
        <td><span>@TheLQ That's what Builder with fluent syntax is for, see e.g. <a href="http://guava-libraries.googlecode.com/svn/trunk/javadoc/com/google/common/collect/MapMaker.html" rel="nofollow noreferrer">Guava's MapMaker</a>.</span> <span> - </span> <span class="display-name">maaartinus</span> <span> </span> <span class="date">6 Aug 2011 at 16:35</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I've recently been looking into chained functions like those used in jQuery for cases where there are more than 5 options. I'm not sure how well it fits into OO programming though...</span> <span> - </span> <span class="display-name">Ivan</span> <span> </span> <span class="date">3 Oct 2011 at 15:58</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span>@Thorbjørn Ravn Andersen, I'd say "give all arguments as parameters" is better OO-style than "call JavaBean setters" because a setter implies there is an underlying attribute being set, which by definition exposes internal details. Using the connect(..) method in the example makes no such assumption; maybe you set a user and password attributes, maybe you don't. What's important is that you focus on the right OO concept: the "connect" message.</span> <span> - </span> <span class="display-name">Andres F.</span> <span> </span> <span class="date">21 Nov 2011 at 16:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Of course, if you want to be able to ask the object what the username / password used to connect was, you'd need some way to get them, and then the first style makes a lot more sense since you need a getter anyway, might as well have the setter (or properties in C#).</span> <span> - </span> <span class="display-name">Andy</span> <span> </span> <span class="date">15 Jul 2015 at 14:59</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@Andy I disagree if you have a UI, even a very simple one, a core interface like a Connection, that serves both batch mode and interactive mode use cases, should not be changed to accommodate it. The onus is on the UI to gather the username and password together before calling <code>Connect</code>.</span> <span> - </span> <span class="display-name">Aluan Haddad</span> <span> </span> <span class="date">17 Oct 2017 at 02:27</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@AluanHaddad Nonsense. The UI <b>absolutely</b> influences the business layer. The UI is the visual representation of the use case the user is operating under. Also in C# (and Java I believe), using databinding requires properties (getters/setters). Not using databinding actually leads to writing more and duplicate code (i.e., validation, as objects which are databound can implement <a href="https://msdn.microsoft.com/en-us/library/system.componentmodel.idataerrorinfo(v=vs.110).aspx" rel="nofollow noreferrer">IDataErrorInfo</a> which allows the UI to query the object to find out what the problem is and show to the user.</span> <span> - </span> <span class="display-name">Andy</span> <span> </span> <span class="date">17 Oct 2017 at 12:35</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@Andy I'm suggesting that you could store the these fields in a separate structure, one with Getters and Setters, that is used to connect to the database when both are filled in. That allows the connection to still require both fields before attempting to connect. This data structure could be a simple class or a closure. Another option would be to have the connection return a builder.</span> <span> - </span> <span class="display-name">Aluan Haddad</span> <span> </span> <span class="date">17 Oct 2017 at 16:43</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@AluanHaddad Or you can keep it simple and just put the properties on the connection. The connection is useless without a username and password; there's no reason to divorce the state from the behavior that needs that state.</span> <span> - </span> <span class="display-name">Andy</span> <span> </span> <span class="date">17 Oct 2017 at 21:37</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>So, when you finally come around implementing auto-reconnect functionality you're going to carry <code>"dukie"</code> and <code>"duke"</code> around as arguments through dozen of state-checking and connection dropping and re-initializing functions just in case that it happens that yes, you need to call <code>connect</code> once again because it explicitly needs them as arguments? Instead, you know, setting them once as in your first example?</span> <span> - </span> <span class="display-name">Oleg V. Volkov</span> <span> </span> <span class="date">14 Aug 2019 at 06:57</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Oleg V. Volkov Not having setters/getters for something doesn't mean you don't store information in some way. Instead you can add a <code>reconnect</code> method which doesn't need parameters and instead reuses settings from the existing parameters.</span> <span> - </span> <span class="display-name">Hedede</span> <span> </span> <span class="date">17 Aug 2021 at 05:42</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>For example, in our internal framework uses this approach: a <code>connect</code> method which takes either a connection string or host, port, login password. User of the interface doesn't know anything about how this information is stored - it might be stored as separate fields, or as a connection string, or both, or not at all - it might be stored by an underlying library.</span> <span> - </span> <span class="display-name">Hedede</span> <span> </span> <span class="date">17 Aug 2021 at 05:53</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>21</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Cormac Mulhall</span>
     </div>
     <div>
      <span> Answered: </span> <span>8 Sep 2014 at 09:24</span>
     </div>
    </div>
    <div>
     <blockquote>
      <p>When are getters and setters justified?</p>
     </blockquote>
     <p>When the behavior "get" and "set" actually match up to behavior in your model, which is <strong>practically never</strong>.</p>
     <p>Every other use is just a cheat because the behavior of the business domain is not clear.</p>
     <p><strong>Edit</strong></p>
     <p>That answer might have come across as flippant, so let me expand. The answers above are mostly correct but focus on the programming paradigms of OO design and some what miss the big picture. In my experience this leads people to think that avoiding gettings and setters is some academic rule for OO programming languages (e.g people think replacing getters with properties is grand)</p>
     <p>In fact it is a consequence of the design process. You don't have to get into interfaces and encapsulation and patterns, arguing over whether it does or doesn't break these paradigms and what is or isn't good OO programming. The only point that ultimately matters is that if there is nothing in your domain that works like this by putting them in you are not modeling your domain.</p>
     <p>The reality is that it is highly unlikely that any system in your domain space has getters and setters. You cannot walk up to the man or woman who is responsible for payroll and simply say <strong>"Set this salary to X"</strong> or <strong>"Get me this salary"</strong>. Such behavior simply doesn't exist</p>
     <p>If you are putting this into your code you are not designing your system to match the model of your domain. Yes that breaks interfaces and encapsulation, but that isn't the point. The point is that you are modelling something that doesn't exist.</p>
     <p>More over you are probably missing an important step or process, because there is probably a reason I can't just walk up to pay roll and say set this salary to X.</p>
     <p>When people use getters and setters they tend to push the rules for this process into the wrong place. This is moving away from your domain even more. Using the real world example, it is like salary assuming that the random person who walked in has the permission to get these values otherwise he wouldn't be asking for them. Not only is that not how the domain is, it is in fact lying about how the domain is.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>this doesn't seem to offer anything substantial over points made and explained in prior 17 answers</span> <span> - </span> <span class="display-name">gnat</span> <span> </span> <span class="date">8 Sep 2014 at 10:12</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>The other answers talk about objects, interfaces and other languages paradigms. Which is fine, but it is not the central issue. Getters and setters are not just bad because they break some coding conventions, but primarily because you hardly ever encounter this behaviour in the actual model you are representing. This point tends to get lost in the discussion about the best coding practices.</span> <span> - </span> <span class="display-name">Cormac Mulhall</span> <span> </span> <span class="date">8 Sep 2014 at 10:42</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Just what do you think the interface to payroll is if it isn't <code>set/get</code> salary?</span> <span> - </span> <span class="display-name">Winston Ewert</span> <span> </span> <span class="date">8 Sep 2014 at 17:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>The interface to payroll should model the business, ie the interface should reflect the business rules of the company. No company has a payroll department with 'get' or 'set' process, where anyone can walk up and either get someones salary or set someones salary. No payroll department behaves like that so that behaviour should not be reflected in the software model. Build what already exists, cause I'm pretty sure your payroll department has already figured out how to manage access to employee salaries.</span> <span> - </span> <span class="display-name">Cormac Mulhall</span> <span> </span> <span class="date">9 Sep 2014 at 08:52</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>On the contrary, many businesses <b>do</b> have the equivalent of get and set payroll processes. Granted, those processes are wrapped within authorization layers but there are getters and setters nonetheless. An employee's manager sets the employee's salary; it's not payroll that does that. Likewise, the manager's manager can get the salary information for all of their reporting employees.</span> <span> - </span> <span class="display-name">user53019</span> <span> </span> <span class="date">9 Sep 2014 at 13:48</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>If they are wrapped around authorization layers and restricted to certain external entities they are not getters and setters. I'm not saying don't have any method on the payroll department that changes the salary, but that method should align with the internal processes in place in the company itself. For example most companies set salary based on the employees contract, which is authorized by a manager. If the employee's salary changes a new contract is drawn up and a manager has to sign it. Therefore payroll should expect a contract object and some authorisation object to change pay roll</span> <span> - </span> <span class="display-name">Cormac Mulhall</span> <span> </span> <span class="date">9 Sep 2014 at 14:17</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>Or to put it another way, there is quite a difference between set_salary(new_salary, employee_id) and authorized_salary_update(employee_contract, authorising_manager). The process should model the internal business process</span> <span> - </span> <span class="display-name">Cormac Mulhall</span> <span> </span> <span class="date">9 Sep 2014 at 14:23</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>15</span>
     </div>
     <div>
      <span>Answerer: </span> <span>rwallace</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Aug 2011 at 16:54</span>
     </div>
    </div>
    <div>
     <p>As a general rule, getters and setters are a bad idea. If a field isn't logically part of the interface and you make it private, that's fine. If it is logically part of the interface and you make it public, that's fine. But if you make it private and then turn around and make it effectively public again by providing a getter and setter, you're back to where you started except your code is now more verbose and obfuscated.</p>
     <p>Obviously, there are exceptions. In Java, you might need to use interfaces. The Java standard library has backward compatibility requirements so extreme as to outweigh normal measures of code quality. It's even possible that you may actually be dealing with the legendary but rare case where there's a good chance you may later replace a stored field with on the fly calculation without otherwise breaking the interface. But these are exceptions. Getters and setters are an anti-pattern that needs special justification.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>6</td>
        <td><span>A getter and setter mean that the attribute, not the field, is part of the interface. Suppose getBirthDate() and SetBirthDate() take "yyyy/mm/dd" but the field stored is the number of days since 01/01/1000. You can change that to 01/01/0001 and the getter and setter will keep the interface the same. Especially because 'public' means publically trashable, variables should never be public; always use a setter to validate the incoming value, update any related fields, convert as needed, etc. Try to use a getter in case the internal storage changes.</span> <span> - </span> <span class="display-name">Andy Canfield</span> <span> </span> <span class="date">4 Oct 2011 at 07:35</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@AndyCanfield that's a bit strong to say public means publicly trashable..That's only so if u program it badly. If you have a setter and the wrong value is sent to it then u could throw an exception which u could call trashing the program but it's quitting with an errorAlso if the user of the object can give a variable a value and cud give it the wrong value then u can bear that in mind and test it.u may say "ah but I only have to do 1 test if I use a setter",but maybe ur own code gives the variable a bad value..so the setter might not reduce your tests.n with tests,ur prog isn't "trashed"</span> <span> - </span> <span class="display-name">barlop</span> <span> </span> <span class="date">1 Feb 2015 at 05:31</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>4</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user470365</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Oct 2011 at 13:17</span>
     </div>
    </div>
    <div>
     <p>whether field is accesible directly or via method is not realy important.</p>
     <p>Class invariants (usefull ones) is important. And to preserve them, we sometimes need to not be able to change something from outside. Eg. if we have class Square with separete width and height, changing one of them makes it become something else than square. So we need method changeSide If it was Rectangle, we could have setters/public field. But setter than would test whether its greater than zero would be better.</p>
     <p>And in concrete languages (eg. java) are reasons why we need those methods (interfaces). And another reason for method is compatibility (source and binary). So its easier to add them then think whether public field would suffice.</p>
     <p>btw. I like to use simple immutable value holding classes with public final fields.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>This is pretty much the only thing that should be avoided. Going from field to property/getter/setter is a breaking change in most languages.</span> <span> - </span> <span class="display-name">MrDosu</span> <span> </span> <span class="date">16 Sep 2014 at 11:13</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>George Silva</span>
     </div>
     <div>
      <span> Answered: </span> <span>25 Aug 2011 at 22:45</span>
     </div>
    </div>
    <div>
     <p>You may want to change your internals to whatever while keeping the interfaces the same. If your interfaces don't vary, them you code won't break. You still can change your internals as you wish.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>1</td>
        <td><span>I'm surprised this answer is so far down. Getters and setters allow you to do more in the future (e.g. fire an event, do more input validation, do internal bookkeeping) without breaking your existing API. Even with non-public code, the fewer APIs you have to change, the fewer dependencies to update, and the fewer bugs introduced making those updates.</span> <span> - </span> <span class="display-name">AmadeusDrZaius</span> <span> </span> <span class="date">27 Apr 2016 at 06:00</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>mP01</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Oct 2011 at 08:35</span>
     </div>
    </div>
    <div>
     <p>Firstly there are broadly two types of objects which i will comment on, value and service types.</p>
     <p>Service types should never have setters, whatever dependencies they require should not be gettable. THe best way to pass dependencies is via a constructor or factory that way all instances are fully formed from the beginning, plain and simple.</p>
     <p>Value types should also be immutable, on the oher hand there are times when this is not practical such as an ORM, or some other mapping such as from a widget to an object. All other value types that get passed around the system from one layer or part to another should be immutable and should not have setters.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>I'd suggest a third type: a mutable container, whose purpose is to hold one or more values; in many cases, a container should not be expected to have much in the way of logic or validation. Code which needs a method to compute six positive integers may pass a container for six integers to the method which will store the results therein. Responsibility for ensuring the numbers are positive should generally lie with either the caller or the called method, not with the container.</span> <span> - </span> <span class="display-name">supercat</span> <span> </span> <span class="date">13 Jan 2016 at 22:37</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Tobias Cohen</span>
     </div>
     <div>
      <span> Answered: </span> <span>4 Oct 2011 at 02:06</span>
     </div>
    </div>
    <div>
     <p>If using getters and setters feels complicated, the problem might be the language, not the concept itself.</p>
     <p>Here's the code from the <em>second</em> example written in Ruby:</p>
     <pre><code>class Fridge
  attr_accessor :cheese
end

def go_shopping fridge
  fridge.cheese += 5
end
</code></pre>
     <p>Notice it looks a lot like the <em>first</em> example in Java? When getters and setters are treated as first class citizens, they're not a chore to use, and the added flexibility can sometimes be a real boon - for example, we could decide to return a default value for cheese on a new fridge:</p>
     <pre><code>class Fridge
  attr_accessor :cheese

  def cheese
    @cheese || 0
  end
end
</code></pre>
     <p>Of course there will be many variables that shouldn't be exposed publicly at all. Needlessly exposing internal variables will make your code worse, but you can hardly blame that on getters and setters.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>That is beautifully stated. Builder functions were added because we want to create immutable objects while gradually building up the recipe: maybe if you add artificial sweetener, you don't need to add sugar. Using named parameters, and even with overloading, it is very hard building one method doing all. And then of course java doesn't have named parameters, hence one more reason people are using the Builder pattern.</span> <span> - </span> <span class="display-name">YoYo</span> <span> </span> <span class="date">13 Jan 2016 at 00:38</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>gnasher729</span>
     </div>
     <div>
      <span> Answered: </span> <span>12 Oct 2021 at 15:50</span>
     </div>
    </div>
    <div>
     <p>In Swift, there are variables (class, instance, and static variables) which are quite the same as properties. And for every variable, you can add a getter and a setter if you wish to do so, plus code to be called before the setter is called (with a parameter "newValue") and code to be called after the setter is called (with a parameter "newValue).</p>
     <p>The variable itself can be private or public (or fileprivate, or internal, or open; these are Swift specific), and the setter can be private.</p>
     <p>If it's private it doesn't expose anything (and fileprivate only exposes within one source file). If you have a private setter, it can't be modified without control so you are always safe. And if you have a getter, then it doesn't expose any internal state. It only exposes what the interface says it exposes.</p>
     <p>Perfectly object oriented. What you see may be the internal state, maybe it's not. I might have four temperate classes Kelvin, Celsius, Fahrenheit and Reamur which all store temperature in degree Kelvin internally - but only one exposes this directly as a property. And you don't know which one (since the could all four store the temperature in Celsius), and it doesn't matter. Only the interface matters.</p>
     <p>The only difference between a variable and a function is mostly that functions have () appended :-) And you don't have a "get" or "set" prefix. And variables should be used for things that are reasonably fast.</p>
     <p>BTW. Swift allows fridge.cheese += 5 (no semicolon), calling a "getter" and a "setter".</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Paul Nathan</span>
     </div>
     <div>
      <span> Answered: </span> <span>26 Nov 2010 at 23:08</span>
     </div>
    </div>
    <div>
     <p>My approach is this -</p>
     <p>When I expect to diddle with the data later on, a getter/setter is justified. Also, if change is happening, I often push the data into a getter/setter.</p>
     <p>If it's a POD structure, I leave the slots available.</p>
     <p>On a more abstract level, the question is "who manages the data", and that depends on the project.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span> <span class="arrow"> <a href="#answer_13">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Bryan Harrington</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 Nov 2010 at 05:34</span>
     </div>
    </div>
    <div>
     <p>If getters and setters violate encapsulation and true OO, then I'm seriously in trouble.</p>
     <p>I always felt an object represents whatever best comes to mind that you need it to do.</p>
     <p>I have just finished writing a program that generates Mazes in Java, and I have class that represents "Maze Squares". I have data in this class that represents coordinates, walls and booleans etc.</p>
     <p>I have to have some way to change/manipulate/access this data! What do I do without getters and setters? Java doesn't use properties and setting all my data that is local to this class to public is DEFINITELY a violation of encapsulation and OO.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>7</td>
        <td><span>Here is the question: If you made all those fields public, and stopped using the getters and setters how would your code be different?</span> <span> - </span> <span class="display-name">Winston Ewert</span> <span> </span> <span class="date">27 Nov 2010 at 15:10</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>In theory, its not. Why even make a class at that point? Same argument could be made with anything. But the post below mine seems to have said it more elegantly. (Getters and setters are a way to safely hand a value to an object, or retrieve a value from that object.) The post goes on..</span> <span> - </span> <span class="display-name">Bryan Harrington</span> <span> </span> <span class="date">27 Nov 2010 at 15:14</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>I'd point out: that poster eventually agreed with me and posted another answer to that effect. Essentially, using getters and setters is the same as manipulating the data directly. You don't really gain OOness by doing that. In order to be OO you ought to provide a higher level interface to the data.</span> <span> - </span> <span class="display-name">Winston Ewert</span> <span> </span> <span class="date">27 Nov 2010 at 15:29</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>I think the best way of describing it would be to say that you should design your interfaces from the outside in, not the inside out. The interface your object provides should be dictated by how the object is used not how it is implemented. So don't write getters and allow external object to interpret the data. Find out what question they need answered, and write a method that answers that question. Don't allow external objects to modify state by a setter, find out what kind of manipulations they need to perform and write methods that do that.</span> <span> - </span> <span class="display-name">Winston Ewert</span> <span> </span> <span class="date">27 Nov 2010 at 15:31</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>In some cases, Getters and Setters are the best method. Sometimes they are the best interface you can provide. However, in many cases they are not. In many cases, you are just leaking implementation details into other classes.</span> <span> - </span> <span class="display-name">Winston Ewert</span> <span> </span> <span class="date">27 Nov 2010 at 15:32</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>You can manipulate the data inside the object that contains this data. In this way you may not need direct access to the data. If your code is public I can perhaps suggest ways to do this.</span> <span> - </span> <span class="display-name">Jon Acker</span> <span> </span> <span class="date">12 Jul 2022 at 10:12</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_13"><span>Answer 13</span> <span class="arrow"> <a href="#answer_12">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Dale</span>
     </div>
     <div>
      <span> Answered: </span> <span>16 Jul 2013 at 15:46</span>
     </div>
    </div>
    <div>
     <p>Consider a <code>Size</code> class which encapsulates width and height. I can eliminate setters by using the constructor but how does that help me draw a rectangle with <code>Size</code>? Width and height are not internal data to the class; they're shared data that must be available to the consumers of Size.</p>
     <p>Objects consist of behaviors and state - or attributes. If there is no exposed state then only behaviors are public.</p>
     <p>Without state, how would you sort a collection of objects? How would you search for a specific instance of an object? If you only use constructors, what happens when your object has a long list of attributes?</p>
     <p>No method parameter should ever be consumed without validation. Therefore it is laziness to write:</p>
     <pre><code>setMyField(int myField){
    this.myField = myField;
}
</code></pre>
     <p>If you do write it that way then you have at least prepared for using the setter for validation; it's better than a public field - but just barely. But at least you have a consistent public interface that you can come back and put in validation rules without breaking the code of your customers.</p>
     <p>Getters, setters, properties, mutators, call them what you will, but they're necessary.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span><i>But at least you have a consistent public interface that you can come back and put in validation rules without breaking the code of your customers.</i> That's not true. Adding validation rules further down the road could very well "break the code of your customers". Take an <code>int</code> instance variable, for example, and imagine that you decide to add a validation rule to only accepts nonnegative values. The problem is that your customer's code may already rely on the possibility to set it to a negative value...</span> <span> - </span> <span class="display-name">jub0bs</span> <span> </span> <span class="date">1 Nov 2015 at 14:19</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>