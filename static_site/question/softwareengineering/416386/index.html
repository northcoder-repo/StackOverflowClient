<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>What is the utility and advantage of getters &amp; setters especially when they are merely used to read and assign values to properties of an object?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>What is the utility and advantage of getters &amp; setters especially when they are merely used to read and assign values to properties of an object?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>83</span>
    </div>
    <div>
     <span>Asker: </span> <span>ProjectDiversion</span>
    </div>
    <div>
     <span>Asked: </span> <span>29 Sep 2020 at 19:26</span>
    </div>
    <div>
     <a href="https://softwareengineering.stackexchange.com/questions/416386/what-is-the-utility-and-advantage-of-getters-setters-especially-when-they-are">source</a>
    </div>
   </div>
   <div>
    <p>I’m still really new to learning to program. Just learning the syntax for a few programming languages at the moment.</p>
    <p>The courses I viewed for C# and Java touched only very briefly on getters &amp; setters and it still didn’t make an awful lot of sense to me. So I researched them further and found that the whole subject of getters &amp; setters is a lot more debated than I could believe. For every argument &amp; example both for and against getters &amp; setters there was a counter argument, saying that it was wrong, the code was a bad example etc. and I still didn’t know who to agree with or even fully grasp the jargon behind it.</p>
    <p>So I’m really not sure what to go for at the moment. So I’m going to post my take on what getters &amp; setters really are given what I’ve read and if there’s anything I’ve got wrong then please tell me. Then I have a few more questions that I haven’t found any answers for anywhere.</p>
    <p><strong>My take on getters &amp; setters</strong></p>
    <p>FOR:</p>
    <ul>
     <li>
      <p>Getters and setters are methods declared within a class and applied to fields within said class, and control what other classes can access and modify these fields.</p></li>
     <li>
      <p>They’re used on fields which need to be accessed from outside their class, but at the same time cannot let anything have access other than what needs access.</p></li>
     <li>
      <p>When programmers talk about “if you make a field public then ANYONE can have access to them” by anyone they’re not necessarily talking about hackers or the user of your finished program. They’re talking about any other programmers who are working on the same program (or yourself) creating something which accidentally creates side effects which modify that class. Then you not being able to work out what is causing that change.</p></li>
     <li>
      <p>As well as controlling access they can do other things such as validate any input to the field before it is added (Mike Dane aka Giraffeacademy has used the example several times that a movie can only have 3 age ratings, so adding into the setter a method which checks the rating of a movie before it is added is a good side effect of a setter). In the same example, it can also improve the maintainability of your program, for example if a fourth rating is added, you can modify any objects where the new rating applies to just by adding it to the setter, rather than going through each movie individually.</p></li>
    </ul>
    <p>AGAINST</p>
    <ul>
     <li>
      <p>Many programmers nowadays are strongly against the use of getters and setters. They argue that it ruins the encapsulation of your objects and makes code noisy and unreadable. Also that they encourage programmers to think of objects as data structures.</p></li>
     <li>
      <p>I’ve seen some arguments that they are now somewhat obsolete as some programming languages such as Python, which doesn’t need to use getters &amp; setters. Also some IDE’s make it easy to see where side effects are taking place.</p></li>
     <li>
      <p>The main argument I’ve seen against them is that they’re just poor design. Code and classes should be clean and organised in a way that fields are only accessed outside the class when it absolutely needs to be, and getters and setters should only be used as a last resort.</p></li>
     <li>
      <p>An idea I saw recently is that you should start off making every field you create private. Then find everything which needs to be accessed outside the class and if there’s no other way around it, add a getter and/or setter to it.</p></li>
    </ul>
    <p>The final, neutral argument I’ve seen is that you shouldn’t be adding things to your code that you don’t understand or don’t know if you’re going to need or not. That I absolutely agree with. But obviously I need to know if they’re going to be useful to me or not when I actually create something.</p>
    <p>So if I’ve got anything wrong then please let me know, and I still have a few questions:</p>
    <ul>
     <li>
      <p>What parts of your program would you actually use getters and setters on? The examples I’ve seen online use classes such as ‘Dog/Ball’ and ‘Person’ which really aren’t much use to me. I’m thinking you would use them if you had a class for ‘Accounts’ and a different class for ‘Settings’.. the settings class would need to access the Account’s user name if the username requested to change it.. right?</p></li>
     <li>
      <p>Going with that example, if getters and setters are created to prevent someone from being able to change a variable through a side effect, what kind of code could actually change a user’s name as a side effect accidentally? Surely the only kind of areas in your program that could modify an accounts username are setUsername, displayUsername and changeUsername, and nothing else would ever need to go near those variables.</p></li>
     <li>
      <p>Given the debate I’ve found surrounding getters &amp; setters why do courses and tutorials touch so briefly on them only just teaching you the syntax for them, and not arguing the cases for and against or even providing actual real world examples? (See note before about dog/ball). Are they too biased of an opinion? Or am I just looking into one topic way too much?</p></li>
    </ul>
    <p>As I said I’m still so new to programming, so I’m probably either too inexperienced or thinking about it way too much. I just want to be absolutely clear on what I’m adding/not adding to my programs before I release them to the world.</p>
    <p>Any help much appreciated. Have a good day.</p>
   </div>
   <div class="tags">
    <span class="tag">java</span><span class="tag">c#</span><span class="tag">object-oriented</span><span class="tag">setters</span><span class="tag">getters</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>14</td>
       <td><span>While this is interesting question, I think the answer would be too opinionated. I'm sure you can find here people from both sides of the argument. For me, one thing I agree highly is the "Don't add properties until you absolutely need them." And C# being my main language, I still use them frequently.</span> <span> - </span> <span class="display-name">Euphoric</span> <span> </span> <span class="date">29 Sep 2020 at 19:34</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>@Euphoric That’s the exact problem that it’s too opinionated, especially on a website like Stack Overflow. With that being said, I’d rather read a comment on a forum or Stack Overflow than a single blog post by one person with no means of someone else challenging it or pointing out its flaws. I guess the problem is I just don’t know enough about them. But where’s a reliable resource?</span> <span> - </span> <span class="display-name">ProjectDiversion</span> <span> </span> <span class="date">29 Sep 2020 at 19:41</span></td>
      </tr>
      <tr>
       <td>17</td>
       <td><span>It sounds like you are overthinking it. If you are not sure you need a getter/setter then you probably don't. Getters/setters are appropriate in some circumstances and not others, so it is hard to say without further context if you should use then. What is they problem you are trying to solve?</span> <span> - </span> <span class="display-name">JacquesB</span> <span> </span> <span class="date">29 Sep 2020 at 19:41</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@JacquesB That’s definitely true. But it sounds like not using them when you need to can have far worse consequences than using them when you don’t need to. It would be good if someone could point me to some source code/open source projects which use them, as I’m sure that would give me the best understanding.</span> <span> - </span> <span class="display-name">ProjectDiversion</span> <span> </span> <span class="date">29 Sep 2020 at 19:50</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>I think a discussion about getters/setters needs to be centered around the <i>purpose</i> they serve. If they're being applied to a language where the purpose isn't being met, then they shouldn't be used. I have an article that talks about the motivation behind them in a Java context, and why that <i>doesn't</i> carry through another language (Swift, in this case) <a href="https://github.com/amomchilov/Blog/blob/master/Stop%20writing%20getters%20and%20setters%20in%20Swift.md" rel="nofollow noreferrer">github.com/amomchilov/Blog/blob/master/…</a></span> <span> - </span> <span class="display-name">Alexander</span> <span> </span> <span class="date">29 Sep 2020 at 20:00</span></td>
      </tr>
      <tr>
       <td>7</td>
       <td><span>It's not that getters and setters are inherently evil. This is not about a single class, but about maintainability problems which arise in a larger system where classes/objects interact. The problem is coupling; the more classes know the details of each other, the more they become coupled in a way that makes change harder, and increases the overall complexity. This essentially happens "on its own" as the project ages, unless steps are actively taken to battle this entanglement. 1/2</span> <span> - </span> <span class="display-name">Filip Milovanović</span> <span> </span> <span class="date">30 Sep 2020 at 12:12</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>A common cause of such coupling is when a class accesses data from another class (accesses properties and does something with the values), instead just <i>asking, in a more generalized way</i>, the other class to do something (by calling a method), and letting the other class handle the logic. Code that's greedy for data has a lot of getters and setters, while the more OO code has classes with a number of methods that provide some small service to their callers. The first one looks like a bunch of low level instructions, the second is more declarative, with the details hidden in the methods. 2/2</span> <span> - </span> <span class="display-name">Filip Milovanović</span> <span> </span> <span class="date">30 Sep 2020 at 12:12</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>As far as I can tell, the debate is entirely about <i>trivial</i> getters and setters: those that provide direct access to a member variable, and nothing else. I've never seen anyone argue against non-trivial ones, such as a <code>SetLongitude()</code> that normalizes the longitude to the range [-180,180].</span> <span> - </span> <span class="display-name">Mark</span> <span> </span> <span class="date">30 Sep 2020 at 20:18</span></td>
      </tr>
      <tr>
       <td>3</td>
       <td><span>At some point in my career I decided to program my thesis project without getters/setters. Everything went swimmingly until later in the project I realized I needed to execute some code each time some members were accessed. I had to waste a few good hours replacing member access with a call to an appropriate getter (all of this happened in Java).</span> <span> - </span> <span class="display-name">Spidey</span> <span> </span> <span class="date">1 Oct 2020 at 11:34</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>Getters/setters are definitely an eyesore. No one likes looking at them and they're mostly boilerplate. Therefore I really like how Kotlin, C# and Python to some extend are handling them (yeah Python offers @property which effectively creates getters and setters under the hood).</span> <span> - </span> <span class="display-name">Spidey</span> <span> </span> <span class="date">1 Oct 2020 at 11:36</span></td>
      </tr>
      <tr>
       <td>6</td>
       <td><span>@ProjectDiversion Two good rules of thumb: (a) it's better to call a method than to access a field (for reasons others have given), (b) think hard about method names, rather than blindly using <code>getFoo</code> and <code>setFoo</code>. For example, instead of <code>Account::getBalance</code> why not call it <code>Account::balance</code>? Would it be better to replace <code>Account::setBalance</code> with separate <code>Account::deposit</code> and <code>Account::withdraw</code> methods? etc.</span> <span> - </span> <span class="display-name">Warbo</span> <span> </span> <span class="date">1 Oct 2020 at 15:07</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>For Java the answer is rather simple - you are encouraged to code to interfaces, but they only list methods, not fields, so getters/setters are a hack around this.</span> <span> - </span> <span class="display-name">Thorbjørn Ravn Andersen</span> <span> </span> <span class="date">2 Oct 2020 at 08:32</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@ThorbjørnRavnAndersen You're confusing interfaces and <code>interface</code>s</span> <span> - </span> <span class="display-name">user253751</span> <span> </span> <span class="date">2 Oct 2020 at 10:10</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>You forgot one FOR argument - getters and setters allow you to achieve a better access granularity, basically splitting between READ and WRITE permissions. If your field is read-only - you only implement the getter, if it is write only - the setter if both, both, but making the field itself public will not give you this control (would be read-write by default).</span> <span> - </span> <span class="display-name">ACV</span> <span> </span> <span class="date">2 Oct 2020 at 11:02</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@user253951 well, did you understand the point given the java-tag?</span> <span> - </span> <span class="display-name">Thorbjørn Ravn Andersen</span> <span> </span> <span class="date">2 Oct 2020 at 11:13</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span><i>"I researched them further and found that the whole subject of getters &amp; setters is a lot more debated than I could believe. For every argument &amp; example both for and against getters &amp; setters there was a counter argument, saying that it was wrong, the code was a bad example etc. and I still didn’t know who to agree with or even fully grasp the jargon behind it."</i> Welcome to the industry :P</span> <span> - </span> <span class="display-name">Asteroids With Wings</span> <span> </span> <span class="date">2 Oct 2020 at 20:21</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Recognize that the whole dogma arises from a language limitation: <b>Java has no properties</b>. This prevents you from solving refactoring headaches <i>as they arise</i> — instead, you're forced to prepare for every possibility that a field <code>foo</code> may have to be removed in the future without breaking client code touching <code>foo</code>. The way you prepare is, of course, by only ever using <code>setFoo/getFoo</code> outside the class — while if there was an option to turn <code>foo</code> into a property at any point breaking nothing, you could just use <code>myobj.foo</code> directly everywhere and avoid writing accessors you never needed.</span> <span> - </span> <span class="display-name">ulidtko</span> <span> </span> <span class="date">7 Oct 2020 at 08:23</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Another thing to consider: Getters and setters are a good place to implement some <a href="https://en.wikipedia.org/wiki/Design_by_contract" rel="nofollow noreferrer">Design by contract</a>-ish behaviour, e. g. using <code>assert</code>s (yes, I'm a C++ programmer in the first place). Read the <i>Pragmatic Programmer</i> if you want to know more.</span> <span> - </span> <span class="display-name">Murphy</span> <span> </span> <span class="date">7 Oct 2020 at 13:10</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>I cannot answer, because the question is closed, but I want to give another simple view on setters/getters which should both make clearer what the danger of using them all around is, and, for contrast, what you could use them for. Given a <code>Person</code> class with <code>age</code> and <code>number_of_sons</code> as two fields, having a getter and setter for both, exposes you to the invalid status of a <code>person</code> object having <code>person.age == 3</code> and <code>person.number_of_sons &gt; 0</code>. [Functional Programming in C++](I cannot answer, because the question is closed), page 249-250 gives a nice explanation along these lines.</span> <span> - </span> <span class="display-name">Enlico</span> <span> </span> <span class="date">7 Oct 2020 at 19:52</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>The design by contract example is good @Murphy. The same can be said about designing a program which uses a state machine style logic. In this situation, switches in state can be efficiently modelled through modifying getter/setter code while also being easier to comprehend; in comparison to maintaining state variables and performing state switches using function calls.</span> <span> - </span> <span class="display-name">demoncrate</span> <span> </span> <span class="date">8 Oct 2020 at 11:54</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>Getters and Setters provide colander-style encapsulation to the point that it's rendered almost useless. It comes from the "property-style" programming that's provided by some languages and GUI frameworks, where poking the attributes of a control makes some sense. Personally I put "get/set programming" down to a failure to think about the problem in abstract terms, and I adopt the principle of "allow other actors to peek, but don't let them poke". Instead, the other actors should <i>only</i> be able to perform <i>operations</i> (methods) on a class, not poking around its internal state and integrity.</span> <span> - </span> <span class="display-name">Den-Jason</span> <span> </span> <span class="date">14 Oct 2020 at 01:47</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>134</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Doc Brown</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Sep 2020 at 21:14</span>
     </div>
    </div>
    <div>
     <blockquote>
      <p>I’m still really new to learning to program. Just learning the syntax for a few programming languages at the moment.</p>
     </blockquote>
     <p>And that is actually the problem here - you approach this way too much from a syntactical point of view. What you need to learn first is solving problems with programs. When the problems get larger, the programs will get larger and require more structure. That will bring you to a point where you need</p>
     <ul>
      <li>
       <p>data structures and data abstractions</p></li>
      <li>
       <p>functional abstractions</p></li>
      <li>
       <p>functions which operate on specific data structures, so the data structures might become classes, and the functions become member functions of that classes.</p></li>
     </ul>
     <p>At that point, you will have to learn about how to design the public API of a class to create a good abstraction, for reaching a certain goal. You will also start to learn why making members "private" by default is a really good idea. If you work in some context of a real problem, you will know the precise requirements for your classes and their API, so you can decide which parts / functions / properties can stay private, and which not.</p>
     <p>That will be the point in time where you may notice a very frequent requirement for classes: getting external access to some state information of the object (either read access - for which a getter is fine, or also write access, for which an additional setter will be required). Such state often corresponds to the content of a private member variable. However, that is not mandatory, getters and setters can also deliver (or change) values/state which are not stored directly in a member variable, but can be derived or calculated indirectly.</p>
     <p>So in short: you do not decide about using or not using getters and setters by a pro/con list. Getters and setters are just tools which help you to solve some problems (specifically the problems you listed in your FOR section). One decides about their usage depending on if the actual problem requires them, and if they fit well to the kind of abstraction one wants to build by a class.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>Well said. You get some very different problems when working on a codebase of tens of thousands of lines than you get from the small, manageable programs you write when you're learning. Anything that helps tame that complexity, anything that lets you work on small parts in isolation, is something that will reduce bugs and improve productivity. Strong encapsulation is one such tool — it's one of the main reasons why object-oriented programming has become so successful.</span> <span> - </span> <span class="display-name">gidds</span> <span> </span> <span class="date">30 Sep 2020 at 13:35</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>Getting access to private member variables is <b>not</b> a frequent requirement if you're doing object-orientation, exactly the opposite, it is pretty rare. "Getters and setters are just tools", while technically correct, is therefore <i>extremely</i> misleading.</span> <span> - </span> <span class="display-name">Robert Bräutigam</span> <span> </span> <span class="date">1 Oct 2020 at 08:27</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@RobertBräutigam: at least it is so frequent that in C# language designers decided to introduce an own language feature for it (properties). It is so frequent Fowler has a an own refactoring in his <a href="https://refactoring.com/catalog/encapsulateVariable.html" rel="nofollow noreferrer">catalog</a>. There should be nothing misleading here, if you don't try intentionally to misread what I wrote.</span> <span> - </span> <span class="display-name">Doc Brown</span> <span> </span> <span class="date">1 Oct 2020 at 08:42</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@DocBrown You wrote it is a "frequent requirement for classes", not that it is frequently done. I agree that it is frequently done, that is why all the languages want it incorporated, they just follow the majority. The majority of designs however are data structure-services type designs, not object-oriented ones. This difference matters a lot.</span> <span> - </span> <span class="display-name">Robert Bräutigam</span> <span> </span> <span class="date">1 Oct 2020 at 09:02</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@RobertBräutigam: if the requirement for getters and setters arise from designs which fit into your idealistic wish of what OO should be, or if they arise from real-world designs does not invalidate what I wrote. I guess most of the classes in the .Net standard libraries as well as in the Java standard libraries have properties/getters and setters, I doubt they are all there because the designers placed them there without having requirements for them, or because they were unexperienced in OO programming.</span> <span> - </span> <span class="display-name">Doc Brown</span> <span> </span> <span class="date">1 Oct 2020 at 13:40</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@DocBrown I don't think they were inexperienced, although could be. I think they just don't care. Their focus is to capture as many developers as possible, not to dictate how proper software development should be done, let alone how object-orientation should look like. Although you should probably use the idioms of your environment, can we agree that neither C#/.NET nor Java/JDK/JEE should be taken as blueprint on how to do object-oriented development?</span> <span> - </span> <span class="display-name">Robert Bräutigam</span> <span> </span> <span class="date">1 Oct 2020 at 14:33</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@RobertBräutigam: such huge environments always contain a lot of compromises. However, in reality, both were very successful over the years. I agree they are probably not a blueprint of <i>your</i> idea how to do OO development, but because of their sustaining success, I tend to the opinion they are a blueprint for how successful development of larger systems can be done (if one calls them OO or not).</span> <span> - </span> <span class="display-name">Doc Brown</span> <span> </span> <span class="date">1 Oct 2020 at 15:11</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Well done. References to resources ( books, blog posts, etc ) to learn more about designing such API's would be appreciated.</span> <span> - </span> <span class="display-name">deividaspetraitis</span> <span> </span> <span class="date">1 Oct 2020 at 17:22</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@deividaspetraitis: I am talking from over three decades of practical experience here. Sure, I also learned a lot from books, blog posts, articles, university as well, but I am actually unsure which I would recommend here for the specific problem described in the question. Maybe <a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html" rel="nofollow noreferrer">SICP</a>, but that takes a full semester course to get through, and it expects the reader to transfer its wisdom to current mainstream programming languages . Not sure if that would reall be helpful for the OP.</span> <span> - </span> <span class="display-name">Doc Brown</span> <span> </span> <span class="date">2 Oct 2020 at 04:33</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@deividaspetraitis: <a href="https://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read">Here</a> is a good list, I think I have read (or at least used) several of the top 30 fo them.</span> <span> - </span> <span class="display-name">Doc Brown</span> <span> </span> <span class="date">2 Oct 2020 at 04:43</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>^^^^ THIS RIGHT HERE ^^^^</span> <span> - </span> <span class="display-name">Asteroids With Wings</span> <span> </span> <span class="date">2 Oct 2020 at 20:23</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>35</span>
     </div>
     <div>
      <span>Answerer: </span> <span>o.m.</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Sep 2020 at 13:08</span>
     </div>
    </div>
    <div>
     <p>Getters and setters allow the programmer to change the implementation of a class later on more easily. If the class is used elsewhere, and if there are no getters and setters, then the programmer has to change <em>every other class</em> which uses it. With getters and setters, the using classes can remain unchanged.</p>
     <p>Imagine you have a class called <strong>BankAccount</strong> with a balance and a transaction history. There is another class which retrieves BankAccount objects from the database.</p>
     <p>You find out that your program is too slow. After some profiling, it is the transaction history which takes a long time to load, yet almost all uses of the bankAccount query the balance only. Fortunately, there is a getter.</p>
     <pre><code>public List&lt;Transaction&gt; getTransactionHistory() { 
    return transactionHistory; 
}
</code></pre>
     <p>You can simply change this getter and the way the bank account is initially loaded.</p>
     <pre><code>public List&lt;Transaction&gt; getTransactionHistory() { 
    if (transactionHistory == null) {
        loadTransactionHistory();
    }
    return transactionHistory; 
}
</code></pre>
     <p>People who use your class don't see a difference, except that the initial loading got much faster and the subsequent call to the getter got slower.</p>
     <p>Or you find that saving BankAccount objects back into the database takes a lot of time, even if most of the time nothing has changed. Fortunately, there is a setter on both balance and transaction history.</p>
     <pre><code>public void setBalance(int balance) { 
    this.balance = balance;
}
</code></pre>
     <p>You simply add a new field, a boolean called isDirty.</p>
     <pre><code>public void setBalance(int balance) { 
    this.isDirty = true;
    this.balance = balance;
}
</code></pre>
     <p>And when it comes to persisting the object again, if <code>!isDirty</code> you can skip the persisting.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>Also, validation can be added into property setters. Also firing events, say when the property has been changed. It's quite common for user interface elements to subscribe to "PropertyChangedEvent" which is fired from the setter if the new value does not equal the old one for example.</span> <span> - </span> <span class="display-name">David Waterworth</span> <span> </span> <span class="date">1 Oct 2020 at 06:08</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>This answer gets much more to the point than the more upvoted answers. Having setters and getters allows you to modify the behavior without modifying the outside interface, which is very, very important.</span> <span> - </span> <span class="display-name">Morfildur</span> <span> </span> <span class="date">2 Oct 2020 at 06:55</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I would just add what is kind of implicit here: if you had a public member called from somewhere else, if you change it to a getter to implement this, you would need to update every assembly calling it, as a getter is a method call and not just a variable access. If it's <b>only</b> accessed from within your solution, then this is probably not much of an issue.</span> <span> - </span> <span class="display-name">Andrew</span> <span> </span> <span class="date">8 Oct 2020 at 16:39</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@Andrew, added.</span> <span> - </span> <span class="display-name">o.m.</span> <span> </span> <span class="date">9 Oct 2020 at 04:55</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>23</span>
     </div>
     <div>
      <span>Answerer: </span> <span>candied_orange</span>
     </div>
     <div>
      <span> Answered: </span> <span>29 Sep 2020 at 21:40</span>
     </div>
    </div>
    <div>
     <p>Getters and setters make accessing fields into their own methods. When you're in Java you have to do this up front or when you decide to do it later you change the interface. In C# they have lovely properties so your clients won't care when you decide to make your public fields private.</p>
     <p>These let you detect when something is accessing your fields. Public fields can't do that.</p>
     <p>This is why getters and setters exist. It's certainly not that they provide encapsulation. They don't. They just let you detect when someone is breaking your encapsulation. They don't make you object oriented. They don't enable polymorphism. But they still exist for a reason.</p>
     <p>Use getters when you can't move the method that needs access into the class with the data. If you can you should under OO. This happens when you're up against a boundary like code you don't control. You can also use a collection in these cases but using getters provides type safety that collections don't offer. When up against the boundary problem a Data Transfer Object (DTO) full of getters is still better than a pile of public fields.</p>
     <p>Use setters when you have to mutate the class during its lifetime. It's better to be immutable but somethings can't be. Deserializers used to require this but most no longer do. Immutable objects are great but try to get two nodes to point at each other without a setter.</p>
     <p>Much as I hate how they break encapsulation I have to admit they sometimes have their uses. I use them in behaviorless DTOs. I keep them out of my behavior objects. I don't like hybrids that try to be both.</p>
     <hr>
     <blockquote>
      <p><strong>My take on getters &amp; setters</strong></p>
      <p>FOR:</p>
      <ul>
       <li>Getters and setters are methods declared within a class and applied to fields within said class, and control what other classes can access and modify these fields.</li>
      </ul>
     </blockquote>
     <p>No, access modifiers (public, private, protected, default) do that on their own. This doesn't explain the existence of getters and setters.</p>
     <blockquote>
      <ul>
       <li>They’re used on fields which need to be accessed from outside their class, but at the same time cannot let anything have access other than what needs access.</li>
      </ul>
     </blockquote>
     <p>No, getters and setters have no idea what is accessing them. Well, unless you're peeking at the call stack with some reflection magic.</p>
     <blockquote>
      <ul>
       <li>When programmers talk about “if you make a field public then ANYONE can have access to them” by anyone they’re not necessarily talking about hackers or the user of your finished program. They’re talking about any other programmers who are working on the same program (or yourself) creating something which accidentally creates side effects which modify that class. Then you not being able to work out what is causing that change.</li>
      </ul>
     </blockquote>
     <p>This is correct. Information hiding, as this is called, isn't about security (unless someone adds some toys that make it that way). This is about protecting a chunk of code from being used any old crazy way rather than through its proper interface. That way you know what you're breaking when you change it. This is why maintaining real encapsulation is important. Access modifiers encourage that by making clear what is private and what is public. "Anyone" really just means coders working on other classes.</p>
     <blockquote>
      <ul>
       <li>As well as controlling access they can do other things such as validate any input to the field before it is added (Mike Dane aka Giraffeacademy has used the example several times that a movie can only have 3 age ratings, so adding into the setter a method which checks the rating of a movie before it is added is a good side effect of a setter). In the same example, it can also improve the maintainability of your program, for example if a fourth rating is added, you can modify any objects where the new rating applies to just by adding it to the setter, rather than going through each movie individually.</li>
      </ul>
     </blockquote>
     <p>Validation is something your constructor can do. You don't need it in setters if you don't have them. Anything that might invalidate your state should trigger validation. Limit what can invalidate you.</p>
     <blockquote>
      <p>AGAINST</p>
     </blockquote>
     <blockquote>
      <ul>
       <li>Many programmers nowadays are strongly against the use of getters and setters. They argue that it ruins the encapsulation of your objects and makes code noisy and unreadable. Also that they encourage programmers to think of objects as data structures.</li>
      </ul>
     </blockquote>
     <p>I'm strongly against brainless use of getters and setters on every field. It ruins object orientation because there's no polymorphism. I want to tell something to do something and not have to know exactly what it is or what it will do. I want something else to worry about that. I don't get that if I poke my nose into every private thing that exists.</p>
     <blockquote>
      <ul>
       <li>I’ve seen some arguments that they are now somewhat obsolete as some programming languages such as Python, which doesn’t need to use getters &amp; setters. Also some IDE’s make it easy to see where side effects are taking place.</li>
      </ul>
     </blockquote>
     <p>What python doesn't use is enforced access modifiers. They just mark their private fields with names that start with underscores. "We're all adults here" means you'll behave and respect that right?</p>
     <blockquote>
      <ul>
       <li>The main argument I’ve seen against them is that they’re just poor design. Code and classes should be clean and organised in a way that fields are only accessed outside the class when it absolutely needs to be, and getters and setters should only be used as a last resort.</li>
      </ul>
     </blockquote>
     <p>Properly encapsulated behavioral objects shouldn't let you know that those fields even exist. They provide an interface that you use to tell them to do things and they do it. They might use those fields to make decisions but you don't need to know that.</p>
     <blockquote>
      <ul>
       <li>An idea I saw recently is that you should start off making every field you create private. Then find everything which needs to be accessed outside the class and if there’s no other way around it, add a getter and/or setter to it.</li>
      </ul>
     </blockquote>
     <p>No. This is just pretending it's OK as long as you feel guilty about it. It's also promoting the idea that once a field is public it must stay that way. Learn to move what needs the field into the object that has it. If the field value must be sent somewhere else do the sending yourself. Don't let just anyone in here to get it.</p>
     <blockquote>
      <p>The final, neutral argument I’ve seen is that you shouldn’t be adding things to your code that you don’t understand or don’t know if you’re going to need or not. That I absolutely agree with. But obviously I need to know if they’re going to be useful to me or not when I actually create something.</p>
     </blockquote>
     <p>Add getters and setters to Java to keep people from directly accessing fields (thus, offer no public fields). C# has properties that makes that a non issue. But if you're trying to be object oriented try to keep people from touching your fields at all.</p>
     <blockquote>
      <ul>
       <li>What parts of your program would you actually use getters and setters on? The examples I’ve seen online use classes such as ‘Dog/Ball’ and ‘Person’ which really aren’t much use to me. I’m thinking you would use them if you had a class for ‘Accounts’ and a different class for ‘Settings’.. the settings class would need to access the Account’s user name if the username requested to change it.. right?</li>
      </ul>
     </blockquote>
     <p>Getters and setters solve problems that are difficult to realistically recreate in an example.</p>
     <blockquote>
      <ul>
       <li>Going with that example, if getters and setters are created to prevent someone from being able to change a variable through a side effect, what kind of code could actually change a user’s name as a side effect accidentally? Surely the only kind of areas in your program that could modify an accounts username are setUsername, displayUsername and changeUsername, and nothing else would ever need to go near those variables.</li>
      </ul>
     </blockquote>
     <p>Getters and setters are not created to prevent changing variables through side effects. They're created so that you can detect that variables have been changed or read.</p>
     <blockquote>
      <ul>
       <li>Given the debate I’ve found surrounding getters &amp; setters why do courses and tutorials touch so briefly on them only just teaching you the syntax for them, and not arguing the cases for and against or even providing actual real world examples? (See note before about dog/ball). Are they too biased of an opinion? Or am I just looking into one topic way too much?</li>
      </ul>
     </blockquote>
     <p>Probably because the debate is still raging. They prefer to teach people what they can prove.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>15</td>
        <td><span>"you can't set a breakpoint on a field" that depends on the language</span> <span> - </span> <span class="display-name">Lie Ryan</span> <span> </span> <span class="date">29 Sep 2020 at 21:53</span></td>
       </tr>
       <tr>
        <td>16</td>
        <td><span>and the debugger; similarly as data-breakpoints.</span> <span> - </span> <span class="display-name">Hans Olsson</span> <span> </span> <span class="date">30 Sep 2020 at 07:38</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Note that if it's all within your program, your IDE probably has a "replace field with getters and setters" option.</span> <span> - </span> <span class="display-name">user253751</span> <span> </span> <span class="date">30 Sep 2020 at 11:48</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>The discussion is <i>not</i> between setter/getters vs. public fields, it's between setters/getters/public fields vs. <i>proper encapsulation</i>. The difference between using setters/getters and public fields is mostly irrelevant, but the difference between those and object-orientation is so ground-braking that we still discussing after 50 or so years, and still largely getting it wrong.</span> <span> - </span> <span class="display-name">Robert Bräutigam</span> <span> </span> <span class="date">30 Sep 2020 at 12:55</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@RobertBräutigam my answer is not simply to contrast *etters vs public fields. I'm explaining why *etters persist. Just saying *etters are bad causes confusion that leads to people giving up understanding and applying them everywhere or nowhere. The correct answer is to create a safe place in your code for fully encapsulated polymorphic behavioral objects even if they have to spit out or consume some *etter covered DTO that some 3rd party library requires. Use as needed only.</span> <span> - </span> <span class="display-name">candied_orange</span> <span> </span> <span class="date">30 Sep 2020 at 14:33</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>"If the field value must be sent somewhere else do the sending yourself." How can that be applied consistently? If information must be passed from object foo to object bar, surely either bar needs to call foo.getInfo() or foo needs to call bar.setInfo(), no? In which case one of them would be violating this rule.</span> <span> - </span> <span class="display-name">SirTechSpec</span> <span> </span> <span class="date">30 Sep 2020 at 19:15</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@SirTechSpec if <code>info</code> is part of <code>foo</code>s state it shouldn’t be made part <code>bar</code>s state. See “single source of truth”. However It can be operated on by the method you pass it to. For example <code>foo</code> can call <code>bar.print(info)</code> without knowing or caring how bar will print it.</span> <span> - </span> <span class="display-name">candied_orange</span> <span> </span> <span class="date">30 Sep 2020 at 19:26</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>You <i>can</i> set "breakpoints" on members. gdb calls them <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Set-Watchpoints.html" rel="nofollow noreferrer">watchpoints</a>.</span> <span> - </span> <span class="display-name">Phil Frost</span> <span> </span> <span class="date">1 Oct 2020 at 02:02</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>In all seriousness, what's the difference between Java's public fields and Scala's and Kotlin's case/data class fields? Both cases are anemic data containers.</span> <span> - </span> <span class="display-name">Branislav Lazic</span> <span> </span> <span class="date">1 Oct 2020 at 12:47</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@BranislavLazic for the history look up the Java bean spec. Setters allow for validated no arg object initialization which used to be important in enterprise java. Add getters and you detect when people violate your encapsulation.</span> <span> - </span> <span class="display-name">candied_orange</span> <span> </span> <span class="date">1 Oct 2020 at 13:08</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@candied_orange That doesn't quite answer my question...</span> <span> - </span> <span class="display-name">Branislav Lazic</span> <span> </span> <span class="date">1 Oct 2020 at 13:12</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@BranislavLazic a Java bean, free of behavioral code, is most certainly an anemic data container. However some people create hybrids that have both. I’d rather work with a pure anemic data container.</span> <span> - </span> <span class="display-name">candied_orange</span> <span> </span> <span class="date">1 Oct 2020 at 13:19</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>15</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Scott Shipp</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Sep 2020 at 16:24</span>
     </div>
    </div>
    <div>
     <p>I am one of the software engineers who advocates suspicion for getters and setters, <em>but only because of how they are used today.</em> The reason I object is mainly that application programmers have developed the bad habit of generating getters and setters for every field without considering whether or not each getter or setter is necessary.</p>
     <p>Furthermore, as you mentioned, the default access modifier for generated getters and setters, by default in many IDE's, is public.</p>
     <p>Some languages do not even provide access control to fields (like Python) and in others like Java it is common to use libraries like Lombok to short-circuit type-safety and encapsulation.</p>
     <p>In some cases, application developers literally could change many classes over to public fields, delete all the getters and setters, and have equivalent functionality to what they have today while removing hundreds of lines of potentially buggy code from their applications.</p>
     <p>Both the existence of unnecessary getters or setters, and too-relaxed access modifiers on them, have <strong>created a significant percentage of the bugs I have seen in my seventeen-year career</strong>.</p>
     <p>Nevertheless, as others have pointed out, getters and setters themselves are a different topic than access control and immutability, which are both more important to good application design.</p>
     <p>A library developer will pay the most attention to getters and setters because they pay the highest price for problematic designs. In their context, even access to read-only fields must be controlled through getters because at least then they can keep one consistent library API while being able to modify the implementation underneath as necessary.</p>
     <p>Thankfully, the good news is that most languages are evolving with new higher-level constructs that provide the ability to enforce good design for various use cases. Examples include C# properties and Scala case classes.</p>
     <p>In short: good object-oriented design is subject to the context of many factors (application vs. library, available language features, open-source vs. private) and there is no single dogma that applies in all cases.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>How would one know in advance if getters/setters are required or direct access is sufficient? I see them as preparation for future refactoring. Of course modern IDEs will help with simple signature changes, but it still clutters up the merge request if you change not just one class but all other classes which use it.</span> <span> - </span> <span class="display-name">o.m.</span> <span> </span> <span class="date">2 Oct 2020 at 08:56</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>Rather than decide between adding getters/setters or providing direct access, I would advocate neither as the first step.</span> <span> - </span> <span class="display-name">Scott Shipp</span> <span> </span> <span class="date">2 Oct 2020 at 18:09</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>What can be private should be private, but what cannot be private should use getters instead of direct access.</span> <span> - </span> <span class="display-name">o.m.</span> <span> </span> <span class="date">3 Oct 2020 at 04:49</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Ah, the problem is Java syntax. Most modern languages (Java is more than 25 years old now) have setters &amp; getters generated by the compiler. There are ways to do the same in Java using annotations, e.g. with Lombok. However, sooner or later Java will either evolve radically (not a trivial change every few years) or people will abandon it for other languages, be it Kotlin, C# or others.</span> <span> - </span> <span class="display-name">Sulthan</span> <span> </span> <span class="date">5 Oct 2020 at 09:14</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Sulthan Java has a feature like that already. It's called records.</span> <span> - </span> <span class="display-name">Scott Shipp</span> <span> </span> <span class="date">6 Oct 2020 at 15:28</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@ScottShipp I know. The problem is that it should have supported that at least 5 years ago. The process is waaay too slow. I would be happy to see Java again as a language full of new features instead of small changes that other languages had several years earlier.</span> <span> - </span> <span class="display-name">Sulthan</span> <span> </span> <span class="date">6 Oct 2020 at 17:27</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>COME FROM</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Sep 2020 at 09:51</span>
     </div>
    </div>
    <div>
     <p>When you're learning a new language and you're not sure about programming style, it might be good idea to take a look at the core libraries of the language. They might not always be a perfect model, but they're most likely way better than most of the code you'll see elsewhere.</p>
     <p>Adopting a similar programming style will be beneficial. Your code will be easy to understand for anyone who is familiar with the language. If fields are not directly exposed in core libraries, then you could avoid exposing fields too <em>just to follow the convention</em>. Conventions are very important.</p>
     <p>Sticking to the style of important libraries might be beneficial even when you're experienced enough to form your own opinion and even when you'd personally prefer an alternative style. If really want to abandon conventions, you can always do it in a private hobby project.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>5</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Robert Bräutigam</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Sep 2020 at 09:47</span>
     </div>
    </div>
    <div>
     <p>The main difference between using <em>setters/getters/direct access</em> and <em>properly encapsulated objects</em>, is a design question not a syntactical one.</p>
     <p>The former ones are basically a holdover from our procedural past, that we can't seem to shake. It is much <em>easier</em> to imagine a set of instructions on some data that the CPU has to execute. This thinking results in data structures and algorithms. Therefore those who think this way will often <em>need</em> access to data and usually can't imagine how else they could write a program.</p>
     <p>Object-orientation is about decomposing a problem into individual <em>agents</em> (objects) that <em>do</em> stuff. Not just any (technical) stuff, but business stuff, something that fulfills some requirement that is important for users/business people. This is why it is hard to have examples, because the methods you put in an object are determined by your requirements, not the object itself. A <code>Book</code> doesn't automatically have <code>Pages</code> or even a <code>title</code>, only if there is a functionality that needs it. And this functionality needs to be <em>in the <code>Book</code></em>, therefore there will be no need to access those from the outside.</p>
     <p>From the above it follows, we only provide access to pure data (setter/getters/direct access) if we don't, or even can't know what the supported functionality should be. This happens on the "edges" of your code. For example you are writing an http-client, you'll (probably) have to provide the raw content to the caller, because you don't (can't) know how that will be used. <em>Inside</em> a software, like a web-application or similar this should never happen.</p>
     <p>I think it is awesome that you think about these things. And remember, most resources out there still didn't quite made the leap to object-orientation, so you'll have to use your own judgement, and later, you own experience.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>If I got you right, something like a <code>Book</code> class needs to contain <i>all</i> the functionality which is related to books. That does not make much sense to me. In any non-trivial program which deals with books, a <code>Book</code> will be only one component of many. <code>Pages</code> or even a <code>title</code> are properties of a book which can (and often should) be processed by other components. Cramming all functionality which is related to books into a <code>Book</code> class, in my experience, leads exactly to the kind of overcharged "OO" designs which failed frequently in reality.</span> <span> - </span> <span class="display-name">Doc Brown</span> <span> </span> <span class="date">1 Oct 2020 at 15:06</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I've never saw projects even <i>try</i> moving non-trivial functionality into "<code>Book</code>" objects, let alone go overboard with it as you describe. And I've been doing enterprise development since the late 90s. It's possible that you have more experience with such projects, I don't know. I think it is more likely that most OO concepts, as most FP concepts for that matter, are just so alien to the average procedural/imperative developer, that there is an understandable lack of imagination of how those would look like. That's not a critique, I'm honestly trying to change that, with articles and comments.</span> <span> - </span> <span class="display-name">Robert Bräutigam</span> <span> </span> <span class="date">1 Oct 2020 at 16:48</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Did I understand you correctly: in over 20 years, you have never seen classes growing so large that any maintenance and further development became painful, if not impossible?</span> <span> - </span> <span class="display-name">Doc Brown</span> <span> </span> <span class="date">1 Oct 2020 at 19:40</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>3</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Mad Scientist - on strike</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Sep 2020 at 10:37</span>
     </div>
    </div>
    <div>
     <p>I think you're combining two things here, using getters/setters and making a field public. There are essentially three options here:</p>
     <ul>
      <li>add a private field</li>
      <li>add a public field</li>
      <li>add a private field with getter/setter</li>
     </ul>
     <p>As a general rule fields should only be public if necessary, and you shouldn't expose any implementation details that the user of the class doesn't need to know by making fields public unnecessarily. Adding a getter/setter by definition also makes a field public, and some of your arguments are really about that part. But that is also independent of using a getter/setter, you have the same issues if you just make the field public.</p>
     <p>I'm assuming C# here as I'm not entirely sure about the details in modern Java in this regard. C# has automatically generated getters and setters, which does minimize the boilerplate you'd usually have for trivial getters and setters that simply set a private field. In this case you would generally prefer to use autogenerated getters/setters instead of a public field. It adds hardly any noise, and it gives you the option to change the implementation without changing the public interface of your class and potentially breaking code using it.</p>
     <p>In general you need to be careful to not do anything in getters and setters that a reasonable programmer would find surprising. Validation is fine, side effects that e.g. perform IO or affect other parts of your object are probably a very bad idea.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>2</td>
        <td><span>Note that both Java and C# support private on getters and setters. I think your description of having three options implies that accessibility is related to getter/setter, but they're actually orthogonal.</span> <span> - </span> <span class="display-name">Brian</span> <span> </span> <span class="date">30 Sep 2020 at 13:52</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>workerjoe</span>
     </div>
     <div>
      <span> Answered: </span> <span>30 Sep 2020 at 14:08</span>
     </div>
    </div>
    <div>
     <p>In addition to what has been said by others, I will add that there are two broad categories of uses I see for Java classes in my applications:</p>
     <ul>
      <li>classes that encapsulate program logic about a certain area of the program (like the objects you read about in your programming textbooks!)</li>
      <li>classes that exist only to hold data about an entity in the program</li>
     </ul>
     <p>The latter kind have names like Customer, or Product, or Item, are generally filled up with data by reading data out of a database and creating one instance for each row of the result, or are filled in by a user with a web form. The data, once entered, is rarely changed, and there's little to no logic within the class.</p>
     <p>For the first type, the classes that encapsulate program logic, generally your fields should be private and you shouldn't have getters and setters for the fields, except maybe for injecting dependencies or setting configuration options. This is real object-oriented code and you should take care to design a good public API.</p>
     <p>For the second type, these are <strong>dumb data structures</strong> and all you need to do is (1) define the fields and (2) use your IDE to automatically create getters and setters for all of them. (Typically the frameworks and libraries you employ will require getters/setters.) You will hardly ever touch these again, although occasionally it becomes handy to modify a getter or setter for example to do some string formatting or to change a data type. It is pointless to worry about applying object-oriented design principles or design patterns to these cases -- they aren't really what the philosophers of those fields considered to be "objects" anyway.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>@Walfrat Good point! I added a remark about that.</span> <span> - </span> <span class="display-name">workerjoe</span> <span> </span> <span class="date">1 Oct 2020 at 12:19</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>2</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Reg Edit</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Oct 2020 at 02:31</span>
     </div>
    </div>
    <div>
     <p>As others have pointed out, you are in places conflating <code>access control</code> (public, private...) with the question of whether to implement <code>getters and setters</code> (which, depending on the language, can themselves take access control modifiers). While these are of course related, it's important to be clear which you are focusing on at any point.</p>
     <p>However, between the lines of that discussion there are also other, more fundamental questions that need answering:</p>
     <blockquote>
      <p>What parts of your program would you actually use getters and setters on? The examples I’ve seen online use classes such as ‘Dog/Ball’ and ‘Person’ which really aren’t much use to me. I’m thinking you would use them if you had a class for ‘Accounts’ and a different class for ‘Settings’.. the settings class would need to access the Account’s user name if the username requested to change it.. right?</p>
     </blockquote>
     <p>No. Not necessarily, anyway, and I would say probably not. But the question of how to update the username is one you would first want to consider as part of your overall design, and in the context of your overall data model.</p>
     <p>For example, let's say there is a business requirement to maintain settings for our product (a website). These might be configuration settings (for administrators to set options controlling how the website behaves when users edit accounts) or they might be user settings (enabling website users to choose to view the site in a different language whenever they visit, or to choose a preferred navigation style).</p>
     <p>And let's say there is also a business requirement for both users and administrators to edit Account records, changing such things as email address, postal address, telephone number and username. Now, it could be that in your data model, the Account field values (email address, username...) are defined as "settings" in some global repository (cue Windows Registry designers!). Quite likely though, your data model defines the Account field values not as "settings" but as properties of the Account entity. And from here, the question would not be whether to implement a getter and setter for username. The question would be, "Given that we're using object orientation here, and given the relationship between the Account entity and the entities that need to interact with it, what interface should Account expose to support these interactions? Because here's the thing: the answer <em>might</em> be "make username public", but actually it might be "provide an UpdateUsername method (or even an UpdateAccount method) that takes as parameters both the updated value(s) and some additional information needed any time an account is updated."</p>
     <p>Like Dog and Ball, even Account doesn't lend itself well to examples that are universally right and wrong.</p>
     <p>In summary, focusing on getter and setters and questioning them as you have done is valuable—as are many of the points on this subject noted in other answers. But don't just think about whether to expose a field directly or via a getter/setter; think first about whether it should even <em>be</em> exposed. Encapsulation is key here: which entities should be responsible for implementing the business logic, and hence which entities should have the low-level knowledge that a certain business rule is met by updating a certain field? Username is pretty clear but in other cases the meaning of a field can be less clear, or may be subject to subtle or complex business logic. The caller's view should be abstracted to a higher level that doesn't assume knowledge of the low-level implementation details. In such cases, exposing a field—whichever way you do it—is not sufficient.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span> <span class="arrow"> <a href="#answer_11">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Captain Man</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Oct 2020 at 18:36</span>
     </div>
    </div>
    <div>
     <p>You mentioned the thing about making fields public then anyone can mess with your data -- that's true, but the missing thing is that a lot of times you don't want a setter, just a getter, and in some languages (like Java) there's not good ways to make fields public and immutable.</p>
     <pre class="lang-java prettyprint-override"><code>public class Foo {

  public int a; // Anyone can see this, but they can also *change* it.

  public final int b; // They can't edit this since it's final!

  public final List&lt;Integer&gt; intList; // Even though this is final it is still mutable.

  // But using a getter we can return a read-only copy of the list to accomplish this.
  public List&lt;Integer&gt; getIntList() {
    return Collections.unmodifiableList(intList);
  }
}
</code></pre>
     <p>Often times we think of getters and setters as simply returning the value as-is or setting the value as-is, and in many cases that's all it is. Sometimes you need more fine grained control though.</p>
     <p>Also it helps to let you change your implementation details. Say you have a method that returns the date as "YYYY-MM-DD".</p>
     <pre class="lang-java prettyprint-override"><code>public class Bar {
  public String year;
  public String month;
  public String day;

  public String getDateString() {
    return year + "-" + month + "-" + day;
  }
}
</code></pre>
     <p>But then you find out about <a href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html" rel="nofollow noreferrer"><code>LocalDate</code></a> class and thing it's a much simpler way to store it so you change your class to this.</p>
     <pre class="lang-java prettyprint-override"><code>public class Bar {
  public LocalDate date;

  public String getYear() {
    return getDateString().substring(0, 4);
  }

  public String getMonth() {
    return getDateString().substring(5, 7);
  }

  public String getDay() {
    return getDateString().substring(8, 10);
  }

  public String getDateString() {
    return date.toString();
  }
}
</code></pre>
     <p>This design is cleaner, and let's hypothetically say there's more methods that makes it even more useful for whatever reason. But oh no, you make this change and push the code and now one of your teammates is complaining about a compilation error. You had the fields as public before. Their code relied on it. Now you have to argue about if you need to keep the fields or if they have to change their code. But if you had not exposed the implementation details you would not need to worry. Everything that is public is essentially like a contract about how your code will work.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>"Even though this is final it is still mutable." That's a flat-out lie. What it points to is mutable though. Don't perpetuate the inability to navigate indirection.</span> <span> - </span> <span class="display-name">Deduplicator</span> <span> </span> <span class="date">1 Oct 2020 at 19:28</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Deduplicator that list is certainly mutable in that example. Am I misunderstanding you?</span> <span> - </span> <span class="display-name">Captain Man</span> <span> </span> <span class="date">1 Oct 2020 at 19:37</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Yes. You are saying despite being final, it is still mutable. But <code>intList</code> is most certainly not mutable. What it points to is, but that's a different affair. Thus, I bemoan your perpetuation of the inability to differentiate levels of indirection, a most fundamental and crucial ability for any aspiring programmer.</span> <span> - </span> <span class="display-name">Deduplicator</span> <span> </span> <span class="date">1 Oct 2020 at 20:55</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Deduplicator I get you're point, but I don't see the issue. When talking about non-primitive fields generally the terms "final" and "non-final" are used to say whether the field is mutable and the terms "mutable" and "immutable" are used to say whether the object behind the reference has mutable fields.</span> <span> - </span> <span class="display-name">Captain Man</span> <span> </span> <span class="date">1 Oct 2020 at 21:22</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>If that's the Java jargon, and you want to only talk in that group, that's fine. Other languages allow more levels directly, allow applying immutability beyond the outermost level, etc.</span> <span> - </span> <span class="display-name">Deduplicator</span> <span> </span> <span class="date">1 Oct 2020 at 21:50</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Deduplicator "and in some languages <b>(like Java)</b> there's not good ways to make fields public and immutable." -- I think this makes it clear I'm talking specifically about Java. But yes, this is the common jargon for Java.</span> <span> - </span> <span class="display-name">Captain Man</span> <span> </span> <span class="date">1 Oct 2020 at 21:59</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>You are making it clear that the example is in Java, but not that all your language before is to be interpreted as Java-jargon, instead of general programming speak. Actually, that is very surprising, and it makes all the difference.</span> <span> - </span> <span class="display-name">Deduplicator</span> <span> </span> <span class="date">1 Oct 2020 at 22:04</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_11"><span>Answer 11</span> <span class="arrow"> <a href="#answer_10">↑</a> </span> <span class="arrow"> <a href="#answer_12">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>jmoreno</span>
     </div>
     <div>
      <span> Answered: </span> <span>3 Oct 2020 at 00:34</span>
     </div>
    </div>
    <div>
     <blockquote>
      <p>I still don’t fully understand getters &amp; setters I’m still really new to learning to program. Just learning the syntax for a few programming languages at the moment.</p>
     </blockquote>
     <p>Getters/setters/fields/function are all implementation details around getting and changing state. Unless you are designing or working on a public api, I would recommend that you simply follow the practice of whatever project you are working on or the guidance of teacher/co-workers.</p>
     <p>Part of the reasons to use them or not are implementation details of the language, tools and libraries of the project. If you need to deserialize a string to a class and the deserialization library only uses properties, well, the class needs to have properties.</p>
     <p>So, there’s no one size fits all answer, and you don’t have a strong opinion, use what those around you are using, and be willing to do so on whatever project you are working on, until you do develop a strong opinion.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_12"><span>Answer 12</span> <span class="arrow"> <a href="#answer_11">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>-1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>null</span>
     </div>
     <div>
      <span> Answered: </span> <span>1 Oct 2020 at 21:04</span>
     </div>
    </div>
    <div>
     <p>In C#/WPF, if you want to use data binding, you have to use properties. It doesn't work with fields.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>