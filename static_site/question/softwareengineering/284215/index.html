<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>How do you avoid getters and setters?</title>
  <link rel="stylesheet" type="text/css" href="/css/base.css">
  <script type="text/x-mathjax-config">
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
            tex2jax: { inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
            TeX: {
            extensions: ["begingroup.js"],
            noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
            Macros: { href: "{}" }
            },
            messageStyle: "none",
            styles: { ".MathJax_Display, .MathJax_Preview, .MathJax_Preview > *": { "background": "inherit" } },
            SEEditor: "mathjaxEditing"
            });
        </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML-full"></script>
 </head>
 <body>
  <div class="question">
   <a href="/questions">All Questions</a>
   <h2>How do you avoid getters and setters?</h2>
   <div class="container-metadata">
    <div>
     <span>Score: </span> <span>90</span>
    </div>
    <div>
     <span>Asker: </span> <span>IntelliData</span>
    </div>
    <div>
     <span>Asked: </span> <span>18 May 2015 at 14:54</span>
    </div>
    <div>
     <a href="https://softwareengineering.stackexchange.com/questions/284215/how-do-you-avoid-getters-and-setters">source</a>
    </div>
   </div>
   <div>
    <p>I'm having something of a hard time with designing classes in an oo way. I've read that objects expose their behavior, not their data; therefore, rather than using getter/setters to modify data, the methods of a given class should be "verbs" or actions operating on the object. For example, in an 'Account' object, we would have the methods <code>Withdraw()</code> and <code>Deposit()</code> rather than <code>setAmount()</code> etc. See: <a href="http://www.javaworld.com/article/2073723/core-java/why-getter-and-setter-methods-are-evil.html" rel="noreferrer">Why getter and setter methods are evil</a>.</p>
    <p>So for example, given a Customer class that keeps alot of information about the customer, e.g. Name, DOB, Tel, Address etc., how would one avoid getter/setters for getting and setting all those attributes? What 'Behavior' type method can one write to populate all that data?</p>
   </div>
   <div class="tags">
    <span class="tag">java</span><span class="tag">object-oriented</span>
   </div>
   <hr>
   <div class="comment">
    <table>
     <tbody>
      <tr>
       <td>3</td>
       <td><span>possible duplicate of <a href="http://programmers.stackexchange.com/questions/30297/is-there-any-reason-to-use-plain-old-data-classes">Is there any reason to use "plain old data" classes?</a></span> <span> - </span> <span class="display-name">gnat</span> <span> </span> <span class="date">18 May 2015 at 15:29</span></td>
      </tr>
      <tr>
       <td>3</td>
       <td><span>see also: <a href="http://programmers.stackexchange.com/q/21802/31260">When are Getters and Setters Justified</a></span> <span> - </span> <span class="display-name">gnat</span> <span> </span> <span class="date">18 May 2015 at 15:29</span></td>
      </tr>
      <tr>
       <td>9</td>
       <td><span>I would point out that if you have to deal with <a href="http://www.oracle.com/technetwork/articles/javaee/spec-136004.html" rel="nofollow noreferrer">Java Beans specification</a>, you <i>will</i> be having getters and setters. Lots of things use Java Beans (Expression Language in jsps) and trying to avoid such will likely be... challenging.</span> <span> - </span> <span class="display-name">user40980</span> <span> </span> <span class="date">18 May 2015 at 16:32</span></td>
      </tr>
      <tr>
       <td>5</td>
       <td><span>...and, from the opposite perspective from MichaelT: if you're not using the JavaBeans spec (and I personally think you should avoid it unless you're using your object in a context where it's necessary), then there's no need for the "get" wart on getters, especially for properties that don't have any corresponding setter. I think a method called <code>name()</code> on <code>Customer</code> is as clear, or clearer, than a method called <code>getName()</code>.</span> <span> - </span> <span class="display-name">Daniel Pryden</span> <span> </span> <span class="date">18 May 2015 at 21:05</span></td>
      </tr>
      <tr>
       <td>2</td>
       <td><span>@Daniel Pryden: name() can mean both to set or to get?...</span> <span> - </span> <span class="display-name">IntelliData</span> <span> </span> <span class="date">19 May 2015 at 16:51</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>Why do you assume that article is nothing but 100% BS?</span> <span> - </span> <span class="display-name">Andy</span> <span> </span> <span class="date">19 May 2015 at 16:58</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>@IntelliData: As a method with no arguments, it cannot be a setter. The pattern of using methods named after the properties exists throughout the Java standard library (<code>Collection.size()</code> for example) and is quite common in other languages as well (I see it a lot in C++ code, for example). I've seen people make <code>name()</code> the getter and <code>name(new_name)</code> the setter, although I'd shy away from that in favor of having an explicit <code>setName()</code>, or better yet omitting setters entirely. IMO, value objects should always be immutable unless there's a strong need for them to be otherwise.</span> <span> - </span> <span class="display-name">Daniel Pryden</span> <span> </span> <span class="date">19 May 2015 at 18:16</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>I wonder how much of this entire conversation would be obsolete if Java had a hash literal syntax with dot property access for plain jane data structures.</span> <span> - </span> <span class="display-name">Jared Smith</span> <span> </span> <span class="date">20 May 2015 at 12:57</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@DanielPryden: Methods are typically named using <i>verbs.</i></span> <span> - </span> <span class="display-name">Robert Harvey</span> <span> </span> <span class="date">20 May 2015 at 13:03</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@DanielPryden: How can a Customer be an immutable object? Don't peoples addresses &amp; phone numbers change?</span> <span> - </span> <span class="display-name">IntelliData</span> <span> </span> <span class="date">20 May 2015 at 16:33</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@RobertHarvey: They are indeed, and that's a good way to articulate why I don't like the <code>name(new_name)</code> form. I don't believe that naming methods after verbs is a hard <i>rule</i> though, so I have no objection to naming a (non-state-changing, obvious-from-context) method after a noun. I realize that not everyone concurs with this opinion, though.</span> <span> - </span> <span class="display-name">Daniel Pryden</span> <span> </span> <span class="date">20 May 2015 at 18:11</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@DanielPryden: <code>getSomething()</code> is unambiguous, and enterprise Java is already exceptionally wordy anyway.</span> <span> - </span> <span class="display-name">Robert Harvey</span> <span> </span> <span class="date">20 May 2015 at 18:14</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@IntelliData: It depends on what you're modeling <code>Customer</code> to mean. If you model <code>Customer</code> to mean "the knowledge I have about a customer at a point in time", then it can freely be immutable; when you have more knowledge you just create a different instance. In fact that can be a much easier way to model data if you have both local (in-memory) and remote (database) structures: the <code>Customer</code> object in memory will by necessity not always be identical to the <code>Customer</code> record in the database, so being able to represent them differently (and being to compare between them) can be very useful.</span> <span> - </span> <span class="display-name">Daniel Pryden</span> <span> </span> <span class="date">20 May 2015 at 18:15</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@RobertHarvey: Are we talking exclusively about enterprise Java here, though? Like I said in my comment above, I personally think you should avoid specs like JavaBeans if you don't need them -- but if you do need them, then yeah, ignore my advice. :-)</span> <span> - </span> <span class="display-name">Daniel Pryden</span> <span> </span> <span class="date">20 May 2015 at 18:17</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@DanielPryden the conventions that are idiomatic to a language are useful even if you are not doing "enterprise development"...</span> <span> - </span> <span class="display-name">Roland Tepp</span> <span> </span> <span class="date">21 May 2015 at 13:20</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@RolandTepp: You're saying that naming a method <code>size()</code> or <code>ordinal()</code> rather than <code>getSize()</code> or <code>getOrdinal()</code> is not idiomatic? Better change all collection types in the standard library and the definition of enums in the language spec then, because those don't use the "get" prefix. There are plenty of other examples I can find. Basically: I reject the premise that the "get" prefix is an idiom of the <i>language</i>, only of some libraries of the language.</span> <span> - </span> <span class="display-name">Daniel Pryden</span> <span> </span> <span class="date">21 May 2015 at 15:27</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>Note that the article you mention was written in 2003 and contains (among more useful stuff) this pearl: " a metadata feature will be incorporated into Java 1.5 (due in mid 2004). [...] You'll be able to use something like: private @property int property;" which clearly didn't happen. There's <a href="http://projectlombok.org/" rel="nofollow noreferrer">project Lombok</a> but it does bad things to your bytecode so I wouldn't recommend it. Better use your IDE's code generation feature.</span> <span> - </span> <span class="display-name">Michał Kosmulski</span> <span> </span> <span class="date">23 May 2015 at 08:07</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@DanielPryden I am not saying any such thing. What I was trying to say is that labeling certain idiomatic patterns as not useful just because you don't agree with them is pure hubris. Code isn't only meant for machines to execute. It's also useful to remember the people (including you five years from now) who read it later and need to understand it. Human brain is great with recognizing patterns. Naming your getters and setters in idiomatic ways helps people to recognize them for what they are.</span> <span> - </span> <span class="display-name">Roland Tepp</span> <span> </span> <span class="date">23 May 2015 at 13:49</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@RolandTepp: I don't really want to derail the comments on this question. But my point was that omitting the "get" prefix is <b>also a valid idiom</b> in Java. Since there are multiple possible idioms which are both in wide use (see my previous comment, which you say you do not disagree with), I don't see how adopting one idiom over another -- in contexts where you have the choice -- is "pure hubris" or results in reduced code readability. You are free to disagree, and I don't begrudge you your opinion. Perhaps you should open a separate question about the naming convention?</span> <span> - </span> <span class="display-name">Daniel Pryden</span> <span> </span> <span class="date">23 May 2015 at 23:02</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@DanielPryden, true, omitting <code>get</code> prefix is a valid pattern in Java, but if you look at how or when this is used, it usually is reserved for either computed, derived or transformed values, not so much for object attributes/properties of an object. In any case, bringing it back to the original topic, it does not matter if you put a <code>get</code> prefix in front of it or not, if it's only function is to <i>get a value of a private field</i>, it is a getter. Disguising it by omitting the <code>get</code> prefix is only going to confuse people.</span> <span> - </span> <span class="display-name">Roland Tepp</span> <span> </span> <span class="date">26 May 2015 at 06:51</span></td>
      </tr>
      <tr>
       <td>1</td>
       <td><span>@IntelliData Is there anything specific that you think the existing answers are lacking? Are you going to be satisfied with answers of the form "You probably want DTOs/property bags in x and y situation, but otherwise you can avoid getters and setters by...", or do you really want to be puritanical about avoiding them altogether?</span> <span> - </span> <span class="display-name">Ben Aaronson</span> <span> </span> <span class="date">26 May 2015 at 15:22</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@Ben Aaronson: Well, the question was asked assuming the OO puritan point of view, which says that public getters/setters are almost as bad as accessing field variables, and do not implement encapsulation. According to my understanding of OOP, DTO's are discouraged as well, at least as regular entities. Most answers were attempting to justify getters/setters fir this situation, or why we might need a DTO, which is not OO pure at all...</span> <span> - </span> <span class="display-name">IntelliData</span> <span> </span> <span class="date">27 May 2015 at 16:21</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>@IntelliData DTOs are discouraged in many situations (like as domain objects), but they're very useful for transferring data across boundaries, (esp. using serialization) and this is a widely accepted practice. I don't think you're going to get any good answer that says "there are no situations where DTOs are appropriate!" simply because that isn't true. What you might get is an answer that defines a very narrow category of situations where DTOs are appropriate, and gives advice on how to more or less eliminate getters/setters elsewhere. Would that suffice?</span> <span> - </span> <span class="display-name">Ben Aaronson</span> <span> </span> <span class="date">27 May 2015 at 16:26</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>That is exactly what I meant.. Primarily with domain objects, how would I eliminate getters/setters, as in the Customer example which i gave. Whew! Somebody finally understood my question...</span> <span> - </span> <span class="display-name">IntelliData</span> <span> </span> <span class="date">27 May 2015 at 21:12</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>The easiest way to get around getters and setters is to access the data member directly. QED.</span> <span> - </span> <span class="display-name">Thomas Eding</span> <span> </span> <span class="date">28 May 2015 at 14:55</span></td>
      </tr>
      <tr>
       <td></td>
       <td><span>As the question is tagged as a Java question, please note that Java conventions require you to start your methods' names with a lower case.</span> <span> - </span> <span class="display-name">mgoeminne</span> <span> </span> <span class="date">30 May 2015 at 08:04</span></td>
      </tr>
     </tbody>
    </table>
   </div>
   <br>
   <div>
    <h2 id="answer_1"><span>Answer 1</span> <span class="arrow"> <a href="#answer_2">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>77</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Robert Harvey</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 May 2015 at 15:02</span>
     </div>
    </div>
    <div>
     <p>The simplest way to avoid setters is to <strong>hand the values to the constructor method when you <code>new</code> up the object.</strong> This is also the usual pattern when you want to make an object <em>immutable.</em> That said, things are not always that clear in the real world.</p>
     <p>It is true that methods should be about behavior. However, some objects, like Customer, exist primarily to <em>hold information.</em> Those are the kinds of objects that benefit the most from getters and setters; were there no need at all for such methods, we would simply eliminate them altogether.</p>
     <p><strong>Further Reading</strong><br><a href="https://softwareengineering.stackexchange.com/questions/21802/when-are-getters-and-setters-justified">When are Getters and Setters Justified</a></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>3</td>
        <td><span>so why all the hype about 'Getter/Setters' are evil?</span> <span> - </span> <span class="display-name">IntelliData</span> <span> </span> <span class="date">18 May 2015 at 15:03</span></td>
       </tr>
       <tr>
        <td>47</td>
        <td><span>Just the usual pontification by software developers who should know better. For the article you linked, the author is using the phrase "getters and setters are evil" to get your attention, but that doesn't mean the statement is categorically true.</span> <span> - </span> <span class="display-name">Robert Harvey</span> <span> </span> <span class="date">18 May 2015 at 15:04</span></td>
       </tr>
       <tr>
        <td>13</td>
        <td><span>@IntelliData some people will tell you that java itself is evil.</span> <span> - </span> <span class="display-name">null</span> <span> </span> <span class="date">18 May 2015 at 15:09</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I've heard <code>null</code> is evil.</span> <span> - </span> <span class="display-name">MetaFight</span> <span> </span> <span class="date">18 May 2015 at 16:14</span></td>
       </tr>
       <tr>
        <td>19</td>
        <td><span>@MetaFight <code>setEvil(null);</code></span> <span> - </span> <span class="display-name">user40980</span> <span> </span> <span class="date">18 May 2015 at 16:26</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>Certainly eval is Evil Incarnate. Or a near cousin.</span> <span> - </span> <span class="display-name">bishop</span> <span> </span> <span class="date">18 May 2015 at 16:47</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>If <code>Customer</code> primarily holds information, it can be interesting to have a <code>Property</code> type and a single method <code>Customer.get : Property -&gt; Value</code>, solving the equation <code>algorithms = data + code</code> by putting more on the <code>data</code> side and less on the <code>code</code> side.</span> <span> - </span> <span class="display-name">Michaël Le Barbier</span> <span> </span> <span class="date">18 May 2015 at 19:09</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@IntelliData It's people who spend all their time behind ivory towers and textbooks, instead of putting good, clean code together in the real world. The rest of us understand the need to group related variables together into meaningful, yet simple, aggregates from time to time. It makes code much more maintainable than letting too many random variables float around as members in a much bigger class, just to avoid getters and setters. It also helps clean up method signatures.</span> <span> - </span> <span class="display-name">Panzercrisis</span> <span> </span> <span class="date">18 May 2015 at 20:38</span></td>
       </tr>
       <tr>
        <td>3</td>
        <td><span>@IntelliData It used to be the case that direct access to variables was considered evil and that all access/mutation operations should go through get/set methods. Now it's swinging the other way. I think calling getters and setters "evil" is a tongue-in-cheek reference to former conventional wisdom.</span> <span> - </span> <span class="display-name">Rag</span> <span> </span> <span class="date">18 May 2015 at 21:25</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>... or just public final fields. Right?</span> <span> - </span> <span class="display-name">user253751</span> <span> </span> <span class="date">19 May 2015 at 03:24</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Data Objects are evil in a devout OOP sense, in that they separate data from behavior. But, alas, sometimes they a necessary evil. Use them when needed, but don't turn all your behavior objects into Data Objects or JavaBeans by automatically adding getters and setters for everything.</span> <span> - </span> <span class="display-name">user949300</span> <span> </span> <span class="date">19 May 2015 at 17:16</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@bishop <code>eval</code> can be misused, but it can be very useful for e.g. writing a REPL</span> <span> - </span> <span class="display-name">Max Nanasy</span> <span> </span> <span class="date">19 May 2015 at 17:36</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@BrianGordon I understood the issue is that blindly following a "all variables must be accessed via a method" means people replace <code>myobj.var</code> with <code>myobj.getvar()</code> - which is fundamentally no different and why brain-dead getters and setters should be considered evil. Getting rid of these and replacing them with get/set methods that make <i>sense in context of the object and not the internal variables</i> is how accessors should be considered.</span> <span> - </span> <span class="display-name">gbjbaanb</span> <span> </span> <span class="date">20 May 2015 at 09:08</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@IntelliData That would make an interesting question of its own (if it doesn't already exist)</span> <span> - </span> <span class="display-name">Ben Aaronson</span> <span> </span> <span class="date">20 May 2015 at 16:48</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>And then to allow you to make "modifications" while maintaining the immutability, you could have "setters" that actually return a new object that the desired property. For example, Scala's case classes have a special <code>copy</code> method that allows any number of fields to be set in this manner. So you could do something like <code>employee.copy(phone = "555-555-5555", email = "me@example.com")</code> to get a new object with the desired values.</span> <span> - </span> <span class="display-name">Kat</span> <span> </span> <span class="date">21 May 2015 at 15:24</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Panzercrisis: When we say 'Avoid getters/setters' we don't mean access the field variables directly; we mean access them some other way.</span> <span> - </span> <span class="display-name">IntelliData</span> <span> </span> <span class="date">21 May 2015 at 16:06</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Mike:The builder pattern in java is probably the closest thing to smalltalk's copy.</span> <span> - </span> <span class="display-name">IntelliData</span> <span> </span> <span class="date">21 May 2015 at 16:06</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@IntelliData I'm not talking about exposing the variables.</span> <span> - </span> <span class="display-name">Panzercrisis</span> <span> </span> <span class="date">22 May 2015 at 03:17</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_2"><span>Answer 2</span> <span class="arrow"> <a href="#answer_1">↑</a> </span> <span class="arrow"> <a href="#answer_3">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>61</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Ben Aaronson</span>
     </div>
     <div>
      <span> Answered: </span> <span>28 May 2015 at 13:40</span>
     </div>
    </div>
    <div>
     <p>As stated in quite a few answers and comments, DTOs <em>are</em> appropriate and useful in some situations, especially in transferring data across boundaries (e.g. serializing to JSON to send through a web service). For the rest of this answer, I'll more or less ignore that and talk about domain classes, and how they can be designed to minimize (if not eliminate) getters and setters, and still be useful in a large project. I also won't talk about <em>why</em> remove getters or setters, or <em>when</em> to do so, because those are questions of their own.</p>
     <p>As an example, imagine that your project is a board game like Chess or Battleship. You might have various ways of representing this in a presentation layer (console app, web service, GUI,etc.), but you also have a core domain. One class you might have is <code>Coordinate</code>, representing a position on the board. The "evil" way to write it would be:</p>
     <pre><code>public class Coordinate
{
    public int X {get; set;}
    public int Y {get; set;}
}
</code></pre>
     <p>(I'm going to be writing code examples in C# rather than Java, for brevity and because I'm more familiar with it. Hopefully that's not a problem. The concepts are the same and the translation should be simple.)</p>
     <h2>Removing Setters: Immutability</h2>
     <p>While public getters and setters are both potentially problematic, setters are the far more "evil" of the two. They're also usually the easier to eliminate. The process is a simple one- set the value from within the constructor. Any methods which previously mutated the object should instead return a new result. So:</p>
     <pre><code>public class Coordinate
{
    public int X {get; private set;}
    public int Y {get; private set;}

    public Coordinate(int x, int y)
    {
        X = x;
        Y = y;
    }
}
</code></pre>
     <p>Note that this doesn't protect against other methods in the class mutating X and Y. To be more strictly immutable, you could use <code>readonly</code> (<code>final</code> in Java). But either way- whether you make your properties truly immutable or just prevent direct public mutation through setters- it does the trick of removing your public setters. In the vast majority of situations, this works just fine.</p>
     <h2>Removing Getters, Part 1: Designing for Behavior</h2>
     <p>The above is all well and good for setters, but in terms of getters, we actually shot ourselves in the foot before even starting. Our process was to think of what a coordinate is- the <em>data</em> it represents- and create a class around that. Instead, we should have started with what <em>behavior</em> we need from a coordinate. This process, by the way, is aided by TDD, where we only extract classes like this once we have a need for them, so we start with the desired behavior and work from there.</p>
     <p>So let's say that the first place you found yourself needing a <code>Coordinate</code> was for collision detection: you wanted to check if two pieces occupy the same space on the board. Here's the "evil" way (constructors omitted for brevity):</p>
     <pre><code>public class Piece
{
    public Coordinate Position {get; private set;}
}

public class Coordinate
{
    public int X {get; private set;}
    public int Y {get; private set;}
}

    //...And then, inside some class
    public bool DoPiecesCollide(Piece one, Piece two)
    {
        return one.X == two.X &amp;&amp; one.Y == two.Y;
    }
</code></pre>
     <p>And here's the good way:</p>
     <pre><code>public class Piece
{
    private Coordinate _position;
    public bool CollidesWith(Piece other)
    {
        return _position.Equals(other._position);
    }
}

public class Coordinate
{
    private readonly int _x;
    private readonly int _y;
    public bool Equals(Coordinate other)
    {
        return _x == other._x &amp;&amp; _y == other._y;
    }
}
</code></pre>
     <p>(<code>IEquatable</code> implementation abbreviated for simplicity). By designing for behavior rather than modelling data, we've managed to remove our getters.</p>
     <p>Note this is also relevant to your example. You may be using an ORM, or display customer information on a website or something, in which case some kind of <code>Customer</code> DTO would probably make sense. But just because your system includes customers and they are represented in the data model does not automatically mean you should have a <code>Customer</code> class in your domain. Maybe as you design for behavior, one will emerge, but if you want to avoid getters, don't create one pre-emptively.</p>
     <h2>Removing Getters, Part 2: External Behaviour</h2>
     <p>So the above is a good start, but sooner or later you will probably run into a situation where you have behavior which is associated with a class, which in some way depends on the class's state, but which doesn't belong <em>on</em> the class. This sort of behavior is what typically lives in the <strong>service layer</strong> of your application.</p>
     <p>Taking our <code>Coordinate</code> example, eventually you'll want to represent your game to the user, and that might mean drawing to the screen. You might, for example, have a UI project which uses <code>Vector2</code> to represent a point on the screen. But it would be inappropriate for the <code>Coordinate</code> class to take charge of converting from a coordinate to a point on the screen- that would be bringing all sorts of presentation concerns into your core domain. Unfortunately this type of situation is inherent in OO design.</p>
     <p><strong>The first option</strong>, which is very commonly chosen, is just expose the damn getters and say to hell with it. This has the advantage of simplicity. But since we're talking about avoiding getters, let's say for argument's sake we reject this one and see what other options there are.</p>
     <p><strong>A second option</strong> is to add some kind of <code>.ToDTO()</code> method on your class. This- or similar- may well be needed anyway, for example when you want to save the game you need to capture pretty much all of your state. But the difference between doing this for your services and just accessing the getter directly is more or less aesthetic. It still has just as much "evil" to it.</p>
     <p><strong>A third option</strong>- which I've seen advocated by <a href="http://codinghelmet.com/" rel="noreferrer">Zoran Horvat</a> in a couple of Pluralsight videos- is to use a modified version of the visitor pattern. This is a pretty unusual use and variation of the pattern and I think people's mileage will vary massively on whether it's adding complexity for no real gain or whether it's a nice compromise for the situation. The idea is essentially to use the standard visitor pattern, but have the <code>Visit</code> methods take the state they need as parameters, instead of the class they're visiting. Examples can be found <a href="http://codinghelmet.com/?path=howto/visitor-pattern-encapsulation" rel="noreferrer">here</a>.</p>
     <p>For our problem, a solution using this pattern would be:</p>
     <pre><code>public class Coordinate
{
    private readonly int _x;
    private readonly int _y;

    public T Transform&lt;T&gt;(IPositionTransformer&lt;T&gt; transformer)
    {
        return transformer.Transform(_x,_y);
    }
}

public interface IPositionTransformer&lt;T&gt;
{
    T Transform(int x, int y);
}

//This one lives in the presentation layer
public class CoordinateToVectorTransformer : IPositionTransformer&lt;Vector2&gt;
{
    private readonly float _tileWidth;
    private readonly float _tileHeight;
    private readonly Vector2 _topLeft;

    Vector2 Transform(int x, int y)
    {
        return _topLeft + new Vector2(_tileWidth*x + _tileHeight*y);
    }
}
</code></pre>
     <p>As you can probably tell, <code>_x</code> and <code>_y</code> aren't <em>really</em> encapsulated any more. We could extract them by creating an <code>IPositionTransformer&lt;Tuple&lt;int,int&gt;&gt;</code> which just returns them directly. Depending on taste, you may feel this makes the entire exercise pointless.</p>
     <p>However, with public getters, it's very easy to do things the wrong way, just pulling data out directly and using it in violation of <a href="https://pragprog.com/articles/tell-dont-ask" rel="noreferrer">Tell, Don't Ask</a>. Whereas using this pattern it's actually <em>simpler</em> to do it the right way: when you want to create behaviour, you'll automatically start by creating a type associated with it. Violations of TDA will be very obviously smelly and probably require working around a simpler, better solution. In practice, these points make it much easier to do it the right, OO, way than the "evil" way that getters encourage.</p>
     <p><strong>Finally</strong>, even if it isn't initially obvious, there may in fact be ways to expose <em>enough</em> of what you need as behavior to avoid needing to expose state. For example, using our previous version of <code>Coordinate</code> whose only public member is <code>Equals()</code> (in practice it would need a full <code>IEquatable</code> implementation), you could write the following class in your presentation layer:</p>
     <pre><code>public class CoordinateToVectorTransformer
{
    private Dictionary&lt;Coordinate,Vector2&gt; _coordinatePositions;

    public CoordinateToVectorTransformer(int boardWidth, int boardHeight)
    {
        for(int x=0; x&lt;boardWidth; x++)
        {
            for(int y=0; y&lt;boardWidth; y++)
            {
                _coordinatePositions[new Coordinate(x,y)] = GetPosition(x,y);
            }
        }
    }

    private static Vector2 GetPosition(int x, int y)
    {
        //Some implementation goes here...
    }

    public Vector2 Transform(Coordinate coordinate)
    {
        return _coordinatePositions[coordinate];
    }
}
</code></pre>
     <p>It turns out, perhaps surprisingly, that all the behavior we <em>really</em> needed from a coordinate to achieve our goal was equality checking! Of course, this solution is tailored to this problem, and makes assumptions about acceptable memory usage/performance. It's just an example that fits this particular problem domain, rather than a blueprint for a general solution.</p>
     <p>And again, opinions will vary on whether in practice this is needless complexity. In some cases, no such solution like this might exist, or it might be prohibitively weird or complex, in which case you can revert to the above three.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>Beautifully answered! I would like to accept, but first some comments:1. I do think the toDTO() is great, bcuz ur not accessing the get/set, which allows u to change the fields given to DTO w/o breaking existing code. 2. Say Customer has enough behaviour to justify making it an entity, how would u access props to modify them, e.g. address/tel change etc.</span> <span> - </span> <span class="display-name">IntelliData</span> <span> </span> <span class="date">28 May 2015 at 17:02</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@IntelliData 1. When you say "change the fields", you mean change the class definition or mutate the data? The latter can just be avoided by removing public setters but leaving the getters, so the dto aspect is irrelevant. The former isn't really the (whole) reason that public getters are "evil". See <a href="http://programmers.stackexchange.com/questions/157526/explanation-on-how-tell-dont-ask-is-considered-good-oo" title="explanation on how tell dont ask is considered good oo">programmers.stackexchange.com/questions/157526/…</a> for example.</span> <span> - </span> <span class="display-name">Ben Aaronson</span> <span> </span> <span class="date">28 May 2015 at 17:58</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@IntelliData 2. This is difficult to answer without knowing the behaviour. But probably, the answer is: you wouldn't. What behaviour could a <code>Customer</code> class have that requires being able to mutate its telephone number? Perhaps the customer's telephone number changes and I need to persist that change in the database, but none of that is the responsibility of a behaviour-providing domain object. That's a data-access concern, and would probably be handled with a DTO and, say, a repository.</span> <span> - </span> <span class="display-name">Ben Aaronson</span> <span> </span> <span class="date">28 May 2015 at 18:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@IntelliData Keeping the <code>Customer</code> domain object's data relatively fresh (in sync with the db) is a matter of managing its lifecycle, which is also not its own responsibility, and would again probably end up living in a repository or a factory or an IOC container or whatever instantiates <code>Customer</code>s.</span> <span> - </span> <span class="display-name">Ben Aaronson</span> <span> </span> <span class="date">28 May 2015 at 18:03</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I mean change class definition; even exposing getters only can be a problem: say I have several functions calling getDTO() on the object, I can always change the fields being exposed via getDTO() w/o breaking the code; however, if I do getProperty(), then if I remove the property later on I will be breaking the code in many places.</span> <span> - </span> <span class="display-name">IntelliData</span> <span> </span> <span class="date">28 May 2015 at 18:20</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@IntelliData Yeah I understand. I agree <code>toDTO</code> it may mitigate that, but as I mentioned in the comment, there are other problems (violation of "Tell, Don't Ask"), which it does not.</span> <span> - </span> <span class="display-name">Ben Aaronson</span> <span> </span> <span class="date">28 May 2015 at 18:25</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>1. 'Tell, Don't Ask', good point; however, if I say provideDTO(), is it in effect 'Tell' even though it returns something? (Yeah, I know it's only a semantical difference.) 2. If a behaviour providing Customer also has data, whose responsibility is it to change the data if necessary?</span> <span> - </span> <span class="display-name">IntelliData</span> <span> </span> <span class="date">28 May 2015 at 18:37</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>In general, would u say that 'Tell Don't Ask' means never return data? How is that possible?</span> <span> - </span> <span class="display-name">IntelliData</span> <span> </span> <span class="date">28 May 2015 at 18:40</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Let us <a href="http://chat.stackexchange.com/rooms/24226/discussion-between-intellidata-and-ben-aaronson">continue this discussion in chat</a>.</span> <span> - </span> <span class="display-name">IntelliData</span> <span> </span> <span class="date">28 May 2015 at 18:55</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>I <i>really</i> like the <i>Design for Behavior</i> concept. This informs the underlying "data structure" and helps avoid the all too common anemic, hard-to-use classes. plus one.</span> <span> - </span> <span class="display-name">radarbob</span> <span> </span> <span class="date">3 Jun 2015 at 15:38</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>1_ Where does that "IEquatable" (which you say you've abbreviated in your answer) belong to? May I know where you wanted to use this interface? 2_ Also about this line: "<code>return _position.Equals(other._position);</code>", would this be possible at all? It's accessing a private field of another object(although it's of the same class, it doesn't make a difference, private field cannot be read from an object).</span> <span> - </span> <span class="display-name">aderchox</span> <span> </span> <span class="date">6 Sep 2021 at 04:02</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I somehow like the <code>toDTO()</code> - I'd probably call it <code>transfer()</code> - approach for use cases where you need to access a lot of fields of domain entities in order to make them cross boundaries e.g. in a HTTP API response. It's much better than accessing all the individual fields through getters and putting the data that way into the response, because a <code>transfer()</code> method is expressing the purpose very specifically and prevents careless misuse of the countless would-be-added getters on the domain entities. It's easy to spot if some yokel is abusing that method.</span> <span> - </span> <span class="display-name">Eugene</span> <span> </span> <span class="date">28 Nov 2021 at 02:12</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>^-- After thinking some more about it I tend to belive CQRS is the correct solution to the problem mentioned in my prev comment</span> <span> - </span> <span class="display-name">Eugene</span> <span> </span> <span class="date">28 Nov 2021 at 23:05</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_3"><span>Answer 3</span> <span class="arrow"> <a href="#answer_2">↑</a> </span> <span class="arrow"> <a href="#answer_4">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>60</span>
     </div>
     <div>
      <span>Answerer: </span> <span>JacquesB</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 May 2015 at 15:01</span>
     </div>
    </div>
    <div>
     <p>It is perfectly fine to have an object which exposes data rather than behavior. We just call it a "data object". The pattern exists under names like Data Transfer Object or Value Object. If the purpose of the object is to hold data, then getters and setters are valid to access the data.</p>
     <p>So <strong>why</strong> would someone say "getter and setter methods are evil"? You will see this a lot - someone takes a guideline which is perfectly valid in a specific context and then remove the context in order to get a more hard-hitting headline. For example "<a href="http://en.wikipedia.org/wiki/Composition_over_inheritance">favor composition over inheritance</a>" is a fine principle, but soon enough someone is going to remove the context and write "<a href="http://www.javaworld.com/article/2073649/core-java/why-extends-is-evil.html">Why extends is evil</a>" (hey, same author, what a coincidence!) or "<a href="http://blog.berniesumption.com/software/inheritance-is-evil-and-must-be-destroyed/">inheritance is evil and must be destroyed</a>".</p>
     <p>If you look at the content of the article it actually have some valid points, it just stretches the point to make a click-baity headline. For example, the article states that implementation details should not be exposed. This is the principles of encapsulation and data hiding which are fundamental in OO. However, a getter method does not by definition expose implementation details. In the case of a <strong>Customer</strong> data object, the properties of <strong>Name</strong>, <strong>Address</strong> etc. are not implementation details but rather the whole purpose of the object and should be part of the public interface.</p>
     <p>Read the <a href="http://www.javaworld.com/article/2072302/core-java/more-on-getters-and-setters.html">continuation</a> of the article you link to, to see how he suggest actually setting properties like 'name' and 'salary' on a 'Employee'-object without the use of the evil setters. Turns out he uses a pattern with an 'Exporter' which is populated with methods called <strong>add</strong>Name, <strong>add</strong>Salary which in turn sets fields of the same name... So in the end he ends up using exactly the setter pattern, just with a different naming convention.</p>
     <p>This is like thinking you avoid the pitfalls of singletons by renaming them therecanbeonlyonethings while keeping the same implementation.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>In oop, the so called experts seem to say that this is not the case.</span> <span> - </span> <span class="display-name">IntelliData</span> <span> </span> <span class="date">18 May 2015 at 15:26</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@IntelliData: I have amended the answer to explain why so-called experts would say such a thing.</span> <span> - </span> <span class="display-name">JacquesB</span> <span> </span> <span class="date">18 May 2015 at 16:39</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>As a matter of fact, some have explicitly said 'Never use Getter/Setters'!</span> <span> - </span> <span class="display-name">IntelliData</span> <span> </span> <span class="date">18 May 2015 at 18:54</span></td>
       </tr>
       <tr>
        <td>8</td>
        <td><span>Then again, some people have said 'Never use OOP': <a href="http://harmful.cat-v.org/software/OO_programming/" rel="nofollow noreferrer">harmful.cat-v.org/software/OO_programming</a></span> <span> - </span> <span class="display-name">JacquesB</span> <span> </span> <span class="date">18 May 2015 at 18:57</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>True, but the question is being asked in the context of OOP...</span> <span> - </span> <span class="display-name">IntelliData</span> <span> </span> <span class="date">18 May 2015 at 19:09</span></td>
       </tr>
       <tr>
        <td>7</td>
        <td><span>FTR, I think more “experts” still teach to meaninglessly create getters/setters for <i>everything</i>, than to never create any at all. IMO, the latter is less misguiding advice.</span> <span> - </span> <span class="display-name">leftaroundabout</span> <span> </span> <span class="date">19 May 2015 at 07:44</span></td>
       </tr>
       <tr>
        <td>5</td>
        <td><span>@leftaroundabout: OK, but I'm suggesting a middle ground between 'always' and 'never' which is 'use when appropriate'.</span> <span> - </span> <span class="display-name">JacquesB</span> <span> </span> <span class="date">19 May 2015 at 09:29</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@JacquesB A Value Object can have behavior and be more than a dumb data structure. It's an orthogonal concept.</span> <span> - </span> <span class="display-name">guillaume31</span> <span> </span> <span class="date">19 May 2015 at 13:09</span></td>
       </tr>
       <tr>
        <td>4</td>
        <td><span>I think the issue is that many programmers turn every object (or too many objects) into a DTO. Sometimes they are necessary, but avoid them as much as possible since they separate data from behavior. (Assuming you are a devout OOPer)</span> <span> - </span> <span class="display-name">user949300</span> <span> </span> <span class="date">19 May 2015 at 17:19</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@guillaume31 Do you mean it in the DDD sense? It has historically also been used to mean the same as DTO or "property bag" (which is more C#-ish). The double-meaning is confusing which is why I think people should avoid using it for this</span> <span> - </span> <span class="display-name">Ben Aaronson</span> <span> </span> <span class="date">20 May 2015 at 16:51</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@BenAaronson Yes, in the DDD sense which I think is the most common now. But you're right, according to <a href="http://martinfowler.com/bliki/ValueObject.html" rel="nofollow noreferrer">Martin Fowler</a>, "Early J2EE literature used the term value object to describe a different notion, what I call a Data Transfer Object. They have since changed their usage and use the term Transfer Object instead."</span> <span> - </span> <span class="display-name">guillaume31</span> <span> </span> <span class="date">22 May 2015 at 20:24</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I'd say the evilness is object behavior dependent on the client manually setting state first (i.e. not using constructor or other method parameters). However, exposed in context, i.e. properly encapsulated, exposing data is not per se evil.</span> <span> - </span> <span class="display-name">radarbob</span> <span> </span> <span class="date">3 Jun 2015 at 16:04</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_4"><span>Answer 4</span> <span class="arrow"> <a href="#answer_3">↑</a> </span> <span class="arrow"> <a href="#answer_5">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>12</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Kasper van den Berg</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 May 2015 at 16:36</span>
     </div>
    </div>
    <div>
     <p>To transform the <code>Customer</code>-class from a data object, we can ask ourselves the following questions about the data fields:</p>
     <p>How do we want to use {data field}? Where is {data field} used? Can and should the use of {data field} be moved to the class?</p>
     <p>E.g.:</p>
     <ul>
      <li>
       <p>What is the purpose of <code>Customer.Name</code>?</p>
       <p>Possible answers, display the name in a login web page, use the name in mailings to the customer.</p>
       <p>Which leads to methods:</p>
       <ul>
        <li>Customer.FillInTemplate(…)</li>
        <li>Customer.IsApplicableForMailing(…)</li>
       </ul></li>
      <li>
       <p>What is the purpose of <code>Customer.DOB</code>?</p>
       <p>Validating the customer's age. Discounts on the customer's birthday. Mailings.</p>
       <ul>
        <li>Customer.IsApplicableForProduct()</li>
        <li>Customer.GetPersonalDiscount()</li>
        <li>Customer.IsApplicableForMailing()</li>
       </ul></li>
     </ul>
     <p>Given the comments, the example object <code>Customer</code> – both as a data object and as "real" object with its own responsibilities – is too broad; i.e. it has too much properties/responsibilities. Which leads to either lots of components depending on <code>Customer</code> (by reading its properties) or to <code>Customer</code> depending on lots of components. Perhaps there exist different views of customer, perhaps each should have its own distinct class<sup>1</sup>:</p>
     <ul>
      <li>
       <p>The customer in the context of <code>Account</code> and monetary transactions is probably only used to:</p>
       <ul>
        <li>help humans identify that their money transfer goes to the correct person; and</li>
        <li>group <code>Account</code>s.</li>
       </ul>
       <p>This customer does not need fields like <code>DOB</code>, <code>FavouriteColour</code>, <code>Tel</code>, and perhaps not even <code>Address</code>.</p></li>
      <li>
       <p>The customer in the context of a user logging in to a banking website.</p>
       <p>Relevant fields are:</p>
       <ul>
        <li><code>FavouriteColour</code>, which might come in the form of personalised theming;</li>
        <li><code>LanguagePreferences</code>, and</li>
        <li><code>GreetingName</code></li>
       </ul>
       <p>Instead of properties with getters and setters, these might be captured in a single method:</p>
       <ul>
        <li>PersonaliseWebPage(Template page);</li>
       </ul></li>
      <li>
       <p>The customer in the context of marketing and and personalised mailing.</p>
       <p>Here not relying on the properties of a dataobject, but instead starting from the responsibilities of the object; e.g.:</p>
       <ul>
        <li>IsCustomerInterestedInAction(); and</li>
        <li>GetPersonalDiscounts().</li>
       </ul>
       <p>The fact that this customer object has a <code>FavouriteColour</code> property, and/or an <code>Address</code> property becomes irrelevant: perhaps the implementation uses these properties; but it might also use some machine learning techniques and use previous interactions with the customer to discover in which products the customer might be interested.</p></li>
     </ul>
     <hr>
     <p><sup> 1. Of course, the <code>Customer</code> and <code>Account</code> classes were examples, and for a simple example or homework exercise, splitting this customer might be overkill, but with the example of splitting, I hope to demonstrate that the method of turning a data object into an object with responsibilities will work. </sup></p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>4</td>
        <td><span>Upvote because you are actually answering the question :) However it is also obvious that the proposed solutions are much worse than just having gettes/setters - e.g. FillInTemplate clearly breaks the separation of concerns principle. Which just goes to show that the premise of the question is flawed.</span> <span> - </span> <span class="display-name">JacquesB</span> <span> </span> <span class="date">18 May 2015 at 18:48</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@Kasper van den Berg: And when you have many attributes in the <b>Customer</b> as is usually the case, how would you initially set them?</span> <span> - </span> <span class="display-name">IntelliData</span> <span> </span> <span class="date">18 May 2015 at 19:00</span></td>
       </tr>
       <tr>
        <td>2</td>
        <td><span>@IntelliData your values are likely coming from a database, XML, etc. The Customer, or a CustomerBuilder, reads them, then sets using (i.e. in Java) private / package / inner class access, or, (ick) reflection. Not perfect, but you can usually avoid public setters. (See my answer for some more details)</span> <span> - </span> <span class="display-name">user949300</span> <span> </span> <span class="date">18 May 2015 at 20:21</span></td>
       </tr>
       <tr>
        <td>6</td>
        <td><span>I don't think the customer class should know about any of these things.</span> <span> - </span> <span class="display-name">CodesInChaos</span> <span> </span> <span class="date">19 May 2015 at 10:13</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>What about something like <code>Customer.FavoriteColor</code>?</span> <span> - </span> <span class="display-name">Gabe</span> <span> </span> <span class="date">20 May 2015 at 07:38</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@CodesInChaos And I think you have an anemic domain model if you think so</span> <span> - </span> <span class="display-name">Eugene</span> <span> </span> <span class="date">14 Jan 2022 at 23:33</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_5"><span>Answer 5</span> <span class="arrow"> <a href="#answer_4">↑</a> </span> <span class="arrow"> <a href="#answer_6">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>8</span>
     </div>
     <div>
      <span>Answerer: </span> <span>cmaster - reinstate monica</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 May 2015 at 19:56</span>
     </div>
    </div>
    <div>
     <p><strong>TL;DR</strong></p>
     <ul>
      <li>
       <p>Modeling for behavior is good.</p></li>
      <li>
       <p>Modeling for good(!) abstractions is better.</p></li>
      <li>
       <p>Sometimes data objects are required.</p></li>
     </ul>
     <hr>
     <p><strong>Behavior and Abstraction</strong></p>
     <p>There are several reasons to avoid getters and setters. One is, as you noted, to avoid modeling data. This is actually the minor reason. The bigger reason is to provide abstraction.</p>
     <p>In your example with the bank account that is clear: A <code>setBalance()</code> method would be really bad because setting a balance is not what an account should be used for. The behavior of the account should abstract from its current balance as much as possible. It may take the balance into account when deciding whether to fail a withdrawal, it may give access to the current balance, but modifying interaction with a bank account should not require the user to calculate the new balance. That's what the account should do itself.</p>
     <p>Even a pair of <code>deposit()</code> and <code>withdraw()</code> methods is not ideal to model a bank account. A better way would be to provide only one <code>transfer()</code> method that takes another account and an amount as arguments. This would allow the account class to trivially ensure that you don't accidentally create/destroy money in your system, it would provide a very usable abstraction, and it would actually provide users with more insight because it would force the use of special accounts for earned/invested/lost money (see <a href="http://en.wikipedia.org/wiki/Double-entry_bookkeeping_system">double-accounting</a>). Of course, not every use of an account needs this level of abstraction, but it is definitely worth considering how much abstraction your classes can provide.</p>
     <p>Note that providing abstraction and hiding data internals is not always the same thing. Almost any application contains classes that are effectively just data. Tuples, dictionaries, and arrays are frequent examples. You don't want to hide the x-coordinate of a point from the user. There is very little abstraction that you can/should be doing with a point.</p>
     <hr>
     <p><strong>The Customer Class</strong></p>
     <p>A customer is certainly an entity in your system that should try to provide useful abstractions. For instance, it should likely be associated with a shopping cart, and the combination of the cart and the customer should allow committing a purchase, which might kick off actions like sending him the requested products, charging him money (taking into account his selected payment method), etc.</p>
     <p>The catch is, that all the data that you mentioned is not only associated with a customer, all of that data is also mutable. The customer may move. They may change their credit card company. They may change their email-address and phone number. Heck, they may even change their name and/or sex! So, a full featured customer class indeed has to provide full modifying access to all these data items.</p>
     <p>Still, the setters can/should provide non-trivial services: They can ensure correct format of email-adresses, verification of postal adresses, etc. Likewise, the "getters" can provide high-level services like providing email-adresses in the <code>Name &lt;user@server.com&gt;</code> format using the name fields and the deposited email address, or provide a correctly formatted postal address, etc. Of course, what of this high level functionality makes sense depends heavily on your use-case. It might be complete overkill, or it might call for another class to do it right. The choice of abstraction level is not an easy one.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>sounds right, although I disagree on the sex part... ;)</span> <span> - </span> <span class="display-name">IntelliData</span> <span> </span> <span class="date">19 May 2015 at 16:56</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_6"><span>Answer 6</span> <span class="arrow"> <a href="#answer_5">↑</a> </span> <span class="arrow"> <a href="#answer_7">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>6</span>
     </div>
     <div>
      <span>Answerer: </span> <span>user949300</span>
     </div>
     <div>
      <span> Answered: </span> <span>18 May 2015 at 20:17</span>
     </div>
    </div>
    <div>
     <p>Trying to expand on Kasper's answer, it's easiest to rant against and eliminate setters. In a rather vague, handwaving (and hopefully humorous) argument:</p>
     <p><strong>When would Customer.Name ever change?</strong></p>
     <p>Seldom. Maybe they got married. Or went into witness protection. But in that case you'd also want to check on and possibly change their residence, next of kin, and other information.</p>
     <p><strong>When would DOB ever change?</strong></p>
     <p>Only on initial creation, or on a data entry screwup. Or if they are a Domincan baseball player. :-)</p>
     <p>These fields should not be accessible with routine, normal setters. Maybe you have a <code>Customer.initialEntry()</code> method, or a <code>Customer.screwedUpHaveToChange()</code> method that requires special permissions. But don't have a public <code>Customer.setDOB()</code> method.</p>
     <p>Usually a Customer is read from a database, a REST API, some XML, whatever. Have a method <code>Customer.readFromDB()</code>, or, if you are stricter about SRP / separation of concerns, you'd have a separate builder, e.g. a <code>CustomerPersister</code> object with a <code>read()</code> method. Internally, they somehow set the fields (I prefer using package access or an inner class, YMMV). But again, avoid public setters.</p>
     <p><strong>(Addendum as Question has changed somewhat...)</strong></p>
     <p>Let's say that your application makes heavy use of relational databases. It would be foolish to have <code>Customer.saveToMYSQL()</code> or <code>Customer.readFromMYSQL()</code> methods. That creates undesireable coupling to a <strong>concrete, non-standard, and likely to change</strong> entity. For example, when you change the schema, or change to Postgress or Oracle.</p>
     <p>However, IMO, it's perfectly acceptable to couple Customer to an <strong>abstract standard</strong>, <code>ResultSet</code>. A separate helper object (I'll call it <code>CustomerDBHelper</code>, which is probably a subclass of <code>AbstractMySQLHelper</code>) knows about all the complex connections to your DB, knows the tricky optimization details, knows the tables, query, joins, etc... (or uses a ORM like Hibernate) to generate the ResultSet. Your object talks to the <code>ResultSet</code>, which is an <strong>abstract standard</strong>, unlikely to change. When you change the underlying database, or change the schema, <strong>Customer doesn't change</strong>, but the <strong>CustomerDBHelper</strong> does. If you are lucky, it's only AbstractMySQLHelper that changeswhich automatically makes the changes for Customer, Merchant, Shipping etc...</p>
     <p>This way you can (perhaps) avoid or lessen the need for getters and setters.</p>
     <p>And, the main point of the Holub article, compare and contrast the above to how it would be if you used getters and setters for everything and changed the database.</p>
     <p>Similarly, let's say you use a lot of XML. IMO, it's fine to couple your Customer to an abstract standard, such as a Python <strong>xml.etree.ElementTree</strong> or a Java <strong>org.w3c.dom.Element</strong>. Customer gets and sets itself from that. Again, you can (perhaps) lessen the need for getters and setters.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>would you say it is advisable to use a Builder Pattern?</span> <span> - </span> <span class="display-name">IntelliData</span> <span> </span> <span class="date">19 May 2015 at 16:55</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>Builder is useful for making the construction of an object easier and more robust, and, if you wish, allowing the object to be immutable. However, it still (partially) exposes the fact that the underlying object has a DOB field, so it's not the bee-all end-all.</span> <span> - </span> <span class="display-name">user949300</span> <span> </span> <span class="date">19 May 2015 at 17:10</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_7"><span>Answer 7</span> <span class="arrow"> <a href="#answer_6">↑</a> </span> <span class="arrow"> <a href="#answer_8">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>nvuono</span>
     </div>
     <div>
      <span> Answered: </span> <span>19 May 2015 at 15:43</span>
     </div>
    </div>
    <div>
     <blockquote>
      <p>So for example, given a Customer class that keeps alot if information about the customer, e.g. Name, DOB, Tel, Address etc., how would one avoid getter/setters for getting and setting all those attributes? What 'Behavior' type method can one write to populate all that data?</p>
     </blockquote>
     <p>I think this question is prickly because you are worried about behavior methods for populating data but I don't see any indication of what behavior the <code>Customer</code> class of objects is intended to encapsulate.</p>
     <p>Don't confuse <code>Customer</code> as a <strong>class of objects</strong> with 'Customer' as a <strong>user/<a href="http://en.wikipedia.org/wiki/Actor_%28UML%29" rel="nofollow">actor</a></strong> who performs different tasks using your software.</p>
     <p>When you say <em>given a Customer class that keeps alot if information about the customer</em> then as far as behavior goes it looks like your Customer class has little distinguishing it from a rock. A <code>Rock</code> can have a color, you could give it a name, you could have a field for storing its current address but we don't expect any sort of intelligent behavior from a rock.</p>
     <p>From the linked article about getters/setters being evil:</p>
     <blockquote>
      <p>The OO design process centers on use cases: a user performs standalone tasks that have some useful outcome. (Logging on is not a use case because it lacks a useful outcome in the problem domain. Drawing a paycheck is a use case.) An OO system, then, implements the activities needed to play out the various scenarios that comprise a use case.</p>
     </blockquote>
     <p>Without any behavior defined, referring to a rock as a <code>Customer</code> doesn't change the fact that it is just an object with some properties you'd like to track and it doesn't matter what tricks you want to play to get away from getters and setters. A rock doesn't care if it has a valid name and a rock wouldn't be expected to know whether an address is valid or not.</p>
     <p>Your order system could associate a <code>Rock</code> with a purchase order and as long as that <code>Rock</code> has an address defined then some part of the system can make sure an item gets delivered to a rock.</p>
     <p>In all of these cases the <code>Rock</code> is just a Data Object and will continue to be one until we define specific behaviors with useful outcomes instead of hypotheticals.</p>
     <hr>
     <p><strong>Try This:</strong></p>
     <p>When you avoid overloading the word 'Customer' with 2 potentially different meanings it should make things easier to conceptualize.</p>
     <p>Does a <code>Rock</code> object place an Order or is that something that a human being does by clicking on UI elements to trigger actions in your system?</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td></td>
        <td><span>The customer is an actor that does many things, but also happens to have alot of info associated with it; does that justify creating 2 separate classes, 1 as an actor and 1 as a data object?</span> <span> - </span> <span class="display-name">IntelliData</span> <span> </span> <span class="date">19 May 2015 at 16:59</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@IntelliData passing rich objects across layers is where things get tricky. If you are sending the object from a controller to a view, the view needs to understand the general contract of the object (JavaBeans standard for example). If you are sending the object across the wire, JaxB or the like needs to be able to reinstaitate it to a dumb object (because you didn't give them the full rich object). Rich objects are wonderful for manipulating data - they are poor for transferring state. Conversely, dumb objects are poor for manipulating data and ok for transferring state.</span> <span> - </span> <span class="display-name">user40980</span> <span> </span> <span class="date">19 May 2015 at 19:49</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>+1 It's not answering the question 100 %, but anyway it is an important hint that "customer" <i>might</i> be a too generic term</span> <span> - </span> <span class="display-name">Eugene</span> <span> </span> <span class="date">14 Jan 2022 at 23:45</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_8"><span>Answer 8</span> <span class="arrow"> <a href="#answer_7">↑</a> </span> <span class="arrow"> <a href="#answer_9">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>1</span>
     </div>
     <div>
      <span>Answerer: </span> <span>CashCow</span>
     </div>
     <div>
      <span> Answered: </span> <span>27 May 2015 at 15:12</span>
     </div>
    </div>
    <div>
     <p>The issue of having getters and setters can be a matter of the fact that a class may be used in the business logic in one way but you may also have helper classes to serialize / deserialize the data from a database or file or other persistent storage.</p>
     <p>Due to the fact there are many ways to store / retrieve your data and you want to decouple the data objects from the way they are stored, the encapsulation can be "compromised" by either making these members public, or making them accessible through getters and setters which is almost as bad as making them public.</p>
     <p>There are various ways around this. One way is to make the data available to a "friend". Although friendship is not inherited, this can be overcome by whatever serializer requesting the information from the friend, i.e. the base serializer "forwarding" the information.</p>
     <p>Your class could have a generic "fromMetadata" or "toMetadata" method. From-metadata constructs an object so may well be a constructor. If it is dynamically typed language, metadata is pretty standard to such a language and probably is the primary way to construct such objects.</p>
     <p>If your language is C++ specifically, one way around this is to have a public "struct" of data and then for your class to have an instance of this "struct" as a member and in fact all the data you are going to store / retrieve to be stored in it. You can then easily write "wrappers" to read/write your data in multiple formats.</p>
     <p>If your language is C# or Java which don't have "structs" then you can do similarly but your struct is now a secondary class. There is no real concept of "ownership" of the data or const-ness so if you give out an instance of the class containing your data and it's all public, whatever gets hold can modify it. You could "clone" it although this can be expensive. Alternatively you could make this class have private data but use accessors. That gives users of your class a roundabout way to get to the data but it isn't the direct interface with your class and is really a detail in storing the data of the class which is a use-case too.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_9"><span>Answer 9</span> <span class="arrow"> <a href="#answer_8">↑</a> </span> <span class="arrow"> <a href="#answer_10">↓</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Nicolas Bousquet</span>
     </div>
     <div>
      <span> Answered: </span> <span>19 May 2015 at 07:06</span>
     </div>
    </div>
    <div>
     <p>OOP is about encapsulating and hidding behavior inside objects. Objects are black boxes. This is a way to design thing. The asset is in many case one doesn't need to know the internal state of another component and is better to not have to know it. You can enforce that idea with mainly interfaces or inside an object with visibility and taking care only allowed verbs/action are available to caller.</p>
     <p>This work well for some kind of problem. For example in user interfaces to modelize individual UI component. When you interract with a text box you are only interrested in setting the text, getting it or listening to text change event. You are typically not interrested as to where the cursor is, the font used to draw the text or how the keyboard is used. Encapsulation provide a lot here.</p>
     <p>On the contrary when you call a network service, your provide an explicit input. There usually a grammar (like in JSON or XML) and all the option of calling the service have no reason to be hidden. The idea is that you can call the service the way you want and the data format is public and published.</p>
     <p>In this case, or many other (like access to a database) you really work with shared data. As such there no reason to hide it, on the contrary you want to make it available. There can be concern of read/write access or datacheck consistency but at this core, the core concept if this is public.</p>
     <p>For such design requirement where you want to avoid encapsulation and make things publics and in the clear, you want to avoid objects. What you really need are tuples, C structs or their equivalent, not objects.</p>
     <p>But it also happen in languages like Java, the only things you can modelize is objects or arrays of objects. Objects themselve can hold a few natives types (int, float...) but that's all. But objects can also behave like a simple struct with just public fields and that all.</p>
     <p>So if you modelize data you can be done with just public fields inside objects because you don't need more. You don't use encapsulation because you don't need it. This is done this way in many languages. In java, historically, a standard rose where with getter/setter you could at least have read/write control (by not adding setter for example) and that toolings and framework by using instrospection API would look for getter/setter methods and use it to autofill the content or display theses as modifiable fields in auto generated user interface.</p>
     <p>There also the argument you could add some logic/checking in the setter method.</p>
     <p>In reality there almost no justification for getter/setters as they are most often used to modelize pure data. Frameworks and developpers using your objects do expect the getter/setter do nothing more than setting/getting the fields anyway. You are effectively doing no more with getter/setter than what could be done with public fields.</p>
     <p>But that's old habits and olds habits are difficult to remove... You could even be threatened by your collegues or teacher if you don't put getters/setter blindly everywhere if they lack the background to better understand what they are and what they are not.</p>
     <p>You would likely need to change the language to get ride of all theses getters/setters boilerplate code. (Like C# or lisp). To me getters/setter are just another one billion dollar mistake...</p>
    </div>
    <hr>
    <div class="comment">
     <table>
      <tbody>
       <tr>
        <td>6</td>
        <td><span>C# properties do not really implement encapsulation any more than do getters and setters...</span> <span> - </span> <span class="display-name">IntelliData</span> <span> </span> <span class="date">19 May 2015 at 17:01</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>The advantage of [gs]etters is that you can do the things you usually don't (check values, notify observers), simulate non-existing fields etc., and mainly that you can <i>change it later</i>. With <a href="https://projectlombok.org" rel="nofollow noreferrer">Lombok</a>, the boilerplate is gone: <code>@Getter @Setter class MutablePoint3D {private int x, y, z;}</code>.</span> <span> - </span> <span class="display-name">maaartinus</span> <span> </span> <span class="date">20 May 2015 at 03:47</span></td>
       </tr>
       <tr>
        <td>1</td>
        <td><span>@maaartinus For sure [gs]etter can do anything as any other method can. This mean that any caller code should be aware any value they set can throw an exception, be changed or potentialy send notification of change... or whatever else. That more or less [gs]etter are not providing access to a field but doing arbitrar code.</span> <span> - </span> <span class="display-name">Nicolas Bousquet</span> <span> </span> <span class="date">20 May 2015 at 07:06</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>@IntelliData C# properties allow to not write 1 useless single character of boilerplate and to not care of all this getter/setter stuff... This is already better achievement than project lombok. Also to me a POJO with just getters/setter is not here to provide encapsulation but rather to publish a data format that one is free to read or write as exchange with a service. Encapsulation is then the opposite of the design requirement.</span> <span> - </span> <span class="display-name">Nicolas Bousquet</span> <span> </span> <span class="date">20 May 2015 at 07:17</span></td>
       </tr>
       <tr>
        <td></td>
        <td><span>I don't really think properties are really good. Sure, you save the prefix and the parentheses, i.e., 5 chars per call, but 1. they look like fields, which is confusing. 2. they're an additional thing for which you need support in reflection. No big deal, but no big advantage either (when compared to Java+Lombok; pure Java is at clear loss).</span> <span> - </span> <span class="display-name">maaartinus</span> <span> </span> <span class="date">20 May 2015 at 07:51</span></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <div>
    <h2 id="answer_10"><span>Answer 10</span> <span class="arrow"> <a href="#answer_9">↑</a> </span></h2>
    <div class="container-metadata">
     <div>
      <span>Score: </span> <span>0</span>
     </div>
     <div>
      <span>Answerer: </span> <span>Vadim Samokhin</span>
     </div>
     <div>
      <span> Answered: </span> <span>11 Sep 2017 at 13:08</span>
     </div>
    </div>
    <div>
     <p>I add my 2 cents here mentioning <a href="https://medium.com/@wrong.about/you-dont-need-an-orm-7ef83bd1b37d" rel="nofollow noreferrer">SQL-speaking objects</a> approach.</p>
     <p>This approach is based on the notion of self-contained object. It has all resources it needs to implement its behavior. It doesn't need to be told <em>how</em> to do its job -- declarative request is enough. And an object definitely doesn't have to hold all its data as class properties. It really doesn't -- and shouldn't -- matter where they are got from.</p>
     <p>Talking about an <a href="https://martinfowler.com/bliki/DDD_Aggregate.html" rel="nofollow noreferrer">aggregate</a>, immutability is not an issue as well. Say, you have a sequence of states that aggregate can hold: <a href="https://i.stack.imgur.com/saDkU.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/saDkU.png" alt="Aggregate root as saga"></a> It's totally fine to implement each state as standalone object. Probably you could go even further: have a chat with your domain expert. Chances are that he or she doesn't see this aggregate as some unified entity. Probably each state has it's own meaning, deserving it's own object.</p>
     <p>Finally, I'd like to note that object finding process is very similar with <a href="https://medium.com/@wrong.about/how-to-define-service-boundaries-251c4fc0f205" rel="nofollow noreferrer">system decomposition into subsystems</a>. Both are based on behavior, not anything else.</p>
    </div>
    <hr>
    <div class="comment">
     <table>
     </table>
    </div>
   </div>
   <br>
   <div>
    <span>License: </span> <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <span>by </span> <a href="https://stackoverflow.com/legal/terms-of-service#licensing">Stack Overflow Inc.</a>
   </div>
  </div>
 </body>
</html>